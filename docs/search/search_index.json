{
    "docs": [
        {
            "location": "/", 
            "text": "Bmob\n文档中心\n\n            \n\n        \n\n        \n\n            \nBmob 后端云专注于为移动应用提供一整套后端云服务\n\n            \n帮助开发者免去几乎所有的服务器端编码的工作量，成倍降低开发成本和开发时间。\n\n        \n\n        \n\n        \n\n        \n\n        \n\n         \n\n    \n\n\n\n\n\n\n\n\n\n    \n\n        \n\n            \n\n                \n\n            \n\n            \n数据服务\n\n            \n\n                \n\n                  \nAndroid\n\n                  \niOS\n\n                  \nRestful\n\n                  \nC#\n\n                  \nJavaScript\n\n                  \nPHP\n\n                  \nCocos2d-x\n\n                  \nGo\n\n                  \n小程序\n\n                  \n\n                \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n                \n\n            \n\n            \n云函数\n\n            \n\n                \n\n                  \nAndroid\n\n                  \niOS\n\n                  \nRestful\n\n                  \nC#\n\n                  \nJavaScript\n\n                  \nPHP\n\n                  \nWEB\n\n                  \n\n                \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n                \n\n            \n\n            \n短信服务\n\n            \n\n                \n\n                  \nAndroid\n\n                  \niOS\n\n                  \nRestful\n\n                  \nJavaScript\n\n                  \nPHP\n\n                  \n\n                \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n                \n\n            \n\n            \n即时通讯\n\n            \n\n                \n\n                  \nAndroid\n\n                  \niOS\n\n                  \n\n                \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n                \n\n            \n\n            \n推送功能\n\n            \n\n                \n\n                  \nAndroid\n\n                  \niOS\n\n                  \nRestful\n\n                  \nJavaScript\n\n                  \nPHP\n\n                  \n\n                \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n                \n\n            \n\n            \n移动支付\n\n            \n\n                \n\n                  \nAndroid\n\n                  \niOS\n\n                  \nRestful\n\n                  \n\n                \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n                \n\n            \n\n            \n容器服务\n\n            \n\n                \n\n                  \nContainer\n\n                  \n\n                \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n               \n\n            \n\n            \n其他\n\n            \n\n                \n\n                  \n错误码\n\n                  \n常见问题\n\n                  \nBQL详细指南\n\n                  \n数据与安全\n\n                  \n\n                  \n视频教程", 
            "title": "文档首页"
        }, 
        {
            "location": "/data/android/", 
            "text": "注册Bmob帐号\n\n\n在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。\n\n\n\n\n网站后台创建应用\n\n\n登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。\n\n\n\n\n获取应用密钥和下载SDK\n\n\n选择你要开发的应用，进入该应用\n\n\n\n\n在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID\n\n\n\n\n获取Application ID后，下载SDK（下载地址：\nhttp://www.bmob.cn/site/sdk#android_sdk\n）。\n\n\n\n\nSDK导入\n\n\nAndroidStudio配置\n\n\n鉴于目前Google官方推荐使用 \nAndroid Studio\n 进行Android项目开发，自 \nV3.4.2\n 开始，Bmob Android SDK 可以使用Gradle来进行包依赖管理，如果你使用Android Studio来进行基于BmobSDK的项目开发，有两种方式：\n\n\n自动导入(推荐)\n\n\n请按照如下两个步骤进行：\n\n\n\n\n在 \nProject\n 的 \nbuild.gradle\n 文件中添加 \nBmob的maven仓库地址\n，示例如下：（\n注意文字说明部分\n）：\n\n\n\n\n    buildscript {\n        repositories {\n            jcenter()\n        }\n        dependencies {\n            classpath 'com.android.tools.build:gradle:1.2.3'\n        }\n    }\n\n    allprojects {\n        repositories {\n            jcenter()\n            //Bmob的maven仓库地址--必填\n            maven { url \nhttps://raw.github.com/bmob/bmob-android-sdk/master\n }\n        }\n    }\n\n\n\n\n\n\n在\napp\n的\nbuild.gradle\n文件中添加\ncompile依赖文件\n,示例如下：（\n注意文字说明部分\n）：\n\n\n\n\n    apply plugin: 'com.android.application'\n\n    android {\n        compileSdkVersion 22\n        buildToolsVersion '22.0.1'\n\n        **兼容Android6.0系统所需，如果这句话报错，可在dependencies标签下使用compile 'cn.bmob.android:http-legacy:1.0'**\n        useLibrary 'org.apache.http.legacy'\n\n        ...\n    }\n\n\n    dependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n\n        //以下SDK开发者请根据需要自行选择\n        //bmob-sdk：Bmob的android sdk包，包含了Bmob的数据存储、文件等服务，以下是最新的bmob-sdk:\n        //3.5.5：请务必查看下面注释[1]\n        compile 'cn.bmob.android:bmob-sdk:3.5.5'\n\n        //bmob-push：Bmob的推送包\n        compile 'cn.bmob.android:bmob-push:0.8'\n\n        //bmob-im：Bmob的即时通讯包，注意每个版本的im依赖特定版本的bmob-sdk，具体的依赖关系可查看下面注释[2]\n        compile 'cn.bmob.android:bmob-im:2.0.5@aar'\n        compile 'cn.bmob.android:bmob-sdk:3.4.7-aar'\n\n        //bmob-sms ：Bmob单独为短信服务提供的包\n        compile 'cn.bmob.android:bmob-sms:1.0.1'\n\n        //如果你想应用能够兼容Android6.0，请添加此依赖(org.apache.http.legacy.jar)\n        compile 'cn.bmob.android:http-legacy:1.0'\n    }\n\n\n\n\n\n注：\n\n\n[1]、为了降低开发者的使用成本，自v3.4.7开始，同步提供\naar\n格式的文件，此aar包含\nlibbmob.so、依赖jar包(okhttp、okio、rx、gson等)及自动更新组件所需要的资源文件\n。开发者再也不需要配置libbmob.so,不需要添加依赖jar，也不需要复制自动更新组件的资源文件啦，只需要添加以下依赖即可。\n\n\ncompile 'cn.bmob.android:bmob-sdk:3.5.0'\n\n\n\n注：由于\nPermissionManager权限管理类\n需要依赖\nsupport-v4:23.2.1\n的jar包,导致开发者认为SDK依赖文件较多，故分离出SDK。开发者如果需要兼容Android6.0系统，可以在下载的SDK的官方Demo的\ncom.example.bmobexample.permission\n包下面查看该类源码。\n\n\n[2]、每个版本的im依赖特定版本的bmob-sdk：\n\n\n\n\nbmob-im:1.1.8---\nbmob-sdk:3.3.5\n\n\nbmob-im:1.1.9---\nbmob-sdk:3.4.3\n\n\nbmob-im:2.0.1---\nbmob-sdk:3.4.6-0304\n\n\nbmob-im:2.0.2---\nbmob-sdk:3.4.6-0304\n\n\nbmob-im:2.0.3---\nbmob-sdk:3.4.6\n\n\nbmob-im:2.0.4---\nbmob-sdk:3.4.6\n \n\n\nbmob-im:2.0.5---\nbmob-sdk:3.4.7-aar\n\n\nbmob-im:2.0.6---\nbmob-sdk:3.5.0\n\n\n\n\n其中\n\n\n\n\nbmob-sdk:3.4.6-0304\n是Bmob Android SDK的过渡版本，主要用于NewIM_v2.0.1及v2.0.2\n\n\nbmob-sdk:3.4.6\n的相关依赖包可见注释[3]\n\n\n\n\n[3]、bmob-sdk:3.4.6依赖以下包：\n\n\ncompile 'cn.bmob.android:bmob-sdk:3.4.6'\ncompile 'com.squareup.okhttp:okhttp:2.4.0'//CDN文件服务使用okhttp相关包进行文件的上传和下载（必填）\ncompile 'com.squareup.okio:okio:1.4.0'\n\n\n\n如果需要兼容Android6.0系统，请添加以下两项：\n\n\ncompile 'com.android.support:support-v4:23.2.1'\ncompile 'cn.bmob.android:http-legacy:1.0'\n\n\n\n[4]、bmob-sms适用于只需要使用Bmob短信功能的开发者，而bmob-sdk内部包含了bmob-sms的短信功能,请不要重复添加。\n\n\n[5]、BmobSDK的官方仓库：\nbmob-android-sdk\n，开发者可到此仓库查看最新发布的各版本SDK，我们会尽量与官网发布的SDK保持同步更新。\n\n\n手动导入\n\n\n\n\n\n\n开发者到\nSDK下载中心\n下载 \n数据服务\n 的Android 版本的SDK，并将下载下来的\nlibs\n文件夹里面的文件根据需要复制到工程的libs目录下(注意，自\nv3.4.7\n开始提供\nlibbmob.so\n文件)； \n\n\n\n\n\n\n在\napp\n的\nbuid.gradle\n文件中添加SO库目录配置：\n\n\nandroid {\n    sourceSets {\n        main.jniLibs.srcDirs = ['libs']\n   }\n}\n\n\n\n\n\n\n\n点击Sync，同步配置。\n\n\n\n\n\n\nEclipse导入\n\n\n开发者到 \nSDK下载中心\n 下载 \n数据服务\n 的Android 版本的SDK，在Eclipse工程的项目根目录中新建\nlibs\n文件夹，将下载的jar包添加到此文件夹即可。\n\n\n注：\n\n\n1、若配置不成功，则需要额外增加以下步骤：\n\n\n右键工程根目录，选择\nProperties -\n Java Build Path -\n Libraries\n，然后点击\nAdd External JARs...\n 选择指向该libs文件夹下的jar的路径，点击OK即可\n\n\n2、BmobSDK_v3.5.0需要依赖\nrxjava（1.1.6）、rxandroid(1.2.0)、gson(2.6.2)、okhttp3（3.3.1）、okio（1.7.0）\n及\nlibbmob.so\n库；\n\n\n3、BmobSDK_v3.4.7需要依赖\nokhttp3（3.2.0）、okio（1.7.0）\n及\nlibbmob.so\n库；\n\n\n4、BmobSDK_v3.4.6需要依赖\nokhttp（2.4.0）、okio（1.4.0）\n，如果需要兼容Android6.0系统，则还需要添加support-v4（23.2.1）及org.apache.http.legacy依赖包。\n\n\n配置AndroidManifest.xml\n\n\n在你的应用程序的\nAndroidManifest.xml\n文件中添加相应的权限：\n\n\n\n\n!--允许联网 --\n \n\nuses-permission android:name=\nandroid.permission.INTERNET\n /\n \n\n!--获取GSM（2g）、WCDMA（联通3g）等网络状态的信息  --\n \n\nuses-permission android:name=\nandroid.permission.ACCESS_NETWORK_STATE\n /\n \n\n!--获取wifi网络状态的信息 --\n \n\nuses-permission android:name=\nandroid.permission.ACCESS_WIFI_STATE\n /\n \n\n!--保持CPU 运转，屏幕和键盘灯有可能是关闭的,用于文件上传和下载 --\n\n\nuses-permission android:name=\nandroid.permission.WAKE_LOCK\n /\n \n\n!--获取sd卡写的权限，用于文件上传和下载--\n\n\nuses-permission android:name=\nandroid.permission.WRITE_EXTERNAL_STORAGE\n /\n\n\n!--允许读取手机状态 用于创建BmobInstallation--\n \n\nuses-permission android:name=\nandroid.permission.READ_PHONE_STATE\n /\n\n\n\n\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n    \nmanifest xmlns:android=\nhttp://schemas.android.com/apk/res/android\n\n        package=\ncn.bmob.example\n\n        android:versionCode=\n1\n\n        android:versionName=\n1.0\n\n\n    \nuses-sdk android:minSdkVersion=\n8\n android:targetSdkVersion=\n17\n/\n\n\n    \nuses-permission android:name=\nandroid.permission.INTERNET\n /\n \n    \nuses-permission android:name=\nandroid.permission.ACCESS_NETWORK_STATE\n /\n \n    \nuses-permission android:name=\nandroid.permission.ACCESS_WIFI_STATE\n /\n \n    \nuses-permission android:name=\nandroid.permission.WAKE_LOCK\n /\n \n    \nuses-permission android:name=\nandroid.permission.WRITE_EXTERNAL_STORAGE\n /\n\n    \nuses-permission android:name=\nandroid.permission.READ_PHONE_STATE\n /\n\n\n    \napplication\n        android:allowBackup=\ntrue\n\n        android:icon=\n@drawable/ic_launcher\n\n        android:label=\n@string/app_name\n\n        android:theme=\n@style/AppTheme\n\n        \nactivity\n            android:name=\ncn.bmob.example.MainActivity\n\n            android:screenOrientation=\nportrait\n\n            android:label=\n@string/app_name\n\n\n                \naction android:name=\nandroid.intent.action.MAIN\n/\n\n                \ncategory android:name=\nandroid.intent.category.LAUNCHER\n/\n\n\n\n        \nactivity\n            android:name=\n.CreateActivity\n\n            android:screenOrientation=\nportrait\n\n        \nactivity\n            android:name=\n.DeleteActivity\n\n            android:screenOrientation=\nportrait\n\n        \nactivity\n            android:name=\n.UpdateActivity\n\n            android:screenOrientation=\nportrait\n\n        \nactivity\n            android:name=\n.FindActivity\n\n            android:screenOrientation=\nportrait\n\n    \n/application\n\n\n/manifest\n\n\n\n\n\n初始化BmobSDK\n\n\n在你应用程序启动的Activity的onCreate()方法中初始化Bmob功能。代码如下所示：\n\n\npackage com.bmob.example;\nimport cn.bmob.v3.Bmob;\nimport android.app.Activity;\nimport android.os.Bundle;\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n         // TODO Auto-generated method stub\n        super.onCreate(savedInstanceState);\n         //提供以下两种方式进行初始化操作：\n\n        //第一：默认初始化\n        Bmob.initialize(this, \nYour Application ID\n);\n        // 注:自v3.5.2开始，数据sdk内部缝合了统计sdk，开发者无需额外集成，传渠道参数即可，不传默认没开启数据统计功能\n        //Bmob.initialize(this, \nYour Application ID\n,\nbmob\n);\n\n        //第二：自v3.4.7版本开始,设置BmobConfig,允许设置请求超时时间、文件分片上传时每片的大小、文件的过期时间(单位为秒)，\n        //BmobConfig config =new BmobConfig.Builder(this)\n        ////设置appkey\n        //.setApplicationId(\nYour Application ID\n)\n        ////请求超时时间（单位为秒）：默认15s\n        //.setConnectTimeout(30)\n        ////文件分片上传时每片的大小（单位字节），默认512*1024\n        //.setUploadBlockSize(1024*1024)\n        ////文件的过期时间(单位为秒)：默认1800s\n        //.setFileExpiration(2500)\n        //.build();\n        //Bmob.initialize(config);\n    }\n}\n\n\n\n\n添加一行数据\n\n\n首先创建JavaBean（对应为Bmob后台的数据表，更详细的解释请\n查看Android开发文档\n）\n\n\npublic class Person extends BmobObject {\n    private String name;\n    private String address;\n\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public String getAddress() {\n        return address;\n    }\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}\n\n\n\n\n添加数据\n\n\nPerson p2 = new Person();\np2.setName(\nlucky\n);\np2.setAddress(\n北京海淀\n);\np2.save(new SaveListener\nString\n() {\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            toast(\n添加数据成功，返回objectId为：\n+objectId);\n        }else{\n            toast(\n创建数据失败：\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n如果toast出添加数据成功的消息，你会在Bmob对应Application Id的数据表中看到有一行新增的数据，如下图所示：\n\n\n\n\n获取一行数据\n\n\n//查找Person表里面id为6b6c11c537的数据\nBmobQuery\nPerson\n bmobQuery = new BmobQuery\nPerson\n();\nbmobQuery.getObject(\n6b6c11c537\n, new \nQueryListener\nPerson\n() {\n    @Override\n    public void done(Person object,BmobException e) {\n        if(e==null){\n            toast(\n查询成功\n);\n        }else{\n            toast(\n查询失败：\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n修改一行数据\n\n\n//更新Person表里面id为6b6c11c537的数据，address内容更新为“北京朝阳”\nPerson p2 = new Person();\np2.setAddress(\n北京朝阳\n);\np2.update(\n6b6c11c537\n, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n更新成功:\n+p2.getUpdatedAt());\n        }else{\n            toast(\n更新失败：\n + e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n删除一行数据\n\n\nPerson p2 = new Person();\np2.setObjectId(\n6b6c11c537\n);\np2.delete(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n删除成功:\n+p2.getUpdatedAt());\n        }else{\n            toast(\n删除失败：\n + e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n源码下载\n\n\n快速入门相关源码下载\n\n\n案例教程和源码是快速入门的最简单方法，Bmob也为大家准备了相关的\n案例教程和源码\n，欢迎大家下载和查看。\n\n\n为方便大家更好的理解Bmob SDK能够做的事情，我们还特意为大家提供了一些源码，大家可以下载之后，\n嵌入Bmob的AppKey\n，再打包运行。\n\n\n阅读源码是一种良好的习惯！！\n\n\n即时聊天案例源码：\nhttps://github.com/bmob/BmobIMSDK4Android\n\n\n图文社区案例源码：\nhttps://git.oschina.net/v7/Wonderful\n  这个案例是猿圈媛圈开发团队提供的。\n\n\n校园小菜案例源码：\nhttps://github.com/bmob/Shop\n 这个案例是湖工大的朋友提供的。\n\n\n社交分享案例源码：\nhttps://github.com/bmob/bmob-android-social-share\n 这个是金刚锁开发者提供的\n\n\n第三方登录案例源码：\nhttps://github.com/bmob/bmob-android-demo-thirdpartylogin\n  包含第三方登录和登录后获取用户信息的源码\n\n\n阅读更多的文档\n\n\n\n\n快速入门只是提供了最最基本的介绍，如果你想了解更多的功能，请查看我们的详细开发文档：\nhttp://docs.bmob.cn/data/Android/b_developdoc/doc/index.html\n\n\n如果想看下SDK的类库文档，可以移步\n这里", 
            "title": "快速入门"
        }, 
        {
            "location": "/data/android/#bmob", 
            "text": "在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。", 
            "title": "注册Bmob帐号"
        }, 
        {
            "location": "/data/android/#_1", 
            "text": "登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。", 
            "title": "网站后台创建应用"
        }, 
        {
            "location": "/data/android/#sdk", 
            "text": "选择你要开发的应用，进入该应用   在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID   获取Application ID后，下载SDK（下载地址： http://www.bmob.cn/site/sdk#android_sdk ）。", 
            "title": "获取应用密钥和下载SDK"
        }, 
        {
            "location": "/data/android/#sdk_1", 
            "text": "", 
            "title": "SDK导入"
        }, 
        {
            "location": "/data/android/#androidstudio", 
            "text": "鉴于目前Google官方推荐使用  Android Studio  进行Android项目开发，自  V3.4.2  开始，Bmob Android SDK 可以使用Gradle来进行包依赖管理，如果你使用Android Studio来进行基于BmobSDK的项目开发，有两种方式：", 
            "title": "AndroidStudio配置"
        }, 
        {
            "location": "/data/android/#_2", 
            "text": "请按照如下两个步骤进行：   在  Project  的  build.gradle  文件中添加  Bmob的maven仓库地址 ，示例如下：（ 注意文字说明部分 ）：       buildscript {\n        repositories {\n            jcenter()\n        }\n        dependencies {\n            classpath 'com.android.tools.build:gradle:1.2.3'\n        }\n    }\n\n    allprojects {\n        repositories {\n            jcenter()\n            //Bmob的maven仓库地址--必填\n            maven { url  https://raw.github.com/bmob/bmob-android-sdk/master  }\n        }\n    }   在 app 的 build.gradle 文件中添加 compile依赖文件 ,示例如下：（ 注意文字说明部分 ）：       apply plugin: 'com.android.application'\n\n    android {\n        compileSdkVersion 22\n        buildToolsVersion '22.0.1'\n\n        **兼容Android6.0系统所需，如果这句话报错，可在dependencies标签下使用compile 'cn.bmob.android:http-legacy:1.0'**\n        useLibrary 'org.apache.http.legacy'\n\n        ...\n    }\n\n\n    dependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n\n        //以下SDK开发者请根据需要自行选择\n        //bmob-sdk：Bmob的android sdk包，包含了Bmob的数据存储、文件等服务，以下是最新的bmob-sdk:\n        //3.5.5：请务必查看下面注释[1]\n        compile 'cn.bmob.android:bmob-sdk:3.5.5'\n\n        //bmob-push：Bmob的推送包\n        compile 'cn.bmob.android:bmob-push:0.8'\n\n        //bmob-im：Bmob的即时通讯包，注意每个版本的im依赖特定版本的bmob-sdk，具体的依赖关系可查看下面注释[2]\n        compile 'cn.bmob.android:bmob-im:2.0.5@aar'\n        compile 'cn.bmob.android:bmob-sdk:3.4.7-aar'\n\n        //bmob-sms ：Bmob单独为短信服务提供的包\n        compile 'cn.bmob.android:bmob-sms:1.0.1'\n\n        //如果你想应用能够兼容Android6.0，请添加此依赖(org.apache.http.legacy.jar)\n        compile 'cn.bmob.android:http-legacy:1.0'\n    }  注：  [1]、为了降低开发者的使用成本，自v3.4.7开始，同步提供 aar 格式的文件，此aar包含 libbmob.so、依赖jar包(okhttp、okio、rx、gson等)及自动更新组件所需要的资源文件 。开发者再也不需要配置libbmob.so,不需要添加依赖jar，也不需要复制自动更新组件的资源文件啦，只需要添加以下依赖即可。  compile 'cn.bmob.android:bmob-sdk:3.5.0'  注：由于 PermissionManager权限管理类 需要依赖 support-v4:23.2.1 的jar包,导致开发者认为SDK依赖文件较多，故分离出SDK。开发者如果需要兼容Android6.0系统，可以在下载的SDK的官方Demo的 com.example.bmobexample.permission 包下面查看该类源码。  [2]、每个版本的im依赖特定版本的bmob-sdk：   bmob-im:1.1.8--- bmob-sdk:3.3.5  bmob-im:1.1.9--- bmob-sdk:3.4.3  bmob-im:2.0.1--- bmob-sdk:3.4.6-0304  bmob-im:2.0.2--- bmob-sdk:3.4.6-0304  bmob-im:2.0.3--- bmob-sdk:3.4.6  bmob-im:2.0.4--- bmob-sdk:3.4.6    bmob-im:2.0.5--- bmob-sdk:3.4.7-aar  bmob-im:2.0.6--- bmob-sdk:3.5.0   其中   bmob-sdk:3.4.6-0304 是Bmob Android SDK的过渡版本，主要用于NewIM_v2.0.1及v2.0.2  bmob-sdk:3.4.6 的相关依赖包可见注释[3]   [3]、bmob-sdk:3.4.6依赖以下包：  compile 'cn.bmob.android:bmob-sdk:3.4.6'\ncompile 'com.squareup.okhttp:okhttp:2.4.0'//CDN文件服务使用okhttp相关包进行文件的上传和下载（必填）\ncompile 'com.squareup.okio:okio:1.4.0'  如果需要兼容Android6.0系统，请添加以下两项：  compile 'com.android.support:support-v4:23.2.1'\ncompile 'cn.bmob.android:http-legacy:1.0'  [4]、bmob-sms适用于只需要使用Bmob短信功能的开发者，而bmob-sdk内部包含了bmob-sms的短信功能,请不要重复添加。  [5]、BmobSDK的官方仓库： bmob-android-sdk ，开发者可到此仓库查看最新发布的各版本SDK，我们会尽量与官网发布的SDK保持同步更新。", 
            "title": "自动导入(推荐)"
        }, 
        {
            "location": "/data/android/#_3", 
            "text": "开发者到 SDK下载中心 下载  数据服务  的Android 版本的SDK，并将下载下来的 libs 文件夹里面的文件根据需要复制到工程的libs目录下(注意，自 v3.4.7 开始提供 libbmob.so 文件)；     在 app 的 buid.gradle 文件中添加SO库目录配置：  android {\n    sourceSets {\n        main.jniLibs.srcDirs = ['libs']\n   }\n}    点击Sync，同步配置。", 
            "title": "手动导入"
        }, 
        {
            "location": "/data/android/#eclipse", 
            "text": "开发者到  SDK下载中心  下载  数据服务  的Android 版本的SDK，在Eclipse工程的项目根目录中新建 libs 文件夹，将下载的jar包添加到此文件夹即可。  注：  1、若配置不成功，则需要额外增加以下步骤：  右键工程根目录，选择 Properties -  Java Build Path -  Libraries ，然后点击 Add External JARs...  选择指向该libs文件夹下的jar的路径，点击OK即可  2、BmobSDK_v3.5.0需要依赖 rxjava（1.1.6）、rxandroid(1.2.0)、gson(2.6.2)、okhttp3（3.3.1）、okio（1.7.0） 及 libbmob.so 库；  3、BmobSDK_v3.4.7需要依赖 okhttp3（3.2.0）、okio（1.7.0） 及 libbmob.so 库；  4、BmobSDK_v3.4.6需要依赖 okhttp（2.4.0）、okio（1.4.0） ，如果需要兼容Android6.0系统，则还需要添加support-v4（23.2.1）及org.apache.http.legacy依赖包。", 
            "title": "Eclipse导入"
        }, 
        {
            "location": "/data/android/#androidmanifestxml", 
            "text": "在你的应用程序的 AndroidManifest.xml 文件中添加相应的权限：   !--允许联网 --   uses-permission android:name= android.permission.INTERNET  /   !--获取GSM（2g）、WCDMA（联通3g）等网络状态的信息  --   uses-permission android:name= android.permission.ACCESS_NETWORK_STATE  /   !--获取wifi网络状态的信息 --   uses-permission android:name= android.permission.ACCESS_WIFI_STATE  /   !--保持CPU 运转，屏幕和键盘灯有可能是关闭的,用于文件上传和下载 --  uses-permission android:name= android.permission.WAKE_LOCK  /   !--获取sd卡写的权限，用于文件上传和下载--  uses-permission android:name= android.permission.WRITE_EXTERNAL_STORAGE  /  !--允许读取手机状态 用于创建BmobInstallation--   uses-permission android:name= android.permission.READ_PHONE_STATE  /   ?xml version= 1.0  encoding= utf-8 ? \n     manifest xmlns:android= http://schemas.android.com/apk/res/android \n        package= cn.bmob.example \n        android:versionCode= 1 \n        android:versionName= 1.0 \n\n     uses-sdk android:minSdkVersion= 8  android:targetSdkVersion= 17 / \n\n     uses-permission android:name= android.permission.INTERNET  /  \n     uses-permission android:name= android.permission.ACCESS_NETWORK_STATE  /  \n     uses-permission android:name= android.permission.ACCESS_WIFI_STATE  /  \n     uses-permission android:name= android.permission.WAKE_LOCK  /  \n     uses-permission android:name= android.permission.WRITE_EXTERNAL_STORAGE  / \n     uses-permission android:name= android.permission.READ_PHONE_STATE  / \n\n     application\n        android:allowBackup= true \n        android:icon= @drawable/ic_launcher \n        android:label= @string/app_name \n        android:theme= @style/AppTheme \n         activity\n            android:name= cn.bmob.example.MainActivity \n            android:screenOrientation= portrait \n            android:label= @string/app_name \n\n                 action android:name= android.intent.action.MAIN / \n                 category android:name= android.intent.category.LAUNCHER / \n\n\n         activity\n            android:name= .CreateActivity \n            android:screenOrientation= portrait \n         activity\n            android:name= .DeleteActivity \n            android:screenOrientation= portrait \n         activity\n            android:name= .UpdateActivity \n            android:screenOrientation= portrait \n         activity\n            android:name= .FindActivity \n            android:screenOrientation= portrait \n     /application  /manifest", 
            "title": "配置AndroidManifest.xml"
        }, 
        {
            "location": "/data/android/#bmobsdk", 
            "text": "在你应用程序启动的Activity的onCreate()方法中初始化Bmob功能。代码如下所示：  package com.bmob.example;\nimport cn.bmob.v3.Bmob;\nimport android.app.Activity;\nimport android.os.Bundle;\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n         // TODO Auto-generated method stub\n        super.onCreate(savedInstanceState);\n         //提供以下两种方式进行初始化操作：\n\n        //第一：默认初始化\n        Bmob.initialize(this,  Your Application ID );\n        // 注:自v3.5.2开始，数据sdk内部缝合了统计sdk，开发者无需额外集成，传渠道参数即可，不传默认没开启数据统计功能\n        //Bmob.initialize(this,  Your Application ID , bmob );\n\n        //第二：自v3.4.7版本开始,设置BmobConfig,允许设置请求超时时间、文件分片上传时每片的大小、文件的过期时间(单位为秒)，\n        //BmobConfig config =new BmobConfig.Builder(this)\n        ////设置appkey\n        //.setApplicationId( Your Application ID )\n        ////请求超时时间（单位为秒）：默认15s\n        //.setConnectTimeout(30)\n        ////文件分片上传时每片的大小（单位字节），默认512*1024\n        //.setUploadBlockSize(1024*1024)\n        ////文件的过期时间(单位为秒)：默认1800s\n        //.setFileExpiration(2500)\n        //.build();\n        //Bmob.initialize(config);\n    }\n}", 
            "title": "初始化BmobSDK"
        }, 
        {
            "location": "/data/android/#_4", 
            "text": "首先创建JavaBean（对应为Bmob后台的数据表，更详细的解释请 查看Android开发文档 ）  public class Person extends BmobObject {\n    private String name;\n    private String address;\n\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public String getAddress() {\n        return address;\n    }\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}  添加数据  Person p2 = new Person();\np2.setName( lucky );\np2.setAddress( 北京海淀 );\np2.save(new SaveListener String () {\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            toast( 添加数据成功，返回objectId为： +objectId);\n        }else{\n            toast( 创建数据失败：  + e.getMessage());\n        }\n    }\n});  如果toast出添加数据成功的消息，你会在Bmob对应Application Id的数据表中看到有一行新增的数据，如下图所示：", 
            "title": "添加一行数据"
        }, 
        {
            "location": "/data/android/#_5", 
            "text": "//查找Person表里面id为6b6c11c537的数据\nBmobQuery Person  bmobQuery = new BmobQuery Person ();\nbmobQuery.getObject( 6b6c11c537 , new  QueryListener Person () {\n    @Override\n    public void done(Person object,BmobException e) {\n        if(e==null){\n            toast( 查询成功 );\n        }else{\n            toast( 查询失败：  + e.getMessage());\n        }\n    }\n});", 
            "title": "获取一行数据"
        }, 
        {
            "location": "/data/android/#_6", 
            "text": "//更新Person表里面id为6b6c11c537的数据，address内容更新为“北京朝阳”\nPerson p2 = new Person();\np2.setAddress( 北京朝阳 );\np2.update( 6b6c11c537 , new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 更新成功: +p2.getUpdatedAt());\n        }else{\n            toast( 更新失败：  + e.getMessage());\n        }\n    }\n\n});", 
            "title": "修改一行数据"
        }, 
        {
            "location": "/data/android/#_7", 
            "text": "Person p2 = new Person();\np2.setObjectId( 6b6c11c537 );\np2.delete(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 删除成功: +p2.getUpdatedAt());\n        }else{\n            toast( 删除失败：  + e.getMessage());\n        }\n    }\n\n});", 
            "title": "删除一行数据"
        }, 
        {
            "location": "/data/android/#_8", 
            "text": "快速入门相关源码下载  案例教程和源码是快速入门的最简单方法，Bmob也为大家准备了相关的 案例教程和源码 ，欢迎大家下载和查看。  为方便大家更好的理解Bmob SDK能够做的事情，我们还特意为大家提供了一些源码，大家可以下载之后， 嵌入Bmob的AppKey ，再打包运行。  阅读源码是一种良好的习惯！！  即时聊天案例源码： https://github.com/bmob/BmobIMSDK4Android  图文社区案例源码： https://git.oschina.net/v7/Wonderful   这个案例是猿圈媛圈开发团队提供的。  校园小菜案例源码： https://github.com/bmob/Shop  这个案例是湖工大的朋友提供的。  社交分享案例源码： https://github.com/bmob/bmob-android-social-share  这个是金刚锁开发者提供的  第三方登录案例源码： https://github.com/bmob/bmob-android-demo-thirdpartylogin   包含第三方登录和登录后获取用户信息的源码", 
            "title": "源码下载"
        }, 
        {
            "location": "/data/android/#_9", 
            "text": "快速入门只是提供了最最基本的介绍，如果你想了解更多的功能，请查看我们的详细开发文档： http://docs.bmob.cn/data/Android/b_developdoc/doc/index.html  如果想看下SDK的类库文档，可以移步 这里", 
            "title": "阅读更多的文档"
        }, 
        {
            "location": "/data/android/develop_doc/", 
            "text": "简介\n\n\nBmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。\n\n\n快速入门\n\n\n建议您在阅读本开发文档之前，先阅读我们提供的 \nAndroid快速入门文档\n，便于您后续的开发。\n\n如果开发者想使用不同历史版本的SDK，可以移步\n历史版本的github仓库\n，选择使用各个历史版本。\n\n\n模板代码\n\n\n在使用SDK过程中，如果一些Api如查询是高频代码，可以把一些重复的样板代码抽出来，并在AndroidStudio中设置模板，即可实现快速输入，能提高编码效率，效果如下：\n\n\n\n\n数据迁移\n\n\n从v3.5.5开始，数据SDK新增了能重新设置请求域名的Api，类似数据迁移，调用方式如下：\n\n\n    Bmob.resetDomain(\"http://demo.bmob.cn/\");\n\n\n\n其中，参数为开发者的域名，调用后的所有请求都指向新的域名。\n\n\n统计SDK\n\n\n从v3.5.2开始，把统计SDK集成到了数据服务SDK，上传应用不再需要额外集成统计SDK，低于此版本的可以去控制台的应用官网下载。\n\n\n添加方法\n\n\n\n\n\n\n确保项目有\nINTERNET\n和\nREAD_PHONE_STATE\n权限\n\n\nuses-permission android:name=\"android.permission.INTERNET\" /\n\n\nuses-permission android:name=\"android.permission.READ_PHONE_STATE\" /\n\n\n\n\n\n\n\n\n在初始化方法中传一个渠道参数(不传默认没开启统计功能)\n\n\nBmob.initialize(this,APPID,\"Bmob\");\n\n\n\n\n\n\n\n将libs文件夹内的BmobStat.jar文件添加进项目（AS选择远程依赖可以忽略，本地依赖需要指定libs文件夹，Eclipse中放进libs即可）；\n\n\n\n\n\n\n兼容Android6.0系统\n\n\n自\nv3.4.6\n版本开始，Bmob提供了一些新的方法和工具类来帮助开发者为自己的应用兼容Android6.0系统。\n\n\n添加对Apache的HTTP-client支持\n\n\nAndroid6.0版本移除了对Appache的HTTP client的支持，因此，需要添加\norg.apache.http.legacy.jar\n包，请参照如下方式添加：\n\n\n1.Eclipse\n\n\n你需要在Eclipse工程的项目根目录中新建libs文件夹，将org.apache.http.legacy.jar包，添加到libs文件夹中\n\n\n\n2.AndroidStudio\n\n\n你需要在\napp\n的\nbuild.gradle\n文件添加配置信息useLibrary 'org.apache.http.legacy'声明编译时依赖\n\n\n    android {\n        compileSdkVersion 23\n        buildToolsVersion \"23.0.2\"\n        useLibrary 'org.apache.http.legacy'\n    }\n\n\n\n注：如果在build.gradle文件中\nuseLibrary 'org.apache.http.legacy'\n这句话报错，可将该jar直接放到libs目录下即可。\n\n\n运行时权限管理\n\n\nAndroid6.0中对特定的权限进行了动态授权的方式，需要在运行时用户手动授予，如果用户拒绝后再次申请还可以向用户弹框说明权限的作用，用户点击确认后再去申请。\n\n\n因此，我们提供了一个权限管理的工具类\nPermissionManager(cn.bmob.v3.helper)\n，具体使用如下：\n\n\n注：在\nv3.4.6\n的BmobSDK内部集成\nPermissionManager\n类，自\nv3.4.7\n以后的SDK内部将不再提供该类，开发者可以在下载的配套官方Demo的\ncom.example.bmobexample.permission\n包下面查看该类源码。\n\n\n1.构建\nPermissionManager\n对象\n\n\nPermissionManager helper;\nhelper = PermissionManager.with(MainActivity.this)\n        //添加权限请求码\n        .addRequestCode(MainActivity.REQUEST_CODE_CAMERA)\n        //设置权限，可以添加多个权限\n        .permissions(Manifest.permission.CAMERA)\n        //设置权限监听器\n        .setPermissionsListener(new PermissionListener() {\n\n            @Override\n            public void onGranted() {\n                //当权限被授予时调用\n               Toast.makeText(MainActivity.this, \"Camera Permission granted\",Toast.LENGTH_LONG).show();\n            }\n\n            @Override\n            public void onDenied() {\n                //用户拒绝该权限时调用\n               Toast.makeText(MainActivity.this, \"Camera Permission denied\",Toast.LENGTH_LONG).show();\n            }\n\n            @Override\n            public void onShowRationale(String[] permissions) {\n                //当用户拒绝某权限时并点击`不再提醒`的按钮时，下次应用再请求该权限时，需要给出合适的响应（比如,给个展示对话框来解释应用为什么需要该权限）\n                Snackbar.make(btn_camera, \"需要相机权限去拍照\", Snackbar.LENGTH_INDEFINITE)\n                        .setAction(\"ok\", new View.OnClickListener() {\n                            @Override\n                            public void onClick(View v) {\n                                //必须调用该`setIsPositive(true)`方法\n                                helper.setIsPositive(true);\n                                helper.request();\n                            }\n                        }).show();\n            }\n        })\n        //请求权限\n        .request();\n\n\n\n注：\n\n\n\n\nwith\n方法可以传入Activity或者Fragment；\n\n\naddRequestCode\n方法传入请求码，用于区分各种不同的权限申请；\n\n\npermissions\n方法传入的是你所要请求的权限，支持可变参数，可以批量申请权限；\n\n\nPermissionListener\n接口回调的三个方法：\n\n\nonGranted()会在权限申请通过后被调用；\n\n\nonDenied()在权限申请被拒绝时被调用\n\n\nonShowRationale()方法中你可以弹对话框向用户解释权限的作用，不过记得要调用\nsetIsPositive(true)\n。\n\n\nrequest\n方法用来请求权限申请\n\n\n\n\n2.覆写\nonRequestPermissionsResult\n方法\n\n\n@Override\npublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n    switch (requestCode) {\n        case REQUEST_CODE_CAMERA:\n            helper.onPermissionResult(permissions, grantResults);\n            break;\n    }\n}\n\n\n\nNotification变更\n\n\nAndroid6.0中，\nNotification.setLatestEventInfo()\n方法被移除，替代的方案是用Notification.Builder来构建通知，对此SDK提供了\nNotificationCompat(cn.bmob.v3.helper)\n类来做版本兼容（与\nandroid.support.v4.app\n包下的NotificationCompat用法一样）。\n\n\n参照代码如下：\n\n\n    NotificationManager notificationManager = (NotificationManager) mContext\n            .getSystemService(Context.NOTIFICATION_SERVICE);\n    PendingIntent pi = PendingIntent.getActivity(mContext, 0,\n            new Intent(MainActivity.this, MainActivity.class), 0);\n    NotificationCompat.Builder builder = new NotificationCompat.Builder(mContext)\n            .setTicker(\n更新啦\n)\n            .setContentTitle(\n标题\n)\n            .setContentText(\n内容\n)\n            .setSmallIcon(R.drawable.ic_launcher);\n    Notification notification = builder.build();\n    notificationManager.notify(0, notification);\n\n\n\n\n对象\n\n\n一个数据对象（APP中创建的BmobObject类的子类）对应于Bmob后台的一个数据表。\n\n\n数据对象\n\n\nBmob存储的数据是建立在BmobObject基础上的，所以任何要保存的数据对象必须继承自BmobObject类(不建议用抽象类去继承BmobObject或者定义父类然后在子类中写bean，这样也解析不了，一般不会这么用，一个bean类对应一张表，类似使用ORM库)。BmobObject类本身包含objectId、createdAt、updatedAt、ACL四个默认的属性，objectId是数据的唯一标示，相当于数据库中表的主键，createdAt是数据的创建时间，updatedAt是数据的最后修改时间，ACL是数据的操作权限。\n\n\n如，你的游戏中使用GameScore表来记录玩家的比分信息，其中表的字段有：score（分数）、playerName（玩家名字）、isPay(是否付费玩家)、pic（玩家头像）属性，那么这个数据对象为如下定义：\n\n\n//必须要继承自BmobObject类\npublic class GameScore extends BmobObject{\n\n    private String playerName;\n    private Integer score;\n    private Boolean isPay;\n    private BmobFile pic;\n\n    public String getPlayerName() {\n        return playerName;\n    }\n\n    public void setPlayerName(String playerName) {\n        this.playerName = playerName;\n    }\n\n    public Integer getScore() {\n        return score;\n    }\n\n    public void setScore(Integer score) {\n        this.score = score;\n    }\n\n    public Boolean getIsPay() {\n        return isPay;\n    }\n\n    public void setIsPay(Boolean isPay) {\n        this. isPay = isPay;\n    }\n\n    public BmobFile getPic() {\n        return pic;\n    }\n\n    public void setPic(BmobFile pic) {\n        this.pic = pic;\n    }\n}\n\n\n\n\n需要注意的是：\n\n\n\n\nJavaBean不需要对\nobjectId、createdAt、updatedAt、ACL\n四个属性进行定义。\n\n\n不少开发者会没有注意到createdAt和updatedAt属性中的字母d，写成createAt和updateAt。\n\n\n尽可能使用Integer、Boolean，而不是int、boolean，也就是选择包装类，而不是使用基本数据类型（这两者的区别大家可以看这篇文章：http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html）\n\n\n\n\n特殊对象\n\n\n为了提供更好的服务，BmobSDK中提供了\nBmobUser、BmobInstallation、BmobRole\n三个特殊的BmobObject对象来完成不同的功能，在这里我们统一称为特殊对象。\n\n\n\n\n\n\nBmobUser\n对象主要是针对应用中的用户功能而提供的，它对应着web端的User表，使用BmobUser对象可以很方便的在应用中实现用户的注册、登录、邮箱验证等功能，具体的使用方法可查看文档的\n用户管理\n部分。\n\n\n\n\n\n\nBmobInstallation\n对象主要用于应用的安装设备管理中，它对应着web端的Installation表，任何安装了你应用的设备都会在此表中产生一条数据标示该设备。结合Bmob提供的推送功能，还可以实现将自定义的消息推送给不同的设备终端，具体的使用方法可查看文档的\n消息推送\n部分。\n\n\n\n\n\n\nBmobRole\n对象主要用于角色管理，对应用于Web端的Role表，具体的使用方法可查看文档的\nACL和角色\n部分。\n\n\n\n\n\n\n数据类型\n\n\n目前为止，Bmob支持的数据类型：String、Integer、Float、Short、Byte、Double、Character、Boolean、Object、Array。\n同时也支持BmobObject、BmobDate、BmobGeoPoint、BmobFile特有的数据类型。\n\n\n以下为Web端类型与SDK端支持的JAVA类型对应表：\n\n\n\n\n\n\n\n\nWeb端类型\n\n\n支持的JAVA类型\n\n\n说明\n\n\n\n\n\n\n\n\n\n\nNumber\n\n\nInteger、Float、Short、Byte、Double、Character\n\n\n对应数据库的Number类型\n\n\n\n\n\n\nArray\n\n\nList\n\n\n数组类型\n\n\n\n\n\n\nFile\n\n\nBmobFile\n\n\nBmob特有类型，用来标识文件类型\n\n\n\n\n\n\nGeoPoint\n\n\nBmobGeoPoint\n\n\nBmob特有类型，用来标识地理位置\n\n\n\n\n\n\nDate\n\n\nBmobDate\n\n\nBmob特有类型，用来标识日期类型\n\n\n\n\n\n\nPointer\n\n\n特定对象\n\n\nBmob特有类型，用来标识指针类型\n\n\n\n\n\n\nRelation\n\n\nBmobRelation\n\n\nBmob特有类型，用来标识数据关联\n\n\n\n\n\n\n\n\n注：不能使用int、float、short byte、double、character等基本数据类型。\n\n\n类名和表名的关系\n\n\n\n\nBmob官方推荐类名和表名完全一致的映射使用方式， 即如，上面的GameScore类，它在后台对应的表名也是GameScore（区分大小写）。\n\n\n如果你希望表名和类名并不相同，如表名为T_a_b，而类名还是GameScore，那么你可以使用BmobObject提供的setTableName(\"表名\")的方法，\n\n\n\n\n示例代码如下：\n\n\n//这时候实际操作的表是T_a_b\npublic class GameScore extends BmobObject{\n    private String playerName;\n    private Integer score;\n    private Boolean isPay;\n    private BmobFile pic;\n\n    public GameScore() {\n        this.setTableName(\nT_a_b\n);\n    }\n\n    public String getPlayerName() {\n        return playerName;\n    }\n    //其他方法，见上面的代码\n}\n\n\n\n\n当然了，除了在构造函数中直接调用setTableName方法之外，你还可以在GameScore的实例中动态调用setTableName方法。\n\n\n查询自定义表名的数据\n\n\n如果您使用了setTableName方法来自定义表名，那么在对该表进行数据查询的时候必须使用以下方法。\n需要注意的是查询的结果是JSONArray,需要自行解析JSONArray中的数据\n。\n\n\n/**\n * 查询数据\n */\npublic void queryData(){\n    BmobQuery query =new BmobQuery(\nPerson\n);\n    query.addWhereEqualTo(\nage\n, 25);\n    query.setLimit(2);\n    query.order(\ncreatedAt\n);\n    //v3.5.0版本提供`findObjectsByTable`方法查询自定义表名的数据\n    query.findObjectsByTable(new QueryListener\nJSONArray\n() {\n        @Override\n        public void done(JSONArray ary, BmobException e) {\n            if(e==null){\n                Log.i(\nbmob\n,\n查询成功：\n+ary.toString());\n            }else{\n                Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n            }\n        }\n    });\n}\n\n\n\n\n自定义表名情况下的更新、删除数据和普通的更新、删除数据方式一样，没有变化。为方便大家了解学习，我们提供了一个关于自定义表名情况下增删改查数据的Demo，下载地址是：\nhttps://github.com/bmob/bmob-android-demo-dynamic-tablename\n。\n\n\n添加数据\n\n\n添加数据使用BmobObject对象的\nsave\n方法，就可以将当前对象的内容保存到Bmob服务端。\n例如，你现在要保存一条游戏分数的记录，代码如下：\n\n\nGameScore gameScore = new GameScore();\n//注意：不能调用gameScore.setObjectId(\n)方法\ngameScore.setPlayerName(\n比目\n);\ngameScore.setScore(89);\ngameScore.setIsPay(false);\ngameScore.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        if(e==null){\n            toast(\n创建数据成功：\n + objectId);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n})\n\n\n\n\n运行以上代码，如果添加成功，你可以在Bmob提供的后台的数据浏览中看到类似这样的结果：\n\n\nobjectId: \n0c6db13c\n, score: 89, playerName: \n比目\n, isPay: false,createdAt:\n2013-09-27 10:32:54\n, updatedAt:\n2013-09-27 10:32:54\n\n\n\n\n\n这里需要注意的是：\n\n\n\n\n\n\n如果服务器端不存在GameScore表，那么系统将自动建表，并插入数据。\n\n\n\n\n\n\n如果服务器端已经存在GameScore表，和相应的score、playerName、isPay字段，那么你此时添加的数据和数据类型也应该和服务器端的表结构一致，否则会保存数据失败。\n\n\n\n\n\n\n每个BmobObject对象都有几个默认的键(数据列)是不需要开发者指定的，\nobjectId\n是每个保存成功数据的唯一标识符。\ncreatedAt\n和\nupdatedAt\n代表每个对象(每条数据)在服务器上创建和最后修改的时间。这些键(数据列)的创建和数据内容是由服务器端自主来完成的。\n因此，使用save和insert方法时,不需要调用setObjectId方法，否则会出现提示：“It is a reserved field: objectId(105)”--表明objectId为系统保留字段，不允许修改。\n。\n\n\n\n\n\n\n更新数据\n\n\n更新一个对象也是非常简单。例如：将GameScore表中objectId为\n0c6db13c\n的游戏分数修改为77.\n\n\nGameScore gameScore = new GameScore();\ngameScore.setScore(77);\ngameScore.update(\n0c6db13c\n, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n更新成功\n);\n        }else{\n            Log.i(\nbmob\n,\n更新失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n自\nV3.4.4\n版本开始，SDK提供了另一种方法来更新数据，通过调用\nBmobobject\n类中的\nsetValue（key，value）\n方法，只需要传入key及想要更新的值即可\n\n\n举例，说明如下：\n\n\npublic class Person extends BmobObject {\n    private BmobUser user;  //BmobObject类型\n    private BankCard cards; //Object类型\n    private Integer age;    //Integer类型\n    private Boolean gender; //Boolean类型\n    ...\n    getter、setter方法\n}\n\n其中BankCard类结构如下：\n\npublic class BankCard{\n    private String cardNumber;\n    private String bankName;\n    public BankCard(String bankName, String cardNumber){\n        this.bankName = bankName;\n        this.cardNumber = cardNumber;\n    }\n    ...\n    getter、setter方法\n}\n\n\n\n\n\nPerson p2=new Person();\n//更新BmobObject的值\n//  p2.setValue(\nuser\n, BmobUser.getCurrentUser(this, MyUser.class));\n//更新Object对象\np2.setValue(\nbankCard\n,new BankCard(\n农行\n, \n农行账号\n));\n//更新Object对象的值\n//p2.setValue(\nbankCard.bankName\n,\n建行\n);\n//更新Integer类型\n//p2.setValue(\nage\n,11);\n//更新Boolean类型\n//p2.setValue(\ngender\n, true);\np2.update(objectId, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n更新成功\n);\n        }else{\n            Log.i(\nbmob\n,\n更新失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n\n});\n\n\n\n\n\n注意：修改数据只能通过objectId来修改，目前不提供查询条件方式的修改方法。\n\n\n原子计数器\n\n\n很多应用可能会有计数器功能的需求，比如文章点赞的功能，如果大量用户并发操作，用普通的更新方法操作的话，会存在数据不一致的情况。\n\n\n为此，Bmob提供了原子计数器来保证原子性的修改某一\n数值字段\n的值。注意：原子计数器只能对应用于Web后台的Number类型的字段，即JavaBeans数据对象中的Integer对象类型（\n不要用int类型\n）。\n\n\ngameScore.increment(\nscore\n); // 分数递增1\ngameScore.update(updateListener);\n\n\n\n\n您还可以通过\nincrement(key, amount)\n方法来递增或递减任意幅度的数字\n\n\ngameScore.increment(\nscore\n, 5); // 分数递增5\n//gameScore.increment(\nscore\n, -5); // 分数递减5\ngameScore.update(updateListener);\n\n\n\n\n删除数据\n\n\n从服务器删除对象。例如：将GameScore表中objectId为\ndd8e6aff28\n的数据删除。\n\n\nGameScore gameScore = new GameScore();\ngameScore.setObjectId(\ndd8e6aff28\n);\ngameScore.delete(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n注意：删除数据只能通过objectId来删除，目前不提供查询条件方式的删除方法。\n\n\n删除字段的值\n\n\n你可以在一个对象中删除一个字段的值，通过\nremove\n操作：\n\n\nGameScore gameScore = new GameScore();\ngameScore.setObjectId(\ndd8e6aff28\n);\ngameScore.remove(\nscore\n);  // 删除GameScore对象中的score字段\ngameScore.update(new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n批量数据操作\n\n\n自2017年04月起，为了提供更稳定的服务，后端启用了QPS限制，所以推荐采用批量数据操作来解决如果需要在循环里多次提交请求但是后端返回QPS达到限制的报错。\n\n\n自\nv3.5.0\n开始,新增\nBmobBatch\n批量操作类，\n支持批量添加、批量更新、批量删除的三种操作的同步提交\n，且批量添加的请求返回objectId字段。\n\n\n在BmobObject对象中提供了三种用于批量操作的方法，分别是\ninsertBatch\n、\nupdateBatch\n、\ndeleteBatch\n,批量添加、更新、删除。\n\n\n批量添加\n\n\nList\nBmobObject\n persons = new ArrayList\nBmobObject\n();\nfor (int i = 0; i \n 3; i++) {\n    Person person = new Person();\n    person.setName(\n张三 \n+i);\n    persons.add(person);\n}\n//第一种方式:v3.5.0之前的版本\nnew BmobObject().insertBatch(this, persons, new SaveListener() {\n    @Override\n    public void onSuccess() {\n        toast(\n批量添加成功\n);\n    }\n    @Override\n    public void onFailure(int code, String msg) {\n        toast(\n批量添加失败:\n+msg);\n    }\n});\n//第二种方式：v3.5.0开始提供\nnew BmobBatch().insertBatch(persons).doBatch(new QueryListListener\nBatchResult\n() {\n    @Override\n    public void done(List\nBatchResult\n o, BmobException e) {\n        if(e==null){\n            for(int i=0;i\no.size();i++){\n                BatchResult result = o.get(i);\n                BmobException ex =result.getError();\n                if(ex==null){\n                    log(\n第\n+i+\n个数据批量添加成功：\n+result.getCreatedAt()\n                    +\n,\n+result.getObjectId()+\n,\n+result.getUpdatedAt());\n                }else{\n                    log(\n第\n+i+\n个数据批量添加失败：\n+ex.getMessage()+\n,\n+ex.getErrorCode());\n                }\n            }\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n批量更新\n\n\nList\nBmobObject\n persons = new ArrayList\nBmobObject\n();\nPerson p1 = new Person();\np1.setObjectId(\ne51d651c22\n);\np1.setAge(25);\nPerson p2 = new Person();\np2.setObjectId(\n3f70a922c4\n);\np2.setAge(26);\np2.setGender(false);\nPerson p3 = new Person();\np3.setObjectId(\n08fdd55765\n);\np3.setAge(27);\n\npersons.add(p1);\npersons.add(p2);\npersons.add(p3);\n\n//第一种方式：v3.5.0之前的版本\nnew BmobObject().updateBatch(this, persons, new UpdateListener() {\n    @Override\n    public void onSuccess() {\n        toast(\n批量更新成功\n);\n    }\n    @Override\n    public void onFailure(int code, String msg) {\n        toast(\n批量更新失败:\n+msg);\n    }\n});\n\n//第二种方式：v3.5.0开始提供\nnew BmobBatch().updateBatch(persons).doBatch(new QueryListListener\nBatchResult\n() {\n\n    @Override\n    public void done(List\nBatchResult\n o, BmobException e) {\n        if(e==null){\n            for(int i=0;i\no.size();i++){\n                BatchResult result = o.get(i);\n                BmobException ex =result.getError();\n                if(ex==null){\n                    log(\n第\n+i+\n个数据批量更新成功：\n+result.getUpdatedAt());\n                }else{\n                    log(\n第\n+i+\n个数据批量更新失败：\n+ex.getMessage()+\n,\n+ex.getErrorCode());\n                }\n            }\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n批量删除\n\n\nList\nBmobObject\n persons = new ArrayList\nBmobObject\n();\nPerson p1 = new Person();\np1.setObjectId(\n38ea274d0c\n);\nPerson p2 = new Person();\np2.setObjectId(\n01e29165bc\n);\nPerson p3 = new Person();\np3.setObjectId(\nd8226c4828\n);\n\npersons.add(p1);\npersons.add(p2);\npersons.add(p3);\n//第一种方式：v3.5.0之前的版本\nnew BmobObject().deleteBatch(this, persons, new DeleteListener() {\n    @Override\n    public void onSuccess() {\n        toast(\n批量删除成功\n);\n    }\n    @Override\n    public void onFailure(int code, String msg) {\n        toast(\n批量删除失败:\n+msg);\n    }\n});\n\n//第二种方式：v3.5.0开始提供\nnew BmobBatch().deleteBatch(persons).doBatch(new QueryListListener\nBatchResult\n() {\n\n            @Override\n            public void done(List\nBatchResult\n o, BmobException e) {\n                if(e==null){\n                    for(int i=0;i\no.size();i++){\n                        BatchResult result = o.get(i);\n                        BmobException ex =result.getError();\n                        if(ex==null){\n                            log(\n第\n+i+\n个数据批量删除成功\n);\n                        }else{\n                            log(\n第\n+i+\n个数据批量删除失败：\n+ex.getMessage()+\n,\n+ex.getErrorCode());\n                        }\n                    }\n                }else{\n                    Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n                }\n            }\n        });\n\n\n\n\n批量添加、批量更新、批量删除同步提交（v3.5.0开始提供）\n\n\nBmobBatch batch =new BmobBatch();\n//批量添加\nList\nBmobObject\n persons = new ArrayList\nBmobObject\n();\nPerson person = new Person();\nperson.setName(\n张三 \n);\npersons.add(person);\nbatch.insertBatch(persons);\n\n//批量更新\nList\nBmobObject\n persons1=new ArrayList\nBmobObject\n();\nPerson p1 = new Person();\np1.setObjectId(\n3388eb6caf\n);\np1.setAge(35);\npersons1.add(p1);\nbatch.updateBatch(persons1);\n\n//批量删除\nList\nBmobObject\n persons2 = new ArrayList\nBmobObject\n();\nPerson p2 = new Person();\np2.setObjectId(\n9af452ebd\n);\npersons2.add(p2);\nbatch.deleteBatch(persons2);\n//执行批量操作\nbatch.doBatch(new QueryListListener\nBatchResult\n(){\n\n    @Override\n    public void done(List\nBatchResult\n results, BmobException ex) {\n        if(ex==null){\n            //返回结果的results和上面提交的顺序是一样的，请一一对应\n            for(int i=0;i\nresults.size();i++){\n                BatchResult result= results.get(i);\n                if(result.isSuccess()){//只有批量添加才返回objectId\n                    log(\n第\n+i+\n个成功：\n+result.getObjectId()+\n,\n+result.getUpdatedAt());\n                }else{\n                    BmobException error= result.getError();\n                    log(\n第\n+i+\n个失败：\n+error.getErrorCode()+\n,\n+error.getMessage());\n                }\n            }\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n\n注：\n\n\n\n\n批量操作每次只支持最大50条记录的操作。\n\n\n批量操作不支持对User表的操作。\n\n\n\n\n查询数据\n\n\n数据的查询可能是每个应用都会频繁使用到的，BmobSDK中提供了\nBmobQuery\n类，它提供了多样的方法来实现不同条件的查询，同时它的使用也是非常的简单和方便的。\n\n\n查询单条数据\n\n\n当我们知道某条数据的\nobjectId\n时，就可以根据\nobjectId\n直接获取单条数据对象。例如：查询\nobjectId\n为\na203eba875\n的人员信息。\n\n\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\nquery.getObject(\na203eba875\n, new QueryListener\nGameScore\n() {\n\n    @Override\n    public void done(GameScore object, BmobException e) {\n        if(e==null){\n            //获得playerName的信息\n            object.getPlayerName();\n            //获得数据的objectId信息\n            object.getObjectId();\n            //获得createdAt数据创建时间（注意是：createdAt，不是createAt）\n            object.getCreatedAt();\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n\n});\n\n\n\n\n查询多条数据\n\n\n查询某个数据表中的所有数据是非常简单的查询操作，例如：查询GameScore表中playerName为“比目”的50条数据记录。\n\n\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\n//查询playerName叫“比目”的数据\nquery.addWhereEqualTo(\nplayerName\n, \n比目\n);\n//返回50条数据，如果不加上这条语句，默认返回10条数据\nquery.setLimit(50);\n//执行查询方法\nquery.findObjects(new FindListener\nGameScore\n() {\n    @Override\n    public void done(List\nGameScore\n object, BmobException e) {\n        if(e==null){\n            toast(\n查询成功：共\n+object.size()+\n条数据。\n);\n            for (GameScore gameScore : object) {\n               //获得playerName的信息\n               gameScore.getPlayerName();\n               //获得数据的objectId信息\n               gameScore.getObjectId();\n               //获得createdAt数据创建时间（注意是：createdAt，不是createAt）\n               gameScore.getCreatedAt();\n            }\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n查询的结果不需要进行任何处理，BmobSDK已经为你封装成相应的JavaBean集合了，你直接使用即可。\n\n\n注：\n\n\n\n\n\n\n通过setLimit方法设置返回的记录数量。更多细节可查看下一节(查询条件)中的分页查询。\n\n\n\n\n\n\nv3.5.2开始可以对查询条件等提供链式调用的写法，如下：\n\n\n\n\n\n\nBmobQuery\nBook\n query = new BmobQuery\n();\nquery.setLimit(8).setSkip(1).order(\n-createdAt\n)\n        .findObjects(new FindListener\nBook\n() {\n            @Override\n            public void done(List\nBook\n object, BmobException e) {\n                if (e == null) {\n                    // ...\n                } else {\n                    // ...\n                }\n            }\n        }); \n\n\n\n\n查询条件\n\n\n在查询的使用过程中，基于不同条件的查询是非常常见的，BmobQuery同样也支持不同条件的查询。\n\n\n比较查询\n\n\n如果要查询特定键的特定值，可以使用\naddWhereEqualTo\n方法，如果要过滤掉特定键的值可以使用\naddWhereNotEqualTo\n方法。\n\n\n比如需要查询playerName不等于“Barbie”的数据时可以这样写：\n\n\nquery.addWhereNotEqualTo(\nplayerName\n, \nBarbie\n);\n\n\n\n\n当然，你可以在你的查询操作中添加多个约束条件，来查询符合要求的数据。\n\n\nquery.addWhereNotEqualTo(\nplayerName\n, \nBarbie\n);     //名字不等于Barbie\nquery.addWhereGreaterThan(\nscore\n, 60);               //条件：分数大于60岁\n\n\n\n\n各种不同条件的比较查询：\n\n\n// 分数 \n 50\nquery.addWhereLessThan(\nscore\n, 50);\n//分数 \n= 50\nquery.addWhereLessThanOrEqualTo(\nscore\n, 50);\n//分数 \n 50\nquery.addWhereGreaterThan(\nscore\n, 50);\n//分数 \n= 50\nquery.addWhereGreaterThanOrEqualTo(\nscore\n, 50);\n\n\n\n\n子查询\n\n\n如果你想查询匹配几个不同值的数据，如：要查询“Barbie”,“Joe”,“Julia”三个人的成绩时，你可以使用\naddWhereContainedIn\n方法来实现。\n\n\nString[] names = {\nBarbie\n, \nJoe\n, \nJulia\n};\nquery.addWhereContainedIn(\nplayerName\n, Arrays.asList(names));\n\n\n\n\n相反，如果你想查询排除“Barbie”,“Joe”,“Julia”这三个人的其他同学的信息，你可以使用\naddWhereNotContainedIn\n方法来实现。\n\n\nString[] names = {\nBarbie\n, \nJoe\n, \nJulia\n};\nquery.addWhereNotContainedIn(\nplayerName\n, Arrays.asList(names));\n\n\n\n\n时间查询\n\n\n时间查询\n比较特殊，我们需要结合\nBmobDate\n这个类来查询某个指定日期时间前后的数据，这里也给出示例供大家参考：\n\n\n比如:\n\n\n如果想查询指定日期之前的数据，则可以使用\naddWhereLessThan\n或者\naddWhereLessThanOrEqualTo\n（包含当天）来查询。\n\n\n如果想查询指定日期之后的数据，则可以使用\naddWhereGreaterThan\n或\naddWhereGreaterThanOrEqualTo\n（包含当天）来查询。\n\n\n如果想查询指定时间当天的数据，则需要使用\n复合与查询\n来查询，例如，想\n查询2015年5月1号当天的Person数据\n,示例代码如下：\n\n\nBmobQuery\nPerson\n query = new BmobQuery\nPerson\n();\nList\nBmobQuery\nPerson\n and = new ArrayList\nBmobQuery\nPerson\n();\n//大于00：00：00\nBmobQuery\nPerson\n q1 = new BmobQuery\nPerson\n();\nString start = \n2015-05-01 00:00:00\n;  \nSimpleDateFormat sdf = new SimpleDateFormat(\nyyyy-MM-dd HH:mm:ss\n);  \nDate date  = null;\ntry {\ndate = sdf.parse(start);\n} catch (ParseException e) {\ne.printStackTrace();\n}  \nq1.addWhereGreaterThanOrEqualTo(\ncreatedAt\n,new BmobDate(date));\nand.add(q1);\n//小于23：59：59\nBmobQuery\nPerson\n q2 = new BmobQuery\nPerson\n();\nString end = \n2015-05-01 23:59:59\n; \nSimpleDateFormat sdf1 = new SimpleDateFormat(\nyyyy-MM-dd HH:mm:ss\n);  \nDate date1  = null;\ntry {\ndate1 = sdf1.parse(end);\n} catch (ParseException e) {\ne.printStackTrace();\n}  \nq2.addWhereLessThanOrEqualTo(\ncreatedAt\n,new BmobDate(date1));\nand.add(q2);\n//添加复合与查询\nquery.and(and);\n\n\n\n\n注：\n\n\n由于createdAt、updatedAt是服务器自动生成的时间，在服务器保存的是精确到微秒值的时间，所以，基于时间类型的比较的值要加1秒。\n\n\n数组查询\n\n\n对于字段类型为数组的情况，需要查找字段中的数组值包含有xxx的对象，可以使用\naddWhereContainsAll\n方法：\n\n\n比如我想查询有阅读和唱歌爱好的人，可以这样：\n\n\nBmobQuery\nPerson\n query = new BmobQuery\nPerson\n();\nString [] hobby = {\n阅读\n,\n唱歌\n};\nquery.addWhereContainsAll(\nhobby\n, Arrays.asList(hobby));\nquery.findObjects(new FindListener\nPerson\n() {\n\n    @Override\n    public void done(List\nPerson\n object, BmobException e) {\n        if(e==null){\n            ...\n        }else{\n            ...\n        }\n    }\n\n});\n\n\n\n\n模糊查询\n\n\n对字符串值的模糊查询 比如 查询包含字符串的值，有几种方法。\n\n\n你可以使用任何正确的正则表达式来检索相匹配的值，使用\naddWhereMatches\n方法：\n\n\nquery.addWhereMatches((\nusername\n, \n^[A-Z]\\\\d\n);\n\n\n\n\n还可以使用如下方法：\n\n\n//查询username字段的值含有“sm”的数据\nquery.addWhereContains(\nusername\n, \nsm\n);\n\n//查询username字段的值是以“sm“字开头的数据\nquery.whereStartsWith(\nusername\n, \nsm\n);\n\n// 查询username字段的值是以“ile“字结尾的数据\nquery.whereEndsWith(\nusername\n, \nile\n);\n\n\n\n\n注:模糊查询只对付费用户开放，付费后可直接使用。\n\n\n列值是否存在\n\n\n如果你想查询某个列的值存在，那么可以使用\naddWhereExists\n方法：\n\n\n//查询username有值的数据\nquery.addWhereExists(\nusername\n);\n\n\n\n\n如果想查询某个列的值不存在，则可以用\naddWhereDoesNotExists\n方法\n\n\n//查询username字段没有值的数据\nquery.addWhereDoesNotExists(\nusername\n);\n\n\n\n\n分页查询\n\n\n有时，在数据比较多的情况下，你希望查询出的符合要求的所有数据能按照多少条为一页来显示，这时可以使用\nsetLimit\n方法来限制查询结果的数据条数来进行分页。\n\n\n默认情况下，Limit的值为\n100\n，最大有效设置值\n1000\n（设置的数值超过1000还是视为1000）。\n\n\nquery.setLimit(10); // 限制最多10条数据结果作为一页\n\n\n\n\n在数据较多的情况下，在\nsetLimit\n的基础上分页显示数据是比较合理的解决办法。\n\nsetSKip\n方法可以做到跳过查询的前多少条数据来实现分页查询的功能。默认情况下Skip的值为10。\n\n\nquery.setSkip(10); // 忽略前10条数据（即第一页数据结果）\n\n\n\n\n大家也可以直接下载我们提供的Demo源码（\nhttps://github.com/bmob/bmob-android-demo-paging\n），查看如何使用分页查询，结合ListView开发下拉刷新查看更多内容的应用。\n\n\n排序\n\n\n对应数据的排序，如数字或字符串，你可以使用升序或降序的方式来控制查询数据的结果顺序：\n\n\n// 根据score字段升序显示数据\nquery.order(\nscore\n);\n// 根据score字段降序显示数据\nquery.order(\n-score\n);\n// 多个排序字段可以用（，）号分隔\nquery.order(\n-score,createdAt\n);\n\n\n\n\n说明：多个字段排序时，先按第一个字段进行排序，再按第二个字段进行排序，依次进行。\n\n\n复合查询\n\n\n与查询(and)\n\n\n有些查询需要使用到复合“与”的查询条件，例如：你想查询出Person表中年龄在6-29岁之间且姓名以\"y\"或者\"e\"结尾的人，那么，可以采用and查询，示例代码如下：\n\n\n//查询年龄6-29岁之间的人，每一个查询条件都需要New一个BmobQuery对象\n//--and条件1\nBmobQuery\nPerson\n eq1 = new BmobQuery\nPerson\n();\neq1.addWhereLessThanOrEqualTo(\nage\n, 29);//年龄\n=29\n//--and条件2\nBmobQuery\nPerson\n eq2 = new BmobQuery\nPerson\n();\neq2.addWhereGreaterThanOrEqualTo(\nage\n, 6);//年龄\n=6\n\n//查询姓名以\ny\n或者\ne\n结尾的人--这个需要使用到复合或查询（or）\n//--and条件3\nBmobQuery\nPerson\n eq3 = new BmobQuery\nPerson\n();\neq3.addWhereEndsWith(\nname\n, \ny\n);\nBmobQuery\nPerson\n eq4 = new BmobQuery\nPerson\n();\neq4.addWhereEndsWith(\nname\n, \ne\n);\nList\nBmobQuery\nPerson\n queries = new ArrayList\nBmobQuery\nPerson\n();\nqueries.add(eq3);\nqueries.add(eq4);\nBmobQuery\nPerson\n mainQuery = new BmobQuery\nPerson\n();\nBmobQuery\nPerson\n or = mainQuery.or(queries);\n\n//最后组装完整的and条件\nList\nBmobQuery\nPerson\n andQuerys = new ArrayList\nBmobQuery\nPerson\n();\nandQuerys.add(eq1);\nandQuerys.add(eq2);\nandQuerys.add(or);\n//查询符合整个and条件的人\nBmobQuery\nPerson\n query = new BmobQuery\nPerson\n();\nquery.and(andQuerys);\nquery.findObjects(new FindListener\nPerson\n() {\n    @Override\n    public void done(List\nPerson\n object, BmobException e) {\n        if(e==null){\n            toast(\n查询年龄6-29岁之间，姓名以'y'或者'e'结尾的人个数：\n+object.size());\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n或查询(or)\n\n\n有些情况，在查询的时候需要使用到复合的“或”的查询条件。例如，你想查出 Person 表中 age 等于 29 或者 age 等于 6 的人，可以这样：\n\n\nBmobQuery\nPerson\n eq1 = new BmobQuery\nPerson\n();\neq1.addWhereEqualTo(\nage\n, 29);\nBmobQuery\nPerson\n eq2 = new BmobQuery\nPerson\n();\neq2.addWhereEqualTo(\nage\n, 6);\nList\nBmobQuery\nPerson\n queries = new ArrayList\nBmobQuery\nPerson\n();\nqueries.add(eq1);\nqueries.add(eq2);\nBmobQuery\nPerson\n mainQuery = new BmobQuery\nPerson\n();\nmainQuery.or(queries);\nmainQuery.findObjects(new FindListener\nPerson\n() {\n    @Override\n    public void done(List\nPerson\n object, BmobException e) {\n        if(e==null){\n            toast(\n查询年龄6-29岁之间，姓名以'y'或者'e'结尾的人个数：\n+object.size());\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n你还可以在此基础上添加更多的约束条件到新创建的 BmobQuery 对象上，表示一个 and 查询操作。\n\n\n查询结果计数\n\n\n如果你只是想统计满足查询对象的数量，你并不需要获取所有匹配对象的具体数据信息，可以直接使用\ncount\n替代\nfindObjects\n。例如，查询一个特定玩家玩的游戏场数：\n\n\nBmobQuery\nGameSauce\n query = new BmobQuery\nGameSauce\n();\nquery.addWhereEqualTo(\nplayerName\n, \nBarbie\n);\nquery.count(GameSauce.class, new CountListener() {\n    @Override\n    public void done(Integer count, BmobException e) {\n        if(e==null){\n            toast(\ncount对象个数为：\n+count);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n查询指定列\n\n\n有的时候，一张表的数据列比较多，而我们只想查询返回某些列的数据时，我们可以使用BmobQuery对象提供的\naddQueryKeys\n方法来实现。如下所示：\n\n\n//只返回Person表的objectId这列的值\nBmobQuery\nPerson\n bmobQuery = new BmobQuery\nPerson\n();\nbmobQuery.addQueryKeys(\nobjectId\n);\nbmobQuery.findObjects(new FindListener\nPerson\n() {\n    @Override\n    public void done(List\nPerson\n object, BmobException e) {\n        if(e==null){\n            toast(\n查询成功：共\n + object.size() + \n条数据。\n);\n            //注意：这里的Person对象中只有指定列的数据。\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n指定多列时用\n,\n号分隔每列，如：\naddQueryKeys(\"objectId,name,age\")\n;\n\n\n统计查询\n\n\n从\nBmobSDKV3.3.6\n开始，Bmob为开发者提供了以下关键字或其组合的统计查询操作,分别用于计算\n总和、平均值、最大值、最小值\n，同时支持分组和过滤条件。\n\n\n\n\n\n\n\n\n方法名\n\n\n参数说明\n\n\n方法说明\n\n\n\n\n\n\n\n\n\n\nsum\n\n\nString[] sumKeys（多个列名）\n\n\n求某列或多列的和\n\n\n\n\n\n\naverage\n\n\nString[] aveKeys（多个列名）\n\n\n求某列或多列的平均值\n\n\n\n\n\n\nmax\n\n\nString[] maxKeys（多个列名）\n\n\n求某列或多列的最大值\n\n\n\n\n\n\nmin\n\n\nString[] minKeys（多个列名）\n\n\n求某列或多列的最小值\n\n\n\n\n\n\ngroupby\n\n\nString[] groupKeys（多个列名）\n\n\n分组\n\n\n\n\n\n\nhaving\n\n\nHashMap map(键（String）值(Object)对的形式)\n\n\n分组的过滤条件\n\n\n\n\n\n\nsetHasGroupCount\n\n\nboolean hasCount\n\n\n是否返回每个分组的记录数\n\n\n\n\n\n\n\n\n注：\n\n\n\n\n为避免和用户创建的列名称冲突，Bmob约定以上查询返回的字段采用\n_(关键字)+首字母大写的列名\n 的格式：\n\n\n\n\n例：\n计算玩家得分表（GameScore）中列名为score的总和，那么返回的结果集会有一个列名为\n_sumScore\n，\n若设置了setHasGroupCount（true）,则结果集中会返回\n_count\n。\n\n\n\n\n\n\n以上方法可自由组合且与之前的查询语句中的where, order, limit, skip等组合一起使用。 \n\n\n\n\n\n\n因为返回格式不固定，故使用\nfindStatistics\n来专门处理统计查询。\n\n\n\n\n\n\n统计查询方法\n\n\n例如，如果要计算所有玩家的得分总和，那么代码如下：\n\n\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\nquery.sum(new String[] { \nplayScore\n });\nquery.findStatistics(GameScore.class,new QueryListener\nJSONArray\n() {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if(ary!=null){//\n                try {\n                    JSONObject obj = ary.getJSONObject(0);\n                    int sum = obj.getInt(\n_sumPlayScore\n);//_(关键字)+首字母大写的列名\n                    showToast(\n游戏总得分：\n + sum);\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            }else{\n                showToast(\n查询成功，无数据\n);\n            }\n        }else{  \n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n\n});\n\n\n\n\n\n注：\nsum方法的参数只能查询Number类型的列名（对应Java的Integer类型）\n，即要计算哪个列的值的总和。\n\n\n查询平均值、最大、最小和上面的求和类似，在这里也一并提示下：\n\n\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\n//query.average(new String[]{\nplayScore\n});//查询某列的平均值\nquery.min(new String[]{\nplayScore\n});//查询最小值\n//query.max(new String[]{\nplayScore\n});//查询最大值\nquery.groupby(new String[]{\ncreatedAt\n});\nquery.findStatistics(GameScore.class, new QueryListener\nJSONArray\n() {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            JSONArray ary = (JSONArray) result;\n            if (ary!=null) {\n                try {\n                    JSONObject obj = ary.getJSONObject(0);\n    //              int playscore = obj.getInt(\n_avgPlayScore\n);\n                    int minscore = obj.getInt(\n_minPlayScore\n);\n    //              int maxscore = obj.getInt(\n_maxPlayScore\n);\n                    String createDate = obj.getString(\ncreatedAt\n);\n                    showToast(\nminscore = \n + minscore+ \n,统计时间 = \n+ createDate);\n                } catch (JSONException e) {\n                    e.printStackTrace();\n                }\n        } else {\n            showToast(\n查询成功，无数据\n);\n        }\n        }else{\n            loge(e);\n        }\n    }\n});\n\n\n\n\n\n分组统计\n\n\n如果你需要对查询结果进行分组，可使用\ngroupby\n方法，支持根据多个列名进行分组。\n\n\n//我们以创建时间按天和游戏分别统计玩家的得分，并按时间降序\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\nquery.sum(new String[] { \nplayScore\n, \nsignScore\n });//求多个列的总和\nquery.groupby(new String[] { \ncreatedAt\n, \ngame\n });//按照时间和游戏名进行分组\nquery.order(\n-createdAt\n);//降序排列\nquery.findStatistics(GameScore.class,new QueryListener\nJSONArray\n() {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if(ary!=null){\n                int length = ary.length();\n                try {\n                    for (int i = 0; i \n length; i++) {\n                        JSONObject obj = ary.getJSONObject(i);\n                        int playscore = obj.getInt(\n_sumPlayScore\n);\n                        int signscore = obj.getInt(\n_sumSignScore\n);\n                        String createDate = obj.getString(\ncreatedAt\n);\n                        String game = obj.getString(\ngame\n);\n                        showToast(\n游戏总得分：\n + playscore + \n,签到得分：\n\n                                + signscore + \n,时间:\n + createDate+\n,game:\n+game);\n                    }\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            } else {\n                showToast(\n查询成功，无数据\n);\n            }\n        }else{\n            loge(e);\n        }\n    }\n});\n\n\n\n\n有时候，我们需要知道分组统计时每个分组有多少条记录，可使用\nsetHasGroupCount（true）\n,如下：\n\n\n// 查询创建时间按天统计所有玩家的得分和每一天有多少条玩家的得分记录，并按时间降序:\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\nquery.sum(new String[] { \nplayScore\n });    // 统计总得分\nquery.groupby(new String[] { \ncreatedAt\n });// 按照时间分组\nquery.order(\n-createdAt\n);                  // 降序排列\nquery.setHasGroupCount(true);              // 统计每一天有多少个玩家的得分记录，默认不返回分组个数\nquery.findStatistics(GameScore.class,new QueryListener\nJSONArray\n() {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if (ary!=null) {\n                int length = ary.length();\n                try {\n                    for (int i = 0; i \n length; i++) {\n                        JSONObject obj = ary.getJSONObject(i);\n                        int playscore = obj.getInt(\n_sumPlayScore\n);\n                        String createDate = obj.getString(\ncreatedAt\n);\n                        int count = obj.getInt(\n_count\n);//setHasGroupCount设置为true时，返回的结果中含有\n_count\n字段\n                        showToast(\n游戏总得分：\n + playscore + \n,总共统计了\n\n                                + count + \n条记录,统计时间 = \n+ createDate);\n                    }\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            } else {\n                showToast(\n查询成功，无数据\n);\n            }\n        }else{\n            loge(e);\n        }\n    }\n});\n\n\n\n\n添加过滤条件\n\n\n如果需要对分组计算后的结果再进行过滤，可使用\nhaving\n来继续过滤部分结果。\n\n\n//我们按游戏名统计所有玩家的总得分，并只返回总得分大于100的记录，并按时间降序\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\nquery.sum(new String[] {\nplayScore\n});//计算总得分数\nquery.groupby(new String[] {\ngame\n});//分组条件：按游戏名进行分组\nquery.order(\n-createdAt\n);// 降序排列\nHashMap\nString, Object\n map = new HashMap\nString, Object\n();\nJSONObject js = new JSONObject();\ntry {\n    js.put(\n$gt\n, 100);\n} catch (JSONException e1) {\n}\nmap.put(\n_sumPlayScore\n, js);//过滤条件：总得分数大于100\nquery.having(map);\nquery.setLimit(100);\nquery.findStatistics(GameScore.class,new QueryListener\nJSONArray\n() {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if(ary!=null){\n                int length = ary.length();\n                try {\n                    for (int i = 0; i \n length; i++) {\n                        JSONObject obj = ary.getJSONObject(i);\n                        int playscore = obj.getInt(\n_sumPlayScore\n);//过滤条件的key是什么，返回的数据中就有什么\n                        String game = obj.getString(\ngame\n);//返回的数据中同样包含groupby里面的列名\n                        showToast(\n游戏得分：\n + playscore + \n,游戏名 = \n+ game);\n                    }\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            } else {\n                showToast(\n查询成功，无数据\n);\n            }\n        }else{\n            loge(e);\n        }\n    }\n\n});\n\n\n\n\n\n缓存查询\n\n\n缓存查询通常是将查询结果缓存在磁盘上。\n当用户的设备处于离线状态时，就可以从缓存中获取数据来显示。\n或者在应用界面刚刚启动，从网络获取数据还未得到结果时，先使用缓存数据来显示。\n这样可以让用户不必在按下某个按钮后进行枯燥的等待。\n默认的查询操作是没有启用缓存的，开发者可以使用\nsetCachePolicy\n方法来启用缓存功能。\n例如：优先从缓存获取数据，如果获取失败再从网络获取数据。\n\n\nbmobQuery.setCachePolicy(CachePolicy.CACHE_ELSE_NETWORK);   // 先从缓存获取数据，如果没有，再从网络获取。\nbmobQuery.findObjects(new FindListener\nPerson\n() {\n    @Override\n    public void done(List\nPerson\n object,BmobException e) {\n        if(e==null){\n            toast(\n查询成功：共\n+object.size()+\n条数据。\n);\n        }else{\n            toast(\n查询失败：\n+msg);\n        }\n    }\n\n});\n\n\n\n\n缓存策略\n\n\nBmob SDK提供了几种不同的缓存策略，以适应不同应用场景的需求：\n\n\n\n\nIGNORE_CACHE\n     :只从网络获取数据，且不会将数据缓存在本地，这是默认的缓存策略。\n\n\nCACHE_ONLY\n        :只从缓存读取数据，如果缓存没有数据会导致一个BmobException,可以忽略不处理这个BmobException.\n\n\nNETWORK_ONLY\n      :只从网络获取数据，同时会在本地缓存数据。\n\n\nNETWORK_ELSE_CACHE\n:先从网络读取数据，如果没有，再从缓存中获取。\n\n\nCACHE_ELSE_NETWORK\n:先从缓存读取数据，如果没有，再从网络获取。\n\n\nCACHE_THEN_NETWORK\n:先从缓存取数据，无论结果如何都会再次从网络获取数据。也就是说会产生2次调用。\n\n\n\n\n建议的做法：\n\n\n第一次进入应用的时候，设置其查询的缓存策略为\nCACHE_ELSE_NETWORK\n,当用户执行上拉或者下拉刷新操作时，设置查询的缓存策略为\nNETWORK_ELSE_CACHE\n。\n\n\n缓存方法\n\n\n如果需要操作缓存内容，可以使用BmobQuery提供的方法做如下操作：\n\n\n\n\n检查是否存在当前查询条件的缓存数据\n\n\n\n\nboolean isInCache = query.hasCachedResult(Class\n?\n clazz);\n\n\n\n\n注：缓存和查询条件有关，此方法必须放在所有的查询条件（where、limit、order、skip、include等）都设置完之后，否则会得不到缓存数据。\n\n\n\n\n清除当前查询的缓存数据\n\n\n\n\nquery.clearCachedResult(Class\n?\n clazz);\n\n\n\n\n\n\n清除所有查询结果的缓存数据\n\n\n\n\nBmobQuery.clearAllCachedResults(Class\n?\n clazz);\n\n\n\n\n\n\n设置缓存的最长时间（以毫秒为单位）\n\n\n\n\nquery.setMaxCacheAge(TimeUnit.DAYS.toMillis(1));//此表示缓存一天\n\n\n\n\n示例如下：\n\n\nBmobQuery\nPerson\n query  = new BmobQuery\nPerson\n();\nquery.addWhereEqualTo(\nage\n, 25);\nquery.setLimit(10);\nquery.order(\ncreatedAt\n);\n//判断是否有缓存，该方法必须放在查询条件（如果有的话）都设置完之后再来调用才有效，就像这里一样。\nboolean isCache = query.hasCachedResult(Person.class);\nif(isCache){--此为举个例子，并不一定按这种方式来设置缓存策略\n    query.setCachePolicy(CachePolicy.CACHE_ELSE_NETWORK);   // 如果有缓存的话，则设置策略为CACHE_ELSE_NETWORK\n}else{\n    query.setCachePolicy(CachePolicy.NETWORK_ELSE_CACHE);   // 如果没有缓存的话，则设置策略为NETWORK_ELSE_CACHE\n}\nquery.findObjects(new FindListener\nPerson\n() {\n\n    @Override\n    public void done(List\nPerson\n object,BmobException e) {\n        if(e==null){\n            toast(\n查询成功：共\n+object.size()+\n条数据。\n);\n        }else{\n            toast(\n查询失败：\n+msg);\n        }\n    }\n});\n\n\n\n\n注：\n\n\n1、只有当缓存查询的条件一模一样时才会获取到缓存到本地的缓存数据。\n\n\n2、设置的默认的最大缓存时长为5小时。\n\n\nBQL查询\n\n\nBmob Query Language\n（简称 BQL） 是 Bmob 自 \nBmobSDKV3.3.7\n 版本开始，为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 Bmob 查询API 的成本，可以使用传统的 SQL 语法来查询 Bmob 应用内的数据。 \n\n\n具体的 BQL 语法，请参考 \nBmob Query Language 详细指南\n。\n\n\n基本BQL查询\n\n\n可以通过以下方法来进行SQL查询：\n例如：需要查询所有的游戏得分记录\n\n\nString bql =\nselect * from GameScore\n;//查询所有的游戏得分记录\nnew BmobQuery\nGameScore\n().doSQLQuery(bql,new SQLQueryListener\nGameScore\n(){\n\n    @Override\n    public void done(BmobQueryResult\nGameScore\n result, BmobException e) {\n        if(e ==null){\n            List\nGameScore\n list = (List\nGameScore\n) result.getResults();\n            if(list!=null \n list.size()\n0){\n                ...\n            }else{\n                Log.i(\nsmile\n, \n查询成功，无数据返回\n);\n            }\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n上面的示例也等价于(\n此方法自BmobV3.3.8版本提供\n)：\n\n\n//查询所有的游戏得分记录\nString bql =\nselect * from GameScore\n;\nBmobQuery\nGameScore\n query=new BmobQuery\nGameScore\n();\n//设置查询的SQL语句\nquery.setSQL(bql);\nquery.doSQLQuery(new SQLQueryListener\nGameScore\n(){\n\n    @Override\n    public void done(BmobQueryResult\nGameScore\n result, BmobException e) {\n        if(e ==null){\n            List\nGameScore\n list = (List\nGameScore\n) result.getResults();\n            if(list!=null \n list.size()\n0){\n                ...\n            }else{\n                Log.i(\nsmile\n, \n查询成功，无数据返回\n);\n            }\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n如果需要查询个数，则可以这样：\n\n\nString bql = \nselect count(*),* from GameScore\n;//查询GameScore表中总记录数并返回所有记录信息\nnew BmobQuery\nGameScore\n().doSQLQuery(bql, new SQLQueryListener\nGameScore\n(){\n\n    @Override\n    public void done(BmobQueryResult\nGameScore\n result, BmobException e) {\n        if(e ==null){\n            int count = result.getCount();//这里得到符合条件的记录数\n            List\nGameScore\n list = (List\nGameScore\n) result.getResults();\n            if(list.size()\n0){\n                ...\n            }else{\n                Log.i(\nsmile\n, \n查询成功，无数据\n);\n            }\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n注：当查询的表为系统表（目前系统表有User、Installation、Role）时，需要带上下划线 \n_\n。\n\n\n比如，你想查询的是用户\nsmile\n的信息，则：\n\n\nselect * from _User where username = smile\n\n\n\n\n统计BQL查询\n\n\n由于统计查询的结果是不定的，故BQL提供了另外一种查询方法来进行统计查询，可以使用\ndoStatisticQuery\n方法来进行：\n\n\n//按照姓名分组求和,并将结果按时间降序排列\nString bql = \nselect sum(playScore) from GameScore group by name order by -createdAt\n;\nnew BmobQuery\nGameScore\n().doStatisticQuery(bql,new QueryListener\nJSONArray\n(){\n\n    @Override\n    public void done(Object result, BmobException e) {\n        if(e ==null){\n            JSONArray ary = (JSONArray) result;\n            if(ary!=null){//开发者需要根据返回结果自行解析数据\n                ...\n            }else{\n                showToast(\n查询成功，无数据\n);\n            }\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n占位符查询\n\n\n在更多的时候，一个查询语句中间会有很多的值是可变值，为此，我们也提供了类似 Java JDBC 里的 \nPreparedStatement\n 使用占位符查询的语法结构。\n\n\n普通查询\n\n\nString bql=\nselect * from GameScore where player = ? and game = ?\n;//查询玩家1的地铁跑酷的GameScore信息\nnew BmobQuery\nGameScore\n().doSQLQuery(bql,new SQLQueryListener\nGameScore\n(){\n\n    @Override\n    public void done(BmobQueryResult\nGameScore\n result, BmobException e) {\n        if(e ==null){\n            List\nGameScore\n list = (List\nGameScore\n) result.getResults();\n            if(list!=null \n list.size()\n0){\n                ...\n            }else{\n                Log.i(\nsmile\n, \n查询成功，无数据返回\n);\n            }\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n},\n玩家1\n,\n地铁跑酷\n);\n\n\n\n\n最后的可变参数 \n玩家1\n 和 \n地铁跑酷\n 会自动替换查询语句中的问号位置（按照问号的先后出现顺序）。\n\n\n上面的示例也等价于如下代码（\n此方法自BmobV3.3.8版本提供\n）：\n\n\nString bql=\nselect * from GameScore where player = ? and game = ?\n;\nBmobQuery\nGameScore\n query=new BmobQuery\nGameScore\n();\n//设置SQL语句\nquery.setSQL(bql);\n//设置占位符参数\nquery.setPreparedParams(new Object[]{\n玩家1\n,\n地铁跑酷\n});\nquery.doSQLQuery(new SQLQueryListener\nGameScore\n(){\n\n    @Override\n    public void done(BmobQueryResult\nGameScore\n result, BmobException e) {\n        if(e ==null){\n            List\nGameScore\n list = (List\nGameScore\n) result.getResults();\n            if(list!=null \n list.size()\n0){\n                ...\n            }else{\n                Log.i(\nsmile\n, \n查询成功，无数据返回\n);\n            }\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n内置函数\n\n\n对于包含\n内置函数\n的占位符查询，比较特殊，请使用\nBmob Query Language 详细指南\n中的\n内置函数\n中\n占位符查询用到的内置函数\n列出的形式进行查询操作：\n\n\n举例：我想查询当前用户在2015年5月12日之后，在特定地理位置附近的游戏记录，可以这样：\n\n\nString sql = \nselect * from GameScore where createdAt \n date(?) and player = pointer(?,?) and gps near geopoint(?,?)\n;\nnew BmobQuery\nGameScore\n().doSQLQuery(sql,new SQLQueryListener\nGameScore\n(){\n\n    @Override\n    public void done(BmobQueryResult\nGameScore\n result, BmobException e) {\n        if(e ==null){\n            List\nGameScore\n list = (List\nGameScore\n) result.getResults();\n            if(list!=null \n list.size()\n0){\n                ...\n            }else{\n                Log.i(\nsmile\n, \n查询成功，无数据返回\n);\n            }\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n},\n2015-05-12 00:00:00\n,\n_User\n,user.getObjectId(),112.934755,24.52065);\n\n\n\n\n注\n\n\n1、我们更推荐使用占位符语法，理论上会降低 BQL 转换的性能开销；\n\n\n2、最后的可变参数会自动替换查询语句中的问号位置（按照问号的先后出现顺序），有多少个问号，最后的可变参数就应该有多少个；\n\n\n3、同样的，统计查询也支持占位符,只需要将\ndoSQLQuery\n替换成\ndoStatisticQuery\n方法即可；\n\n\n4、只有查询条件\nwhere``limit\n子句支持占位符查询，和统计查询有关的\ngroup by\n、\norder by\n、\nhaving\n等字句是不支持占位符的。\n\n\n例如：\n\n正确\n查询：\n\n\n//按照游戏名进行分组并获取总得分数大于200的统计信息，同时统计各分组的记录数\nString bql = \nselect sum(playScore),count(*) from GameScore group by game having _sumPlayScore\n200\n;\nnew BmobQuery\nGameScore\n().doStatisticQuery(bql,new StatisticQueryListener(){\n\n    @Override\n    public void done(Object result, BmobException e) {\n        ...\n    }\n});\n\n\n\n\n错误\n查询：\n\n\nString bql = \nselect sum(playScore),count(*) from GameScore group by ? having ?\n;\nnew BmobQuery\nGameScore\n().doStatisticQuery(bql,new StatisticQueryListener(){\n\n    @Override\n    public void done(Object result, BmobException e) {\n        ...\n    }\n},\ngame\n,\n_sumPlayScore\n200\n);\n\n\n\n\nBQL缓存查询\n\n\nBQL查询同步支持\n缓存查询\n，只需要调用BmobQuery的\nsetCachePolicy\n方法设置缓存策略即可，\n建议使用如下方式进行BQL缓存查询\n：\n\n\nString sql = \nselect * from GameScore order by playScore,signScore desc\n;\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\n//设置sql语句\nquery.setSQL(sql);\n//判断此查询本地是否存在缓存数据\nboolean isCache = query.hasCachedResult(GameScore.class);\nif(isCache){\n    query.setCachePolicy(CachePolicy.CACHE_ELSE_NETWORK);   // 如果有缓存的话，则设置策略为CACHE_ELSE_NETWORK\n}else{\n    query.setCachePolicy(CachePolicy.NETWORK_ELSE_CACHE);   // 如果没有缓存的话，则设置策略为NETWORK_ELSE_CACHE\n}\nquery.doSQLQuery(new SQLQueryListener\nGameScore\n(){\n\n    @Override\n    public void done(BmobQueryResult\nGameScore\n result, BmobException e) {\n        if(e ==null){\n            Log.i(\nsmile\n, \n查询到：\n+result.getResults().size()+\n符合条件的数据\n);\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n注：\n\n\ndoSQLQuery目前有三种查询方式进行SQL查询，分别是：\n\n\n1、doSQLQuery（Context context,SQLQueryListener\n listener)\n\n\n2、doSQLQuery（Context context, String bql, SQLQueryListener\n listener)----基本BQL查询\n\n\n3、doSQLQuery（Context context, String bql, SQLQueryListener\n listener,Object... params)----占位符查询\n\n\n只有\n第一种查询方式\n才能和\nquery.hasCachedResult(context,class)\n或者\nquery.clearCachedResult(context,class)\n并列使用。\n\n\n建议使用\n第一种查询方式\n进行BQL缓存查询。\n\n\n数组\n\n\n对于数组类型数据，BmobSDK提供了3种操作来原子性地修改一个数组字段的值：\n\n\n\n\nadd、addAll\n 在一个数组字段的后面添加一些指定的对象(包装在一个数组内)\n\n\naddUnique、addAllUnique\n 只会在原本数组字段中没有这些对象的情形下才会添加入数组，插入数组的位置随机\n\n\nremoveAll\n 从一个数组字段的值内移除指定数组中的所有对象\n\n\n\n\n举例子：\n\n\npublic class Person extends BmobObject {\n    private List\nString\n hobbys;        // 爱好-对应服务端Array类型：String类型的集合\n    private List\nBankCard\n cards;       // 银行卡-对应服务端Array类型:Object类型的集合\n    ...\n    getter、setter方法\n}\n\n其中BankCard类结构如下：\npublic class BankCard{\n    private String cardNumber;\n    private String bankName;\n    public BankCard(String bankName, String cardNumber){\n        this.bankName = bankName;\n        this.cardNumber = cardNumber;\n    }\n    ...\n    getter、setter方法\n}\n\n\n\n\n添加数组数据\n\n\n给\nPerson\n对象中的数组类型字段添加数据,有以下两种方式：\n\n\n使用add、addAll添加\n\n\nPerson p = new Person();\np.setObjectId(\nd32143db92\n);\n//添加String类型的数组\np.add(\nhobbys\n, \n唱歌\n);                              // 添加单个String\n//p.addAll(\nhobbys\n, Arrays.asList(\n游泳\n, \n看书\n));    // 添加多个String\n//添加Object类型的数组\np.add(\ncards\n,new BankCard(\n工行卡\n, \n工行卡账号\n))   //添加单个Object\nList\nBankCard\n cards =new ArrayList\nBankCard\n();\nfor(int i=0;i\n2;i++){\n    cards.add(new BankCard(\n建行卡\n+i, \n建行卡账号\n+i));\n}\n//p.addAll(\ncards\n, cards);                         //添加多个Object值\np.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n保存成功\n);\n        }else{\n            Log.i(\nbmob\n,\n保存失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n 注：此类方法不管这些数据之前是否已添加过，都会再次添加。\n\n\n使用addUnique、addAllUnique添加\n\n\nPerson p = new Person();\n//添加String类型的数组\np.addUnique(\nhobbys\n, \n唱歌\n);                                // 添加单个String\n//p.addAllUnique(\nhobbys\n, Arrays.asList(\n游泳\n, \n看书\n));  // 添加多个String\n//添加Object类型的数组\np.addUnique(\ncards\n,new BankCard(\n工行卡\n, \n工行卡账号\n))     //添加单个Object\nList\nBankCard\n cards =new ArrayList\nBankCard\n();\nfor(int i=0;i\n2;i++){\n    cards.add(new BankCard(\n建行卡\n+i, \n建行卡账号\n+i));\n}\n//p.addAllUnique(\ncards\n, cards);                           //添加多个Object\np.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功:\n+objectId);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n 注： 只有在这些数据之前未添加过的情况下才会被添加。\n\n\n更新数组数据\n\n\n数组更新比较特殊，自\nV3.4.4\n版本开始提供\nBmobObject\n的\nsetValue\n方法来更新数组，例：\n\n\nPerson p2 = new Person();\n//更新String类型数组中的值\np2.setValue(\nhobbys.0\n,\n爬山\n);                             //将hobbys中第一个位置的爱好（上面添加成功的唱歌）修改为爬山\n//更新Object类型数组中的某个位置的对象值(0对应集合中第一个元素)\np2.setValue(\ncards.0\n, new BankCard(\n中行\n, \n中行卡号\n));    //将cards中第一个位置银行卡修改为指定BankCard对象\n//更新Object类型数组中指定对象的指定字段的值\n//  p2.setValue(\ncards.0.bankName\n, \n农行卡\n);             //将cards中第一个位置的银行卡名称修改为农行卡\n//  p2.setValue(\ncards.1.cardNumber\n, \n农行卡账号\n);         //将cards中第二个位置的银行卡账号修改为农行卡账号\np2.update(objectId, new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n删除数组数据\n\n\n同理我们也可以使用removeAll从数组字段中移除某些值：\n\n\nPerson p = new Person();\np.removeAll(\nhobby\n, Arrays.asList(\n阅读\n,\n唱歌\n,\n游泳\n));\np.update(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n查询数组数据\n\n\n对于字段类型为数组的情况，可以以数组字段中包含有xxx的数据为条件进行查询：\n\n\nBmobQuery\nPerson\n query = new BmobQuery\nPerson\n();\nString [] hobby = {\n阅读\n,\n唱歌\n};\nquery.addWhereContainsAll(\nhobby\n, Arrays.asList(hobby));\nquery.findObjects(new FindListener\nPerson\n() {\n\n    @Override\n    public void done(List\nPerson\n object,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n查询成功：共\n + object.size() + \n条数据。\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n数据关联性\n\n\n关联关系描述\n\n\n在程序设计中，不同类型的数据之间可能存在某种关系。\n比如：帖子和作者的关系，一篇帖子只属于某个作者，这是\n一对一的关系\n。\n比如：帖子和评论的关系，一条评论只属于某一篇帖子，而一篇帖子对应有很多条评论，这是\n一对多的关系\n。\n比如：学生和课程的关系，一个学生可以选择很多课程，一个课程也可以被很多学生所选择，这是\n多对多的关系\n。\n\n\nBmob提供了\nPointer（一对一、一对多）\n和\nRelation（多对多）\n两种数据类型来解决这种业务需求。\n\n\n关联关系案例详解\n\n\n由于关联关系讲解起来比较复杂，以下用一个简单的案例来说明在Bmob中是如何使用关联关系的。\n\n\n场景：\n用户发表帖子，同时又可对帖子进行评论留言。\n\n\n在这个场景中涉及到三个表：用户表（\n_User\n）、帖子表（\nPost\n）、评论表（\nComment\n）,以下是各个表的字段：\n\n\n_User\n字段如下：\n\n\n\n\n\n\n\n\n字段\n\n\n类型\n\n\n含义\n\n\n\n\n\n\n\n\n\n\nobjectId\n\n\nString\n\n\n用户ID\n\n\n\n\n\n\nusername\n\n\nString\n\n\n用户名(可以既发帖子又发评论)\n\n\n\n\n\n\nage\n\n\nInteger\n\n\n年龄\n\n\n\n\n\n\n\n\nPost\n字段如下：\n\n\n\n\n\n\n\n\n字段\n\n\n含义\n\n\n类型\n\n\n\n\n\n\n\n\n\n\nobjectId\n\n\nString\n\n\n帖子ID\n\n\n\n\n\n\ntitle\n\n\nString\n\n\n帖子标题\n\n\n\n\n\n\ncontent\n\n\nString\n\n\n帖子内容\n\n\n\n\n\n\nauthor\n\n\nPointer\n\n\n帖子作者\n\n\n\n\n\n\nlikes\n\n\nRelation\n\n\n喜欢帖子的读者\n\n\n\n\n\n\n\n\nComment\n字段如下：\n\n\n\n\n\n\n\n\n字段\n\n\n含义\n\n\n类型\n\n\n\n\n\n\n\n\n\n\nobjectId\n\n\nString\n\n\n评论ID\n\n\n\n\n\n\ncontent\n\n\nString\n\n\n评论内容\n\n\n\n\n\n\npost\n\n\nPointer\n\n\n评论对应的帖子\n\n\n\n\n\n\nauthor\n\n\nPointer\n\n\n评论该帖子的人\n\n\n\n\n\n\n\n\nWeb端创建关联字段\n\n\n如果你需要在Web端创建上述表的话，那么当选择的字段类型为\nPointer或Relation\n时，会提示你选择该字段所指向或关联的数据表。\n\n\n如下图所示：\n\n\n\n\n创建数据对象\n\n\npublic class MyUser extends BmobUser {\n\n    private Integer age;//为用户表新增一个age字段，注意其必须为`Integer`类型，而不是int\n\n    //自行实现getter和setter方法\n}\n\n\n\n\n\n1、扩展BmobUser的时，不需要再加上\nobjectId、username、password、createAt、updateAt\n等系统字段，因为BmobUser中已经实现了，如果再次声明的话，会导致编译性的错误。\n\n\n2、类名可以自定义，这个跟其他表的命名方式有所不同。\n\n\n\npublic class Post extends BmobObject {\n\n    private String title;//帖子标题\n\n    private String content;// 帖子内容\n\n    private MyUser author;//帖子的发布者，这里体现的是一对一的关系，该帖子属于某个用户\n\n    private BmobFile image;//帖子图片\n\n    private BmobRelation likes;//多对多关系：用于存储喜欢该帖子的所有用户\n\n    //自行实现getter和setter方法\n\n}\n\n\n\n\n\n\npublic class Comment extends BmobObject {\n\n    private String content;//评论内容  \n\n    private MyUser user;//评论的用户，Pointer类型，一对一关系\n\n    private Post post; //所评论的帖子，这里体现的是一对多的关系，一个评论只能属于一个微博\n\n    //自行实现getter和setter方法\n}\n\n\n\n\n\n注：\n\n\n1、类名要和数据表名保持一致。\n\n\n2、MyUser属性对应为Pointer的指针类型。\n\n\n以下举例均假定A用户已注册并登陆\n\n\n\n\n一对一关系\n\n\n用户发表帖子，一篇帖子也只能属于某个用户，那么帖子和用户之间的关系是\n一对一关系\n，建议使用\nPointer\n类型来表示。\n\n\nPointer\n本质上可以看成是我们将一个指向某条记录的指针记录下来，我们查询时可以通过该指针来获得其指向的关联对象。\n\n\n用户A写了一篇帖子，需要在\nPost\n表中生成一条记录，并将该帖子关联到用户A这条记录，表明该帖子是A所发表的。\n\n\n示例如下：\n\n\n添加一对一关联\n\n\nMyUser user = BmobUser.getCurrentUser(MyUser.class);\n// 创建帖子信息\nPost post = new Post();\npost.setContent(content);\n//添加一对一关联\npost.setAuthor(user);\npost.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n保存成功\n);\n        }else{\n            Log.i(\nbmob\n,\n保存失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n添加成功后，在后台的\nPost\n表中，你就会看到有一条记录生成，并且该帖子的\nauthor\n字段的值指向了\n_User\n表中的\n用户A\n这条记录。\n\n\n\n\n查询一对一关联\n\n\n如果想查询\n用户A\n(当前用户)所发表的所有帖子，那么可以这样：\n\n\nMyUser user = BmobUser.getCurrentUser(MyUser.class);\nBmobQuery\nPost\n query = new BmobQuery\nPost\n();\nquery.addWhereEqualTo(\nauthor\n, user);  // 查询当前用户的所有帖子\nquery.order(\n-updatedAt\n);\nquery.include(\nauthor\n);// 希望在查询帖子信息的同时也把发布人的信息查询出来\nquery.findObjects(new FindListener\nPost\n() {\n\n    @Override\n    public void done(List\nPost\n object,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n注：如果想查询某个用户所发表的所有帖子，则将该用户查询出来，然后使用上述代码查询指定用户所发表的所有帖子。\n\n\n更新一对一关联\n\n\n如果希望将刚刚这条帖子的作者修改成\n用户B\n,示例：\n\n\nPost p = new Post();\n//构造用户B，如果你知道用户B的objectId的话，可以使用这种方式进行关联，如果不知道的话，你需要将用户B查询出来\n// 这里假设已知用户B的objectId为aJyG2224\nMyUser userB =new MyUser();\nuserB.setObjectId(\naJyG2224\n);\np.setAuthor(userB);//重新设置帖子作者\np.update(\nESIt3334\n, new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n修改成功后，在后台可查看到这个帖子的作者已经变更为用户B\n\n\n\n\n删除一对一关联\n\n\n如果你想和\nESIt3334\n这个帖子解除关联关系，可以这样：\n\n\nPost p = new Post();\np.remove(\nauthor\n);\np.update(\nESIt3334\n, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n删除成功后，在后台的\nPost\n表中，你就会看到\nESIt3334\n这个帖子的\nauthor\n字段的值已经被置空了。\n\n\n\n\n一对多关系\n\n\n一条评论只能属于某一篇帖子，一篇帖子可以有很多用户对其进行评论，那么帖子和评论之间的关系就是\n一对多关系\n，推荐使用\npointer\n类型来表示\n。\n\n\n因为使用方法和上面的一对一关联基本相同，只是查询一对多关联的时候有些区别，故只举添加和查询两个例子：\n\n\n添加一对多关联\n\n\n将评论和微博进行关联，并同时和当前用户进行关联，表明是当前用户对该帖子进行评论，示例如下：\n\n\nMyUser user = BmobUser.getCurrentUser(MyUser.class);\nPost post = new Post();\npost.setObjectId(\nESIt3334\n);\nfinal Comment comment = new Comment();\ncomment.setContent(content);\ncomment.setPost(post);\ncomment.setUser(user);\ncomment.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n评论发表成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n查询一对多关联\n\n\n我想\n查询出某个帖子（objectId为ESIt3334）的所有评论,同时将该评论的作者的信息也查询出来\n，那么可以使用\naddWhereEqualTo\n方法进行查询：\n\n\nBmobQuery\nComment\n query = new BmobQuery\nComment\n();\n//用此方式可以构造一个BmobPointer对象。只需要设置objectId就行\nPost post = new Post();\npost.setObjectId(\nESIt3334\n);\nquery.addWhereEqualTo(\npost\n,new BmobPointer(post));        \n//希望同时查询该评论的发布者的信息，以及该帖子的作者的信息，这里用到上面`include`的并列对象查询和内嵌对象的查询\nquery.include(\nuser,post.author\n);\nquery.findObjects(new FindListener\nComment\n() {\n\n    @Override\n    public void done(List\nComment\n objects,BmobException e) {\n        ...\n    }\n});\n\n\n\n\n\n注：\naddWhereEqualTo\n对\nBmobPonter\n类型的一对多的关联查询是\nBmobSDKV3.3.8\n开始支持的，因此使用时，请更新SDK版本。\n\n\n多对多关系\n\n\n一个帖子可以被很多用户所喜欢，一个用户也可能会喜欢很多帖子，那么可以使用\nRelation\n类型来表示这种\n多对多关联关系\n。\n\n\nRelation\n本质上可以理解为其存储的是一个对象，而这个对象中存储的是多个指向其它记录的指针。\n\n\n添加多对多关联\n\n\nMyUser user = BmobUser.getCurrentUser(MyUser.class);\nPost post = new Post();\npost.setObjectId(\nESIt3334\n);\n//将当前用户添加到Post表中的likes字段值中，表明当前用户喜欢该帖子\nBmobRelation relation = new BmobRelation();\n//将当前用户添加到多对多关联中\nrelation.add(user);\n//多对多关联指向`post`的`likes`字段\npost.setLikes(relation);\npost.update(new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n多对多关联添加成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n添加成功后，在后台的\nPost\n表中就能查看到\nlikes\n字段已经生成并对应到了\n_User\n\n\n\n\n点击红框中的\n关联关系\n按钮展开后，可查看刚才所添加的喜欢该帖子的用户A：\n\n\n\n\n查询多对多关联\n\n\n如果希望\n查询喜欢该帖子（objectId为ESIt3334）的所有用户\n,那么就需要用到\naddWhereRelatedTo\n方法进行多对多关联查询。\n\n\n示例代码：\n\n\n// 查询喜欢这个帖子的所有用户，因此查询的是用户表\nBmobQuery\nMyUser\n query = new BmobQuery\nMyUser\n();\nPost post = new Post();\npost.setObjectId(\nESIt3334\n);\n//likes是Post表中的字段，用来存储所有喜欢该帖子的用户\nquery.addWhereRelatedTo(\nlikes\n, new BmobPointer(post));    \nquery.findObjects(new FindListener\nMyUser\n() {\n\n    @Override\n    public void done(List\nMyUser\n object,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n查询个数：\n+object.size());\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n修改多对多关联\n\n\n如果\n用户B也喜欢该帖子（objectId为ESIt3334）\n，此时需要为该帖子(Post)的\nlikes\n字段多添加一个用户,示例如下：\n\n\nPost post = new Post();\npost.setObjectId(\nESIt3334\n);\n//将用户B添加到Post表中的likes字段值中，表明用户B喜欢该帖子\nBmobRelation relation = new BmobRelation();\n//构造用户B\nMyUser user = new MyUser();\nuser.setObjectId(\naJyG2224\n);\n//将用户B添加到多对多关联中\nrelation.add(user);\n//多对多关联指向`post`的`likes`字段\npost.setLikes(relation);\npost.update(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n用户B和该帖子关联成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n修改成功后，你在点击该帖子的\nlikes\n字段下面的\n关联关系\n按钮展开后，可查看刚才所添加的喜欢该帖子的用户B：\n\n\n\n\n删除多对多关联\n\n\n如果\n想对该帖子进行取消喜欢的操作\n，此时，需要删除之前的多对多关联，具体代码：\n\n\nPost post = new Post();\npost.setObjectId(\n83ce274594\n);\nMyUser user = BmobUser.getCurrentUser(MyUser.class);\nBmobRelation relation = new BmobRelation();\nrelation.remove(user);\npost.setLikes(relation);\npost.update(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n关联关系删除成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n1 例子中的Comment和Post表请大家注意下在后端控制台建表的数据类型是Pointer还是Relation 否则返回类型不匹配的111错误，表的结构和字段类型如下：\n\n\n\n\n\n\n2 为方便大家了解学习，我们提供了一个关于数据关联的Demo，下载地址是：https://github.com/bmob/RelationDemo\n\n\ninclude用法\n\n\n在某些情况下，你想在一个查询内获取\nPointer\n类型的关联对象。\n\n\n比如上述示例中，如果希望在查询帖子信息的同时也把该帖子的作者的信息查询出来，可以使用\ninclude\n方法\n\n\nquery.include(\nauthor\n);\n\n\n\n\n你可以使用\n,\n号(逗号)操作符来\ninclude并列查询\n两个对象\n\n\n比如，查询评论表的同时将该评论用户的信息和所评论的帖子信息也一并查询出来（因为Comment表有两个\nPointer类型\n的字段），那么可以这样做：\n\n\nquery.include(\nuser,post\n);\n\n\n\n\n但不能如下的做法：\n\n\nquery.include(\nuser\n);\nquery.include(\npost\n);\n\n\n\n\n你同时还可以使用 \n.\n号（英语句号）操作符来进行\ninclude中的内嵌对象查询\n\n\n比如，你想在查询评论信息的同时将该评论\nComment\n对应的帖子\npost\n以及该帖子的作者信息\nauthor\n一并查询出来，你可以这样做：\n\n\nquery.include(\npost.author\n);\n\n\n\n\n另外，include还可以指定返回的字段：\n\n\nquery.include(\npost[likes].author[username|email]\n);\n\n\n\n\n其中，post和author都是Pointer类型，post指向的表只返回likes字段，author指向的表只返回username和email字段。\n\n\n注：include的查询对象只能为BmobPointer类型，而不能是BmobRelation类型。\n\n\n内部查询\n\n\n如果你在查询某个对象列表时，它们的某个字段是BmobObject类型，并且这个BmobObject匹配一个不同的查询，这种情况下可使用\naddWhereMatchesQuery\n方法。\n\n\n请注意，默认的 limit 限制 100 也同样作用在内部查询上。因此如果是大规模的数据查询，你可能需要仔细构造你的查询对象来获取想要的行为。\n\n\n例如：\n查询带有图片的帖子的评论列表\n:\n\n\nBmobQuery\nComment\n query = new BmobQuery\nComment\n();\nBmobQuery\nPost\n innerQuery = new BmobQuery\nPost\n();\ninnerQuery.addWhereExists(\nimage\n, true);\n// 第一个参数为评论表中的帖子字段名post\n// 第二个参数为Post字段的表名，也可以直接用\nPost\n字符串的形式\n// 第三个参数为内部查询条件\nquery.addWhereMatchesQuery(\npost\n, \nPost\n, innerQuery);\nquery.findObjects(new FindListener\nComment\n() {\n\n    @Override\n    public void done(List\nComment\n object,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n反之，不想匹配某个子查询，你可以使用\naddWhereDoesNotMatchQuery\n方法。 \n\n\n比如\n查询不带图片的帖子的评论列表\n：\n\n\nBmobQuery\nComment\n query = new BmobQuery\nComment\n();\nBmobQuery\nPost\n innerQuery = new BmobQuery\nPost\n();\ninnerQuery.addWhereExists(\nimage\n, true);\n// 第一个参数为评论表中的帖子字段名post\n// 第二个参数为Post字段的表名，也可以直接用\nPost\n字符串的形式\n// 第三个参数为内部查询条件\nquery.addWhereDoesNotMatchQuery(\npost\n, \nPost\n, innerQuery);\nquery.findObjects(new FindListener\nComment\n() {\n    @Override\n    public void done(List\nComment\n object,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n注：\n\n\n当查询的表为系统表（目前系统表有User、Installation、Role）时，需要带上下划线\n_\n。\n\n\n比如，你想查询出用户\nsmile\n和\nsmile\n好友的所有帖子，则可以这样：\n\n\n\nBmobQuery\nUser\n innerQuery = new BmobQuery\nUser\n();\nString[] friendIds={\nssss\n,\naaaa\n};//好友的objectId数组\ninnerQuery.addWhereContainedIn(\nobjectId\n, Arrays.asList(friendIds));\n//查询帖子\nBmobQuery\nPost\n query = new BmobQuery\nPost\n();\n`query.addWhereMatchesQuery(\nauthor\n, \n_User\n, innerQuery);`\nquery.findObjects(new FindListener\nPost\n() {\n    @Override\n    public void done(List\nPost\n object,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n用户管理\n\n\n用户是一个应用程序的核心。对于个人开发者来说，自己的应用程序积累到越多的用户，就会给自己带来越强的创作动力。因此Bmob提供了一个专门的用户类——BmobUser来自动处理用户账户管理所需的功能。\n\n\n有了这个类，你就可以在你的应用程序中添加用户账户功能。\n\n\nBmobUser是BmobObject的一个子类，它继承了BmobObject所有的方法，具有BmobObject相同的功能。不同的是，BmobUser增加了一些特定的关于用户账户管理相关的功能。\n\n\n属性\n\n\nBmobUser除了从BmobObject继承的属性外，还有几个特定的属性：\nusername: 用户的用户名\n（必需）\n。\npassword: 用户的密码\n（必需）\n。\nemail: 用户的电子邮件地址\n（可选）\n。\nemailVerified:邮箱认证状态\n（可选）\n。\nmobilePhoneNumber：手机号码\n（可选）\n。\nmobilePhoneNumberVerified：手机号码的认证状态\n（可选）\n。\n\n\n扩展用户类\n\n\n很多时候，你的用户表还会有很多其他字段，如性别、年龄、头像等。那么，你需要对BmobUser类进行扩展，添加一些新的属性。示例代码如下所示：\n\n\npublic class MyUser extends BmobUser {\n\n    private Boolean sex;\n    private String nick;\n    private Integer age;\n\n    public boolean getSex() {\n        return this.sex;\n    }\n\n    public void setSex(boolean sex) {\n        this.sex = sex;\n    }\n\n    public String getNick() {\n        return this.nick;\n    }\n\n    public void setNick(String nick) {\n        this.nick = nick;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}\n\n\n\n\n更多代码实现大家可以下载SDK，在里面的\nBmobExample\n中查找\nMyUser\n类，参考它的用法。\n\n\n创建用户\n\n\n创建用户对象如下：\n\n\nBmobUser user = new BmobUser();\n\n\n\n\n注册\n\n\n你的应用程序可能会要求用户注册。下面的代码是一个典型的注册过程：\n\n\nBmobUser bu = new BmobUser();\nbu.setUsername(\nsendi\n);\nbu.setPassword(\n123456\n);\nbu.setEmail(\nsendi@163.com\n);\n//注意：不能用save方法进行注册\nbu.signUp(new SaveListener\nMyUser\n() {\n    @Override\n    public void done(MyUser s, BmobException e) {\n        if(e==null){\n            toast(\n注册成功:\n +s.toString());\n        }else{\n            loge(e);\n        }\n    }\n});\n\n\n\n\n在注册过程中，服务器会对注册用户信息进行检查，以确保注册的用户名和电子邮件地址是独一无二的。此外，对于用户的密码，你可以在应用程序中进行相应的加密处理后提交。\n\n\n如果注册不成功，你可以查看返回的错误对象。最有可能的情况是，用户名或电子邮件已经被另一个用户注册。这种情况你可以提示用户，要求他们尝试使用不同的用户名进行注册。\n\n\n你也可以要求用户使用Email做为用户名注册，这样做的好处是，你在提交信息的时候可以将输入的“用户名“默认设置为用户的Email地址，以后在用户忘记密码的情况下可以使用Bmob提供重置密码功能。\n\n\n注：\n\n\n\n\n有些时候你可能需要在用户注册时发送一封验证邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在应用设置-\n邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在注册时自动发动一封验证给用户。\n\n\n\n\n\n\n\n\nusername字段是大小写敏感的字段，如果你希望应用的用户名不区分大小写，请在注册和登录时进行大小写的统一转换。\n\n\n\n\n登录\n\n\n当用户注册成功后，您需要让他们以后能够用注册的用户名登录到他们的账户使用应用。要做到这一点，你可以使用BmobUser类的login方法。\n\n\nBmobUser bu2 = new BmobUser();\nbu2.setUsername(\nlucky\n);\nbu2.setPassword(\n123456\n);\nbu2.login(new SaveListener\nBmobUser\n() {\n\n    @Override\n    public void done(BmobUser bmobUser, BmobException e) {\n        if(e==null){\n            toast(\n登录成功:\n);\n            //通过BmobUser user = BmobUser.getCurrentUser()获取登录成功后的本地用户信息\n            //如果是自定义用户对象MyUser，可通过MyUser user = BmobUser.getCurrentUser(MyUser.class)获取自定义用户信息\n        }else{\n            loge(e);\n        }\n    }\n});\n\n\n\n\n也可使用如下方式完成\n用户名+密码\n的登录：\n\n\nBmobUser.loginByAccount(\nusername\n, \n用户密码\n, new LogInListener\nMyUser\n() {\n\n            @Override\n            public void done(MyUser user, BmobException e) {\n                if(user!=null){\n                    Log.i(\nsmile\n,\n用户登陆成功\n);\n                }\n            }\n        });\n\n\n\n\n\n当前用户\n\n\n如果用户在每次打开你的应用程序时都要登录，这将会直接影响到你应用的用户体验。为了避免这种情况，你可以使用缓存的CurrentUser对象。缓存的用户有效期为1年。\n\n\n每当你应用的用户注册成功或是第一次登录成功，都会在本地磁盘中有一个缓存的用户对象，这样，你可以通过获取这个缓存的用户对象来进行登录：\n\n\nBmobUser bmobUser = BmobUser.getCurrentUser();\nif(bmobUser != null){\n    // 允许用户使用应用\n}else{\n    //缓存用户对象为空时， 可打开用户注册界面…\n}\n\n\n\n\n在扩展了用户类的情况下获取当前登录用户，可以使用如下的示例代码（\nMyUser\n类可参看上面）：\n\n\nMyUser userInfo = BmobUser.getCurrentUser(MyUser.class);\n\n\n\n\n\n自\nV3.4.5\n版本开始，SDK新增了\ngetObjectByKey(context,key)\n方法从本地缓存中获取当前登陆用户某一列的值。其中\nkey\n为用户表的指定列名。\n\n\n//BmobUser中的特定属性\nString username = (String) BmobUser.getObjectByKey(\nusername\n);\n//MyUser中的扩展属性\nInteger age = (Integer) BmobUser.getObjectByKey(\nage\n);\nBoolean sex = (Boolean) BmobUser.getObjectByKey(\nsex\n);\n\n\n\n\n更新用户\n\n\n很多情况下你可能需要修改用户信息，比如你的应用具备修改个人资料的功能，Bmob提供的用户更新方式有两种写法：\n\n\n第一种：\n新建一个用户对象，并调用update(objectId,updateListener)方法来更新（推荐使用）\n，示例：\n\n\nBmobUser newUser = new BmobUser();\nnewUser.setEmail(\nxxx@163.com\n);\nBmobUser bmobUser = BmobUser.getCurrentUser(context);\nnewUser.update(bmobUser.getObjectId(),new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n更新用户信息成功\n);\n        }else{\n            toast(\n更新用户信息失败:\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n第二种：获取本地的用户对象，并调用update（updateListener）方法来更新（\n不推荐使用\n），示例：\n\n\nBmobUser bmobUser = BmobUser.getCurrentUser();\n// 修改用户的邮箱为xxx@163.com\nbmobUser.setEmail(\nxxx@163.com\n);\nbmobUser.update(new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n更新用户信息成功\n);\n        }else{\n            toast(\n更新用户信息失败:\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n1、开发者在进行用户更新操作的时候，推荐使用\n第一种\n方式来进行用户的更新操作,因为此方法只会更新你提交的用户信息（比如只会向服务器提交当前用户的email值），而不会将本地存储的用户信息也提交到后台更新。\n\n\n2、在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发一封邮件验证信息给用户。\n\n\n3、需要先登录后才能更新用户信息 否则会返回206 User cannot be altered without sessionToken Error错误。\n\n\n查询用户\n\n\n查询用户和查询普通对象一样，只需指定BmobUser类即可，如下：\n\n\nBmobQuery\nBmobUser\n query = new BmobQuery\nBmobUser\n();\nquery.addWhereEqualTo(\nusername\n, \nlucky\n);\nquery.findObjects(new FindListener\nBmobUser\n() {\n    @Override\n    public void done(List\nBmobUser\n object,BmobException e) {\n        if(e==null){\n            toast(\n查询用户成功:\n+object.size());\n        }else{\n            toast(\n更新用户信息失败:\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n浏览器中查看用户表\n\n\nUser表是一个特殊的表，专门存储BmobUser对象。在浏览器端，你会看到一个User表旁边有一个小人的图标。\n\n\n\n\n退出登录\n\n\n退出登录非常简单，可以使用如下的代码：\n\n\nBmobUser.logOut();   //清除缓存用户对象\nBmobUser currentUser = BmobUser.getCurrentUser(); // 现在的currentUser是null了\n\n\n\n\n密码修改\n\n\n自\nV3.4.3\n版本开始，SDK为开发者提供了直接修改当前用户登录密码的方法，只需要传入旧密码和新密码，然后调用\nBmobUser\n提供的静态方法\nupdateCurrentUserPassword\n即可，以下是示例：\n\n\nBmobUser.updateCurrentUserPassword(\n旧密码\n, \n新密码\n, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n密码修改成功，可以用新密码进行登录啦\n);\n        }else{\n            toast(\n失败:\n + e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n邮箱\n\n\n邮箱登录\n\n\n新增\n邮箱+密码\n登录方式,可以通过\nloginByAccount\n方法来操作：\n\n\nBmobUser.loginByAccount(account, password, new LogInListener\nMyUser\n() {\n\n            @Override\n            public void done(MyUser user, BmobException e) {\n                if(user!=null){\n                    Log.i(\nsmile\n,\n用户登陆成功\n);\n                }\n            }\n        });\n\n\n\n\n\n邮箱验证\n\n\n设置邮件验证是一个可选的应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会被默认设为false，如果应用设置中开启了邮箱认证功能，Bmob会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.\n\n\nemailVerified 字段有 3 种状态可以考虑：\n\n\n\n\ntrue : 用户可以点击邮件中的链接通过Bmob来验证地址，一个用户永远不会在新创建这个值的时候显示emailVerified为true。\n\n\nfalse : 用户(User)对象最后一次被刷新的时候, 用户并没有确认过他的邮箱地址, 如果你看到emailVerified为false的话，你可以考虑刷新用户(User)对象。\n\n\nmissing : 用户(User)对象已经被创建，但应用设置并没有开启邮件验证功能； 或者用户(User)对象没有email邮箱。\n\n\n\n\n请求验证Email\n\n\n发送给用户的邮箱验证邮件会在一周内失效，可以通过调用 \nrequestEmailVerify\n 来强制重新发送：\n\n\nfinal String email = \nxxx@qq.com\n;\nBmobUser.requestEmailVerify(email, new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n请求验证邮件成功，请到\n + email + \n邮箱中进行激活。\n);\n        }else{\n            toast(\n失败:\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n邮箱重置密码\n\n\n开发者只需要求用户输入注册时的电子邮件地址即可：\n\n\nfinal String email = \nxxx@163.com\n;\nBmobUser.resetPasswordByEmail(email, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n重置密码请求成功，请到\n + email + \n邮箱进行密码重置操作\n);\n        }else{\n            toast(\n失败:\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n邮箱重置密码的流程如下：\n\n\n\n\n用户输入他们的电子邮件，请求重置自己的密码。\n\n\nBmob向他们的邮箱发送一封包含特殊的密码重置链接的电子邮件。\n\n\n用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，根据提示他们可以输入一个新的密码。\n\n\n用户的密码已被重置为新输入的密码。\n\n\n\n\n手机号相关功能\n\n\n手机号码登录\n\n\n在手机号码被验证后，用户可以使用该手机号码进行登录操作。\n\n\n手机号码登录包括两种方式：\n手机号码＋密码\n、\n手机号码＋短信验证码\n。\n\n\n手机号码+密码\n\n\nBmobUser.loginByAccount(\n11位手机号码\n, \n用户密码\n, new LogInListener\nMyUser\n() {\n\n    @Override\n    public void done(MyUser user, BmobException e) {\n        if(user!=null){\n            Log.i(\nsmile\n,\n用户登陆成功\n);\n        }\n    }\n});\n\n\n\n\n\n手机号码+短信验证码\n\n\n先请求登录的短信验证码：\n\n\nBmobSMS.requestSMSCode(\n11位手机号码\n,\n模板名称\n, new QueryListener\nInteger\n() {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i(\nsmile\n, \n短信id：\n+smsId);//用于后续的查询本次短信发送状态\n        }\n    }\n});\n\n\n\n\n\n最后调用\nloginBySMSCode\n方法进行手机号码登录:\n\n\nBmobUser.loginBySMSCode(\n11位手机号码\n, code, new LogInListener\nMyUser\n() {\n\n        @Override\n        public void done(MyUser user, BmobException e) {\n            if(user!=null){\n                Log.i(\nsmile\n,\n用户登陆成功\n);\n            }\n        }\n    });\n}\n\n\n\n\n\n手机号码一键注册或登录\n\n\nBmob同样支持手机号码一键注册或登录，以下是一键登录的流程：\n\n\n1、请求登录操作的短信验证码：\n\n\nBmobSMS.requestSMSCode(\n11位手机号码\n,\n模板名称\n, new QueryListener\nInteger\n() {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i(\nsmile\n, \n短信id：\n+smsId);//用于查询本次短信发送详情\n        }\n    }\n    });\n\n\n\n\n\n2、用户收到短信验证码之后，就可以调用\nsignOrLoginByMobilePhone\n方法来实现一键登录:\n\n\nBmobUser.signOrLoginByMobilePhone(\n11位手机号码\n, \n验证码\n, new LogInListener\nMyUser\n() {\n\n    @Override\n    public void done(MyUser user, BmobException e) {\n        if(user!=null){\n            Log.i(\nsmile\n,\n用户登陆成功\n);\n        }\n    }\n});\n\n\n\n\n\n如果，你想在一键注册或登录的同时保存其他字段的数据的时，你可以使用\nsignOrLogin\n方法（此方法\nV3.4.3\n版本提供）。\n\n\n比如，你想在手机号码注册或登录的同时，设置用户名及登录密码等信息，那么具体示例如下：\n\n\n\nMyUser user = new MyUser();\nuser.setMobilePhoneNumber(\n11位手机号码\n);//设置手机号码（必填）\nuser.setUsername(xxx);                  //设置用户名，如果没有传用户名，则默认为手机号码\nuser.setPassword(xxx);                  //设置用户密码\nuser.setAge(18);                        //设置额外信息：此处为年龄\nuser.signOrLogin(\n验证码\n, new SaveListener\nMyUser\n() {\n\n    @Override\n    public void done(MyUser user,BmobException e) {\n        if(e==null){\n            toast(\n注册或登录成功\n);\n            Log.i(\nsmile\n, \n+user.getUsername()+\n-\n+user.getAge()+\n-\n+user.getObjectId());\n        }else{\n            toast(\n失败:\n + e.getMessage());\n        }\n\n    }\n\n});\n\n\n\n\n\n绑定手机号码\n\n\n如果已有用户系统，需要为用户绑定手机号，那么官方推荐的绑定流程如下：\n\n\n第一步、先发送短信验证码并验证验证码的有效性,即调用\nrequestSMSCode\n发送短信验证码，调用\nverifySmsCode\n来验证有效性。\n\n\n第二步、在验证成功之后更新当前用户的\nMobilePhoneNumber\n和\nMobilePhoneNumberVerified\n两个字段，具体绑定示例如下：\n\n\nUser user =new User();\nuser.setMobilePhoneNumber(phone);\nuser.setMobilePhoneNumberVerified(true);\nUser cur = BmobUser.getCurrentUser(User.class);\nuser.update(cur.getObjectId(),new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n手机号码绑定成功\n);\n        }else{\n            toast(\n失败:\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n手机号码重置密码\n\n\nBmob自\nV3.3.9\n版本开始引入了短信验证系统，如果用户已经验证过手机号码或者使用过手机号码注册或登录过，也可以通过手机号码来重置用户密码，以下是官方建议使用的重置流程：\n\n\n1、请求重置密码操作的短信验证码：\n\n\nBmobSMS.requestSMSCode(\n11位手机号码\n,\n模板名称\n, new QueryListener\nInteger\n() {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i(\nsmile\n, \n短信id：\n+smsId);//用于查询本次短信发送详情\n        }\n    }\n    });\n\n\n\n\n\n2、用户收到重置密码的验证码之后，就可以调用\nresetPasswordBySMSCode\n方法来实现密码重置:\n\n\nBmobUser.resetPasswordBySMSCode(code,\n1234567\n, new UpdateListener() {\n\n    @Override\n    public void done(BmobException ex) {\n        if(ex==null){\n            Log.i(\nsmile\n, \n密码重置成功\n);\n        }else{\n            Log.i(\nsmile\n, \n重置失败：code =\n+ex.getErrorCode()+\n,msg = \n+ex.getLocalizedMessage());\n        }\n    }\n});\n\n\n\n\n\n重置成功以后，用户就可以使用新密码登陆了。\n\n\n注：\n\n\n1、请开发者按照官方推荐的操作流程来完成重置密码操作。也就是说，开发者在进行重置密码操作时，无需调用\nverifySmsCode\n接口去验证该验证码的有效性。\n\n\n2、验证码只能使用一次，一旦该验证码被使用就会失效，那么再拿失效的验证码去调用重置密码接口，一定会报\n207-验证码错误\n。因为重置密码接口已经包含验证码的有效性验证。\n\n\n手机号码验证\n\n\n请求发送短信验证码\n\n\nBmob自\nV3.3.9\n版本开始引入了短信验证系统，可通过\nrequestSMSCode\n方式请求发送短信验证码：\n\n\nBmobSMS.requestSMSCode(\n11位手机号码\n, \n模板名称\n,new QueryListener\nInteger\n() {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i(\nsmile\n, \n短信id：\n+smsId);//用于查询本次短信发送详情\n        }\n    }\n});\n\n\n\n\n\n短信默认模板：\n\n\n\n    您的验证码是`%smscode%`，有效期为`%ttl%`分钟。您正在使用`%appname%`的验证码。【比目科技】\n\n\n\n\n\n注：\n\n\n1、\n模板名称\n：模板名称需要开发者在应用的管理后台进行短信模板的添加工作，具体：\n短信服务\n-\n短信模板\n,之后点击创建即可。\n\n\n具体请看下图：\n\n\n\n\n2、只有审核通过之后的自定义短信模板才可以被使用，如果自定义的短信模板其状态显示\n审核中\n或者\n审核失败\n,再调用该方法则会以\n默认模板\n来发送验证码。\n\n\n3、开发者提交短信验证码模板时需注意以下几点：\n\n\n1）、模板中不能有【】和 [] ，否则审核不通过；\n\n\n2）、如果你提交的短信模板无法发送，则有可能包含一些敏感监控词，具体可去Github下载  \n短信关键字监控参考文档\n  来查看提交内容是否合法。\n\n\n3）、一天一个应用给同一手机号发送的短信不能超过10条，否则会报\n10010\n错误，其他错误码可查看  \n短信功能相关错误码\n 。\n\n\n验证验证码\n\n\n通过\nverifySmsCode\n方式可验证该短信验证码：\n\n\nBmobSMS.verifySmsCode(\n11位手机号码\n, \n验证码\n, new UpdateListener() {\n\n    @Override\n    public void done(BmobException ex) {\n        if(ex==null){//短信验证码已验证成功\n            Log.i(\nsmile\n, \n验证通过\n);\n        }else{\n            Log.i(\nsmile\n, \n验证失败：code =\n+ex.getErrorCode()+\n,msg = \n+ex.getLocalizedMessage());\n        }\n    }\n});\n\n\n\n\n\n验证成功后，用户的\nmobilePhoneVerified\n属性会自动变为\ntrue\n。\n\n\n查询短信发送状态\n\n\n通过\nquerySmsState\n方式可查询指定\nsmsId\n的发送状态：\n\n\n\nBmobSMS.querySmsState(smsId, new QueryListener\nBmobSmsState\n() {\n\n            @Override\n            public void done(SmsState state, BmobException ex) {\n                if(ex==null){\n                    Log.i(\nsmile\n,\n短信状态：\n+state.getSmsState()+\n,验证状态：\n+state.getVerifyState());\n                }\n            }\n        });\n\n\n\n\n\n注：\nSmsState\n包含两种状态：\n\n\n1、\nsmsState\n（短信状态）   :SUCCESS（发送成功）、FAIL（发送失败）、SENDING(发送中)。\n\n\n2、\nverifyState\n（验证状态）:true(已验证)、false(未验证)。\n\n\n注意事项：\n\n\n关于短信条数的计算规则如下:\n\n\n\n\n实际计算的短信字数 = 模板的内容或自定义短信的内容字数 + 6。加上6是因为默认的签名【比目科技】占了6个字。\n\n\n实际计算的短信字数在70个字以下算1条。\n\n\n实际计算的短信字数超过70字的以67字为一条来计算的。也就是135个字数是计算为3条的。\n\n\n计算得到的短信条数在本条短信发送成功后将会从你的账户剩余的短信条数中扣除。\n\n\n\n\n短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条。\n\n\n短信验证案例\n\n\n为了方便大家，官方提供了一个短信验证的demo：\nhttps://github.com/bmob/bmob_android_demo_sms\n 。\n\n\n此案例包含了：\n用户名/邮箱/手机号码+密码登录\n、\n手机号码一键注册登录\n、\n绑定手机号\n以及\n通过手机号重置用户密码\n。\n\n\n第三方账号登陆\n\n\nBmob提供了非常简单的方法来实现第三方账号登陆的功能，目前支持\n新浪微博\n、\nQQ账号\n、\n微信账号\n的登陆。\n\n\n自\nBmobV3.3.9\n版本开始，为了与第三方开放平台的SDK解藕，Bmob使用了全新的第三方账号登录方式，之前的微博和qq登录方式的API已删除。\n\n\n应用场景\n\n\n第三方账号登陆目前适应以下两种应用场景：\n\n\n一、没有Bmob账号，希望使用第三方账号一键注册或登陆Bmob账号\n\n\n如果开发者希望用户使用第三方平台的账号注册或登录Bmob的用户体系，则推荐的步骤如下：\n\n\n1、第三方平台授权，开发者需自行根据第三方平台文档提出的授权方法完成账号授权并得到授权信息\n\n\n2、调用Bmob提供的\nloginWithAuthData（BmobV3.3.9版本提供）\n方法，并自行构造\nBmobThirdUserAuth（第三方授权信息）\n对象，调用成功后，在Bmob的User表中会产生一条记录。\n\n\n二、已有Bmob账号，希望与第三方账号进行关联\n\n\n如果已使用Bmob的用户体系（假设用户A已登录），希望和第三方平台进行关联，则推荐的步骤如下：\n\n\n1、第三方平台授权，开发者需自行根据第三方平台文档提出的授权方法完成账号授权并得到授权信息\n\n\n2、调用\nassociateWithAuthData\n方法，并自行构造\nBmobThirdUserAuth(第三方授权信息)\n对象，调用成功后，你就会在后台的用户A的authData这个字段下面看到提交的授权信息。\n\n\n相关文档\n\n\n为了方便开发者完成授权，现整理各个平台的需要查阅的文档：\n\n\n微博登陆相关文档\n\n\n1、\n移动客户端接入文档\n：此文档请着重查阅其中的\nSDK接入流程\n。\n\n\n2、\n新浪微博AndroidSDK快速入门\n，请详细查看\nREADME\n文档,其介绍了完整的集成流程。\n\n\n3、\n新浪微博常见问题\n：在新浪微博授权过程中出现问题，请查看此文档，一般出现频率较高的错误有：\n\n\nsso package and sign error\n- 平台上填写的包名和签名不正确。请仔细检查，一般最需要检查的是\n签名\n，签名需要使用微博提供的获取签名的工具\n（app_signatures.apk）\n。\n\n\nredirect_uri_mismatch\n     - 请确保你在weibo平台上填写的授权回调地址与代码中写的授权回调地址(RedirectURI)一样。\n\n\nQQ登陆相关文档\n\n\n1、如何使用SDK，请参见 \n腾讯开放平台Android_SDK使用说明\n。\n\n\n2、如何调用具体API，请参见 \nAPI调用说明\n。\n\n\n3、常见问题汇总，请参见\n问题汇总说明\n。\n\n\n微信登陆相关文档\n\n\n1、\nAndroid接入指南\n：这里主要介绍的是微信sdk的集成步骤\n\n\n2、\n微信登陆开发指南\n：在\n移动应用开发\n-\n微信登录功能\n-\n移动应用微信登录开发指南\n。主要介绍微信OAuth2.0授权登录的流程。\n\n\n注：\n\n\n三者当中较麻烦的是微信登陆的授权，因此，在此简单说明下可能遇见的问题：\n\n\n1、在微信登陆过程中出现了问题，请仔细注意以下几点：\n\n\n1）、需要在微信开放平台上填写你的\n应用信息、包名和签名\n；\n2）、微信登陆不同于QQ或微博登陆，应用需要\n提交微信官方审核\n，只有审核通过后才能打开授权界面；\n3）、建议\n导出正式签名的apk来测试\n，不建议直接run debug版本的apk；\n4）、检查\n签名是否正确\n、检查\n传递的参数是否正确\n。\n\n\n2、微信登陆的测试相对比较麻烦，如果开发者希望直接能够进行调试，建议使用微信官方demo中的\ndebug keystore\n。具体使用步骤：\n\n\n1)、Eclipse中选择\nWindow-\nPreferences-\nAndroid-\nBuild\n;\n\n\n2)、在Build页有个\nCustom debug keystore\n选项,然后点击\nBrowse\n,选择微信官方demo中的\ndebug keystore\n文件即可。\n\n\n之后重新运行应用时会使用该\ndebug keystore\n文件对应用进行Debug签名。\n\n\n不要忘了在微信后台重新填写通过微信签名工具获得的该调试应用的签名\n。\n\n\n第三方账号一键注册或登录\n\n\n假设你已通过上述提供的文档完成相应平台的授权并得到对应的授权信息，则可以这样来完成一键注册或登陆操作：\n\n\n    BmobThirdUserAuth authInfo = new BmobThirdUserAuth(snsType,accessToken, expiresIn,userId);\n    BmobUser.loginWithAuthData(authInfo, new LogInListener\nJSONObject\n() {\n\n        @Override\n        public void done(JSONObject userAuth,BmobException e) {\n            ...\n        }\n    });         \n\n\n\n\n\n注：\n\n\nBmobThirdUserAuth\n的各参数解释：\n\n\n1、\nsnsType\n:只能是三种取值中的一种：\nweibo、qq、weixin\n\n\n2、\naccessToken\n：接口调用凭证\n\n\n3、\nexpiresIn\n：access_token的有效时间\n\n\n4、\nuserId\n:用户身份的唯一标识，对应微博授权信息中的\nuid\n,对应qq和微信授权信息中的\nopenid\n\n\n关联第三方账号\n\n\n账号关联\n\n\n    BmobThirdUserAuth authInfo = new BmobThirdUserAuth(snsType,accessToken, expiresIn, userId);\n    BmobUser.associateWithAuthData(authInfo, new UpdateListener() {\n\n        @Override\n        public void done(BmobException e) {\n            if(e==null){\n                Log.i(\nbmob\n,\n关联成功\n);\n            }else{\n                Log.i(\nbmob\n,\n关联失败：code =\n + e.getErrorCode() + \n,msg = \n + e.getMessage());\n            }\n\n        }\n    });\n\n\n\n\n\n解除关联\n\n\n    BmobUser.dissociateAuthData(snsType,new UpdateListener() {\n\n        @Override\n        public void done(BmobException e) {\n            if(e==null){\n                Log.i(\nbmob\n,\n取消\n+snsType+\n关联成功\n);\n            }else{\n                int code =e.getErrorCode(); \n                if (code == 208) {// 208错误指的是没有绑定相应账户的授权信息\n                    Log.i(\nsmile\n,\n你没有关联该账号\n);\n                } else {\n                    Log.i(\nsmile\n,\n取消\n+snsType+\n关联失败：code =\n + code + \n,msg = \n + e.getMessage());\n                }\n            }\n        }\n});\n\n\n\n\n\n第三方登录的案例源码\n\n\n具体案例可参考我们Github上的demo：\nhttps://github.com/bmob/bmob-android-demo-thirdpartylogin\n ,这个源码包含了第三方登录的源码和登录之后如何获取用户基本信息的部分。\n\n\n文件管理\n\n\nBmobFile\n可以让你的应用程序将文件存储到服务器中，常见的文件类型都可以实现存储：比如图像文件、影像文件、音乐文件和任何其他二进制数据。\n\n\n注：\n\n\n1、以下均为SDK对文件进行操作的方法，如果你想在Web端对文件进行操作，请查看我们的帮助文档：\n如何在Web后台上传文件\n\n\n2、自 \nBmobSDKv3.4.6\n 开始，文件服务需要注意以下几个方面：\n\n\n\n\n\n\nSDK内部集成CDN文件服务，删除\nBmobProFile\n的相关代码，并不再提供新旧文件管理的功能，但上传的方法名不变\n；\n\n\n\n\n\n\n新增了文件下载\n(download)\n和批量删除CDN文件\n(deleteBatch)\n的方法\n；\n\n\n\n\n\n\n2016年7月,旧版SDK中的新旧文件管理的上传方法将停止服务，之前通过旧版SDK中的新旧文件管理上传的文件仍可下载，请大家及时更新SDK\n；\n\n\n\n\n\n\n之前使用了\nBmobProFile中\n的\nupload\n方法上传的文件，开发者可以直接在文件的url地址后面增加：\"?t=2\na=\"+ 你的accessKey，那么拼接后的文件是可以直接用来访问并下载的。\n；\n\n\n\n\n\n\n    举个例子：\n\n    如果之前通过新版文件管理的上传方法得到的文件url地址：\n    http://newfile.codenow.cn:8080/a272a1aac5274f7085f140de9db94635.png，\n\n    那么签名后的可访问的文件地址为：\n    http://newfile.codenow.cn:8080/a272a1aac5274f7085f140de9db94635.png?t=2\na=你的accessKey。\n\n\n\n\n\n\n无法查看accessKey\n。因为已经废除新旧文件管理功能，所以在开发者管理后台的设置--\n应用密钥中已无法查看accessKey，而之前开发者所使用的accessKey继续有效。\n\n\n\n\n3、CDN文件服务需要\nokhttp-2.4.0、okio-1.4.0\n及\nWAKE_LOCK\n权限，请导入okhttp相关jar包并在\nAndroidManifest.xml\n类的\nmanifest\n标签下添加如下权限，否则会造成调用上传/下载文件的方法无反应。\n\n\n    \n!--保持CPU 运转，屏幕和键盘灯有可能是关闭的,用于文件上传和下载 --\n\n    \nuses-permission android:name=\nandroid.permission.WAKE_LOCK\n /\n\n\n\n\n\n创建文件对象\n\n\n创建文件对象方式如下：\n\n\nString picPath = \nsdcard/temp.jpg\n;\nBmobFile bmobFile = new BmobFile(new File(picPath));\n\n\n\n\n上传单一文件\n\n\n文件分片上传的方法非常简单，示例代码如下：\n\n\nString picPath = \nsdcard/temp.jpg\n;\nBmobFile bmobFile = new BmobFile(new File(picPath));\nbmobFile.uploadblock(new UploadFileListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            //bmobFile.getFileUrl()--返回的上传文件的完整地址\n            toast(\n上传文件成功:\n + bmobFile.getFileUrl());\n        }else{\n            toast(\n上传文件失败：\n + e.getMessage());\n        }\n\n    }\n\n    @Override\n    public void onProgress(Integer value) {\n        // 返回的上传进度（百分比）\n    }\n});\n\n\n\n\n设置文件分片上传时每片大小\n\n\n自\nBmobSDKv3.4.6\n开始,新增\nBmobConfig\n类，允许开发者设置\n查询超时时间\n及\n文件分片上传时的每片大小\n。建议在\nApplication\n类的\nonCreate\n方法中调用。\n\n\n示例代码如下:\n\n\n\npublic class BmobApplication extends Application {\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //设置BmobConfig\n        BmobConfig config =new BmobConfig.Builder()\n        //请求超时时间（单位为秒）：默认15s\n        .setConnectTimeout(30)\n        //文件分片上传时每片的大小（单位字节），默认512*1024\n        .setBlockSize(500*1024)\n        .build();\n        Bmob.getInstance().initConfig(config);\n    }\n}\n\n\n\n\n\n批量上传文件\n\n\n自\nBmobSDKv3.2.7\n开始,新增批量上传文件的方法；\n\n\n自\nBmobSDKv3.4.6\n开始,文件批量上传的静态方法由\nBmob\n转移至\nBmobFile\n类,建议调用\nBmobFile.uploadBatch\n方法。\n\n\n示例代码如下：\n\n\n//详细示例可查看BmobExample工程中BmobFileActivity类\nString filePath_mp3 = \n/mnt/sdcard/testbmob/test1.png\n;\nString filePath_lrc = \n/mnt/sdcard/testbmob/test2.png\n;\nfinal String[] filePaths = new String[2];\nfilePaths[0] = filePath_mp3;\nfilePaths[1] = filePath_lrc;\nBmobFile.uploadBatch(filePaths, new UploadBatchListener() {\n\n    @Override\n    public void onSuccess(List\nBmobFile\n files,List\nString\n urls) {\n        //1、files-上传完成后的BmobFile集合，是为了方便大家对其上传后的数据进行操作，例如你可以将该文件保存到表中\n        //2、urls-上传文件的完整url地址\n        if(urls.size()==filePaths.length){//如果数量相等，则代表文件全部上传完成\n            //do something\n        }\n    }\n\n    @Override\n    public void onError(int statuscode, String errormsg) {\n        ShowToast(\n错误码\n+statuscode +\n,错误描述：\n+errormsg);\n    }\n\n    @Override\n    public void onProgress(int curIndex, int curPercent, int total,int totalPercent) {\n        //1、curIndex--表示当前第几个文件正在上传\n        //2、curPercent--表示当前上传文件的进度值（百分比）\n        //3、total--表示总的上传文件数\n        //4、totalPercent--表示总的上传进度（百分比）\n    }\n});\n\n\n\n\n注：\n\n\n1、有多少个文件上传，onSuccess方法就会执行多少次;\n\n\n2、通过onSuccess回调方法中的files或urls集合的大小与上传的总文件个数比较，如果一样，则表示全部文件上传成功。\n\n\n下载文件\n\n\n自\nBmobSDKv3.4.6\n版本,SDK提供了文件的下载方法\ndownload\n，并且允许开发者设置下载文件的存储路径。\n\n\n注：下载方法并不局限于下载通过BmobSDK上传的文件，也就是说只要提供一个文件url地址，也可以调用下载方法的。\n\n\n下载文件的步骤：\n\n\n1、先获取BmobFile对象实例，可以是查询数据时返回的BmobFile，也可以自行构建BmobFile对象：\n\n\n\n\n通过查询数据时返回的BmobFile，示例代码如下：\n\n\n\n\n\nbmobQuery.findObjects(new FindListener\nGameScore\n() {\n    @Override\n    public void done(List\nGameScore\n object,BmobException e) {\n        if(e==null){\n            for (GameScore gameScore : object) {\n                BmobFile bmobfile = gameScore.getPic();\n               if(file!= null){\n                    //调用bmobfile.download方法\n               }\n            }\n        }else{\n            toast(\n查询失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n\n\n通过如下构造方法构造BmobFile对象：\n\n\n\n\n需求：如果你想下载一个远程图片地址，那么就需要使用下面的构造方法构造一个BmobFile对象（其中group可为空）\n\n\n/**  \n * @param fileName 文件名(必填)\n * @param group 组名（选填）\n * @param url  完整url地址（必填）\n * 注：必须要有文件名和文件的完整url地址，group可为空\n */\npublic BmobFile(String fileName,String group,String url){\n    this.filename = fileName;\n    this.group=group;\n    this.url = url;\n}\n\n\n\n\n\n示例代码如下：\n\n\n\nBmobFile bmobfile =new BmobFile(\nxxx.png\n,\n,\nhttp://bmob-cdn-2.b0.upaiyun.com/2016/04/12/58eeed852a7542cb964600c6cc0cd2d6.png\n)；\n\n\n\n\n\n2、然后调用\nbmobfile.download\n方法下载文件:\n\n\n有两种下载方法：\n\n\n\n\n\n\ndownload(DownloadFileListener listener)\n：此方法会将文件下载到当前应用的默认缓存目录中，以getFilename()得到的值为文件名\n\n\n\n\n\n\ndownload(File savePath, DownloadFileListener listener)\n：此方法允许开发者指定文件存储目录和文件名\n\n\n\n\n\n\n示例代码如下：\n\n\nprivate void downloadFile(BmobFile file){\n    //允许设置下载文件的存储路径，默认下载文件的目录为：context.getApplicationContext().getCacheDir()+\n/bmob/\n\n    File saveFile = new File(Environment.getExternalStorageDirectory(), file.getFilename());\n    file.download(saveFile, new DownloadFileListener() {\n\n        @Override\n        public void onStart() {\n            toast(\n开始下载...\n);\n        }\n\n        @Override\n        public void done(String savePath,BmobException e) {\n            if(e==null){\n                toast(\n下载成功,保存路径:\n+savePath);\n            }else{\n                toast(\n下载失败：\n+e.getErrorCode()+\n,\n+e.getMessage());\n            }\n        }\n\n        @Override\n        public void onProgress(Integer value, long newworkSpeed) {\n            Log.i(\nbmob\n,\n下载进度：\n+value+\n,\n+newworkSpeed);\n        }\n\n    });\n}\n\n\n\n\n\n\n删除文件\n\n\nBmobSDKv3.4.6\n中删除文件的接口，\n只能删除通过CDN文件服务（v3.4.6开始采用CDN文件服务）上传的文件\n。不兼容之前的新旧文件管理，但使用方法不变。\n\n\n示例代码如下：\n\n\nBmobFile file = new BmobFile();\nfile.setUrl(url);//此url是上传文件成功之后通过bmobFile.getUrl()方法获取的。\nfile.delete(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n文件删除成功\n);\n        }else{\n            toast(\n文件删除失败：\n+e.getErrorCode()+\n,\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n批量删除文件\n\n\n自 \nBmobSDKv3.4.6\n 版本，SDK提供了文件的批量删除接口\ndeleteBatch，且只能删除通过CDN文件服务（v3.4.6开始采用CDN文件服务）上传的文件\n。\n\n\n示例代码如下：\n\n\n//此url必须是上传文件成功之后通过bmobFile.getUrl()方法获取的。\nString[] urls =new String[]{url};\nBmobFile.deleteBatch(urls, new DeleteBatchListener() {\n\n    @Override\n    public void done(String[] failUrls, BmobException e) {\n        if(e==null){\n            toast(\n全部删除成功\n);\n        }else{\n            if(failUrls!=null){\n                toast(\n删除失败个数：\n+failUrls.length+\n,\n+e.toString());\n            }else{\n                toast(\n全部文件删除失败：\n+e.getErrorCode()+\n,\n+e.toString());\n            }\n        }\n    }\n});\n\n\n\n\n\n为方便大家理解文件服务的使用，Bmob提供了一个文件上传的案例和源码，大家可以到\n示例和教程中查看和下载\n。\n\n\n缩略图\n\n\n自 \nBmobSDKv3.4.6\n 版本，新版文件服务由第三方厂商又拍云提供，只需要在图片上传成功返回的url后面拼接特定参数即可实现缩放，加水印等效果，\n如图\n，具体可参考\n这里\n 。\n\n\n注：\n\n\n1、文件的批量上传是BmobSDK_v3.2.7版本才提供的功能，如需使用，请更新版本;\n\n\n2、文件的下载和批量删除是BmobSDK_v3.4.6才提供的功能，如需使用，请更新版本。\n\n\n数据实时同步\n\n\n数据实时同步是一个超酷的功能！\n\n\nSDK可以实现对数据表或行的监听，当这个表或者行的数据发生变化时，Bmob会立即将变化的信息告知SDK。\n这种服务非常适合做游戏开发（如，开发斗地主游戏，三个人同时监听一行数据的变化，任何一个人出牌都会将数据写入到这行数据中，其他人也就立即知道了）、群聊（一群人监听某个表的变化，任何人发言都会将数据写入到这个表中，其他人也可以立即知道了）等实时性要求很高的场景中。\n\n\n为方便大家快速了解数据的实时同步服务，我们提供了一个简单的应用实例（ \nhttps://github.com/bmob/bmob-android-demo-realtime-data\n ）供大家参考。\n\n\n开始连接\n\n\n使用数据实时功能，首先需要创建\nBmobRealTimeData\n对象,然后调用\nstart\n方法连接服务器。\n\n\nBmobRealTimeData rtd = new BmobRealTimeData();\nrtd.start(new ValueEventListener() {\n    @Override\n    public void onDataChange(JSONObject data) {\n        Log.d(\nbmob\n, \n(\n+data.optString(\naction\n)+\n)\n+\n数据：\n+data);\n    }\n\n    @Override\n    public void onConnectCompleted(Exception ex) {\n        Log.d(\nbmob\n, \n连接成功:\n+rtd.isConnected());\n    }\n});\n\n\n\n\nstart\n方法中的\nValueEventListener\n参数用于监听连接成功和数据变化的回调。当有数据变化时会通过onDataChange回调方法反馈到客户端。开发者只需要处理得到的data就可以了。\n\n\n注：\n\n\n1、监听器不支持UI线程，在监听回调中请不要直接操作UI；\n\n\n2、如果你要监听User、Installation等系统表的话，表名前需要加上“_”，例如：_User\n\n\n监听数据\n\n\n在BmobRealTimeData对象连接成功后，就可以进行数据的监听了。BmobSDK提供了监听表和行的方法如下：\n\n\n// 监听表更新\nrtd.subTableUpdate(tableName);\n// 监听表删除\nrtd.subTableDelete(tableName);\n// 监听行更新\nrtd.subRowUpdate(tableName, objectId);\n// 监听行删除\nrtd.subRowDelete(tableName, objectId);\n\n\n\n\n其中\ntableName\n为要监听的数据表名，\nobjectId\n为要监听的数据行Id,\n通常比较保险的做法是在\nBmobRealTimeData\n对象的连接状态为\ntrue\n的情况下进行监听，代码如下：\n\n\nif(rtd.isConnected()){\n    // 监听表更新\n    rtd.subTableUpdate(tableName);\n}\n\n\n\n\n取消监听\n\n\n当开发者想取消监听某个行为是，可使用下面的方法：\n\n\n// 取消监听表更新\nrtd.unsubTableUpdate(testTableName);\n// 取消监听表删除\nrtd.unsubTableDelete(testTableName);\n// 取消监听行更新\nrtd.unsubRowUpdate(testTableName, objectId);\n// 取消监听行删除\nrtd.unsubRowDelete(testTableName, objectId);\n\n\n\n\nACL和角色\n\n\n数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看\nBmob数据与安全页面\n，了解Bmob如何保护数据安全）。\n\n\n其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。\n\n\n大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：\n\n\n\n\n对于私有数据，读写权限可以只局限于数据的所有者。\n\n\n对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。\n\n\n对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。\n\n\n属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。\n\n\n一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。\n\n\n\n\n默认访问权限\n\n\n在没有显示指定的情况下，每一个BmobObject(表)中的ACL(列)属性的默认值是所有人可读可写的。在客户端想要修改这个权限设置，只需要简单调用BmobACL的setPublicReadAccess方法和setPublicWriteAccess方法，即：\n\n\nBmobACL aCL = new BmobACL();\n\naCL.setPublicReadAccess(true);\n\naCL.setPublicWriteAccess(true);\n\n\n\n\n注意：可读可写是默认的权限，不需要写额外的代码。\n\n\n指定用户的访问权限\n\n\n假如你想实现一个分享日志类的应用时，这可能会需要针对不同的日志设定不同的访问权限。比如，公开的日志，发布者有更改和修改的权限，其他用户只有读的权限，那么可用如下代码实现：\n\n\nBlog blog = new Blog();\nblog.setTitle(\n论电影的七个元素\n);\nblog.setContent(\n这是blog的具体内容\n);\n\nBmobACL acl = new BmobACL();    //创建一个ACL对象\nacl.setPublicReadAccess(true);  // 设置所有人可读的权限\nacl.setWriteAccess(BmobUser.getCurrentUser(this), true);   // 设置当前用户可写的权限\n\nblog.setACL(acl);    //设置这条数据的ACL信息\nblog.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        ...\n    }\n\n});\n\n\n\n\n有时，用户想发表一篇不公开的日志，这种情况只有发布者才对这篇日志拥有读写权限，相应的代码如下：\n\n\nBlog blog = new Blog();\nblog.setTitle(\n一个人的秘密\n);\nblog.setContent(\n这是blog的具体内容\n);\n\nBmobACL acl = new BmobACL();  //创建ACL对象\nacl.setReadAccess(BmobUser.getCurrentUser(), true); // 设置当前用户可写的权限\nacl.setWriteAccess(BmobUser.getCurrentUser(), true); // 设置当前用户可写的权限\n\nblog.setACL(acl);    //设置这条数据的ACL信息\nblog.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        ...\n    }\n});\n\n\n\n\n角色管理\n\n\n上面的指定用户访问权限虽然很方便，但是对于有些应用可能会有一定的局限性。比如一家公司的工资系统，员工和公司的出纳们只拥有工资的读权限，而公司的人事和老板才拥有全部的读写权限。要实现这种功能，你也可以通过设置每个用户的ACL权限来实现，如下：\n\n\n\n//创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.setWage(100000);   \n\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser boss;\nBmobUser hr_zhang;\nBmobUser cashier_xie;\nBmobUser me;\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\n\n//设置四个用户读的权限\nacl.setReadAccess(boos, true);    \nacl.setReadAccess(hr_zhang, true);\nacl.setReadAccess(cashier_xie, true);\nacl.setReadAccess(me, true);\n\n//设置老板和人事小张对这个工资的写权限\nacl.setWriteAccess(boss, true);\nacl.setWriteAccess(hr_zhang, true);\n\n//设置工资对象的ACL\nwageinfo.setACL(acl);\nwageinfo.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        ...\n    }\n});\n\n\n\n\n但是，一个公司的人事、出纳和员工不仅仅只有一个人，同时还会有离职、调换岗位以及新员工加入等问题存在。如果用上面的代码对公司的每个人进行一一设置的话是不现实的，既麻烦也很难维护。针对这个问题，我们可以利用BmobRole来解决。我们只需要对用户进行分类，每个分类赋予不同的权限。如下代码实现：\n\n\n//创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.setWage(100000);\n\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser boss;\nBmobUser hr_zhang;\nBmobUser hr_luo;\nBmobUser cashier_xie;\nBmobUser me;\n\n//创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\nBmobRole hr = new BmobRole(\nHR\n);\nBmobRole cashier = new BmobRole(\nCashier\n);\n\n//将hr_zhang和hr_luo归属到hr角色中\nhr.getUsers().add(hr_zhang);\nhr.getUsers().add(hr_luo);\n//保存到云端角色表中（web端可以查看Role表）\nhr.save(this);  \n\n//将cashier_xie归属到cashier角色中\ncashier.getUsers().add(cashier_xie);\n//保存到云端角色表中（web端可以查看Role表）\ncashier.save();\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\nacl.setReadAccess(boos, true); // 假设老板只有一个, 设置读权限\nacl.setReadAccess(me, true); // 给自己设置读权限\nacl.setRoleReadAccess(hr, true); // 给hr角色设置读权限\nacl.setRoleReadAccess(cashier, true); // 给cashier角色设置读权限\n\nacl.setWriteAccess(boss, true); // 设置老板拥有写权限\nacl.setRoleWriteAccess(hr, true); // 设置ht角色拥有写权限\n\n//设置工资对象的ACL\nwageinfo.setACL(acl);\nwageinfo.save();\n\n\n\n\n需要说明一点的是，Web端的Role表也具有ACL的列，你可以将角色管理的权限赋予某些用户。\n\n\n角色之间的从属关系\n\n\n下面我们来说一下角色与角色之间的从属关系。用一个例子来说明下：一个互联网企业有移动部门，部门中有不同的小组，如Android开发组和IOS开发组。每个小组只拥有自己小组的代码读写权限，但这两个小组同时拥有核心库代码的读权限。\n\n\n//创建MobileDep（移动研发部）、AndroidTeam（android开发组）和iOSTeam（ios开发组）三个角色\nBmobRole mobileDep = new BmobRole(\nMobileDep\n);\nBmobRole androidTeam = new BmobRole(\nAndroidTeam\n);\nBmobRole iosTeam = new BmobRole(\niOSTeam\n);\n\n//保存AndroidTeam和iosTeam角色到云端\nandroidTeam.save();\niosTeam.save();\n\n//将androidTeam和iosTeam两种角色添加到移动部门角色中\nmobileDep.getRoles().add(androidTeam);\nmobileDep.getRoles().add(iosTeam);\nmobileDep.save();\n\n// 假设创建三个代码数据对象\nCode coreCode = new Code();\nCode androidCode = new Code();\nCode iosCode = new Code();\n\n//......此处省略一些具体的属性设定\n\ncoreCode.save();\nandroidCode.save();\niosCode.save();\n\n//设置androidTeam角色对androidCode对象的读和写的权限\nandroidCode.setRoleReadAccess(androidTeam, true);\nandroidCode.setRoleWriteAccess(androidTeam, true);\n\n//设置iosTeam角色对iosCode对象的读和写的权限\niosCode.setRoleReadAccess(iosTeam, true);\niosCode.setRoleWriteAccess(iosTeam, true);\n\n//设置mobileDep角色可以对coreCode对象进行读操作\ncoreCode.setRoleReadAccess(mobileDep);\n\n\n\n\n\nACL案例源码\n\n\n我们为大家提供一个ACL相关的案例源码，大家可以点击下载：\nhttps://github.com/bmob/bmob-android-demo-acl\n\n\n地理位置\n\n\nBmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询。通过在BmobObject的查询中添加一个BmobGeoPoint的对象查询，你就可以实现轻松查找出离当前用户最接近的信息或地点的功能。\n\n\n为了方便大家查看文档，这里创建一个Person类：\n\n\npublic class Person extends BmobObject{\n    private BmobGeoPoint gpsAdd;\n\n    public BmobGeoPoint getGpsAdd() {\n        return gpsAdd;\n    }\n    public void setGpsAdd(BmobGeoPoint gpsAdd) {\n        this.gpsAdd = gpsAdd;\n    }\n}\n\n\n\n\n\n创建地理位置对象\n\n\n首先需要创建一个BmobGeoPoint对象。例如，创建一个东经116.39727786183357度，北纬39.913768382429105度的BmobGeoPoint对象：\n\n\nBmobGeoPoint point = new BmobGeoPoint(116.39727786183357, 39.913768382429105);\n\n\n\n\n查询地理位置信息\n\n\n现在，你可以测试找出最接近某个点的信息了（\n数据表要有一定的地理坐标对象的数据，GeoPoint字段类型\n）。查询使用BmobQuery对象的\naddWhereNear\n方法进行操作：\n\n\nBmobQuery\nPerson\n bmobQuery = new BmobQuery\nPerson\n();\nbmobQuery.addWhereNear(\ngpsAdd\n, new BmobGeoPoint(112.934755, 24.52065));\nbmobQuery.setLimit(10);    //获取最接近用户地点的10条数据\nbmobQuery.findObjects(new FindListener\nPerson\n() {\n    @Override\n    public void done(List\nPerson\n object,BmobException e) {\n        if(e==null){\n            toast(\n查询成功：共\n + object.size() + \n条数据。\n);\n        }else{\n            toast(\n查询失败：\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n要限制查询指定距离范围的数据可以使用\naddWhereWithinKilometers\n、\naddWhereWithinMiles\n或\naddWhereWithinRadians\n方法。\n\n\n要查询一个矩形范围内的信息可以使用\naddWhereWithinGeoBox\n来实现：\n\n\nBmobGeoPoint southwestOfSF = new BmobGeoPoint(116.10675, 39.711669);\nBmobGeoPoint northeastOfSF = new BmobGeoPoint(116.627623, 40.143687);\nBmobQuery\nPerson\n query = new BmobQuery\nPerson\n();\nquery.addWhereWithinGeoBox(\ngpsAdd\n, southwestOfSF, northeastOfSF);\nquery.findObjects(new FindListener\nPerson\n() {\n\n    @Override\n    public void done(List\nPerson\n object,BmobException e) {\n        if(e==null){\n            toast(\n查询成功：共\n + object.size() + \n条数据。\n);\n        }else{\n            toast(\n查询失败：\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n注意事项\n\n\n\n\n\n\n每个BmobObject数据对象中\n只能\n有一个BmobGeoPoint对象\n。\n\n\n\n\n\n\n地理位置的点不能超过规定的范围。\n纬度的范围\n应该是在\n-90.0到90.0\n之间。\n经度的范围\n应该是在\n-180.0到180.0\n之间。如果您添加的经纬度超出了以上范围，将导致程序错误。\n\n\n\n\n\n\n应用安全\n\n\n请大家在使用Bmob开发应用程序之前，仔细阅读“数据与安全”的文档：\nhttp://docs.bmob.cn/other/Other/n_datasafety/doc/index.html\n\n\n开源案例\n\n\n为方便大家更好的理解Bmob SDK，我们特意为大家提供了一些源码，大家可以下载之后，\n嵌入Bmob的Application Id\n，就可以打包运行了。\n\n\n阅读源码是一种良好的习惯！！\n\n\n\n\n\n\n即时聊天案例源码：\nhttps://github.com/bmob/BmobIMSDK4Android\n\n\n\n\n\n\n图文社区案例源码：\nhttps://git.oschina.net/v7/Wonderful\n  这个案例是猿圈媛圈开发团队提供的。\n\n\n\n\n\n\n校园小菜案例源码：\nhttps://github.com/bmob/Shop\n 这个案例是湖工大的朋友提供的。\n\n\n\n\n\n\n社交分享案例源码：\nhttps://github.com/bmob/bmob-android-social-share\n 这个是金刚锁开发者提供的\n\n\n\n\n\n\n第三方登录案例源码：\nhttps://github.com/bmob/bmob-android-demo-thirdpartylogin\n  包含第三方登录和登录后获取用户信息的源码\n\n\n\n\n\n\n其他功能\n\n\n获取服务器时间\n\n\n在Bmob对象中提供了一个静态方法，用于获取服务器时间。\n\n\nBmob.getServerTime(new QueryListener\nLong\n() {\n\n    @Override\n    public void done(long time,BmobException e) {\n        if(e==null){\n            SimpleDateFormat formatter = new SimpleDateFormat(\nyyyy-MM-dd HH:mm\n);\n            String times = formatter.format(new Date(time * 1000L));\n            Log.i(\nbmob\n,\n当前服务器时间为:\n + times);\n        }else{\n            Log.i(\nbmob\n,\n获取服务器时间失败:\n + e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n自动更新组件\n\n\nBmob为大家提供了应用的自动更新组件，使用这个组件可以快速方便实现应用的自动升级功能。\n详细的使用操作可以参考文档：\n自动更新组件文档\n\n\n表结构\n\n\n自\nV3.4.2\n版本开始，SDK提供了\n获取表结构信息\n方法,具体示例如下：\n\n\n获取特定表的结构\n\n\nBmob.getTableSchema(\n待查询的表名\n, new QueryListener\nBmobTableSchema\n() {\n\n    @Override\n    public void done(BmobTableSchema schema, BmobException ex) {\n        if(ex==null){\n            Log.i(\nbmob\n, \n获取指定表的表结构信息成功：\n+schema.getClassName()+\n-\n+schema.getFields().toString());\n        }else{\n            Log.i(\nbmob\n, \n获取指定表的表结构信息失败:\n + ex.getLocalizedMessage()+\n(\n+ex.getErrorCode()+\n)\n);\n        }\n    }\n});\n\n\n\n\n\n获取所有表的结构\n\n\n\nBmob.getAllTableSchema(context, new QueryListListener\nBmobTableSchema\n() {\n\n    @Override\n    public void done(List\nBmobTableSchema\n schemas, BmobException ex) {\n        if(ex==null \n schemas!=null \n schemas.size()\n0){\n            Log.i(\nbmob\n, \n获取所有表结构信息成功\n);\n        }else{\n            Log.i(\nbmob\n,\n获取所有表结构信息失败：\n+ex.getLocalizedMessage()+\n(\n+ex.getErrorCode()+\n)\n);\n        }\n    }\n});\n\n\n\n\n\n返回数据说明\n\n\n注：\nBmobTableSchema\n参数说明：\n\n\n其中\n\n\nclassName\n：表示表名\n\n\nfields\n   ： 是Map\n类型，里面包含了对应表的所有列的属性，\n\n\n其fields内部结构如下：\n\n\n\n\n{\"列1\":Map,\"列2\":Map, ...}\n\n\n\n\n而Map的结构为：\n\n\n\n\n{\"type\":\"typeName\",\"targetClass\":\"tableName\"}\n\n\n\n\n其中 \ntype\n 指的是该列的类型， 而 \ntargetClass\n 指的是指向的表名，只有在 type 为 Pointer 或者 Relation 时才有值。\n\n\n具体json格式如下,仅供参考：\n\n\n {\n    className: \nPost\n, \n    fields: {\n      ACL: {\n        type: \nObject\n\n      }, \n      author: {\n        targetClass: \n_User\n, \n        type: \nPointer\n\n      }, \n      content: {\n        type: \nString\n\n      }, \n      createdAt: {\n        type: \nDate\n\n      }, \n      objectId: {\n        type: \nString\n\n      }, \n      updatedAt: {\n        type: \nDate\n\n      }\n    }\n }\n\n\n\n\n\n错误码列表\n\n\nAndroid SDK的错误码都是以\n9\n开头的，其他错误码请点击查看：\nRestAPI错误码列表\n。\n\n\n9001\n\n\n内容：AppKey is Null, Please initialize BmobSDK.\n\n\n含义：Application Id为空，请初始化。\n\n\n9002\n\n\n内容：Parse data error\n\n\n含义：解析返回数据出错\n\n\n9003\n\n\n内容：upload file error\n\n\n含义：上传文件出错\n\n\n9004\n\n\n内容：upload file failure\n\n\n含义：文件上传失败\n\n\n9005\n\n\n内容：A batch operation can not be more than 50\n\n\n含义：批量操作只支持最多50条\n\n\n9006\n\n\n内容：objectId is null\n\n\n含义：objectId为空\n\n\n9007\n\n\n内容：BmobFile File size must be less than 10M.\n\n\n含义：文件大小超过10M\n\n\n9008\n\n\n内容：BmobFile File does not exist.\n\n\n含义：上传文件不存在\n\n\n9009\n\n\n内容：No cache data.\n\n\n含义：没有缓存数据\n\n\n9010\n\n\n内容：The network is not normal.(Time out)\n\n\n含义：网络超时\n\n\n9011\n\n\n内容：BmobUser does not support batch operations.\n\n\n含义：BmobUser类不支持批量操作\n\n\n9012\n\n\n内容：context is null.\n\n\n含义：上下文为空\n\n\n9013\n\n\n内容： BmobObject Object names(database table name) format is not correct.\n\n\n含义：BmobObject（数据表名称）格式不正确\n\n\n9014\n\n\n含义：第三方账号授权失败\n\n\n9015\n\n\n含义：其他错误均返回此code\n\n\n9016\n\n\n内容：The network is not available,please check your network!\n\n\n含义：无网络连接，请检查您的手机网络。\n\n\n9017\n\n\n含义：与第三方登录有关的错误，具体请看对应的错误描述\n\n\n9018\n\n\n含义：参数不能为空\n\n\n9019\n\n\n含义：格式不正确：手机号码、邮箱地址、验证码\n\n\n混淆打包\n\n\n使用了BmobSDK的应用在混淆过程中，需注意以下几点：\n\n\n1、\n不要混淆BmobSDK的代码\n，Bmob Android SDK本身进行了代码混淆；\n\n\n2、任何继承自\nBmobObject、BmobUser\n的JavaBean及\n在上述JavaBean中定义的Object属性类\n都不要混淆，否则gson将无法将数据解析成具体对象；\n\n\n3、确保\nrx\n、\nokhttp3 okio\n、\ngson\n及\norg.apache.http.legacy.jar\n包均不要混淆。\n\n\n具体可参考BmobExample中proguard-project.txt的代码：\n\n\n\n-ignorewarnings\n\n-keepattributes Signature,*Annotation*\n\n# keep BmobSDK\n-dontwarn cn.bmob.v3.**\n-keep class cn.bmob.v3.** {*;}\n\n# 确保JavaBean不被混淆-否则gson将无法将数据解析成具体对象\n-keep class * extends cn.bmob.v3.BmobObject {\n    *;\n}\n-keep class com.example.bmobexample.bean.BankCard{*;}\n-keep class com.example.bmobexample.bean.GameScore{*;}\n-keep class com.example.bmobexample.bean.MyUser{*;}\n-keep class com.example.bmobexample.bean.Person{*;}\n-keep class com.example.bmobexample.file.Movie{*;}\n-keep class com.example.bmobexample.file.Song{*;}\n-keep class com.example.bmobexample.relation.Post{*;}\n-keep class com.example.bmobexample.relation.Comment{*;}\n\n# keep BmobPush\n-dontwarn  cn.bmob.push.**\n-keep class cn.bmob.push.** {*;}\n\n# keep okhttp3、okio\n-dontwarn okhttp3.**\n-keep class okhttp3.** { *;}\n-keep interface okhttp3.** { *; }\n-dontwarn okio.**\n\n# keep rx\n-dontwarn sun.misc.**\n-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* {\n long producerIndex;\n long consumerIndex;\n}\n-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef {\n rx.internal.util.atomic.LinkedQueueNode producerNode;\n}\n-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef {\n rx.internal.util.atomic.LinkedQueueNode consumerNode;\n}\n\n# 如果你需要兼容6.0系统，请不要混淆org.apache.http.legacy.jar \n-dontwarn android.net.compatibility.**\n-dontwarn android.net.http.**\n-dontwarn com.android.internal.http.multipart.**\n-dontwarn org.apache.commons.**\n-dontwarn org.apache.http.**\n-keep class android.net.compatibility.**{*;}\n-keep class android.net.http.**{*;}\n-keep class com.android.internal.http.multipart.**{*;}\n-keep class org.apache.commons.**{*;}\n-keep class org.apache.http.**{*;}", 
            "title": "开发文档"
        }, 
        {
            "location": "/data/android/develop_doc/#_1", 
            "text": "Bmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。", 
            "title": "简介"
        }, 
        {
            "location": "/data/android/develop_doc/#_2", 
            "text": "建议您在阅读本开发文档之前，先阅读我们提供的  Android快速入门文档 ，便于您后续的开发。 \n如果开发者想使用不同历史版本的SDK，可以移步 历史版本的github仓库 ，选择使用各个历史版本。", 
            "title": "快速入门"
        }, 
        {
            "location": "/data/android/develop_doc/#_3", 
            "text": "在使用SDK过程中，如果一些Api如查询是高频代码，可以把一些重复的样板代码抽出来，并在AndroidStudio中设置模板，即可实现快速输入，能提高编码效率，效果如下：", 
            "title": "模板代码"
        }, 
        {
            "location": "/data/android/develop_doc/#_4", 
            "text": "从v3.5.5开始，数据SDK新增了能重新设置请求域名的Api，类似数据迁移，调用方式如下：      Bmob.resetDomain(\"http://demo.bmob.cn/\");  其中，参数为开发者的域名，调用后的所有请求都指向新的域名。", 
            "title": "数据迁移"
        }, 
        {
            "location": "/data/android/develop_doc/#sdk", 
            "text": "从v3.5.2开始，把统计SDK集成到了数据服务SDK，上传应用不再需要额外集成统计SDK，低于此版本的可以去控制台的应用官网下载。", 
            "title": "统计SDK"
        }, 
        {
            "location": "/data/android/develop_doc/#_5", 
            "text": "确保项目有 INTERNET 和 READ_PHONE_STATE 权限  uses-permission android:name=\"android.permission.INTERNET\" /  uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /     在初始化方法中传一个渠道参数(不传默认没开启统计功能)  Bmob.initialize(this,APPID,\"Bmob\");    将libs文件夹内的BmobStat.jar文件添加进项目（AS选择远程依赖可以忽略，本地依赖需要指定libs文件夹，Eclipse中放进libs即可）；", 
            "title": "添加方法"
        }, 
        {
            "location": "/data/android/develop_doc/#android60", 
            "text": "自 v3.4.6 版本开始，Bmob提供了一些新的方法和工具类来帮助开发者为自己的应用兼容Android6.0系统。", 
            "title": "兼容Android6.0系统"
        }, 
        {
            "location": "/data/android/develop_doc/#apachehttp-client", 
            "text": "Android6.0版本移除了对Appache的HTTP client的支持，因此，需要添加 org.apache.http.legacy.jar 包，请参照如下方式添加：  1.Eclipse  你需要在Eclipse工程的项目根目录中新建libs文件夹，将org.apache.http.legacy.jar包，添加到libs文件夹中  2.AndroidStudio  你需要在 app 的 build.gradle 文件添加配置信息useLibrary 'org.apache.http.legacy'声明编译时依赖      android {\n        compileSdkVersion 23\n        buildToolsVersion \"23.0.2\"\n        useLibrary 'org.apache.http.legacy'\n    }  注：如果在build.gradle文件中 useLibrary 'org.apache.http.legacy' 这句话报错，可将该jar直接放到libs目录下即可。", 
            "title": "添加对Apache的HTTP-client支持"
        }, 
        {
            "location": "/data/android/develop_doc/#_6", 
            "text": "Android6.0中对特定的权限进行了动态授权的方式，需要在运行时用户手动授予，如果用户拒绝后再次申请还可以向用户弹框说明权限的作用，用户点击确认后再去申请。  因此，我们提供了一个权限管理的工具类 PermissionManager(cn.bmob.v3.helper) ，具体使用如下：  注：在 v3.4.6 的BmobSDK内部集成 PermissionManager 类，自 v3.4.7 以后的SDK内部将不再提供该类，开发者可以在下载的配套官方Demo的 com.example.bmobexample.permission 包下面查看该类源码。  1.构建 PermissionManager 对象  PermissionManager helper;\nhelper = PermissionManager.with(MainActivity.this)\n        //添加权限请求码\n        .addRequestCode(MainActivity.REQUEST_CODE_CAMERA)\n        //设置权限，可以添加多个权限\n        .permissions(Manifest.permission.CAMERA)\n        //设置权限监听器\n        .setPermissionsListener(new PermissionListener() {\n\n            @Override\n            public void onGranted() {\n                //当权限被授予时调用\n               Toast.makeText(MainActivity.this, \"Camera Permission granted\",Toast.LENGTH_LONG).show();\n            }\n\n            @Override\n            public void onDenied() {\n                //用户拒绝该权限时调用\n               Toast.makeText(MainActivity.this, \"Camera Permission denied\",Toast.LENGTH_LONG).show();\n            }\n\n            @Override\n            public void onShowRationale(String[] permissions) {\n                //当用户拒绝某权限时并点击`不再提醒`的按钮时，下次应用再请求该权限时，需要给出合适的响应（比如,给个展示对话框来解释应用为什么需要该权限）\n                Snackbar.make(btn_camera, \"需要相机权限去拍照\", Snackbar.LENGTH_INDEFINITE)\n                        .setAction(\"ok\", new View.OnClickListener() {\n                            @Override\n                            public void onClick(View v) {\n                                //必须调用该`setIsPositive(true)`方法\n                                helper.setIsPositive(true);\n                                helper.request();\n                            }\n                        }).show();\n            }\n        })\n        //请求权限\n        .request();  注：   with 方法可以传入Activity或者Fragment；  addRequestCode 方法传入请求码，用于区分各种不同的权限申请；  permissions 方法传入的是你所要请求的权限，支持可变参数，可以批量申请权限；  PermissionListener 接口回调的三个方法：  onGranted()会在权限申请通过后被调用；  onDenied()在权限申请被拒绝时被调用  onShowRationale()方法中你可以弹对话框向用户解释权限的作用，不过记得要调用 setIsPositive(true) 。  request 方法用来请求权限申请   2.覆写 onRequestPermissionsResult 方法  @Override\npublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n    switch (requestCode) {\n        case REQUEST_CODE_CAMERA:\n            helper.onPermissionResult(permissions, grantResults);\n            break;\n    }\n}", 
            "title": "运行时权限管理"
        }, 
        {
            "location": "/data/android/develop_doc/#notification", 
            "text": "Android6.0中， Notification.setLatestEventInfo() 方法被移除，替代的方案是用Notification.Builder来构建通知，对此SDK提供了 NotificationCompat(cn.bmob.v3.helper) 类来做版本兼容（与 android.support.v4.app 包下的NotificationCompat用法一样）。  参照代码如下：      NotificationManager notificationManager = (NotificationManager) mContext\n            .getSystemService(Context.NOTIFICATION_SERVICE);\n    PendingIntent pi = PendingIntent.getActivity(mContext, 0,\n            new Intent(MainActivity.this, MainActivity.class), 0);\n    NotificationCompat.Builder builder = new NotificationCompat.Builder(mContext)\n            .setTicker( 更新啦 )\n            .setContentTitle( 标题 )\n            .setContentText( 内容 )\n            .setSmallIcon(R.drawable.ic_launcher);\n    Notification notification = builder.build();\n    notificationManager.notify(0, notification);", 
            "title": "Notification变更"
        }, 
        {
            "location": "/data/android/develop_doc/#_7", 
            "text": "一个数据对象（APP中创建的BmobObject类的子类）对应于Bmob后台的一个数据表。", 
            "title": "对象"
        }, 
        {
            "location": "/data/android/develop_doc/#_8", 
            "text": "Bmob存储的数据是建立在BmobObject基础上的，所以任何要保存的数据对象必须继承自BmobObject类(不建议用抽象类去继承BmobObject或者定义父类然后在子类中写bean，这样也解析不了，一般不会这么用，一个bean类对应一张表，类似使用ORM库)。BmobObject类本身包含objectId、createdAt、updatedAt、ACL四个默认的属性，objectId是数据的唯一标示，相当于数据库中表的主键，createdAt是数据的创建时间，updatedAt是数据的最后修改时间，ACL是数据的操作权限。  如，你的游戏中使用GameScore表来记录玩家的比分信息，其中表的字段有：score（分数）、playerName（玩家名字）、isPay(是否付费玩家)、pic（玩家头像）属性，那么这个数据对象为如下定义：  //必须要继承自BmobObject类\npublic class GameScore extends BmobObject{\n\n    private String playerName;\n    private Integer score;\n    private Boolean isPay;\n    private BmobFile pic;\n\n    public String getPlayerName() {\n        return playerName;\n    }\n\n    public void setPlayerName(String playerName) {\n        this.playerName = playerName;\n    }\n\n    public Integer getScore() {\n        return score;\n    }\n\n    public void setScore(Integer score) {\n        this.score = score;\n    }\n\n    public Boolean getIsPay() {\n        return isPay;\n    }\n\n    public void setIsPay(Boolean isPay) {\n        this. isPay = isPay;\n    }\n\n    public BmobFile getPic() {\n        return pic;\n    }\n\n    public void setPic(BmobFile pic) {\n        this.pic = pic;\n    }\n}  需要注意的是：   JavaBean不需要对 objectId、createdAt、updatedAt、ACL 四个属性进行定义。  不少开发者会没有注意到createdAt和updatedAt属性中的字母d，写成createAt和updateAt。  尽可能使用Integer、Boolean，而不是int、boolean，也就是选择包装类，而不是使用基本数据类型（这两者的区别大家可以看这篇文章：http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html）", 
            "title": "数据对象"
        }, 
        {
            "location": "/data/android/develop_doc/#_9", 
            "text": "为了提供更好的服务，BmobSDK中提供了 BmobUser、BmobInstallation、BmobRole 三个特殊的BmobObject对象来完成不同的功能，在这里我们统一称为特殊对象。    BmobUser 对象主要是针对应用中的用户功能而提供的，它对应着web端的User表，使用BmobUser对象可以很方便的在应用中实现用户的注册、登录、邮箱验证等功能，具体的使用方法可查看文档的 用户管理 部分。    BmobInstallation 对象主要用于应用的安装设备管理中，它对应着web端的Installation表，任何安装了你应用的设备都会在此表中产生一条数据标示该设备。结合Bmob提供的推送功能，还可以实现将自定义的消息推送给不同的设备终端，具体的使用方法可查看文档的 消息推送 部分。    BmobRole 对象主要用于角色管理，对应用于Web端的Role表，具体的使用方法可查看文档的 ACL和角色 部分。", 
            "title": "特殊对象"
        }, 
        {
            "location": "/data/android/develop_doc/#_10", 
            "text": "目前为止，Bmob支持的数据类型：String、Integer、Float、Short、Byte、Double、Character、Boolean、Object、Array。\n同时也支持BmobObject、BmobDate、BmobGeoPoint、BmobFile特有的数据类型。  以下为Web端类型与SDK端支持的JAVA类型对应表：     Web端类型  支持的JAVA类型  说明      Number  Integer、Float、Short、Byte、Double、Character  对应数据库的Number类型    Array  List  数组类型    File  BmobFile  Bmob特有类型，用来标识文件类型    GeoPoint  BmobGeoPoint  Bmob特有类型，用来标识地理位置    Date  BmobDate  Bmob特有类型，用来标识日期类型    Pointer  特定对象  Bmob特有类型，用来标识指针类型    Relation  BmobRelation  Bmob特有类型，用来标识数据关联     注：不能使用int、float、short byte、double、character等基本数据类型。", 
            "title": "数据类型"
        }, 
        {
            "location": "/data/android/develop_doc/#_11", 
            "text": "Bmob官方推荐类名和表名完全一致的映射使用方式， 即如，上面的GameScore类，它在后台对应的表名也是GameScore（区分大小写）。  如果你希望表名和类名并不相同，如表名为T_a_b，而类名还是GameScore，那么你可以使用BmobObject提供的setTableName(\"表名\")的方法，   示例代码如下：  //这时候实际操作的表是T_a_b\npublic class GameScore extends BmobObject{\n    private String playerName;\n    private Integer score;\n    private Boolean isPay;\n    private BmobFile pic;\n\n    public GameScore() {\n        this.setTableName( T_a_b );\n    }\n\n    public String getPlayerName() {\n        return playerName;\n    }\n    //其他方法，见上面的代码\n}  当然了，除了在构造函数中直接调用setTableName方法之外，你还可以在GameScore的实例中动态调用setTableName方法。", 
            "title": "类名和表名的关系"
        }, 
        {
            "location": "/data/android/develop_doc/#_12", 
            "text": "如果您使用了setTableName方法来自定义表名，那么在对该表进行数据查询的时候必须使用以下方法。 需要注意的是查询的结果是JSONArray,需要自行解析JSONArray中的数据 。  /**\n * 查询数据\n */\npublic void queryData(){\n    BmobQuery query =new BmobQuery( Person );\n    query.addWhereEqualTo( age , 25);\n    query.setLimit(2);\n    query.order( createdAt );\n    //v3.5.0版本提供`findObjectsByTable`方法查询自定义表名的数据\n    query.findObjectsByTable(new QueryListener JSONArray () {\n        @Override\n        public void done(JSONArray ary, BmobException e) {\n            if(e==null){\n                Log.i( bmob , 查询成功： +ary.toString());\n            }else{\n                Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n            }\n        }\n    });\n}  自定义表名情况下的更新、删除数据和普通的更新、删除数据方式一样，没有变化。为方便大家了解学习，我们提供了一个关于自定义表名情况下增删改查数据的Demo，下载地址是： https://github.com/bmob/bmob-android-demo-dynamic-tablename 。", 
            "title": "查询自定义表名的数据"
        }, 
        {
            "location": "/data/android/develop_doc/#_13", 
            "text": "添加数据使用BmobObject对象的 save 方法，就可以将当前对象的内容保存到Bmob服务端。\n例如，你现在要保存一条游戏分数的记录，代码如下：  GameScore gameScore = new GameScore();\n//注意：不能调用gameScore.setObjectId( )方法\ngameScore.setPlayerName( 比目 );\ngameScore.setScore(89);\ngameScore.setIsPay(false);\ngameScore.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        if(e==null){\n            toast( 创建数据成功：  + objectId);\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n})  运行以上代码，如果添加成功，你可以在Bmob提供的后台的数据浏览中看到类似这样的结果：  objectId:  0c6db13c , score: 89, playerName:  比目 , isPay: false,createdAt: 2013-09-27 10:32:54 , updatedAt: 2013-09-27 10:32:54   这里需要注意的是：    如果服务器端不存在GameScore表，那么系统将自动建表，并插入数据。    如果服务器端已经存在GameScore表，和相应的score、playerName、isPay字段，那么你此时添加的数据和数据类型也应该和服务器端的表结构一致，否则会保存数据失败。    每个BmobObject对象都有几个默认的键(数据列)是不需要开发者指定的， objectId 是每个保存成功数据的唯一标识符。 createdAt 和 updatedAt 代表每个对象(每条数据)在服务器上创建和最后修改的时间。这些键(数据列)的创建和数据内容是由服务器端自主来完成的。 因此，使用save和insert方法时,不需要调用setObjectId方法，否则会出现提示：“It is a reserved field: objectId(105)”--表明objectId为系统保留字段，不允许修改。 。", 
            "title": "添加数据"
        }, 
        {
            "location": "/data/android/develop_doc/#_14", 
            "text": "更新一个对象也是非常简单。例如：将GameScore表中objectId为 0c6db13c 的游戏分数修改为77.  GameScore gameScore = new GameScore();\ngameScore.setScore(77);\ngameScore.update( 0c6db13c , new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 更新成功 );\n        }else{\n            Log.i( bmob , 更新失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});  自 V3.4.4 版本开始，SDK提供了另一种方法来更新数据，通过调用 Bmobobject 类中的 setValue（key，value） 方法，只需要传入key及想要更新的值即可  举例，说明如下：  public class Person extends BmobObject {\n    private BmobUser user;  //BmobObject类型\n    private BankCard cards; //Object类型\n    private Integer age;    //Integer类型\n    private Boolean gender; //Boolean类型\n    ...\n    getter、setter方法\n}\n\n其中BankCard类结构如下：\n\npublic class BankCard{\n    private String cardNumber;\n    private String bankName;\n    public BankCard(String bankName, String cardNumber){\n        this.bankName = bankName;\n        this.cardNumber = cardNumber;\n    }\n    ...\n    getter、setter方法\n}  Person p2=new Person();\n//更新BmobObject的值\n//  p2.setValue( user , BmobUser.getCurrentUser(this, MyUser.class));\n//更新Object对象\np2.setValue( bankCard ,new BankCard( 农行 ,  农行账号 ));\n//更新Object对象的值\n//p2.setValue( bankCard.bankName , 建行 );\n//更新Integer类型\n//p2.setValue( age ,11);\n//更新Boolean类型\n//p2.setValue( gender , true);\np2.update(objectId, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 更新成功 );\n        }else{\n            Log.i( bmob , 更新失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n\n});  注意：修改数据只能通过objectId来修改，目前不提供查询条件方式的修改方法。", 
            "title": "更新数据"
        }, 
        {
            "location": "/data/android/develop_doc/#_15", 
            "text": "很多应用可能会有计数器功能的需求，比如文章点赞的功能，如果大量用户并发操作，用普通的更新方法操作的话，会存在数据不一致的情况。  为此，Bmob提供了原子计数器来保证原子性的修改某一 数值字段 的值。注意：原子计数器只能对应用于Web后台的Number类型的字段，即JavaBeans数据对象中的Integer对象类型（ 不要用int类型 ）。  gameScore.increment( score ); // 分数递增1\ngameScore.update(updateListener);  您还可以通过 increment(key, amount) 方法来递增或递减任意幅度的数字  gameScore.increment( score , 5); // 分数递增5\n//gameScore.increment( score , -5); // 分数递减5\ngameScore.update(updateListener);", 
            "title": "原子计数器"
        }, 
        {
            "location": "/data/android/develop_doc/#_16", 
            "text": "从服务器删除对象。例如：将GameScore表中objectId为 dd8e6aff28 的数据删除。  GameScore gameScore = new GameScore();\ngameScore.setObjectId( dd8e6aff28 );\ngameScore.delete(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});  注意：删除数据只能通过objectId来删除，目前不提供查询条件方式的删除方法。", 
            "title": "删除数据"
        }, 
        {
            "location": "/data/android/develop_doc/#_17", 
            "text": "你可以在一个对象中删除一个字段的值，通过 remove 操作：  GameScore gameScore = new GameScore();\ngameScore.setObjectId( dd8e6aff28 );\ngameScore.remove( score );  // 删除GameScore对象中的score字段\ngameScore.update(new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});", 
            "title": "删除字段的值"
        }, 
        {
            "location": "/data/android/develop_doc/#_18", 
            "text": "自2017年04月起，为了提供更稳定的服务，后端启用了QPS限制，所以推荐采用批量数据操作来解决如果需要在循环里多次提交请求但是后端返回QPS达到限制的报错。  自 v3.5.0 开始,新增 BmobBatch 批量操作类， 支持批量添加、批量更新、批量删除的三种操作的同步提交 ，且批量添加的请求返回objectId字段。  在BmobObject对象中提供了三种用于批量操作的方法，分别是 insertBatch 、 updateBatch 、 deleteBatch ,批量添加、更新、删除。", 
            "title": "批量数据操作"
        }, 
        {
            "location": "/data/android/develop_doc/#_19", 
            "text": "List BmobObject  persons = new ArrayList BmobObject ();\nfor (int i = 0; i   3; i++) {\n    Person person = new Person();\n    person.setName( 张三  +i);\n    persons.add(person);\n}\n//第一种方式:v3.5.0之前的版本\nnew BmobObject().insertBatch(this, persons, new SaveListener() {\n    @Override\n    public void onSuccess() {\n        toast( 批量添加成功 );\n    }\n    @Override\n    public void onFailure(int code, String msg) {\n        toast( 批量添加失败: +msg);\n    }\n});\n//第二种方式：v3.5.0开始提供\nnew BmobBatch().insertBatch(persons).doBatch(new QueryListListener BatchResult () {\n    @Override\n    public void done(List BatchResult  o, BmobException e) {\n        if(e==null){\n            for(int i=0;i o.size();i++){\n                BatchResult result = o.get(i);\n                BmobException ex =result.getError();\n                if(ex==null){\n                    log( 第 +i+ 个数据批量添加成功： +result.getCreatedAt()\n                    + , +result.getObjectId()+ , +result.getUpdatedAt());\n                }else{\n                    log( 第 +i+ 个数据批量添加失败： +ex.getMessage()+ , +ex.getErrorCode());\n                }\n            }\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});", 
            "title": "批量添加"
        }, 
        {
            "location": "/data/android/develop_doc/#_20", 
            "text": "List BmobObject  persons = new ArrayList BmobObject ();\nPerson p1 = new Person();\np1.setObjectId( e51d651c22 );\np1.setAge(25);\nPerson p2 = new Person();\np2.setObjectId( 3f70a922c4 );\np2.setAge(26);\np2.setGender(false);\nPerson p3 = new Person();\np3.setObjectId( 08fdd55765 );\np3.setAge(27);\n\npersons.add(p1);\npersons.add(p2);\npersons.add(p3);\n\n//第一种方式：v3.5.0之前的版本\nnew BmobObject().updateBatch(this, persons, new UpdateListener() {\n    @Override\n    public void onSuccess() {\n        toast( 批量更新成功 );\n    }\n    @Override\n    public void onFailure(int code, String msg) {\n        toast( 批量更新失败: +msg);\n    }\n});\n\n//第二种方式：v3.5.0开始提供\nnew BmobBatch().updateBatch(persons).doBatch(new QueryListListener BatchResult () {\n\n    @Override\n    public void done(List BatchResult  o, BmobException e) {\n        if(e==null){\n            for(int i=0;i o.size();i++){\n                BatchResult result = o.get(i);\n                BmobException ex =result.getError();\n                if(ex==null){\n                    log( 第 +i+ 个数据批量更新成功： +result.getUpdatedAt());\n                }else{\n                    log( 第 +i+ 个数据批量更新失败： +ex.getMessage()+ , +ex.getErrorCode());\n                }\n            }\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});", 
            "title": "批量更新"
        }, 
        {
            "location": "/data/android/develop_doc/#_21", 
            "text": "List BmobObject  persons = new ArrayList BmobObject ();\nPerson p1 = new Person();\np1.setObjectId( 38ea274d0c );\nPerson p2 = new Person();\np2.setObjectId( 01e29165bc );\nPerson p3 = new Person();\np3.setObjectId( d8226c4828 );\n\npersons.add(p1);\npersons.add(p2);\npersons.add(p3);\n//第一种方式：v3.5.0之前的版本\nnew BmobObject().deleteBatch(this, persons, new DeleteListener() {\n    @Override\n    public void onSuccess() {\n        toast( 批量删除成功 );\n    }\n    @Override\n    public void onFailure(int code, String msg) {\n        toast( 批量删除失败: +msg);\n    }\n});\n\n//第二种方式：v3.5.0开始提供\nnew BmobBatch().deleteBatch(persons).doBatch(new QueryListListener BatchResult () {\n\n            @Override\n            public void done(List BatchResult  o, BmobException e) {\n                if(e==null){\n                    for(int i=0;i o.size();i++){\n                        BatchResult result = o.get(i);\n                        BmobException ex =result.getError();\n                        if(ex==null){\n                            log( 第 +i+ 个数据批量删除成功 );\n                        }else{\n                            log( 第 +i+ 个数据批量删除失败： +ex.getMessage()+ , +ex.getErrorCode());\n                        }\n                    }\n                }else{\n                    Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n                }\n            }\n        });", 
            "title": "批量删除"
        }, 
        {
            "location": "/data/android/develop_doc/#v350", 
            "text": "BmobBatch batch =new BmobBatch();\n//批量添加\nList BmobObject  persons = new ArrayList BmobObject ();\nPerson person = new Person();\nperson.setName( 张三  );\npersons.add(person);\nbatch.insertBatch(persons);\n\n//批量更新\nList BmobObject  persons1=new ArrayList BmobObject ();\nPerson p1 = new Person();\np1.setObjectId( 3388eb6caf );\np1.setAge(35);\npersons1.add(p1);\nbatch.updateBatch(persons1);\n\n//批量删除\nList BmobObject  persons2 = new ArrayList BmobObject ();\nPerson p2 = new Person();\np2.setObjectId( 9af452ebd );\npersons2.add(p2);\nbatch.deleteBatch(persons2);\n//执行批量操作\nbatch.doBatch(new QueryListListener BatchResult (){\n\n    @Override\n    public void done(List BatchResult  results, BmobException ex) {\n        if(ex==null){\n            //返回结果的results和上面提交的顺序是一样的，请一一对应\n            for(int i=0;i results.size();i++){\n                BatchResult result= results.get(i);\n                if(result.isSuccess()){//只有批量添加才返回objectId\n                    log( 第 +i+ 个成功： +result.getObjectId()+ , +result.getUpdatedAt());\n                }else{\n                    BmobException error= result.getError();\n                    log( 第 +i+ 个失败： +error.getErrorCode()+ , +error.getMessage());\n                }\n            }\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});  注：   批量操作每次只支持最大50条记录的操作。  批量操作不支持对User表的操作。", 
            "title": "批量添加、批量更新、批量删除同步提交（v3.5.0开始提供）"
        }, 
        {
            "location": "/data/android/develop_doc/#_22", 
            "text": "数据的查询可能是每个应用都会频繁使用到的，BmobSDK中提供了 BmobQuery 类，它提供了多样的方法来实现不同条件的查询，同时它的使用也是非常的简单和方便的。", 
            "title": "查询数据"
        }, 
        {
            "location": "/data/android/develop_doc/#_23", 
            "text": "当我们知道某条数据的 objectId 时，就可以根据 objectId 直接获取单条数据对象。例如：查询 objectId 为 a203eba875 的人员信息。  BmobQuery GameScore  query = new BmobQuery GameScore ();\nquery.getObject( a203eba875 , new QueryListener GameScore () {\n\n    @Override\n    public void done(GameScore object, BmobException e) {\n        if(e==null){\n            //获得playerName的信息\n            object.getPlayerName();\n            //获得数据的objectId信息\n            object.getObjectId();\n            //获得createdAt数据创建时间（注意是：createdAt，不是createAt）\n            object.getCreatedAt();\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n\n});", 
            "title": "查询单条数据"
        }, 
        {
            "location": "/data/android/develop_doc/#_24", 
            "text": "查询某个数据表中的所有数据是非常简单的查询操作，例如：查询GameScore表中playerName为“比目”的50条数据记录。  BmobQuery GameScore  query = new BmobQuery GameScore ();\n//查询playerName叫“比目”的数据\nquery.addWhereEqualTo( playerName ,  比目 );\n//返回50条数据，如果不加上这条语句，默认返回10条数据\nquery.setLimit(50);\n//执行查询方法\nquery.findObjects(new FindListener GameScore () {\n    @Override\n    public void done(List GameScore  object, BmobException e) {\n        if(e==null){\n            toast( 查询成功：共 +object.size()+ 条数据。 );\n            for (GameScore gameScore : object) {\n               //获得playerName的信息\n               gameScore.getPlayerName();\n               //获得数据的objectId信息\n               gameScore.getObjectId();\n               //获得createdAt数据创建时间（注意是：createdAt，不是createAt）\n               gameScore.getCreatedAt();\n            }\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});  查询的结果不需要进行任何处理，BmobSDK已经为你封装成相应的JavaBean集合了，你直接使用即可。  注：    通过setLimit方法设置返回的记录数量。更多细节可查看下一节(查询条件)中的分页查询。    v3.5.2开始可以对查询条件等提供链式调用的写法，如下：    BmobQuery Book  query = new BmobQuery ();\nquery.setLimit(8).setSkip(1).order( -createdAt )\n        .findObjects(new FindListener Book () {\n            @Override\n            public void done(List Book  object, BmobException e) {\n                if (e == null) {\n                    // ...\n                } else {\n                    // ...\n                }\n            }\n        });", 
            "title": "查询多条数据"
        }, 
        {
            "location": "/data/android/develop_doc/#_25", 
            "text": "在查询的使用过程中，基于不同条件的查询是非常常见的，BmobQuery同样也支持不同条件的查询。", 
            "title": "查询条件"
        }, 
        {
            "location": "/data/android/develop_doc/#_26", 
            "text": "如果要查询特定键的特定值，可以使用 addWhereEqualTo 方法，如果要过滤掉特定键的值可以使用 addWhereNotEqualTo 方法。  比如需要查询playerName不等于“Barbie”的数据时可以这样写：  query.addWhereNotEqualTo( playerName ,  Barbie );  当然，你可以在你的查询操作中添加多个约束条件，来查询符合要求的数据。  query.addWhereNotEqualTo( playerName ,  Barbie );     //名字不等于Barbie\nquery.addWhereGreaterThan( score , 60);               //条件：分数大于60岁  各种不同条件的比较查询：  // 分数   50\nquery.addWhereLessThan( score , 50);\n//分数  = 50\nquery.addWhereLessThanOrEqualTo( score , 50);\n//分数   50\nquery.addWhereGreaterThan( score , 50);\n//分数  = 50\nquery.addWhereGreaterThanOrEqualTo( score , 50);", 
            "title": "比较查询"
        }, 
        {
            "location": "/data/android/develop_doc/#_27", 
            "text": "如果你想查询匹配几个不同值的数据，如：要查询“Barbie”,“Joe”,“Julia”三个人的成绩时，你可以使用 addWhereContainedIn 方法来实现。  String[] names = { Barbie ,  Joe ,  Julia };\nquery.addWhereContainedIn( playerName , Arrays.asList(names));  相反，如果你想查询排除“Barbie”,“Joe”,“Julia”这三个人的其他同学的信息，你可以使用 addWhereNotContainedIn 方法来实现。  String[] names = { Barbie ,  Joe ,  Julia };\nquery.addWhereNotContainedIn( playerName , Arrays.asList(names));", 
            "title": "子查询"
        }, 
        {
            "location": "/data/android/develop_doc/#_28", 
            "text": "时间查询 比较特殊，我们需要结合 BmobDate 这个类来查询某个指定日期时间前后的数据，这里也给出示例供大家参考：  比如:  如果想查询指定日期之前的数据，则可以使用 addWhereLessThan 或者 addWhereLessThanOrEqualTo （包含当天）来查询。  如果想查询指定日期之后的数据，则可以使用 addWhereGreaterThan 或 addWhereGreaterThanOrEqualTo （包含当天）来查询。  如果想查询指定时间当天的数据，则需要使用 复合与查询 来查询，例如，想 查询2015年5月1号当天的Person数据 ,示例代码如下：  BmobQuery Person  query = new BmobQuery Person ();\nList BmobQuery Person  and = new ArrayList BmobQuery Person ();\n//大于00：00：00\nBmobQuery Person  q1 = new BmobQuery Person ();\nString start =  2015-05-01 00:00:00 ;  \nSimpleDateFormat sdf = new SimpleDateFormat( yyyy-MM-dd HH:mm:ss );  \nDate date  = null;\ntry {\ndate = sdf.parse(start);\n} catch (ParseException e) {\ne.printStackTrace();\n}  \nq1.addWhereGreaterThanOrEqualTo( createdAt ,new BmobDate(date));\nand.add(q1);\n//小于23：59：59\nBmobQuery Person  q2 = new BmobQuery Person ();\nString end =  2015-05-01 23:59:59 ; \nSimpleDateFormat sdf1 = new SimpleDateFormat( yyyy-MM-dd HH:mm:ss );  \nDate date1  = null;\ntry {\ndate1 = sdf1.parse(end);\n} catch (ParseException e) {\ne.printStackTrace();\n}  \nq2.addWhereLessThanOrEqualTo( createdAt ,new BmobDate(date1));\nand.add(q2);\n//添加复合与查询\nquery.and(and);  注：  由于createdAt、updatedAt是服务器自动生成的时间，在服务器保存的是精确到微秒值的时间，所以，基于时间类型的比较的值要加1秒。", 
            "title": "时间查询"
        }, 
        {
            "location": "/data/android/develop_doc/#_29", 
            "text": "对于字段类型为数组的情况，需要查找字段中的数组值包含有xxx的对象，可以使用 addWhereContainsAll 方法：  比如我想查询有阅读和唱歌爱好的人，可以这样：  BmobQuery Person  query = new BmobQuery Person ();\nString [] hobby = { 阅读 , 唱歌 };\nquery.addWhereContainsAll( hobby , Arrays.asList(hobby));\nquery.findObjects(new FindListener Person () {\n\n    @Override\n    public void done(List Person  object, BmobException e) {\n        if(e==null){\n            ...\n        }else{\n            ...\n        }\n    }\n\n});", 
            "title": "数组查询"
        }, 
        {
            "location": "/data/android/develop_doc/#_30", 
            "text": "对字符串值的模糊查询 比如 查询包含字符串的值，有几种方法。  你可以使用任何正确的正则表达式来检索相匹配的值，使用 addWhereMatches 方法：  query.addWhereMatches(( username ,  ^[A-Z]\\\\d );  还可以使用如下方法：  //查询username字段的值含有“sm”的数据\nquery.addWhereContains( username ,  sm );\n\n//查询username字段的值是以“sm“字开头的数据\nquery.whereStartsWith( username ,  sm );\n\n// 查询username字段的值是以“ile“字结尾的数据\nquery.whereEndsWith( username ,  ile );  注:模糊查询只对付费用户开放，付费后可直接使用。", 
            "title": "模糊查询"
        }, 
        {
            "location": "/data/android/develop_doc/#_31", 
            "text": "如果你想查询某个列的值存在，那么可以使用 addWhereExists 方法：  //查询username有值的数据\nquery.addWhereExists( username );  如果想查询某个列的值不存在，则可以用 addWhereDoesNotExists 方法  //查询username字段没有值的数据\nquery.addWhereDoesNotExists( username );", 
            "title": "列值是否存在"
        }, 
        {
            "location": "/data/android/develop_doc/#_32", 
            "text": "有时，在数据比较多的情况下，你希望查询出的符合要求的所有数据能按照多少条为一页来显示，这时可以使用 setLimit 方法来限制查询结果的数据条数来进行分页。  默认情况下，Limit的值为 100 ，最大有效设置值 1000 （设置的数值超过1000还是视为1000）。  query.setLimit(10); // 限制最多10条数据结果作为一页  在数据较多的情况下，在 setLimit 的基础上分页显示数据是比较合理的解决办法。 setSKip 方法可以做到跳过查询的前多少条数据来实现分页查询的功能。默认情况下Skip的值为10。  query.setSkip(10); // 忽略前10条数据（即第一页数据结果）  大家也可以直接下载我们提供的Demo源码（ https://github.com/bmob/bmob-android-demo-paging ），查看如何使用分页查询，结合ListView开发下拉刷新查看更多内容的应用。", 
            "title": "分页查询"
        }, 
        {
            "location": "/data/android/develop_doc/#_33", 
            "text": "对应数据的排序，如数字或字符串，你可以使用升序或降序的方式来控制查询数据的结果顺序：  // 根据score字段升序显示数据\nquery.order( score );\n// 根据score字段降序显示数据\nquery.order( -score );\n// 多个排序字段可以用（，）号分隔\nquery.order( -score,createdAt );  说明：多个字段排序时，先按第一个字段进行排序，再按第二个字段进行排序，依次进行。", 
            "title": "排序"
        }, 
        {
            "location": "/data/android/develop_doc/#_34", 
            "text": "", 
            "title": "复合查询"
        }, 
        {
            "location": "/data/android/develop_doc/#and", 
            "text": "有些查询需要使用到复合“与”的查询条件，例如：你想查询出Person表中年龄在6-29岁之间且姓名以\"y\"或者\"e\"结尾的人，那么，可以采用and查询，示例代码如下：  //查询年龄6-29岁之间的人，每一个查询条件都需要New一个BmobQuery对象\n//--and条件1\nBmobQuery Person  eq1 = new BmobQuery Person ();\neq1.addWhereLessThanOrEqualTo( age , 29);//年龄 =29\n//--and条件2\nBmobQuery Person  eq2 = new BmobQuery Person ();\neq2.addWhereGreaterThanOrEqualTo( age , 6);//年龄 =6\n\n//查询姓名以 y 或者 e 结尾的人--这个需要使用到复合或查询（or）\n//--and条件3\nBmobQuery Person  eq3 = new BmobQuery Person ();\neq3.addWhereEndsWith( name ,  y );\nBmobQuery Person  eq4 = new BmobQuery Person ();\neq4.addWhereEndsWith( name ,  e );\nList BmobQuery Person  queries = new ArrayList BmobQuery Person ();\nqueries.add(eq3);\nqueries.add(eq4);\nBmobQuery Person  mainQuery = new BmobQuery Person ();\nBmobQuery Person  or = mainQuery.or(queries);\n\n//最后组装完整的and条件\nList BmobQuery Person  andQuerys = new ArrayList BmobQuery Person ();\nandQuerys.add(eq1);\nandQuerys.add(eq2);\nandQuerys.add(or);\n//查询符合整个and条件的人\nBmobQuery Person  query = new BmobQuery Person ();\nquery.and(andQuerys);\nquery.findObjects(new FindListener Person () {\n    @Override\n    public void done(List Person  object, BmobException e) {\n        if(e==null){\n            toast( 查询年龄6-29岁之间，姓名以'y'或者'e'结尾的人个数： +object.size());\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});", 
            "title": "与查询(and)"
        }, 
        {
            "location": "/data/android/develop_doc/#or", 
            "text": "有些情况，在查询的时候需要使用到复合的“或”的查询条件。例如，你想查出 Person 表中 age 等于 29 或者 age 等于 6 的人，可以这样：  BmobQuery Person  eq1 = new BmobQuery Person ();\neq1.addWhereEqualTo( age , 29);\nBmobQuery Person  eq2 = new BmobQuery Person ();\neq2.addWhereEqualTo( age , 6);\nList BmobQuery Person  queries = new ArrayList BmobQuery Person ();\nqueries.add(eq1);\nqueries.add(eq2);\nBmobQuery Person  mainQuery = new BmobQuery Person ();\nmainQuery.or(queries);\nmainQuery.findObjects(new FindListener Person () {\n    @Override\n    public void done(List Person  object, BmobException e) {\n        if(e==null){\n            toast( 查询年龄6-29岁之间，姓名以'y'或者'e'结尾的人个数： +object.size());\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});  你还可以在此基础上添加更多的约束条件到新创建的 BmobQuery 对象上，表示一个 and 查询操作。", 
            "title": "或查询(or)"
        }, 
        {
            "location": "/data/android/develop_doc/#_35", 
            "text": "如果你只是想统计满足查询对象的数量，你并不需要获取所有匹配对象的具体数据信息，可以直接使用 count 替代 findObjects 。例如，查询一个特定玩家玩的游戏场数：  BmobQuery GameSauce  query = new BmobQuery GameSauce ();\nquery.addWhereEqualTo( playerName ,  Barbie );\nquery.count(GameSauce.class, new CountListener() {\n    @Override\n    public void done(Integer count, BmobException e) {\n        if(e==null){\n            toast( count对象个数为： +count);\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});", 
            "title": "查询结果计数"
        }, 
        {
            "location": "/data/android/develop_doc/#_36", 
            "text": "有的时候，一张表的数据列比较多，而我们只想查询返回某些列的数据时，我们可以使用BmobQuery对象提供的 addQueryKeys 方法来实现。如下所示：  //只返回Person表的objectId这列的值\nBmobQuery Person  bmobQuery = new BmobQuery Person ();\nbmobQuery.addQueryKeys( objectId );\nbmobQuery.findObjects(new FindListener Person () {\n    @Override\n    public void done(List Person  object, BmobException e) {\n        if(e==null){\n            toast( 查询成功：共  + object.size() +  条数据。 );\n            //注意：这里的Person对象中只有指定列的数据。\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});  指定多列时用 , 号分隔每列，如： addQueryKeys(\"objectId,name,age\") ;", 
            "title": "查询指定列"
        }, 
        {
            "location": "/data/android/develop_doc/#_37", 
            "text": "从 BmobSDKV3.3.6 开始，Bmob为开发者提供了以下关键字或其组合的统计查询操作,分别用于计算 总和、平均值、最大值、最小值 ，同时支持分组和过滤条件。     方法名  参数说明  方法说明      sum  String[] sumKeys（多个列名）  求某列或多列的和    average  String[] aveKeys（多个列名）  求某列或多列的平均值    max  String[] maxKeys（多个列名）  求某列或多列的最大值    min  String[] minKeys（多个列名）  求某列或多列的最小值    groupby  String[] groupKeys（多个列名）  分组    having  HashMap map(键（String）值(Object)对的形式)  分组的过滤条件    setHasGroupCount  boolean hasCount  是否返回每个分组的记录数     注：   为避免和用户创建的列名称冲突，Bmob约定以上查询返回的字段采用 _(关键字)+首字母大写的列名  的格式：   例：\n计算玩家得分表（GameScore）中列名为score的总和，那么返回的结果集会有一个列名为 _sumScore ，\n若设置了setHasGroupCount（true）,则结果集中会返回 _count 。    以上方法可自由组合且与之前的查询语句中的where, order, limit, skip等组合一起使用。     因为返回格式不固定，故使用 findStatistics 来专门处理统计查询。", 
            "title": "统计查询"
        }, 
        {
            "location": "/data/android/develop_doc/#_38", 
            "text": "例如，如果要计算所有玩家的得分总和，那么代码如下：  BmobQuery GameScore  query = new BmobQuery GameScore ();\nquery.sum(new String[] {  playScore  });\nquery.findStatistics(GameScore.class,new QueryListener JSONArray () {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if(ary!=null){//\n                try {\n                    JSONObject obj = ary.getJSONObject(0);\n                    int sum = obj.getInt( _sumPlayScore );//_(关键字)+首字母大写的列名\n                    showToast( 游戏总得分：  + sum);\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            }else{\n                showToast( 查询成功，无数据 );\n            }\n        }else{  \n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n\n});  注： sum方法的参数只能查询Number类型的列名（对应Java的Integer类型） ，即要计算哪个列的值的总和。  查询平均值、最大、最小和上面的求和类似，在这里也一并提示下：  BmobQuery GameScore  query = new BmobQuery GameScore ();\n//query.average(new String[]{ playScore });//查询某列的平均值\nquery.min(new String[]{ playScore });//查询最小值\n//query.max(new String[]{ playScore });//查询最大值\nquery.groupby(new String[]{ createdAt });\nquery.findStatistics(GameScore.class, new QueryListener JSONArray () {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            JSONArray ary = (JSONArray) result;\n            if (ary!=null) {\n                try {\n                    JSONObject obj = ary.getJSONObject(0);\n    //              int playscore = obj.getInt( _avgPlayScore );\n                    int minscore = obj.getInt( _minPlayScore );\n    //              int maxscore = obj.getInt( _maxPlayScore );\n                    String createDate = obj.getString( createdAt );\n                    showToast( minscore =   + minscore+  ,统计时间 =  + createDate);\n                } catch (JSONException e) {\n                    e.printStackTrace();\n                }\n        } else {\n            showToast( 查询成功，无数据 );\n        }\n        }else{\n            loge(e);\n        }\n    }\n});", 
            "title": "统计查询方法"
        }, 
        {
            "location": "/data/android/develop_doc/#_39", 
            "text": "如果你需要对查询结果进行分组，可使用 groupby 方法，支持根据多个列名进行分组。  //我们以创建时间按天和游戏分别统计玩家的得分，并按时间降序\nBmobQuery GameScore  query = new BmobQuery GameScore ();\nquery.sum(new String[] {  playScore ,  signScore  });//求多个列的总和\nquery.groupby(new String[] {  createdAt ,  game  });//按照时间和游戏名进行分组\nquery.order( -createdAt );//降序排列\nquery.findStatistics(GameScore.class,new QueryListener JSONArray () {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if(ary!=null){\n                int length = ary.length();\n                try {\n                    for (int i = 0; i   length; i++) {\n                        JSONObject obj = ary.getJSONObject(i);\n                        int playscore = obj.getInt( _sumPlayScore );\n                        int signscore = obj.getInt( _sumSignScore );\n                        String createDate = obj.getString( createdAt );\n                        String game = obj.getString( game );\n                        showToast( 游戏总得分：  + playscore +  ,签到得分： \n                                + signscore +  ,时间:  + createDate+ ,game: +game);\n                    }\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            } else {\n                showToast( 查询成功，无数据 );\n            }\n        }else{\n            loge(e);\n        }\n    }\n});  有时候，我们需要知道分组统计时每个分组有多少条记录，可使用 setHasGroupCount（true） ,如下：  // 查询创建时间按天统计所有玩家的得分和每一天有多少条玩家的得分记录，并按时间降序:\nBmobQuery GameScore  query = new BmobQuery GameScore ();\nquery.sum(new String[] {  playScore  });    // 统计总得分\nquery.groupby(new String[] {  createdAt  });// 按照时间分组\nquery.order( -createdAt );                  // 降序排列\nquery.setHasGroupCount(true);              // 统计每一天有多少个玩家的得分记录，默认不返回分组个数\nquery.findStatistics(GameScore.class,new QueryListener JSONArray () {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if (ary!=null) {\n                int length = ary.length();\n                try {\n                    for (int i = 0; i   length; i++) {\n                        JSONObject obj = ary.getJSONObject(i);\n                        int playscore = obj.getInt( _sumPlayScore );\n                        String createDate = obj.getString( createdAt );\n                        int count = obj.getInt( _count );//setHasGroupCount设置为true时，返回的结果中含有 _count 字段\n                        showToast( 游戏总得分：  + playscore +  ,总共统计了 \n                                + count +  条记录,统计时间 =  + createDate);\n                    }\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            } else {\n                showToast( 查询成功，无数据 );\n            }\n        }else{\n            loge(e);\n        }\n    }\n});", 
            "title": "分组统计"
        }, 
        {
            "location": "/data/android/develop_doc/#_40", 
            "text": "如果需要对分组计算后的结果再进行过滤，可使用 having 来继续过滤部分结果。  //我们按游戏名统计所有玩家的总得分，并只返回总得分大于100的记录，并按时间降序\nBmobQuery GameScore  query = new BmobQuery GameScore ();\nquery.sum(new String[] { playScore });//计算总得分数\nquery.groupby(new String[] { game });//分组条件：按游戏名进行分组\nquery.order( -createdAt );// 降序排列\nHashMap String, Object  map = new HashMap String, Object ();\nJSONObject js = new JSONObject();\ntry {\n    js.put( $gt , 100);\n} catch (JSONException e1) {\n}\nmap.put( _sumPlayScore , js);//过滤条件：总得分数大于100\nquery.having(map);\nquery.setLimit(100);\nquery.findStatistics(GameScore.class,new QueryListener JSONArray () {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if(ary!=null){\n                int length = ary.length();\n                try {\n                    for (int i = 0; i   length; i++) {\n                        JSONObject obj = ary.getJSONObject(i);\n                        int playscore = obj.getInt( _sumPlayScore );//过滤条件的key是什么，返回的数据中就有什么\n                        String game = obj.getString( game );//返回的数据中同样包含groupby里面的列名\n                        showToast( 游戏得分：  + playscore +  ,游戏名 =  + game);\n                    }\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            } else {\n                showToast( 查询成功，无数据 );\n            }\n        }else{\n            loge(e);\n        }\n    }\n\n});", 
            "title": "添加过滤条件"
        }, 
        {
            "location": "/data/android/develop_doc/#_41", 
            "text": "缓存查询通常是将查询结果缓存在磁盘上。\n当用户的设备处于离线状态时，就可以从缓存中获取数据来显示。\n或者在应用界面刚刚启动，从网络获取数据还未得到结果时，先使用缓存数据来显示。\n这样可以让用户不必在按下某个按钮后进行枯燥的等待。\n默认的查询操作是没有启用缓存的，开发者可以使用 setCachePolicy 方法来启用缓存功能。\n例如：优先从缓存获取数据，如果获取失败再从网络获取数据。  bmobQuery.setCachePolicy(CachePolicy.CACHE_ELSE_NETWORK);   // 先从缓存获取数据，如果没有，再从网络获取。\nbmobQuery.findObjects(new FindListener Person () {\n    @Override\n    public void done(List Person  object,BmobException e) {\n        if(e==null){\n            toast( 查询成功：共 +object.size()+ 条数据。 );\n        }else{\n            toast( 查询失败： +msg);\n        }\n    }\n\n});", 
            "title": "缓存查询"
        }, 
        {
            "location": "/data/android/develop_doc/#_42", 
            "text": "Bmob SDK提供了几种不同的缓存策略，以适应不同应用场景的需求：   IGNORE_CACHE      :只从网络获取数据，且不会将数据缓存在本地，这是默认的缓存策略。  CACHE_ONLY         :只从缓存读取数据，如果缓存没有数据会导致一个BmobException,可以忽略不处理这个BmobException.  NETWORK_ONLY       :只从网络获取数据，同时会在本地缓存数据。  NETWORK_ELSE_CACHE :先从网络读取数据，如果没有，再从缓存中获取。  CACHE_ELSE_NETWORK :先从缓存读取数据，如果没有，再从网络获取。  CACHE_THEN_NETWORK :先从缓存取数据，无论结果如何都会再次从网络获取数据。也就是说会产生2次调用。   建议的做法：  第一次进入应用的时候，设置其查询的缓存策略为 CACHE_ELSE_NETWORK ,当用户执行上拉或者下拉刷新操作时，设置查询的缓存策略为 NETWORK_ELSE_CACHE 。", 
            "title": "缓存策略"
        }, 
        {
            "location": "/data/android/develop_doc/#_43", 
            "text": "如果需要操作缓存内容，可以使用BmobQuery提供的方法做如下操作：   检查是否存在当前查询条件的缓存数据   boolean isInCache = query.hasCachedResult(Class ?  clazz);  注：缓存和查询条件有关，此方法必须放在所有的查询条件（where、limit、order、skip、include等）都设置完之后，否则会得不到缓存数据。   清除当前查询的缓存数据   query.clearCachedResult(Class ?  clazz);   清除所有查询结果的缓存数据   BmobQuery.clearAllCachedResults(Class ?  clazz);   设置缓存的最长时间（以毫秒为单位）   query.setMaxCacheAge(TimeUnit.DAYS.toMillis(1));//此表示缓存一天  示例如下：  BmobQuery Person  query  = new BmobQuery Person ();\nquery.addWhereEqualTo( age , 25);\nquery.setLimit(10);\nquery.order( createdAt );\n//判断是否有缓存，该方法必须放在查询条件（如果有的话）都设置完之后再来调用才有效，就像这里一样。\nboolean isCache = query.hasCachedResult(Person.class);\nif(isCache){--此为举个例子，并不一定按这种方式来设置缓存策略\n    query.setCachePolicy(CachePolicy.CACHE_ELSE_NETWORK);   // 如果有缓存的话，则设置策略为CACHE_ELSE_NETWORK\n}else{\n    query.setCachePolicy(CachePolicy.NETWORK_ELSE_CACHE);   // 如果没有缓存的话，则设置策略为NETWORK_ELSE_CACHE\n}\nquery.findObjects(new FindListener Person () {\n\n    @Override\n    public void done(List Person  object,BmobException e) {\n        if(e==null){\n            toast( 查询成功：共 +object.size()+ 条数据。 );\n        }else{\n            toast( 查询失败： +msg);\n        }\n    }\n});  注：  1、只有当缓存查询的条件一模一样时才会获取到缓存到本地的缓存数据。  2、设置的默认的最大缓存时长为5小时。", 
            "title": "缓存方法"
        }, 
        {
            "location": "/data/android/develop_doc/#bql", 
            "text": "Bmob Query Language （简称 BQL） 是 Bmob 自  BmobSDKV3.3.7  版本开始，为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 Bmob 查询API 的成本，可以使用传统的 SQL 语法来查询 Bmob 应用内的数据。   具体的 BQL 语法，请参考  Bmob Query Language 详细指南 。", 
            "title": "BQL查询"
        }, 
        {
            "location": "/data/android/develop_doc/#bql_1", 
            "text": "可以通过以下方法来进行SQL查询：\n例如：需要查询所有的游戏得分记录  String bql = select * from GameScore ;//查询所有的游戏得分记录\nnew BmobQuery GameScore ().doSQLQuery(bql,new SQLQueryListener GameScore (){\n\n    @Override\n    public void done(BmobQueryResult GameScore  result, BmobException e) {\n        if(e ==null){\n            List GameScore  list = (List GameScore ) result.getResults();\n            if(list!=null   list.size() 0){\n                ...\n            }else{\n                Log.i( smile ,  查询成功，无数据返回 );\n            }\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n});  上面的示例也等价于( 此方法自BmobV3.3.8版本提供 )：  //查询所有的游戏得分记录\nString bql = select * from GameScore ;\nBmobQuery GameScore  query=new BmobQuery GameScore ();\n//设置查询的SQL语句\nquery.setSQL(bql);\nquery.doSQLQuery(new SQLQueryListener GameScore (){\n\n    @Override\n    public void done(BmobQueryResult GameScore  result, BmobException e) {\n        if(e ==null){\n            List GameScore  list = (List GameScore ) result.getResults();\n            if(list!=null   list.size() 0){\n                ...\n            }else{\n                Log.i( smile ,  查询成功，无数据返回 );\n            }\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n});  如果需要查询个数，则可以这样：  String bql =  select count(*),* from GameScore ;//查询GameScore表中总记录数并返回所有记录信息\nnew BmobQuery GameScore ().doSQLQuery(bql, new SQLQueryListener GameScore (){\n\n    @Override\n    public void done(BmobQueryResult GameScore  result, BmobException e) {\n        if(e ==null){\n            int count = result.getCount();//这里得到符合条件的记录数\n            List GameScore  list = (List GameScore ) result.getResults();\n            if(list.size() 0){\n                ...\n            }else{\n                Log.i( smile ,  查询成功，无数据 );\n            }\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n});  注：当查询的表为系统表（目前系统表有User、Installation、Role）时，需要带上下划线  _ 。  比如，你想查询的是用户 smile 的信息，则：  select * from _User where username = smile", 
            "title": "基本BQL查询"
        }, 
        {
            "location": "/data/android/develop_doc/#bql_2", 
            "text": "由于统计查询的结果是不定的，故BQL提供了另外一种查询方法来进行统计查询，可以使用 doStatisticQuery 方法来进行：  //按照姓名分组求和,并将结果按时间降序排列\nString bql =  select sum(playScore) from GameScore group by name order by -createdAt ;\nnew BmobQuery GameScore ().doStatisticQuery(bql,new QueryListener JSONArray (){\n\n    @Override\n    public void done(Object result, BmobException e) {\n        if(e ==null){\n            JSONArray ary = (JSONArray) result;\n            if(ary!=null){//开发者需要根据返回结果自行解析数据\n                ...\n            }else{\n                showToast( 查询成功，无数据 );\n            }\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n});", 
            "title": "统计BQL查询"
        }, 
        {
            "location": "/data/android/develop_doc/#_44", 
            "text": "在更多的时候，一个查询语句中间会有很多的值是可变值，为此，我们也提供了类似 Java JDBC 里的  PreparedStatement  使用占位符查询的语法结构。", 
            "title": "占位符查询"
        }, 
        {
            "location": "/data/android/develop_doc/#_45", 
            "text": "String bql= select * from GameScore where player = ? and game = ? ;//查询玩家1的地铁跑酷的GameScore信息\nnew BmobQuery GameScore ().doSQLQuery(bql,new SQLQueryListener GameScore (){\n\n    @Override\n    public void done(BmobQueryResult GameScore  result, BmobException e) {\n        if(e ==null){\n            List GameScore  list = (List GameScore ) result.getResults();\n            if(list!=null   list.size() 0){\n                ...\n            }else{\n                Log.i( smile ,  查询成功，无数据返回 );\n            }\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n}, 玩家1 , 地铁跑酷 );  最后的可变参数  玩家1  和  地铁跑酷  会自动替换查询语句中的问号位置（按照问号的先后出现顺序）。  上面的示例也等价于如下代码（ 此方法自BmobV3.3.8版本提供 ）：  String bql= select * from GameScore where player = ? and game = ? ;\nBmobQuery GameScore  query=new BmobQuery GameScore ();\n//设置SQL语句\nquery.setSQL(bql);\n//设置占位符参数\nquery.setPreparedParams(new Object[]{ 玩家1 , 地铁跑酷 });\nquery.doSQLQuery(new SQLQueryListener GameScore (){\n\n    @Override\n    public void done(BmobQueryResult GameScore  result, BmobException e) {\n        if(e ==null){\n            List GameScore  list = (List GameScore ) result.getResults();\n            if(list!=null   list.size() 0){\n                ...\n            }else{\n                Log.i( smile ,  查询成功，无数据返回 );\n            }\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n});", 
            "title": "普通查询"
        }, 
        {
            "location": "/data/android/develop_doc/#_46", 
            "text": "对于包含 内置函数 的占位符查询，比较特殊，请使用 Bmob Query Language 详细指南 中的 内置函数 中 占位符查询用到的内置函数 列出的形式进行查询操作：  举例：我想查询当前用户在2015年5月12日之后，在特定地理位置附近的游戏记录，可以这样：  String sql =  select * from GameScore where createdAt   date(?) and player = pointer(?,?) and gps near geopoint(?,?) ;\nnew BmobQuery GameScore ().doSQLQuery(sql,new SQLQueryListener GameScore (){\n\n    @Override\n    public void done(BmobQueryResult GameScore  result, BmobException e) {\n        if(e ==null){\n            List GameScore  list = (List GameScore ) result.getResults();\n            if(list!=null   list.size() 0){\n                ...\n            }else{\n                Log.i( smile ,  查询成功，无数据返回 );\n            }\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n}, 2015-05-12 00:00:00 , _User ,user.getObjectId(),112.934755,24.52065);  注  1、我们更推荐使用占位符语法，理论上会降低 BQL 转换的性能开销；  2、最后的可变参数会自动替换查询语句中的问号位置（按照问号的先后出现顺序），有多少个问号，最后的可变参数就应该有多少个；  3、同样的，统计查询也支持占位符,只需要将 doSQLQuery 替换成 doStatisticQuery 方法即可；  4、只有查询条件 where``limit 子句支持占位符查询，和统计查询有关的 group by 、 order by 、 having 等字句是不支持占位符的。  例如： 正确 查询：  //按照游戏名进行分组并获取总得分数大于200的统计信息，同时统计各分组的记录数\nString bql =  select sum(playScore),count(*) from GameScore group by game having _sumPlayScore 200 ;\nnew BmobQuery GameScore ().doStatisticQuery(bql,new StatisticQueryListener(){\n\n    @Override\n    public void done(Object result, BmobException e) {\n        ...\n    }\n});  错误 查询：  String bql =  select sum(playScore),count(*) from GameScore group by ? having ? ;\nnew BmobQuery GameScore ().doStatisticQuery(bql,new StatisticQueryListener(){\n\n    @Override\n    public void done(Object result, BmobException e) {\n        ...\n    }\n}, game , _sumPlayScore 200 );", 
            "title": "内置函数"
        }, 
        {
            "location": "/data/android/develop_doc/#bql_3", 
            "text": "BQL查询同步支持 缓存查询 ，只需要调用BmobQuery的 setCachePolicy 方法设置缓存策略即可， 建议使用如下方式进行BQL缓存查询 ：  String sql =  select * from GameScore order by playScore,signScore desc ;\nBmobQuery GameScore  query = new BmobQuery GameScore ();\n//设置sql语句\nquery.setSQL(sql);\n//判断此查询本地是否存在缓存数据\nboolean isCache = query.hasCachedResult(GameScore.class);\nif(isCache){\n    query.setCachePolicy(CachePolicy.CACHE_ELSE_NETWORK);   // 如果有缓存的话，则设置策略为CACHE_ELSE_NETWORK\n}else{\n    query.setCachePolicy(CachePolicy.NETWORK_ELSE_CACHE);   // 如果没有缓存的话，则设置策略为NETWORK_ELSE_CACHE\n}\nquery.doSQLQuery(new SQLQueryListener GameScore (){\n\n    @Override\n    public void done(BmobQueryResult GameScore  result, BmobException e) {\n        if(e ==null){\n            Log.i( smile ,  查询到： +result.getResults().size()+ 符合条件的数据 );\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n});  注：  doSQLQuery目前有三种查询方式进行SQL查询，分别是：  1、doSQLQuery（Context context,SQLQueryListener  listener)  2、doSQLQuery（Context context, String bql, SQLQueryListener  listener)----基本BQL查询  3、doSQLQuery（Context context, String bql, SQLQueryListener  listener,Object... params)----占位符查询  只有 第一种查询方式 才能和 query.hasCachedResult(context,class) 或者 query.clearCachedResult(context,class) 并列使用。  建议使用 第一种查询方式 进行BQL缓存查询。", 
            "title": "BQL缓存查询"
        }, 
        {
            "location": "/data/android/develop_doc/#_47", 
            "text": "对于数组类型数据，BmobSDK提供了3种操作来原子性地修改一个数组字段的值：   add、addAll  在一个数组字段的后面添加一些指定的对象(包装在一个数组内)  addUnique、addAllUnique  只会在原本数组字段中没有这些对象的情形下才会添加入数组，插入数组的位置随机  removeAll  从一个数组字段的值内移除指定数组中的所有对象   举例子：  public class Person extends BmobObject {\n    private List String  hobbys;        // 爱好-对应服务端Array类型：String类型的集合\n    private List BankCard  cards;       // 银行卡-对应服务端Array类型:Object类型的集合\n    ...\n    getter、setter方法\n}\n\n其中BankCard类结构如下：\npublic class BankCard{\n    private String cardNumber;\n    private String bankName;\n    public BankCard(String bankName, String cardNumber){\n        this.bankName = bankName;\n        this.cardNumber = cardNumber;\n    }\n    ...\n    getter、setter方法\n}", 
            "title": "数组"
        }, 
        {
            "location": "/data/android/develop_doc/#_48", 
            "text": "给 Person 对象中的数组类型字段添加数据,有以下两种方式：", 
            "title": "添加数组数据"
        }, 
        {
            "location": "/data/android/develop_doc/#addaddall", 
            "text": "Person p = new Person();\np.setObjectId( d32143db92 );\n//添加String类型的数组\np.add( hobbys ,  唱歌 );                              // 添加单个String\n//p.addAll( hobbys , Arrays.asList( 游泳 ,  看书 ));    // 添加多个String\n//添加Object类型的数组\np.add( cards ,new BankCard( 工行卡 ,  工行卡账号 ))   //添加单个Object\nList BankCard  cards =new ArrayList BankCard ();\nfor(int i=0;i 2;i++){\n    cards.add(new BankCard( 建行卡 +i,  建行卡账号 +i));\n}\n//p.addAll( cards , cards);                         //添加多个Object值\np.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 保存成功 );\n        }else{\n            Log.i( bmob , 保存失败： +e.getMessage());\n        }\n    }\n\n});   注：此类方法不管这些数据之前是否已添加过，都会再次添加。", 
            "title": "使用add、addAll添加"
        }, 
        {
            "location": "/data/android/develop_doc/#adduniqueaddallunique", 
            "text": "Person p = new Person();\n//添加String类型的数组\np.addUnique( hobbys ,  唱歌 );                                // 添加单个String\n//p.addAllUnique( hobbys , Arrays.asList( 游泳 ,  看书 ));  // 添加多个String\n//添加Object类型的数组\np.addUnique( cards ,new BankCard( 工行卡 ,  工行卡账号 ))     //添加单个Object\nList BankCard  cards =new ArrayList BankCard ();\nfor(int i=0;i 2;i++){\n    cards.add(new BankCard( 建行卡 +i,  建行卡账号 +i));\n}\n//p.addAllUnique( cards , cards);                           //添加多个Object\np.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功: +objectId);\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});   注： 只有在这些数据之前未添加过的情况下才会被添加。", 
            "title": "使用addUnique、addAllUnique添加"
        }, 
        {
            "location": "/data/android/develop_doc/#_49", 
            "text": "数组更新比较特殊，自 V3.4.4 版本开始提供 BmobObject 的 setValue 方法来更新数组，例：  Person p2 = new Person();\n//更新String类型数组中的值\np2.setValue( hobbys.0 , 爬山 );                             //将hobbys中第一个位置的爱好（上面添加成功的唱歌）修改为爬山\n//更新Object类型数组中的某个位置的对象值(0对应集合中第一个元素)\np2.setValue( cards.0 , new BankCard( 中行 ,  中行卡号 ));    //将cards中第一个位置银行卡修改为指定BankCard对象\n//更新Object类型数组中指定对象的指定字段的值\n//  p2.setValue( cards.0.bankName ,  农行卡 );             //将cards中第一个位置的银行卡名称修改为农行卡\n//  p2.setValue( cards.1.cardNumber ,  农行卡账号 );         //将cards中第二个位置的银行卡账号修改为农行卡账号\np2.update(objectId, new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n});", 
            "title": "更新数组数据"
        }, 
        {
            "location": "/data/android/develop_doc/#_50", 
            "text": "同理我们也可以使用removeAll从数组字段中移除某些值：  Person p = new Person();\np.removeAll( hobby , Arrays.asList( 阅读 , 唱歌 , 游泳 ));\np.update(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n});", 
            "title": "删除数组数据"
        }, 
        {
            "location": "/data/android/develop_doc/#_51", 
            "text": "对于字段类型为数组的情况，可以以数组字段中包含有xxx的数据为条件进行查询：  BmobQuery Person  query = new BmobQuery Person ();\nString [] hobby = { 阅读 , 唱歌 };\nquery.addWhereContainsAll( hobby , Arrays.asList(hobby));\nquery.findObjects(new FindListener Person () {\n\n    @Override\n    public void done(List Person  object,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 查询成功：共  + object.size() +  条数据。 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});", 
            "title": "查询数组数据"
        }, 
        {
            "location": "/data/android/develop_doc/#_52", 
            "text": "", 
            "title": "数据关联性"
        }, 
        {
            "location": "/data/android/develop_doc/#_53", 
            "text": "在程序设计中，不同类型的数据之间可能存在某种关系。\n比如：帖子和作者的关系，一篇帖子只属于某个作者，这是 一对一的关系 。\n比如：帖子和评论的关系，一条评论只属于某一篇帖子，而一篇帖子对应有很多条评论，这是 一对多的关系 。\n比如：学生和课程的关系，一个学生可以选择很多课程，一个课程也可以被很多学生所选择，这是 多对多的关系 。  Bmob提供了 Pointer（一对一、一对多） 和 Relation（多对多） 两种数据类型来解决这种业务需求。", 
            "title": "关联关系描述"
        }, 
        {
            "location": "/data/android/develop_doc/#_54", 
            "text": "由于关联关系讲解起来比较复杂，以下用一个简单的案例来说明在Bmob中是如何使用关联关系的。  场景： 用户发表帖子，同时又可对帖子进行评论留言。  在这个场景中涉及到三个表：用户表（ _User ）、帖子表（ Post ）、评论表（ Comment ）,以下是各个表的字段：  _User 字段如下：     字段  类型  含义      objectId  String  用户ID    username  String  用户名(可以既发帖子又发评论)    age  Integer  年龄     Post 字段如下：     字段  含义  类型      objectId  String  帖子ID    title  String  帖子标题    content  String  帖子内容    author  Pointer  帖子作者    likes  Relation  喜欢帖子的读者     Comment 字段如下：     字段  含义  类型      objectId  String  评论ID    content  String  评论内容    post  Pointer  评论对应的帖子    author  Pointer  评论该帖子的人", 
            "title": "关联关系案例详解"
        }, 
        {
            "location": "/data/android/develop_doc/#web", 
            "text": "如果你需要在Web端创建上述表的话，那么当选择的字段类型为 Pointer或Relation 时，会提示你选择该字段所指向或关联的数据表。  如下图所示：", 
            "title": "Web端创建关联字段"
        }, 
        {
            "location": "/data/android/develop_doc/#_55", 
            "text": "public class MyUser extends BmobUser {\n\n    private Integer age;//为用户表新增一个age字段，注意其必须为`Integer`类型，而不是int\n\n    //自行实现getter和setter方法\n}  1、扩展BmobUser的时，不需要再加上 objectId、username、password、createAt、updateAt 等系统字段，因为BmobUser中已经实现了，如果再次声明的话，会导致编译性的错误。  2、类名可以自定义，这个跟其他表的命名方式有所不同。  \npublic class Post extends BmobObject {\n\n    private String title;//帖子标题\n\n    private String content;// 帖子内容\n\n    private MyUser author;//帖子的发布者，这里体现的是一对一的关系，该帖子属于某个用户\n\n    private BmobFile image;//帖子图片\n\n    private BmobRelation likes;//多对多关系：用于存储喜欢该帖子的所有用户\n\n    //自行实现getter和setter方法\n\n}  \npublic class Comment extends BmobObject {\n\n    private String content;//评论内容  \n\n    private MyUser user;//评论的用户，Pointer类型，一对一关系\n\n    private Post post; //所评论的帖子，这里体现的是一对多的关系，一个评论只能属于一个微博\n\n    //自行实现getter和setter方法\n}  注：  1、类名要和数据表名保持一致。  2、MyUser属性对应为Pointer的指针类型。  以下举例均假定A用户已注册并登陆", 
            "title": "创建数据对象"
        }, 
        {
            "location": "/data/android/develop_doc/#_56", 
            "text": "用户发表帖子，一篇帖子也只能属于某个用户，那么帖子和用户之间的关系是 一对一关系 ，建议使用 Pointer 类型来表示。  Pointer 本质上可以看成是我们将一个指向某条记录的指针记录下来，我们查询时可以通过该指针来获得其指向的关联对象。  用户A写了一篇帖子，需要在 Post 表中生成一条记录，并将该帖子关联到用户A这条记录，表明该帖子是A所发表的。  示例如下：", 
            "title": "一对一关系"
        }, 
        {
            "location": "/data/android/develop_doc/#_57", 
            "text": "MyUser user = BmobUser.getCurrentUser(MyUser.class);\n// 创建帖子信息\nPost post = new Post();\npost.setContent(content);\n//添加一对一关联\npost.setAuthor(user);\npost.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 保存成功 );\n        }else{\n            Log.i( bmob , 保存失败： +e.getMessage());\n        }\n    }\n});  添加成功后，在后台的 Post 表中，你就会看到有一条记录生成，并且该帖子的 author 字段的值指向了 _User 表中的 用户A 这条记录。", 
            "title": "添加一对一关联"
        }, 
        {
            "location": "/data/android/develop_doc/#_58", 
            "text": "如果想查询 用户A (当前用户)所发表的所有帖子，那么可以这样：  MyUser user = BmobUser.getCurrentUser(MyUser.class);\nBmobQuery Post  query = new BmobQuery Post ();\nquery.addWhereEqualTo( author , user);  // 查询当前用户的所有帖子\nquery.order( -updatedAt );\nquery.include( author );// 希望在查询帖子信息的同时也把发布人的信息查询出来\nquery.findObjects(new FindListener Post () {\n\n    @Override\n    public void done(List Post  object,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});  注：如果想查询某个用户所发表的所有帖子，则将该用户查询出来，然后使用上述代码查询指定用户所发表的所有帖子。", 
            "title": "查询一对一关联"
        }, 
        {
            "location": "/data/android/develop_doc/#_59", 
            "text": "如果希望将刚刚这条帖子的作者修改成 用户B ,示例：  Post p = new Post();\n//构造用户B，如果你知道用户B的objectId的话，可以使用这种方式进行关联，如果不知道的话，你需要将用户B查询出来\n// 这里假设已知用户B的objectId为aJyG2224\nMyUser userB =new MyUser();\nuserB.setObjectId( aJyG2224 );\np.setAuthor(userB);//重新设置帖子作者\np.update( ESIt3334 , new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});  修改成功后，在后台可查看到这个帖子的作者已经变更为用户B", 
            "title": "更新一对一关联"
        }, 
        {
            "location": "/data/android/develop_doc/#_60", 
            "text": "如果你想和 ESIt3334 这个帖子解除关联关系，可以这样：  Post p = new Post();\np.remove( author );\np.update( ESIt3334 , new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n});  删除成功后，在后台的 Post 表中，你就会看到 ESIt3334 这个帖子的 author 字段的值已经被置空了。", 
            "title": "删除一对一关联"
        }, 
        {
            "location": "/data/android/develop_doc/#_61", 
            "text": "一条评论只能属于某一篇帖子，一篇帖子可以有很多用户对其进行评论，那么帖子和评论之间的关系就是 一对多关系 ，推荐使用 pointer 类型来表示 。  因为使用方法和上面的一对一关联基本相同，只是查询一对多关联的时候有些区别，故只举添加和查询两个例子：", 
            "title": "一对多关系"
        }, 
        {
            "location": "/data/android/develop_doc/#_62", 
            "text": "将评论和微博进行关联，并同时和当前用户进行关联，表明是当前用户对该帖子进行评论，示例如下：  MyUser user = BmobUser.getCurrentUser(MyUser.class);\nPost post = new Post();\npost.setObjectId( ESIt3334 );\nfinal Comment comment = new Comment();\ncomment.setContent(content);\ncomment.setPost(post);\ncomment.setUser(user);\ncomment.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 评论发表成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});", 
            "title": "添加一对多关联"
        }, 
        {
            "location": "/data/android/develop_doc/#_63", 
            "text": "我想 查询出某个帖子（objectId为ESIt3334）的所有评论,同时将该评论的作者的信息也查询出来 ，那么可以使用 addWhereEqualTo 方法进行查询：  BmobQuery Comment  query = new BmobQuery Comment ();\n//用此方式可以构造一个BmobPointer对象。只需要设置objectId就行\nPost post = new Post();\npost.setObjectId( ESIt3334 );\nquery.addWhereEqualTo( post ,new BmobPointer(post));        \n//希望同时查询该评论的发布者的信息，以及该帖子的作者的信息，这里用到上面`include`的并列对象查询和内嵌对象的查询\nquery.include( user,post.author );\nquery.findObjects(new FindListener Comment () {\n\n    @Override\n    public void done(List Comment  objects,BmobException e) {\n        ...\n    }\n});  注： addWhereEqualTo 对 BmobPonter 类型的一对多的关联查询是 BmobSDKV3.3.8 开始支持的，因此使用时，请更新SDK版本。", 
            "title": "查询一对多关联"
        }, 
        {
            "location": "/data/android/develop_doc/#_64", 
            "text": "一个帖子可以被很多用户所喜欢，一个用户也可能会喜欢很多帖子，那么可以使用 Relation 类型来表示这种 多对多关联关系 。  Relation 本质上可以理解为其存储的是一个对象，而这个对象中存储的是多个指向其它记录的指针。", 
            "title": "多对多关系"
        }, 
        {
            "location": "/data/android/develop_doc/#_65", 
            "text": "MyUser user = BmobUser.getCurrentUser(MyUser.class);\nPost post = new Post();\npost.setObjectId( ESIt3334 );\n//将当前用户添加到Post表中的likes字段值中，表明当前用户喜欢该帖子\nBmobRelation relation = new BmobRelation();\n//将当前用户添加到多对多关联中\nrelation.add(user);\n//多对多关联指向`post`的`likes`字段\npost.setLikes(relation);\npost.update(new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 多对多关联添加成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});  添加成功后，在后台的 Post 表中就能查看到 likes 字段已经生成并对应到了 _User   点击红框中的 关联关系 按钮展开后，可查看刚才所添加的喜欢该帖子的用户A：", 
            "title": "添加多对多关联"
        }, 
        {
            "location": "/data/android/develop_doc/#_66", 
            "text": "如果希望 查询喜欢该帖子（objectId为ESIt3334）的所有用户 ,那么就需要用到 addWhereRelatedTo 方法进行多对多关联查询。  示例代码：  // 查询喜欢这个帖子的所有用户，因此查询的是用户表\nBmobQuery MyUser  query = new BmobQuery MyUser ();\nPost post = new Post();\npost.setObjectId( ESIt3334 );\n//likes是Post表中的字段，用来存储所有喜欢该帖子的用户\nquery.addWhereRelatedTo( likes , new BmobPointer(post));    \nquery.findObjects(new FindListener MyUser () {\n\n    @Override\n    public void done(List MyUser  object,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 查询个数： +object.size());\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});", 
            "title": "查询多对多关联"
        }, 
        {
            "location": "/data/android/develop_doc/#_67", 
            "text": "如果 用户B也喜欢该帖子（objectId为ESIt3334） ，此时需要为该帖子(Post)的 likes 字段多添加一个用户,示例如下：  Post post = new Post();\npost.setObjectId( ESIt3334 );\n//将用户B添加到Post表中的likes字段值中，表明用户B喜欢该帖子\nBmobRelation relation = new BmobRelation();\n//构造用户B\nMyUser user = new MyUser();\nuser.setObjectId( aJyG2224 );\n//将用户B添加到多对多关联中\nrelation.add(user);\n//多对多关联指向`post`的`likes`字段\npost.setLikes(relation);\npost.update(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 用户B和该帖子关联成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});  修改成功后，你在点击该帖子的 likes 字段下面的 关联关系 按钮展开后，可查看刚才所添加的喜欢该帖子的用户B：", 
            "title": "修改多对多关联"
        }, 
        {
            "location": "/data/android/develop_doc/#_68", 
            "text": "如果 想对该帖子进行取消喜欢的操作 ，此时，需要删除之前的多对多关联，具体代码：  Post post = new Post();\npost.setObjectId( 83ce274594 );\nMyUser user = BmobUser.getCurrentUser(MyUser.class);\nBmobRelation relation = new BmobRelation();\nrelation.remove(user);\npost.setLikes(relation);\npost.update(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 关联关系删除成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});  1 例子中的Comment和Post表请大家注意下在后端控制台建表的数据类型是Pointer还是Relation 否则返回类型不匹配的111错误，表的结构和字段类型如下：    2 为方便大家了解学习，我们提供了一个关于数据关联的Demo，下载地址是：https://github.com/bmob/RelationDemo", 
            "title": "删除多对多关联"
        }, 
        {
            "location": "/data/android/develop_doc/#include", 
            "text": "在某些情况下，你想在一个查询内获取 Pointer 类型的关联对象。  比如上述示例中，如果希望在查询帖子信息的同时也把该帖子的作者的信息查询出来，可以使用 include 方法  query.include( author );  你可以使用 , 号(逗号)操作符来 include并列查询 两个对象  比如，查询评论表的同时将该评论用户的信息和所评论的帖子信息也一并查询出来（因为Comment表有两个 Pointer类型 的字段），那么可以这样做：  query.include( user,post );  但不能如下的做法：  query.include( user );\nquery.include( post );  你同时还可以使用  . 号（英语句号）操作符来进行 include中的内嵌对象查询  比如，你想在查询评论信息的同时将该评论 Comment 对应的帖子 post 以及该帖子的作者信息 author 一并查询出来，你可以这样做：  query.include( post.author );  另外，include还可以指定返回的字段：  query.include( post[likes].author[username|email] );  其中，post和author都是Pointer类型，post指向的表只返回likes字段，author指向的表只返回username和email字段。  注：include的查询对象只能为BmobPointer类型，而不能是BmobRelation类型。", 
            "title": "include用法"
        }, 
        {
            "location": "/data/android/develop_doc/#_69", 
            "text": "如果你在查询某个对象列表时，它们的某个字段是BmobObject类型，并且这个BmobObject匹配一个不同的查询，这种情况下可使用 addWhereMatchesQuery 方法。  请注意，默认的 limit 限制 100 也同样作用在内部查询上。因此如果是大规模的数据查询，你可能需要仔细构造你的查询对象来获取想要的行为。  例如： 查询带有图片的帖子的评论列表 :  BmobQuery Comment  query = new BmobQuery Comment ();\nBmobQuery Post  innerQuery = new BmobQuery Post ();\ninnerQuery.addWhereExists( image , true);\n// 第一个参数为评论表中的帖子字段名post\n// 第二个参数为Post字段的表名，也可以直接用 Post 字符串的形式\n// 第三个参数为内部查询条件\nquery.addWhereMatchesQuery( post ,  Post , innerQuery);\nquery.findObjects(new FindListener Comment () {\n\n    @Override\n    public void done(List Comment  object,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n});  反之，不想匹配某个子查询，你可以使用 addWhereDoesNotMatchQuery 方法。   比如 查询不带图片的帖子的评论列表 ：  BmobQuery Comment  query = new BmobQuery Comment ();\nBmobQuery Post  innerQuery = new BmobQuery Post ();\ninnerQuery.addWhereExists( image , true);\n// 第一个参数为评论表中的帖子字段名post\n// 第二个参数为Post字段的表名，也可以直接用 Post 字符串的形式\n// 第三个参数为内部查询条件\nquery.addWhereDoesNotMatchQuery( post ,  Post , innerQuery);\nquery.findObjects(new FindListener Comment () {\n    @Override\n    public void done(List Comment  object,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n});  注：  当查询的表为系统表（目前系统表有User、Installation、Role）时，需要带上下划线 _ 。  比如，你想查询出用户 smile 和 smile 好友的所有帖子，则可以这样：  \nBmobQuery User  innerQuery = new BmobQuery User ();\nString[] friendIds={ ssss , aaaa };//好友的objectId数组\ninnerQuery.addWhereContainedIn( objectId , Arrays.asList(friendIds));\n//查询帖子\nBmobQuery Post  query = new BmobQuery Post ();\n`query.addWhereMatchesQuery( author ,  _User , innerQuery);`\nquery.findObjects(new FindListener Post () {\n    @Override\n    public void done(List Post  object,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n});", 
            "title": "内部查询"
        }, 
        {
            "location": "/data/android/develop_doc/#_70", 
            "text": "用户是一个应用程序的核心。对于个人开发者来说，自己的应用程序积累到越多的用户，就会给自己带来越强的创作动力。因此Bmob提供了一个专门的用户类——BmobUser来自动处理用户账户管理所需的功能。  有了这个类，你就可以在你的应用程序中添加用户账户功能。  BmobUser是BmobObject的一个子类，它继承了BmobObject所有的方法，具有BmobObject相同的功能。不同的是，BmobUser增加了一些特定的关于用户账户管理相关的功能。", 
            "title": "用户管理"
        }, 
        {
            "location": "/data/android/develop_doc/#_71", 
            "text": "BmobUser除了从BmobObject继承的属性外，还有几个特定的属性：\nusername: 用户的用户名 （必需） 。\npassword: 用户的密码 （必需） 。\nemail: 用户的电子邮件地址 （可选） 。\nemailVerified:邮箱认证状态 （可选） 。\nmobilePhoneNumber：手机号码 （可选） 。\nmobilePhoneNumberVerified：手机号码的认证状态 （可选） 。", 
            "title": "属性"
        }, 
        {
            "location": "/data/android/develop_doc/#_72", 
            "text": "很多时候，你的用户表还会有很多其他字段，如性别、年龄、头像等。那么，你需要对BmobUser类进行扩展，添加一些新的属性。示例代码如下所示：  public class MyUser extends BmobUser {\n\n    private Boolean sex;\n    private String nick;\n    private Integer age;\n\n    public boolean getSex() {\n        return this.sex;\n    }\n\n    public void setSex(boolean sex) {\n        this.sex = sex;\n    }\n\n    public String getNick() {\n        return this.nick;\n    }\n\n    public void setNick(String nick) {\n        this.nick = nick;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}  更多代码实现大家可以下载SDK，在里面的 BmobExample 中查找 MyUser 类，参考它的用法。", 
            "title": "扩展用户类"
        }, 
        {
            "location": "/data/android/develop_doc/#_73", 
            "text": "创建用户对象如下：  BmobUser user = new BmobUser();", 
            "title": "创建用户"
        }, 
        {
            "location": "/data/android/develop_doc/#_74", 
            "text": "你的应用程序可能会要求用户注册。下面的代码是一个典型的注册过程：  BmobUser bu = new BmobUser();\nbu.setUsername( sendi );\nbu.setPassword( 123456 );\nbu.setEmail( sendi@163.com );\n//注意：不能用save方法进行注册\nbu.signUp(new SaveListener MyUser () {\n    @Override\n    public void done(MyUser s, BmobException e) {\n        if(e==null){\n            toast( 注册成功:  +s.toString());\n        }else{\n            loge(e);\n        }\n    }\n});  在注册过程中，服务器会对注册用户信息进行检查，以确保注册的用户名和电子邮件地址是独一无二的。此外，对于用户的密码，你可以在应用程序中进行相应的加密处理后提交。  如果注册不成功，你可以查看返回的错误对象。最有可能的情况是，用户名或电子邮件已经被另一个用户注册。这种情况你可以提示用户，要求他们尝试使用不同的用户名进行注册。  你也可以要求用户使用Email做为用户名注册，这样做的好处是，你在提交信息的时候可以将输入的“用户名“默认设置为用户的Email地址，以后在用户忘记密码的情况下可以使用Bmob提供重置密码功能。  注：   有些时候你可能需要在用户注册时发送一封验证邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在应用设置- 邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在注册时自动发动一封验证给用户。     username字段是大小写敏感的字段，如果你希望应用的用户名不区分大小写，请在注册和登录时进行大小写的统一转换。", 
            "title": "注册"
        }, 
        {
            "location": "/data/android/develop_doc/#_75", 
            "text": "当用户注册成功后，您需要让他们以后能够用注册的用户名登录到他们的账户使用应用。要做到这一点，你可以使用BmobUser类的login方法。  BmobUser bu2 = new BmobUser();\nbu2.setUsername( lucky );\nbu2.setPassword( 123456 );\nbu2.login(new SaveListener BmobUser () {\n\n    @Override\n    public void done(BmobUser bmobUser, BmobException e) {\n        if(e==null){\n            toast( 登录成功: );\n            //通过BmobUser user = BmobUser.getCurrentUser()获取登录成功后的本地用户信息\n            //如果是自定义用户对象MyUser，可通过MyUser user = BmobUser.getCurrentUser(MyUser.class)获取自定义用户信息\n        }else{\n            loge(e);\n        }\n    }\n});  也可使用如下方式完成 用户名+密码 的登录：  BmobUser.loginByAccount( username ,  用户密码 , new LogInListener MyUser () {\n\n            @Override\n            public void done(MyUser user, BmobException e) {\n                if(user!=null){\n                    Log.i( smile , 用户登陆成功 );\n                }\n            }\n        });", 
            "title": "登录"
        }, 
        {
            "location": "/data/android/develop_doc/#_76", 
            "text": "如果用户在每次打开你的应用程序时都要登录，这将会直接影响到你应用的用户体验。为了避免这种情况，你可以使用缓存的CurrentUser对象。缓存的用户有效期为1年。  每当你应用的用户注册成功或是第一次登录成功，都会在本地磁盘中有一个缓存的用户对象，这样，你可以通过获取这个缓存的用户对象来进行登录：  BmobUser bmobUser = BmobUser.getCurrentUser();\nif(bmobUser != null){\n    // 允许用户使用应用\n}else{\n    //缓存用户对象为空时， 可打开用户注册界面…\n}  在扩展了用户类的情况下获取当前登录用户，可以使用如下的示例代码（ MyUser 类可参看上面）：  MyUser userInfo = BmobUser.getCurrentUser(MyUser.class);  自 V3.4.5 版本开始，SDK新增了 getObjectByKey(context,key) 方法从本地缓存中获取当前登陆用户某一列的值。其中 key 为用户表的指定列名。  //BmobUser中的特定属性\nString username = (String) BmobUser.getObjectByKey( username );\n//MyUser中的扩展属性\nInteger age = (Integer) BmobUser.getObjectByKey( age );\nBoolean sex = (Boolean) BmobUser.getObjectByKey( sex );", 
            "title": "当前用户"
        }, 
        {
            "location": "/data/android/develop_doc/#_77", 
            "text": "很多情况下你可能需要修改用户信息，比如你的应用具备修改个人资料的功能，Bmob提供的用户更新方式有两种写法：  第一种： 新建一个用户对象，并调用update(objectId,updateListener)方法来更新（推荐使用） ，示例：  BmobUser newUser = new BmobUser();\nnewUser.setEmail( xxx@163.com );\nBmobUser bmobUser = BmobUser.getCurrentUser(context);\nnewUser.update(bmobUser.getObjectId(),new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 更新用户信息成功 );\n        }else{\n            toast( 更新用户信息失败:  + e.getMessage());\n        }\n    }\n});  第二种：获取本地的用户对象，并调用update（updateListener）方法来更新（ 不推荐使用 ），示例：  BmobUser bmobUser = BmobUser.getCurrentUser();\n// 修改用户的邮箱为xxx@163.com\nbmobUser.setEmail( xxx@163.com );\nbmobUser.update(new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 更新用户信息成功 );\n        }else{\n            toast( 更新用户信息失败:  + e.getMessage());\n        }\n    }\n});  1、开发者在进行用户更新操作的时候，推荐使用 第一种 方式来进行用户的更新操作,因为此方法只会更新你提交的用户信息（比如只会向服务器提交当前用户的email值），而不会将本地存储的用户信息也提交到后台更新。  2、在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发一封邮件验证信息给用户。  3、需要先登录后才能更新用户信息 否则会返回206 User cannot be altered without sessionToken Error错误。", 
            "title": "更新用户"
        }, 
        {
            "location": "/data/android/develop_doc/#_78", 
            "text": "查询用户和查询普通对象一样，只需指定BmobUser类即可，如下：  BmobQuery BmobUser  query = new BmobQuery BmobUser ();\nquery.addWhereEqualTo( username ,  lucky );\nquery.findObjects(new FindListener BmobUser () {\n    @Override\n    public void done(List BmobUser  object,BmobException e) {\n        if(e==null){\n            toast( 查询用户成功: +object.size());\n        }else{\n            toast( 更新用户信息失败:  + e.getMessage());\n        }\n    }\n});  浏览器中查看用户表  User表是一个特殊的表，专门存储BmobUser对象。在浏览器端，你会看到一个User表旁边有一个小人的图标。", 
            "title": "查询用户"
        }, 
        {
            "location": "/data/android/develop_doc/#_79", 
            "text": "退出登录非常简单，可以使用如下的代码：  BmobUser.logOut();   //清除缓存用户对象\nBmobUser currentUser = BmobUser.getCurrentUser(); // 现在的currentUser是null了", 
            "title": "退出登录"
        }, 
        {
            "location": "/data/android/develop_doc/#_80", 
            "text": "自 V3.4.3 版本开始，SDK为开发者提供了直接修改当前用户登录密码的方法，只需要传入旧密码和新密码，然后调用 BmobUser 提供的静态方法 updateCurrentUserPassword 即可，以下是示例：  BmobUser.updateCurrentUserPassword( 旧密码 ,  新密码 , new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 密码修改成功，可以用新密码进行登录啦 );\n        }else{\n            toast( 失败:  + e.getMessage());\n        }\n    }\n\n});", 
            "title": "密码修改"
        }, 
        {
            "location": "/data/android/develop_doc/#_81", 
            "text": "", 
            "title": "邮箱"
        }, 
        {
            "location": "/data/android/develop_doc/#_82", 
            "text": "新增 邮箱+密码 登录方式,可以通过 loginByAccount 方法来操作：  BmobUser.loginByAccount(account, password, new LogInListener MyUser () {\n\n            @Override\n            public void done(MyUser user, BmobException e) {\n                if(user!=null){\n                    Log.i( smile , 用户登陆成功 );\n                }\n            }\n        });", 
            "title": "邮箱登录"
        }, 
        {
            "location": "/data/android/develop_doc/#_83", 
            "text": "设置邮件验证是一个可选的应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会被默认设为false，如果应用设置中开启了邮箱认证功能，Bmob会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.  emailVerified 字段有 3 种状态可以考虑：   true : 用户可以点击邮件中的链接通过Bmob来验证地址，一个用户永远不会在新创建这个值的时候显示emailVerified为true。  false : 用户(User)对象最后一次被刷新的时候, 用户并没有确认过他的邮箱地址, 如果你看到emailVerified为false的话，你可以考虑刷新用户(User)对象。  missing : 用户(User)对象已经被创建，但应用设置并没有开启邮件验证功能； 或者用户(User)对象没有email邮箱。", 
            "title": "邮箱验证"
        }, 
        {
            "location": "/data/android/develop_doc/#email", 
            "text": "发送给用户的邮箱验证邮件会在一周内失效，可以通过调用  requestEmailVerify  来强制重新发送：  final String email =  xxx@qq.com ;\nBmobUser.requestEmailVerify(email, new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 请求验证邮件成功，请到  + email +  邮箱中进行激活。 );\n        }else{\n            toast( 失败:  + e.getMessage());\n        }\n    }\n});", 
            "title": "请求验证Email"
        }, 
        {
            "location": "/data/android/develop_doc/#_84", 
            "text": "开发者只需要求用户输入注册时的电子邮件地址即可：  final String email =  xxx@163.com ;\nBmobUser.resetPasswordByEmail(email, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 重置密码请求成功，请到  + email +  邮箱进行密码重置操作 );\n        }else{\n            toast( 失败:  + e.getMessage());\n        }\n    }\n});  邮箱重置密码的流程如下：   用户输入他们的电子邮件，请求重置自己的密码。  Bmob向他们的邮箱发送一封包含特殊的密码重置链接的电子邮件。  用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，根据提示他们可以输入一个新的密码。  用户的密码已被重置为新输入的密码。", 
            "title": "邮箱重置密码"
        }, 
        {
            "location": "/data/android/develop_doc/#_85", 
            "text": "", 
            "title": "手机号相关功能"
        }, 
        {
            "location": "/data/android/develop_doc/#_86", 
            "text": "在手机号码被验证后，用户可以使用该手机号码进行登录操作。  手机号码登录包括两种方式： 手机号码＋密码 、 手机号码＋短信验证码 。", 
            "title": "手机号码登录"
        }, 
        {
            "location": "/data/android/develop_doc/#_87", 
            "text": "BmobUser.loginByAccount( 11位手机号码 ,  用户密码 , new LogInListener MyUser () {\n\n    @Override\n    public void done(MyUser user, BmobException e) {\n        if(user!=null){\n            Log.i( smile , 用户登陆成功 );\n        }\n    }\n});", 
            "title": "手机号码+密码"
        }, 
        {
            "location": "/data/android/develop_doc/#_88", 
            "text": "先请求登录的短信验证码：  BmobSMS.requestSMSCode( 11位手机号码 , 模板名称 , new QueryListener Integer () {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i( smile ,  短信id： +smsId);//用于后续的查询本次短信发送状态\n        }\n    }\n});  最后调用 loginBySMSCode 方法进行手机号码登录:  BmobUser.loginBySMSCode( 11位手机号码 , code, new LogInListener MyUser () {\n\n        @Override\n        public void done(MyUser user, BmobException e) {\n            if(user!=null){\n                Log.i( smile , 用户登陆成功 );\n            }\n        }\n    });\n}", 
            "title": "手机号码+短信验证码"
        }, 
        {
            "location": "/data/android/develop_doc/#_89", 
            "text": "Bmob同样支持手机号码一键注册或登录，以下是一键登录的流程：  1、请求登录操作的短信验证码：  BmobSMS.requestSMSCode( 11位手机号码 , 模板名称 , new QueryListener Integer () {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i( smile ,  短信id： +smsId);//用于查询本次短信发送详情\n        }\n    }\n    });  2、用户收到短信验证码之后，就可以调用 signOrLoginByMobilePhone 方法来实现一键登录:  BmobUser.signOrLoginByMobilePhone( 11位手机号码 ,  验证码 , new LogInListener MyUser () {\n\n    @Override\n    public void done(MyUser user, BmobException e) {\n        if(user!=null){\n            Log.i( smile , 用户登陆成功 );\n        }\n    }\n});  如果，你想在一键注册或登录的同时保存其他字段的数据的时，你可以使用 signOrLogin 方法（此方法 V3.4.3 版本提供）。  比如，你想在手机号码注册或登录的同时，设置用户名及登录密码等信息，那么具体示例如下：  \nMyUser user = new MyUser();\nuser.setMobilePhoneNumber( 11位手机号码 );//设置手机号码（必填）\nuser.setUsername(xxx);                  //设置用户名，如果没有传用户名，则默认为手机号码\nuser.setPassword(xxx);                  //设置用户密码\nuser.setAge(18);                        //设置额外信息：此处为年龄\nuser.signOrLogin( 验证码 , new SaveListener MyUser () {\n\n    @Override\n    public void done(MyUser user,BmobException e) {\n        if(e==null){\n            toast( 注册或登录成功 );\n            Log.i( smile ,  +user.getUsername()+ - +user.getAge()+ - +user.getObjectId());\n        }else{\n            toast( 失败:  + e.getMessage());\n        }\n\n    }\n\n});", 
            "title": "手机号码一键注册或登录"
        }, 
        {
            "location": "/data/android/develop_doc/#_90", 
            "text": "如果已有用户系统，需要为用户绑定手机号，那么官方推荐的绑定流程如下：  第一步、先发送短信验证码并验证验证码的有效性,即调用 requestSMSCode 发送短信验证码，调用 verifySmsCode 来验证有效性。  第二步、在验证成功之后更新当前用户的 MobilePhoneNumber 和 MobilePhoneNumberVerified 两个字段，具体绑定示例如下：  User user =new User();\nuser.setMobilePhoneNumber(phone);\nuser.setMobilePhoneNumberVerified(true);\nUser cur = BmobUser.getCurrentUser(User.class);\nuser.update(cur.getObjectId(),new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 手机号码绑定成功 );\n        }else{\n            toast( 失败:  + e.getMessage());\n        }\n    }\n});", 
            "title": "绑定手机号码"
        }, 
        {
            "location": "/data/android/develop_doc/#_91", 
            "text": "Bmob自 V3.3.9 版本开始引入了短信验证系统，如果用户已经验证过手机号码或者使用过手机号码注册或登录过，也可以通过手机号码来重置用户密码，以下是官方建议使用的重置流程：  1、请求重置密码操作的短信验证码：  BmobSMS.requestSMSCode( 11位手机号码 , 模板名称 , new QueryListener Integer () {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i( smile ,  短信id： +smsId);//用于查询本次短信发送详情\n        }\n    }\n    });  2、用户收到重置密码的验证码之后，就可以调用 resetPasswordBySMSCode 方法来实现密码重置:  BmobUser.resetPasswordBySMSCode(code, 1234567 , new UpdateListener() {\n\n    @Override\n    public void done(BmobException ex) {\n        if(ex==null){\n            Log.i( smile ,  密码重置成功 );\n        }else{\n            Log.i( smile ,  重置失败：code = +ex.getErrorCode()+ ,msg =  +ex.getLocalizedMessage());\n        }\n    }\n});  重置成功以后，用户就可以使用新密码登陆了。  注：  1、请开发者按照官方推荐的操作流程来完成重置密码操作。也就是说，开发者在进行重置密码操作时，无需调用 verifySmsCode 接口去验证该验证码的有效性。  2、验证码只能使用一次，一旦该验证码被使用就会失效，那么再拿失效的验证码去调用重置密码接口，一定会报 207-验证码错误 。因为重置密码接口已经包含验证码的有效性验证。", 
            "title": "手机号码重置密码"
        }, 
        {
            "location": "/data/android/develop_doc/#_92", 
            "text": "", 
            "title": "手机号码验证"
        }, 
        {
            "location": "/data/android/develop_doc/#_93", 
            "text": "Bmob自 V3.3.9 版本开始引入了短信验证系统，可通过 requestSMSCode 方式请求发送短信验证码：  BmobSMS.requestSMSCode( 11位手机号码 ,  模板名称 ,new QueryListener Integer () {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i( smile ,  短信id： +smsId);//用于查询本次短信发送详情\n        }\n    }\n});  短信默认模板：  \n    您的验证码是`%smscode%`，有效期为`%ttl%`分钟。您正在使用`%appname%`的验证码。【比目科技】  注：  1、 模板名称 ：模板名称需要开发者在应用的管理后台进行短信模板的添加工作，具体： 短信服务 - 短信模板 ,之后点击创建即可。  具体请看下图：   2、只有审核通过之后的自定义短信模板才可以被使用，如果自定义的短信模板其状态显示 审核中 或者 审核失败 ,再调用该方法则会以 默认模板 来发送验证码。  3、开发者提交短信验证码模板时需注意以下几点：  1）、模板中不能有【】和 [] ，否则审核不通过；  2）、如果你提交的短信模板无法发送，则有可能包含一些敏感监控词，具体可去Github下载   短信关键字监控参考文档   来查看提交内容是否合法。  3）、一天一个应用给同一手机号发送的短信不能超过10条，否则会报 10010 错误，其他错误码可查看   短信功能相关错误码  。", 
            "title": "请求发送短信验证码"
        }, 
        {
            "location": "/data/android/develop_doc/#_94", 
            "text": "通过 verifySmsCode 方式可验证该短信验证码：  BmobSMS.verifySmsCode( 11位手机号码 ,  验证码 , new UpdateListener() {\n\n    @Override\n    public void done(BmobException ex) {\n        if(ex==null){//短信验证码已验证成功\n            Log.i( smile ,  验证通过 );\n        }else{\n            Log.i( smile ,  验证失败：code = +ex.getErrorCode()+ ,msg =  +ex.getLocalizedMessage());\n        }\n    }\n});  验证成功后，用户的 mobilePhoneVerified 属性会自动变为 true 。", 
            "title": "验证验证码"
        }, 
        {
            "location": "/data/android/develop_doc/#_95", 
            "text": "通过 querySmsState 方式可查询指定 smsId 的发送状态：  \nBmobSMS.querySmsState(smsId, new QueryListener BmobSmsState () {\n\n            @Override\n            public void done(SmsState state, BmobException ex) {\n                if(ex==null){\n                    Log.i( smile , 短信状态： +state.getSmsState()+ ,验证状态： +state.getVerifyState());\n                }\n            }\n        });  注： SmsState 包含两种状态：  1、 smsState （短信状态）   :SUCCESS（发送成功）、FAIL（发送失败）、SENDING(发送中)。  2、 verifyState （验证状态）:true(已验证)、false(未验证)。  注意事项：  关于短信条数的计算规则如下:   实际计算的短信字数 = 模板的内容或自定义短信的内容字数 + 6。加上6是因为默认的签名【比目科技】占了6个字。  实际计算的短信字数在70个字以下算1条。  实际计算的短信字数超过70字的以67字为一条来计算的。也就是135个字数是计算为3条的。  计算得到的短信条数在本条短信发送成功后将会从你的账户剩余的短信条数中扣除。   短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条。", 
            "title": "查询短信发送状态"
        }, 
        {
            "location": "/data/android/develop_doc/#_96", 
            "text": "为了方便大家，官方提供了一个短信验证的demo： https://github.com/bmob/bmob_android_demo_sms  。  此案例包含了： 用户名/邮箱/手机号码+密码登录 、 手机号码一键注册登录 、 绑定手机号 以及 通过手机号重置用户密码 。", 
            "title": "短信验证案例"
        }, 
        {
            "location": "/data/android/develop_doc/#_97", 
            "text": "Bmob提供了非常简单的方法来实现第三方账号登陆的功能，目前支持 新浪微博 、 QQ账号 、 微信账号 的登陆。  自 BmobV3.3.9 版本开始，为了与第三方开放平台的SDK解藕，Bmob使用了全新的第三方账号登录方式，之前的微博和qq登录方式的API已删除。", 
            "title": "第三方账号登陆"
        }, 
        {
            "location": "/data/android/develop_doc/#_98", 
            "text": "第三方账号登陆目前适应以下两种应用场景：  一、没有Bmob账号，希望使用第三方账号一键注册或登陆Bmob账号  如果开发者希望用户使用第三方平台的账号注册或登录Bmob的用户体系，则推荐的步骤如下：  1、第三方平台授权，开发者需自行根据第三方平台文档提出的授权方法完成账号授权并得到授权信息  2、调用Bmob提供的 loginWithAuthData（BmobV3.3.9版本提供） 方法，并自行构造 BmobThirdUserAuth（第三方授权信息） 对象，调用成功后，在Bmob的User表中会产生一条记录。  二、已有Bmob账号，希望与第三方账号进行关联  如果已使用Bmob的用户体系（假设用户A已登录），希望和第三方平台进行关联，则推荐的步骤如下：  1、第三方平台授权，开发者需自行根据第三方平台文档提出的授权方法完成账号授权并得到授权信息  2、调用 associateWithAuthData 方法，并自行构造 BmobThirdUserAuth(第三方授权信息) 对象，调用成功后，你就会在后台的用户A的authData这个字段下面看到提交的授权信息。", 
            "title": "应用场景"
        }, 
        {
            "location": "/data/android/develop_doc/#_99", 
            "text": "为了方便开发者完成授权，现整理各个平台的需要查阅的文档：", 
            "title": "相关文档"
        }, 
        {
            "location": "/data/android/develop_doc/#_100", 
            "text": "1、 移动客户端接入文档 ：此文档请着重查阅其中的 SDK接入流程 。  2、 新浪微博AndroidSDK快速入门 ，请详细查看 README 文档,其介绍了完整的集成流程。  3、 新浪微博常见问题 ：在新浪微博授权过程中出现问题，请查看此文档，一般出现频率较高的错误有：  sso package and sign error - 平台上填写的包名和签名不正确。请仔细检查，一般最需要检查的是 签名 ，签名需要使用微博提供的获取签名的工具 （app_signatures.apk） 。  redirect_uri_mismatch      - 请确保你在weibo平台上填写的授权回调地址与代码中写的授权回调地址(RedirectURI)一样。", 
            "title": "微博登陆相关文档"
        }, 
        {
            "location": "/data/android/develop_doc/#qq", 
            "text": "1、如何使用SDK，请参见  腾讯开放平台Android_SDK使用说明 。  2、如何调用具体API，请参见  API调用说明 。  3、常见问题汇总，请参见 问题汇总说明 。", 
            "title": "QQ登陆相关文档"
        }, 
        {
            "location": "/data/android/develop_doc/#_101", 
            "text": "1、 Android接入指南 ：这里主要介绍的是微信sdk的集成步骤  2、 微信登陆开发指南 ：在 移动应用开发 - 微信登录功能 - 移动应用微信登录开发指南 。主要介绍微信OAuth2.0授权登录的流程。  注：  三者当中较麻烦的是微信登陆的授权，因此，在此简单说明下可能遇见的问题：  1、在微信登陆过程中出现了问题，请仔细注意以下几点：  1）、需要在微信开放平台上填写你的 应用信息、包名和签名 ；\n2）、微信登陆不同于QQ或微博登陆，应用需要 提交微信官方审核 ，只有审核通过后才能打开授权界面；\n3）、建议 导出正式签名的apk来测试 ，不建议直接run debug版本的apk；\n4）、检查 签名是否正确 、检查 传递的参数是否正确 。  2、微信登陆的测试相对比较麻烦，如果开发者希望直接能够进行调试，建议使用微信官方demo中的 debug keystore 。具体使用步骤：  1)、Eclipse中选择 Window- Preferences- Android- Build ;  2)、在Build页有个 Custom debug keystore 选项,然后点击 Browse ,选择微信官方demo中的 debug keystore 文件即可。  之后重新运行应用时会使用该 debug keystore 文件对应用进行Debug签名。  不要忘了在微信后台重新填写通过微信签名工具获得的该调试应用的签名 。", 
            "title": "微信登陆相关文档"
        }, 
        {
            "location": "/data/android/develop_doc/#_102", 
            "text": "假设你已通过上述提供的文档完成相应平台的授权并得到对应的授权信息，则可以这样来完成一键注册或登陆操作：      BmobThirdUserAuth authInfo = new BmobThirdUserAuth(snsType,accessToken, expiresIn,userId);\n    BmobUser.loginWithAuthData(authInfo, new LogInListener JSONObject () {\n\n        @Override\n        public void done(JSONObject userAuth,BmobException e) {\n            ...\n        }\n    });           注：  BmobThirdUserAuth 的各参数解释：  1、 snsType :只能是三种取值中的一种： weibo、qq、weixin  2、 accessToken ：接口调用凭证  3、 expiresIn ：access_token的有效时间  4、 userId :用户身份的唯一标识，对应微博授权信息中的 uid ,对应qq和微信授权信息中的 openid", 
            "title": "第三方账号一键注册或登录"
        }, 
        {
            "location": "/data/android/develop_doc/#_103", 
            "text": "", 
            "title": "关联第三方账号"
        }, 
        {
            "location": "/data/android/develop_doc/#_104", 
            "text": "BmobThirdUserAuth authInfo = new BmobThirdUserAuth(snsType,accessToken, expiresIn, userId);\n    BmobUser.associateWithAuthData(authInfo, new UpdateListener() {\n\n        @Override\n        public void done(BmobException e) {\n            if(e==null){\n                Log.i( bmob , 关联成功 );\n            }else{\n                Log.i( bmob , 关联失败：code =  + e.getErrorCode() +  ,msg =   + e.getMessage());\n            }\n\n        }\n    });", 
            "title": "账号关联"
        }, 
        {
            "location": "/data/android/develop_doc/#_105", 
            "text": "BmobUser.dissociateAuthData(snsType,new UpdateListener() {\n\n        @Override\n        public void done(BmobException e) {\n            if(e==null){\n                Log.i( bmob , 取消 +snsType+ 关联成功 );\n            }else{\n                int code =e.getErrorCode(); \n                if (code == 208) {// 208错误指的是没有绑定相应账户的授权信息\n                    Log.i( smile , 你没有关联该账号 );\n                } else {\n                    Log.i( smile , 取消 +snsType+ 关联失败：code =  + code +  ,msg =   + e.getMessage());\n                }\n            }\n        }\n});", 
            "title": "解除关联"
        }, 
        {
            "location": "/data/android/develop_doc/#_106", 
            "text": "具体案例可参考我们Github上的demo： https://github.com/bmob/bmob-android-demo-thirdpartylogin  ,这个源码包含了第三方登录的源码和登录之后如何获取用户基本信息的部分。", 
            "title": "第三方登录的案例源码"
        }, 
        {
            "location": "/data/android/develop_doc/#_107", 
            "text": "BmobFile 可以让你的应用程序将文件存储到服务器中，常见的文件类型都可以实现存储：比如图像文件、影像文件、音乐文件和任何其他二进制数据。  注：  1、以下均为SDK对文件进行操作的方法，如果你想在Web端对文件进行操作，请查看我们的帮助文档： 如何在Web后台上传文件  2、自  BmobSDKv3.4.6  开始，文件服务需要注意以下几个方面：    SDK内部集成CDN文件服务，删除 BmobProFile 的相关代码，并不再提供新旧文件管理的功能，但上传的方法名不变 ；    新增了文件下载 (download) 和批量删除CDN文件 (deleteBatch) 的方法 ；    2016年7月,旧版SDK中的新旧文件管理的上传方法将停止服务，之前通过旧版SDK中的新旧文件管理上传的文件仍可下载，请大家及时更新SDK ；    之前使用了 BmobProFile中 的 upload 方法上传的文件，开发者可以直接在文件的url地址后面增加：\"?t=2 a=\"+ 你的accessKey，那么拼接后的文件是可以直接用来访问并下载的。 ；        举个例子：\n\n    如果之前通过新版文件管理的上传方法得到的文件url地址：\n    http://newfile.codenow.cn:8080/a272a1aac5274f7085f140de9db94635.png，\n\n    那么签名后的可访问的文件地址为：\n    http://newfile.codenow.cn:8080/a272a1aac5274f7085f140de9db94635.png?t=2 a=你的accessKey。   无法查看accessKey 。因为已经废除新旧文件管理功能，所以在开发者管理后台的设置-- 应用密钥中已无法查看accessKey，而之前开发者所使用的accessKey继续有效。   3、CDN文件服务需要 okhttp-2.4.0、okio-1.4.0 及 WAKE_LOCK 权限，请导入okhttp相关jar包并在 AndroidManifest.xml 类的 manifest 标签下添加如下权限，否则会造成调用上传/下载文件的方法无反应。       !--保持CPU 运转，屏幕和键盘灯有可能是关闭的,用于文件上传和下载 -- \n     uses-permission android:name= android.permission.WAKE_LOCK  /", 
            "title": "文件管理"
        }, 
        {
            "location": "/data/android/develop_doc/#_108", 
            "text": "创建文件对象方式如下：  String picPath =  sdcard/temp.jpg ;\nBmobFile bmobFile = new BmobFile(new File(picPath));", 
            "title": "创建文件对象"
        }, 
        {
            "location": "/data/android/develop_doc/#_109", 
            "text": "文件分片上传的方法非常简单，示例代码如下：  String picPath =  sdcard/temp.jpg ;\nBmobFile bmobFile = new BmobFile(new File(picPath));\nbmobFile.uploadblock(new UploadFileListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            //bmobFile.getFileUrl()--返回的上传文件的完整地址\n            toast( 上传文件成功:  + bmobFile.getFileUrl());\n        }else{\n            toast( 上传文件失败：  + e.getMessage());\n        }\n\n    }\n\n    @Override\n    public void onProgress(Integer value) {\n        // 返回的上传进度（百分比）\n    }\n});", 
            "title": "上传单一文件"
        }, 
        {
            "location": "/data/android/develop_doc/#_110", 
            "text": "自 BmobSDKv3.4.6 开始,新增 BmobConfig 类，允许开发者设置 查询超时时间 及 文件分片上传时的每片大小 。建议在 Application 类的 onCreate 方法中调用。  示例代码如下:  \npublic class BmobApplication extends Application {\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //设置BmobConfig\n        BmobConfig config =new BmobConfig.Builder()\n        //请求超时时间（单位为秒）：默认15s\n        .setConnectTimeout(30)\n        //文件分片上传时每片的大小（单位字节），默认512*1024\n        .setBlockSize(500*1024)\n        .build();\n        Bmob.getInstance().initConfig(config);\n    }\n}", 
            "title": "设置文件分片上传时每片大小"
        }, 
        {
            "location": "/data/android/develop_doc/#_111", 
            "text": "自 BmobSDKv3.2.7 开始,新增批量上传文件的方法；  自 BmobSDKv3.4.6 开始,文件批量上传的静态方法由 Bmob 转移至 BmobFile 类,建议调用 BmobFile.uploadBatch 方法。  示例代码如下：  //详细示例可查看BmobExample工程中BmobFileActivity类\nString filePath_mp3 =  /mnt/sdcard/testbmob/test1.png ;\nString filePath_lrc =  /mnt/sdcard/testbmob/test2.png ;\nfinal String[] filePaths = new String[2];\nfilePaths[0] = filePath_mp3;\nfilePaths[1] = filePath_lrc;\nBmobFile.uploadBatch(filePaths, new UploadBatchListener() {\n\n    @Override\n    public void onSuccess(List BmobFile  files,List String  urls) {\n        //1、files-上传完成后的BmobFile集合，是为了方便大家对其上传后的数据进行操作，例如你可以将该文件保存到表中\n        //2、urls-上传文件的完整url地址\n        if(urls.size()==filePaths.length){//如果数量相等，则代表文件全部上传完成\n            //do something\n        }\n    }\n\n    @Override\n    public void onError(int statuscode, String errormsg) {\n        ShowToast( 错误码 +statuscode + ,错误描述： +errormsg);\n    }\n\n    @Override\n    public void onProgress(int curIndex, int curPercent, int total,int totalPercent) {\n        //1、curIndex--表示当前第几个文件正在上传\n        //2、curPercent--表示当前上传文件的进度值（百分比）\n        //3、total--表示总的上传文件数\n        //4、totalPercent--表示总的上传进度（百分比）\n    }\n});  注：  1、有多少个文件上传，onSuccess方法就会执行多少次;  2、通过onSuccess回调方法中的files或urls集合的大小与上传的总文件个数比较，如果一样，则表示全部文件上传成功。", 
            "title": "批量上传文件"
        }, 
        {
            "location": "/data/android/develop_doc/#_112", 
            "text": "自 BmobSDKv3.4.6 版本,SDK提供了文件的下载方法 download ，并且允许开发者设置下载文件的存储路径。  注：下载方法并不局限于下载通过BmobSDK上传的文件，也就是说只要提供一个文件url地址，也可以调用下载方法的。  下载文件的步骤：  1、先获取BmobFile对象实例，可以是查询数据时返回的BmobFile，也可以自行构建BmobFile对象：   通过查询数据时返回的BmobFile，示例代码如下：   \nbmobQuery.findObjects(new FindListener GameScore () {\n    @Override\n    public void done(List GameScore  object,BmobException e) {\n        if(e==null){\n            for (GameScore gameScore : object) {\n                BmobFile bmobfile = gameScore.getPic();\n               if(file!= null){\n                    //调用bmobfile.download方法\n               }\n            }\n        }else{\n            toast( 查询失败： +e.getMessage());\n        }\n    }\n});   通过如下构造方法构造BmobFile对象：   需求：如果你想下载一个远程图片地址，那么就需要使用下面的构造方法构造一个BmobFile对象（其中group可为空）  /**  \n * @param fileName 文件名(必填)\n * @param group 组名（选填）\n * @param url  完整url地址（必填）\n * 注：必须要有文件名和文件的完整url地址，group可为空\n */\npublic BmobFile(String fileName,String group,String url){\n    this.filename = fileName;\n    this.group=group;\n    this.url = url;\n}  示例代码如下：  \nBmobFile bmobfile =new BmobFile( xxx.png , , http://bmob-cdn-2.b0.upaiyun.com/2016/04/12/58eeed852a7542cb964600c6cc0cd2d6.png )；  2、然后调用 bmobfile.download 方法下载文件:  有两种下载方法：    download(DownloadFileListener listener) ：此方法会将文件下载到当前应用的默认缓存目录中，以getFilename()得到的值为文件名    download(File savePath, DownloadFileListener listener) ：此方法允许开发者指定文件存储目录和文件名    示例代码如下：  private void downloadFile(BmobFile file){\n    //允许设置下载文件的存储路径，默认下载文件的目录为：context.getApplicationContext().getCacheDir()+ /bmob/ \n    File saveFile = new File(Environment.getExternalStorageDirectory(), file.getFilename());\n    file.download(saveFile, new DownloadFileListener() {\n\n        @Override\n        public void onStart() {\n            toast( 开始下载... );\n        }\n\n        @Override\n        public void done(String savePath,BmobException e) {\n            if(e==null){\n                toast( 下载成功,保存路径: +savePath);\n            }else{\n                toast( 下载失败： +e.getErrorCode()+ , +e.getMessage());\n            }\n        }\n\n        @Override\n        public void onProgress(Integer value, long newworkSpeed) {\n            Log.i( bmob , 下载进度： +value+ , +newworkSpeed);\n        }\n\n    });\n}", 
            "title": "下载文件"
        }, 
        {
            "location": "/data/android/develop_doc/#_113", 
            "text": "BmobSDKv3.4.6 中删除文件的接口， 只能删除通过CDN文件服务（v3.4.6开始采用CDN文件服务）上传的文件 。不兼容之前的新旧文件管理，但使用方法不变。  示例代码如下：  BmobFile file = new BmobFile();\nfile.setUrl(url);//此url是上传文件成功之后通过bmobFile.getUrl()方法获取的。\nfile.delete(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 文件删除成功 );\n        }else{\n            toast( 文件删除失败： +e.getErrorCode()+ , +e.getMessage());\n        }\n    }\n});", 
            "title": "删除文件"
        }, 
        {
            "location": "/data/android/develop_doc/#_114", 
            "text": "自  BmobSDKv3.4.6  版本，SDK提供了文件的批量删除接口 deleteBatch，且只能删除通过CDN文件服务（v3.4.6开始采用CDN文件服务）上传的文件 。  示例代码如下：  //此url必须是上传文件成功之后通过bmobFile.getUrl()方法获取的。\nString[] urls =new String[]{url};\nBmobFile.deleteBatch(urls, new DeleteBatchListener() {\n\n    @Override\n    public void done(String[] failUrls, BmobException e) {\n        if(e==null){\n            toast( 全部删除成功 );\n        }else{\n            if(failUrls!=null){\n                toast( 删除失败个数： +failUrls.length+ , +e.toString());\n            }else{\n                toast( 全部文件删除失败： +e.getErrorCode()+ , +e.toString());\n            }\n        }\n    }\n});  为方便大家理解文件服务的使用，Bmob提供了一个文件上传的案例和源码，大家可以到 示例和教程中查看和下载 。", 
            "title": "批量删除文件"
        }, 
        {
            "location": "/data/android/develop_doc/#_115", 
            "text": "自  BmobSDKv3.4.6  版本，新版文件服务由第三方厂商又拍云提供，只需要在图片上传成功返回的url后面拼接特定参数即可实现缩放，加水印等效果， 如图 ，具体可参考 这里  。  注：  1、文件的批量上传是BmobSDK_v3.2.7版本才提供的功能，如需使用，请更新版本;  2、文件的下载和批量删除是BmobSDK_v3.4.6才提供的功能，如需使用，请更新版本。", 
            "title": "缩略图"
        }, 
        {
            "location": "/data/android/develop_doc/#_116", 
            "text": "数据实时同步是一个超酷的功能！  SDK可以实现对数据表或行的监听，当这个表或者行的数据发生变化时，Bmob会立即将变化的信息告知SDK。\n这种服务非常适合做游戏开发（如，开发斗地主游戏，三个人同时监听一行数据的变化，任何一个人出牌都会将数据写入到这行数据中，其他人也就立即知道了）、群聊（一群人监听某个表的变化，任何人发言都会将数据写入到这个表中，其他人也可以立即知道了）等实时性要求很高的场景中。  为方便大家快速了解数据的实时同步服务，我们提供了一个简单的应用实例（  https://github.com/bmob/bmob-android-demo-realtime-data  ）供大家参考。", 
            "title": "数据实时同步"
        }, 
        {
            "location": "/data/android/develop_doc/#_117", 
            "text": "使用数据实时功能，首先需要创建 BmobRealTimeData 对象,然后调用 start 方法连接服务器。  BmobRealTimeData rtd = new BmobRealTimeData();\nrtd.start(new ValueEventListener() {\n    @Override\n    public void onDataChange(JSONObject data) {\n        Log.d( bmob ,  ( +data.optString( action )+ ) + 数据： +data);\n    }\n\n    @Override\n    public void onConnectCompleted(Exception ex) {\n        Log.d( bmob ,  连接成功: +rtd.isConnected());\n    }\n});  start 方法中的 ValueEventListener 参数用于监听连接成功和数据变化的回调。当有数据变化时会通过onDataChange回调方法反馈到客户端。开发者只需要处理得到的data就可以了。  注：  1、监听器不支持UI线程，在监听回调中请不要直接操作UI；  2、如果你要监听User、Installation等系统表的话，表名前需要加上“_”，例如：_User", 
            "title": "开始连接"
        }, 
        {
            "location": "/data/android/develop_doc/#_118", 
            "text": "在BmobRealTimeData对象连接成功后，就可以进行数据的监听了。BmobSDK提供了监听表和行的方法如下：  // 监听表更新\nrtd.subTableUpdate(tableName);\n// 监听表删除\nrtd.subTableDelete(tableName);\n// 监听行更新\nrtd.subRowUpdate(tableName, objectId);\n// 监听行删除\nrtd.subRowDelete(tableName, objectId);  其中 tableName 为要监听的数据表名， objectId 为要监听的数据行Id,\n通常比较保险的做法是在 BmobRealTimeData 对象的连接状态为 true 的情况下进行监听，代码如下：  if(rtd.isConnected()){\n    // 监听表更新\n    rtd.subTableUpdate(tableName);\n}", 
            "title": "监听数据"
        }, 
        {
            "location": "/data/android/develop_doc/#_119", 
            "text": "当开发者想取消监听某个行为是，可使用下面的方法：  // 取消监听表更新\nrtd.unsubTableUpdate(testTableName);\n// 取消监听表删除\nrtd.unsubTableDelete(testTableName);\n// 取消监听行更新\nrtd.unsubRowUpdate(testTableName, objectId);\n// 取消监听行删除\nrtd.unsubRowDelete(testTableName, objectId);", 
            "title": "取消监听"
        }, 
        {
            "location": "/data/android/develop_doc/#acl", 
            "text": "数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看 Bmob数据与安全页面 ，了解Bmob如何保护数据安全）。  其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。  大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：   对于私有数据，读写权限可以只局限于数据的所有者。  对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。  对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。  属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。  一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。", 
            "title": "ACL和角色"
        }, 
        {
            "location": "/data/android/develop_doc/#_120", 
            "text": "在没有显示指定的情况下，每一个BmobObject(表)中的ACL(列)属性的默认值是所有人可读可写的。在客户端想要修改这个权限设置，只需要简单调用BmobACL的setPublicReadAccess方法和setPublicWriteAccess方法，即：  BmobACL aCL = new BmobACL();\n\naCL.setPublicReadAccess(true);\n\naCL.setPublicWriteAccess(true);  注意：可读可写是默认的权限，不需要写额外的代码。", 
            "title": "默认访问权限"
        }, 
        {
            "location": "/data/android/develop_doc/#_121", 
            "text": "假如你想实现一个分享日志类的应用时，这可能会需要针对不同的日志设定不同的访问权限。比如，公开的日志，发布者有更改和修改的权限，其他用户只有读的权限，那么可用如下代码实现：  Blog blog = new Blog();\nblog.setTitle( 论电影的七个元素 );\nblog.setContent( 这是blog的具体内容 );\n\nBmobACL acl = new BmobACL();    //创建一个ACL对象\nacl.setPublicReadAccess(true);  // 设置所有人可读的权限\nacl.setWriteAccess(BmobUser.getCurrentUser(this), true);   // 设置当前用户可写的权限\n\nblog.setACL(acl);    //设置这条数据的ACL信息\nblog.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        ...\n    }\n\n});  有时，用户想发表一篇不公开的日志，这种情况只有发布者才对这篇日志拥有读写权限，相应的代码如下：  Blog blog = new Blog();\nblog.setTitle( 一个人的秘密 );\nblog.setContent( 这是blog的具体内容 );\n\nBmobACL acl = new BmobACL();  //创建ACL对象\nacl.setReadAccess(BmobUser.getCurrentUser(), true); // 设置当前用户可写的权限\nacl.setWriteAccess(BmobUser.getCurrentUser(), true); // 设置当前用户可写的权限\n\nblog.setACL(acl);    //设置这条数据的ACL信息\nblog.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        ...\n    }\n});", 
            "title": "指定用户的访问权限"
        }, 
        {
            "location": "/data/android/develop_doc/#_122", 
            "text": "上面的指定用户访问权限虽然很方便，但是对于有些应用可能会有一定的局限性。比如一家公司的工资系统，员工和公司的出纳们只拥有工资的读权限，而公司的人事和老板才拥有全部的读写权限。要实现这种功能，你也可以通过设置每个用户的ACL权限来实现，如下：  \n//创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.setWage(100000);   \n\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser boss;\nBmobUser hr_zhang;\nBmobUser cashier_xie;\nBmobUser me;\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\n\n//设置四个用户读的权限\nacl.setReadAccess(boos, true);    \nacl.setReadAccess(hr_zhang, true);\nacl.setReadAccess(cashier_xie, true);\nacl.setReadAccess(me, true);\n\n//设置老板和人事小张对这个工资的写权限\nacl.setWriteAccess(boss, true);\nacl.setWriteAccess(hr_zhang, true);\n\n//设置工资对象的ACL\nwageinfo.setACL(acl);\nwageinfo.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        ...\n    }\n});  但是，一个公司的人事、出纳和员工不仅仅只有一个人，同时还会有离职、调换岗位以及新员工加入等问题存在。如果用上面的代码对公司的每个人进行一一设置的话是不现实的，既麻烦也很难维护。针对这个问题，我们可以利用BmobRole来解决。我们只需要对用户进行分类，每个分类赋予不同的权限。如下代码实现：  //创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.setWage(100000);\n\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser boss;\nBmobUser hr_zhang;\nBmobUser hr_luo;\nBmobUser cashier_xie;\nBmobUser me;\n\n//创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\nBmobRole hr = new BmobRole( HR );\nBmobRole cashier = new BmobRole( Cashier );\n\n//将hr_zhang和hr_luo归属到hr角色中\nhr.getUsers().add(hr_zhang);\nhr.getUsers().add(hr_luo);\n//保存到云端角色表中（web端可以查看Role表）\nhr.save(this);  \n\n//将cashier_xie归属到cashier角色中\ncashier.getUsers().add(cashier_xie);\n//保存到云端角色表中（web端可以查看Role表）\ncashier.save();\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\nacl.setReadAccess(boos, true); // 假设老板只有一个, 设置读权限\nacl.setReadAccess(me, true); // 给自己设置读权限\nacl.setRoleReadAccess(hr, true); // 给hr角色设置读权限\nacl.setRoleReadAccess(cashier, true); // 给cashier角色设置读权限\n\nacl.setWriteAccess(boss, true); // 设置老板拥有写权限\nacl.setRoleWriteAccess(hr, true); // 设置ht角色拥有写权限\n\n//设置工资对象的ACL\nwageinfo.setACL(acl);\nwageinfo.save();  需要说明一点的是，Web端的Role表也具有ACL的列，你可以将角色管理的权限赋予某些用户。", 
            "title": "角色管理"
        }, 
        {
            "location": "/data/android/develop_doc/#_123", 
            "text": "下面我们来说一下角色与角色之间的从属关系。用一个例子来说明下：一个互联网企业有移动部门，部门中有不同的小组，如Android开发组和IOS开发组。每个小组只拥有自己小组的代码读写权限，但这两个小组同时拥有核心库代码的读权限。  //创建MobileDep（移动研发部）、AndroidTeam（android开发组）和iOSTeam（ios开发组）三个角色\nBmobRole mobileDep = new BmobRole( MobileDep );\nBmobRole androidTeam = new BmobRole( AndroidTeam );\nBmobRole iosTeam = new BmobRole( iOSTeam );\n\n//保存AndroidTeam和iosTeam角色到云端\nandroidTeam.save();\niosTeam.save();\n\n//将androidTeam和iosTeam两种角色添加到移动部门角色中\nmobileDep.getRoles().add(androidTeam);\nmobileDep.getRoles().add(iosTeam);\nmobileDep.save();\n\n// 假设创建三个代码数据对象\nCode coreCode = new Code();\nCode androidCode = new Code();\nCode iosCode = new Code();\n\n//......此处省略一些具体的属性设定\n\ncoreCode.save();\nandroidCode.save();\niosCode.save();\n\n//设置androidTeam角色对androidCode对象的读和写的权限\nandroidCode.setRoleReadAccess(androidTeam, true);\nandroidCode.setRoleWriteAccess(androidTeam, true);\n\n//设置iosTeam角色对iosCode对象的读和写的权限\niosCode.setRoleReadAccess(iosTeam, true);\niosCode.setRoleWriteAccess(iosTeam, true);\n\n//设置mobileDep角色可以对coreCode对象进行读操作\ncoreCode.setRoleReadAccess(mobileDep);", 
            "title": "角色之间的从属关系"
        }, 
        {
            "location": "/data/android/develop_doc/#acl_1", 
            "text": "我们为大家提供一个ACL相关的案例源码，大家可以点击下载： https://github.com/bmob/bmob-android-demo-acl", 
            "title": "ACL案例源码"
        }, 
        {
            "location": "/data/android/develop_doc/#_124", 
            "text": "Bmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询。通过在BmobObject的查询中添加一个BmobGeoPoint的对象查询，你就可以实现轻松查找出离当前用户最接近的信息或地点的功能。  为了方便大家查看文档，这里创建一个Person类：  public class Person extends BmobObject{\n    private BmobGeoPoint gpsAdd;\n\n    public BmobGeoPoint getGpsAdd() {\n        return gpsAdd;\n    }\n    public void setGpsAdd(BmobGeoPoint gpsAdd) {\n        this.gpsAdd = gpsAdd;\n    }\n}", 
            "title": "地理位置"
        }, 
        {
            "location": "/data/android/develop_doc/#_125", 
            "text": "首先需要创建一个BmobGeoPoint对象。例如，创建一个东经116.39727786183357度，北纬39.913768382429105度的BmobGeoPoint对象：  BmobGeoPoint point = new BmobGeoPoint(116.39727786183357, 39.913768382429105);", 
            "title": "创建地理位置对象"
        }, 
        {
            "location": "/data/android/develop_doc/#_126", 
            "text": "现在，你可以测试找出最接近某个点的信息了（ 数据表要有一定的地理坐标对象的数据，GeoPoint字段类型 ）。查询使用BmobQuery对象的 addWhereNear 方法进行操作：  BmobQuery Person  bmobQuery = new BmobQuery Person ();\nbmobQuery.addWhereNear( gpsAdd , new BmobGeoPoint(112.934755, 24.52065));\nbmobQuery.setLimit(10);    //获取最接近用户地点的10条数据\nbmobQuery.findObjects(new FindListener Person () {\n    @Override\n    public void done(List Person  object,BmobException e) {\n        if(e==null){\n            toast( 查询成功：共  + object.size() +  条数据。 );\n        }else{\n            toast( 查询失败：  + e.getMessage());\n        }\n    }\n});  要限制查询指定距离范围的数据可以使用 addWhereWithinKilometers 、 addWhereWithinMiles 或 addWhereWithinRadians 方法。  要查询一个矩形范围内的信息可以使用 addWhereWithinGeoBox 来实现：  BmobGeoPoint southwestOfSF = new BmobGeoPoint(116.10675, 39.711669);\nBmobGeoPoint northeastOfSF = new BmobGeoPoint(116.627623, 40.143687);\nBmobQuery Person  query = new BmobQuery Person ();\nquery.addWhereWithinGeoBox( gpsAdd , southwestOfSF, northeastOfSF);\nquery.findObjects(new FindListener Person () {\n\n    @Override\n    public void done(List Person  object,BmobException e) {\n        if(e==null){\n            toast( 查询成功：共  + object.size() +  条数据。 );\n        }else{\n            toast( 查询失败：  + e.getMessage());\n        }\n    }\n});  注意事项    每个BmobObject数据对象中 只能 有一个BmobGeoPoint对象 。    地理位置的点不能超过规定的范围。 纬度的范围 应该是在 -90.0到90.0 之间。 经度的范围 应该是在 -180.0到180.0 之间。如果您添加的经纬度超出了以上范围，将导致程序错误。", 
            "title": "查询地理位置信息"
        }, 
        {
            "location": "/data/android/develop_doc/#_127", 
            "text": "请大家在使用Bmob开发应用程序之前，仔细阅读“数据与安全”的文档： http://docs.bmob.cn/other/Other/n_datasafety/doc/index.html", 
            "title": "应用安全"
        }, 
        {
            "location": "/data/android/develop_doc/#_128", 
            "text": "为方便大家更好的理解Bmob SDK，我们特意为大家提供了一些源码，大家可以下载之后， 嵌入Bmob的Application Id ，就可以打包运行了。  阅读源码是一种良好的习惯！！    即时聊天案例源码： https://github.com/bmob/BmobIMSDK4Android    图文社区案例源码： https://git.oschina.net/v7/Wonderful   这个案例是猿圈媛圈开发团队提供的。    校园小菜案例源码： https://github.com/bmob/Shop  这个案例是湖工大的朋友提供的。    社交分享案例源码： https://github.com/bmob/bmob-android-social-share  这个是金刚锁开发者提供的    第三方登录案例源码： https://github.com/bmob/bmob-android-demo-thirdpartylogin   包含第三方登录和登录后获取用户信息的源码", 
            "title": "开源案例"
        }, 
        {
            "location": "/data/android/develop_doc/#_129", 
            "text": "", 
            "title": "其他功能"
        }, 
        {
            "location": "/data/android/develop_doc/#_130", 
            "text": "在Bmob对象中提供了一个静态方法，用于获取服务器时间。  Bmob.getServerTime(new QueryListener Long () {\n\n    @Override\n    public void done(long time,BmobException e) {\n        if(e==null){\n            SimpleDateFormat formatter = new SimpleDateFormat( yyyy-MM-dd HH:mm );\n            String times = formatter.format(new Date(time * 1000L));\n            Log.i( bmob , 当前服务器时间为:  + times);\n        }else{\n            Log.i( bmob , 获取服务器时间失败:  + e.getMessage());\n        }\n    }\n\n});", 
            "title": "获取服务器时间"
        }, 
        {
            "location": "/data/android/develop_doc/#_131", 
            "text": "Bmob为大家提供了应用的自动更新组件，使用这个组件可以快速方便实现应用的自动升级功能。\n详细的使用操作可以参考文档： 自动更新组件文档", 
            "title": "自动更新组件"
        }, 
        {
            "location": "/data/android/develop_doc/#_132", 
            "text": "自 V3.4.2 版本开始，SDK提供了 获取表结构信息 方法,具体示例如下：", 
            "title": "表结构"
        }, 
        {
            "location": "/data/android/develop_doc/#_133", 
            "text": "Bmob.getTableSchema( 待查询的表名 , new QueryListener BmobTableSchema () {\n\n    @Override\n    public void done(BmobTableSchema schema, BmobException ex) {\n        if(ex==null){\n            Log.i( bmob ,  获取指定表的表结构信息成功： +schema.getClassName()+ - +schema.getFields().toString());\n        }else{\n            Log.i( bmob ,  获取指定表的表结构信息失败:  + ex.getLocalizedMessage()+ ( +ex.getErrorCode()+ ) );\n        }\n    }\n});", 
            "title": "获取特定表的结构"
        }, 
        {
            "location": "/data/android/develop_doc/#_134", 
            "text": "Bmob.getAllTableSchema(context, new QueryListListener BmobTableSchema () {\n\n    @Override\n    public void done(List BmobTableSchema  schemas, BmobException ex) {\n        if(ex==null   schemas!=null   schemas.size() 0){\n            Log.i( bmob ,  获取所有表结构信息成功 );\n        }else{\n            Log.i( bmob , 获取所有表结构信息失败： +ex.getLocalizedMessage()+ ( +ex.getErrorCode()+ ) );\n        }\n    }\n});", 
            "title": "获取所有表的结构"
        }, 
        {
            "location": "/data/android/develop_doc/#_135", 
            "text": "注： BmobTableSchema 参数说明：  其中  className ：表示表名  fields    ： 是Map 类型，里面包含了对应表的所有列的属性，  其fields内部结构如下：   {\"列1\":Map,\"列2\":Map, ...}   而Map的结构为：   {\"type\":\"typeName\",\"targetClass\":\"tableName\"}   其中  type  指的是该列的类型， 而  targetClass  指的是指向的表名，只有在 type 为 Pointer 或者 Relation 时才有值。  具体json格式如下,仅供参考：   {\n    className:  Post , \n    fields: {\n      ACL: {\n        type:  Object \n      }, \n      author: {\n        targetClass:  _User , \n        type:  Pointer \n      }, \n      content: {\n        type:  String \n      }, \n      createdAt: {\n        type:  Date \n      }, \n      objectId: {\n        type:  String \n      }, \n      updatedAt: {\n        type:  Date \n      }\n    }\n }", 
            "title": "返回数据说明"
        }, 
        {
            "location": "/data/android/develop_doc/#_136", 
            "text": "Android SDK的错误码都是以 9 开头的，其他错误码请点击查看： RestAPI错误码列表 。  9001  内容：AppKey is Null, Please initialize BmobSDK.  含义：Application Id为空，请初始化。  9002  内容：Parse data error  含义：解析返回数据出错  9003  内容：upload file error  含义：上传文件出错  9004  内容：upload file failure  含义：文件上传失败  9005  内容：A batch operation can not be more than 50  含义：批量操作只支持最多50条  9006  内容：objectId is null  含义：objectId为空  9007  内容：BmobFile File size must be less than 10M.  含义：文件大小超过10M  9008  内容：BmobFile File does not exist.  含义：上传文件不存在  9009  内容：No cache data.  含义：没有缓存数据  9010  内容：The network is not normal.(Time out)  含义：网络超时  9011  内容：BmobUser does not support batch operations.  含义：BmobUser类不支持批量操作  9012  内容：context is null.  含义：上下文为空  9013  内容： BmobObject Object names(database table name) format is not correct.  含义：BmobObject（数据表名称）格式不正确  9014  含义：第三方账号授权失败  9015  含义：其他错误均返回此code  9016  内容：The network is not available,please check your network!  含义：无网络连接，请检查您的手机网络。  9017  含义：与第三方登录有关的错误，具体请看对应的错误描述  9018  含义：参数不能为空  9019  含义：格式不正确：手机号码、邮箱地址、验证码", 
            "title": "错误码列表"
        }, 
        {
            "location": "/data/android/develop_doc/#_137", 
            "text": "使用了BmobSDK的应用在混淆过程中，需注意以下几点：  1、 不要混淆BmobSDK的代码 ，Bmob Android SDK本身进行了代码混淆；  2、任何继承自 BmobObject、BmobUser 的JavaBean及 在上述JavaBean中定义的Object属性类 都不要混淆，否则gson将无法将数据解析成具体对象；  3、确保 rx 、 okhttp3 okio 、 gson 及 org.apache.http.legacy.jar 包均不要混淆。  具体可参考BmobExample中proguard-project.txt的代码：  \n-ignorewarnings\n\n-keepattributes Signature,*Annotation*\n\n# keep BmobSDK\n-dontwarn cn.bmob.v3.**\n-keep class cn.bmob.v3.** {*;}\n\n# 确保JavaBean不被混淆-否则gson将无法将数据解析成具体对象\n-keep class * extends cn.bmob.v3.BmobObject {\n    *;\n}\n-keep class com.example.bmobexample.bean.BankCard{*;}\n-keep class com.example.bmobexample.bean.GameScore{*;}\n-keep class com.example.bmobexample.bean.MyUser{*;}\n-keep class com.example.bmobexample.bean.Person{*;}\n-keep class com.example.bmobexample.file.Movie{*;}\n-keep class com.example.bmobexample.file.Song{*;}\n-keep class com.example.bmobexample.relation.Post{*;}\n-keep class com.example.bmobexample.relation.Comment{*;}\n\n# keep BmobPush\n-dontwarn  cn.bmob.push.**\n-keep class cn.bmob.push.** {*;}\n\n# keep okhttp3、okio\n-dontwarn okhttp3.**\n-keep class okhttp3.** { *;}\n-keep interface okhttp3.** { *; }\n-dontwarn okio.**\n\n# keep rx\n-dontwarn sun.misc.**\n-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* {\n long producerIndex;\n long consumerIndex;\n}\n-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef {\n rx.internal.util.atomic.LinkedQueueNode producerNode;\n}\n-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef {\n rx.internal.util.atomic.LinkedQueueNode consumerNode;\n}\n\n# 如果你需要兼容6.0系统，请不要混淆org.apache.http.legacy.jar \n-dontwarn android.net.compatibility.**\n-dontwarn android.net.http.**\n-dontwarn com.android.internal.http.multipart.**\n-dontwarn org.apache.commons.**\n-dontwarn org.apache.http.**\n-keep class android.net.compatibility.**{*;}\n-keep class android.net.http.**{*;}\n-keep class com.android.internal.http.multipart.**{*;}\n-keep class org.apache.commons.**{*;}\n-keep class org.apache.http.**{*;}", 
            "title": "混淆打包"
        }, 
        {
            "location": "/data/android/example/", 
            "text": "失物招领案例教程\n\n\n需求描述\n\n\n为演示Bmob提供的云数据库的功能，本文制作了一个失物招领的简单案例，实现物品的发布、修改、呈现和删除，展示如何使用Bmob快速开发一个有后端数据库的应用软件。使用场景如下：用户捡到物品，打开手机软件，填写物品的招领信息（标题、描述和联系方式）；用户丢失物品，打开手机软件，填写物品的丢失信息（标题、描述和联系方式）；任何人都可以查看到失物和招领的信息列表，可以对发布的信息进行删除。\n\n\n说明一点的是，因为是演示案例，所以信息的添加和删除并没有进行用户身份验证。\n\n\n本案例将使用到Bmob的如下功能：\n\n\n1.添加数据\n\n\n添加失物/招领信息到服务器中。\n\n\n2.查找数据\n\n\n在列表中显示所有用户发布的失物/招领信息。\n\n\n3.删除数据\n\n\n删除已发布的失物/招领信息。\n\n\n本案例最终实现的部分界面效果如下：\n\n\n \n\n\n失物招领软件闪图\n\n\n \n\n\n招领列表页\n\n\n \n\n\n失物编辑删除功能\n\n\n \n\n\n添加失物信息\n\n\n数据结构设计\n\n\n本案例的数据结构非常简单，只需要设计两个表，一个是失物表（Lost表），一个是招领表（Found表），对应的数据结构如下（省略对常用默认字段objectId、createAt、updateAt的描述，对于还不知道怎么创建应用和添加数据表的开发朋友请先移步\n快速入门指南\n查看相关教程）：\n\n\n失物表（Lost）\n\n\n\n\n\n\n\n\n字段名\n\n\n类型\n\n\n描述\n\n\n\n\n\n\n\n\n\n\ndescribe\n\n\nString\n\n\n失物的描述信息\n\n\n\n\n\n\nphone\n\n\nString\n\n\n联系的手机号码\n\n\n\n\n\n\ntitle\n\n\nString\n\n\n失物的标题信息\n\n\n\n\n\n\n\n\n招领表（Found）\n\n\n\n\n\n\n\n\n字段名\n\n\n类型\n\n\n描述\n\n\n\n\n\n\n\n\n\n\ndescribe\n\n\nString\n\n\n招领的描述信息\n\n\n\n\n\n\nphone\n\n\nString\n\n\n联系的手机号码\n\n\n\n\n\n\ntitle\n\n\nString\n\n\n招领的标题信息\n\n\n\n\n\n\n\n\n初始化SDK\n\n\nBmob为每个应用都提供了一个唯一标识（对应为开发者后台应用中的“应用密钥-\nApplication ID”），使用Bmob开发的应用都要首先使用这个Application ID”进行初始化。对应代码如下（详细代码实现参看BaseActivity类）：\n\n\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    //初始化 Bmob SDK，第一个参数为上下文，第二个参数为Application ID\n    Bmob.initialize(this, Constants.Bmob_APPID);\n    //其他代码\n}\n\n\n\n\n创建数据模型类\n\n\n为操作Bmob的云端数据库，SDK首先需要创建数据表对应的模型类（模型类的名称必须和云端数据表的名称一致），该类需要继承自BmobObject，实现刚刚创建的数据表字段的set和get方法（系统默认字段objectId、createAt、updateAt不需要声明）。因为本案例需要操作Lost表和Found表，因此需要创建Lost类和Found类。下面是Lost模型类的实现代码（Found模型类的实现代码略）：\n\n\npublic class Lost extends BmobObject{\n\n    private String title;//标题\n    private String describe;//描述\n    private String phone;//联系手机\n    public String getTitle() {\n        return title;\n    }\n    public void setTitle(String title) {\n        this.title = title;\n    }\n    public String getDescribe() {\n        return describe;\n    }\n    public void setDescribe(String describe) {\n        this.describe = describe;\n    }\n    public String getPhone() {\n        return phone;\n    }\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n}\n\n\n\n\n\n添加失物及招领信息\n\n\n用户填写了失物信息之后，只需要构造一个Lost实例，然后简单调用模型类的insertObject方法（第一个参数是上下文，第二个参数是插入信息的回调类）就可以将信息添加到云数据库中，实现代码如下（详细代码实现参看AddActivity类）：\n\n\n        Lost lost = new Lost();\n        lost.setDescribe(describe);\n        lost.setPhone(photo);\n        lost.setTitle(title);\n        lost.save(this, new SaveListener() {\n\n            @Override\n            public void onSuccess() {\n                ShowToast(\n失物信息添加成功!\n);\n                //其他代码\n            }\n\n            @Override\n            public void onFailure(int code, String arg0) {\n                ShowToast(\n添加失败:\n+arg0);\n            }\n        });\n\n\n\n\n获取失物及招领列表\n\n\nBmob提供了复杂和简单的查询方法，可以对查询结果进行排序，可以对结果进行缓存。本案例只使用到Bmob提供的最简单的查询和排序功能，直接调用BmobQuery类的findObjects方法和order方法来获取失物列表，实现代码如下（详细代码实现参看MainActivity类）：\n\n\n        BmobQuery\nLost\n query = new BmobQuery\nLost\n();\n        //按照时间降序\n        query.order(\n-createdAt\n);\n        //执行查询，第一个参数为上下文，第二个参数为查找的回调\n        query.findObjects(this, new FindListener\nLost\n() {\n\n            @Override\n            public void onSuccess(List\nLost\n losts) {\n                .....\n                //将结果显示在列表中\n                LostAdapter.addAll(losts);\n                .....\n            }\n\n            @Override\n            public void onError(int code, String arg0) {\n                showErrorView(0);\n            }\n        });\n\n\n\n\n删除失物及招领信息\n\n\nBmob云数据库对每条新增的数据都有一个唯一标识（objectId），这类似于传统SQL数据库中的唯一主键的性质。从云数据库中删除某条记录需要设置这个要删除的ObjectId的信息，再调用模型类的deleteObject方法就可以了，实现代码如下（详细代码实现参看MainActivity类的deleteLost方法）：\n\n\n        Lost lost = new Lost();\n        //设置ObjectId信息\n        lost.setObjectId(LostAdapter.getItem(position).getObjectId());\n        //执行删除方法，第一个参数为上下文，第二个参数为删除的回调\n        lost.delete(this, new DeleteListener() {\n\n            @Override\n            public void onSuccess() {\n                //删除成功\n                LostAdapter.remove(position);\n            }\n\n            @Override\n            public void onFailure(int code, String arg0) {\n                //删除失败\n            }\n        });\n\n\n\n\n后记\n\n\n本案例只是演示如何用Bmob进行快速的数据增删改查，在真实的应用环境下，你还可能还需要使用到用户系统、文件服务、更复杂的数据结构和服务，这些都可以使用Bmob就可以实现。如果想要获取更多的信息，请各位查看Bmob的\n开发文档\n或者联系技术客服。欢迎砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～\n\n\n案例下载\n\n\n失物招领案例下载\n\n\n上传文件案例教程\n\n\n上传文件需求描述\n\n\n相对于移动网络和数据服务而言，文件服务往往需要更长的i/o时间，因此也就涉及到更多的异步操作的问题。不少朋友在用到Bmob文件服务的时候出错，原因就是没有充分理解同步和异步的本质。为方便大家理解Bmob的文件服务，这里提供一个上传文件的案例，从如何往一个只有一列文件字段的表中插入一条或者多条，到如何往一个有两列甚至多列文件字段的表中插入一条或者多条数据进行详细阐述。\n\n\n案例的界面效果如下：\n\n\n \n\n\n上传文件数据结构设计\n\n\n本案例的数据结构非常简单，只需要设计两个表，一个是电影表（Movie表，只有一个File字段），一个是音乐表（Music表，有两个File字段），对应的数据结构如下（省略对常用默认字段objectId、createAt、updateAt的描述，对于还不知道怎么创建应用和添加数据表的开发朋友请先移步\n快速入门指南\n查看相关教程）：\n\n\n电影表（Movie表）\n\n\n\n\n\n\n\n\n字段名\n\n\n类型\n\n\n描述\n\n\n\n\n\n\n\n\n\n\nname\n\n\nString\n\n\n电影名称\n\n\n\n\n\n\nfile\n\n\nFile\n\n\n电影文件\n\n\n\n\n\n\n\n\n音乐表（Music表）\n\n\n\n\n\n\n\n\n字段名\n\n\n类型\n\n\n描述\n\n\n\n\n\n\n\n\n\n\nname\n\n\nString\n\n\n歌曲名称\n\n\n\n\n\n\nartist\n\n\nString\n\n\n艺术家\n\n\n\n\n\n\nmp3\n\n\nFile\n\n\nmp3文件\n\n\n\n\n\n\nlrc\n\n\nFile\n\n\n歌词文件\n\n\n\n\n\n\n\n\n安装和初始化SDK\n\n\nBmob为每个应用都提供了一个唯一标识（对应为开发者后台应用中的“应用密钥-\nApplication ID”），使用Bmob开发的应用都要首先使用这个Application ID”进行初始化。对应代码如下（详细代码实现参看BaseActivity类，PS：大家可以顺便体会下创建BaseActivity类的好处^_^）：\n\n\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    //初始化 Bmob SDK，第一个参数为上下文，第二个参数为Application ID\n    Bmob.initialize(this, Constants.Bmob_APPID);\n    //其他代码\n}\n\n\n\n\n创建模型类文件\n\n\n为操作Bmob的云端数据库，SDK首先需要创建数据表对应的模型类（模型类的名称必须和云端数据表的名称一致），该类需要继承自BmobObject，实现刚刚创建的数据表字段的set和get方法（系统默认字段objectId、createAt、updateAt不需要声明）。因为本案例需要操作Movie表和Music表，因此需要创建Movie类和Music类。下面是Movie模型类的实现代码（Music模型类的实现代码略）：\n\n\n\npublic class Movie extends BmobObject {\nprivate String name;//电影名称\nprivate BmobFile file;//电影文件\n\npublic Movie(){\n}\n\npublic Movie(String name,BmobFile file){\n    this.name =name;\n    this.file = file;\n}\n\npublic String getName() {\n    return name;\n}\n\npublic void setName(String name) {\n    this.name = name;\n}\n\npublic BmobFile getFile() {\n    return file;\n}\n\npublic void setFile(BmobFile file) {\n    this.file = file;\n}\n}\n\n\n\n\n\n上传一条单个文件的数据\n\n\n往Movie表中添加一条数据非常简单，只需要等到文件上传（BmobFile类的upload方法上传）成功之后，再调用数据服务的insertObject方法将这条数据插入到云数据库中就可以了。实现代码如下：\n\n\n\nfinal BmobFile bmobFile = new BmobFile(file);\nbmobFile.uploadblock(this, new UploadFileListener() {\n\n    @Override\n    public void onSuccess() {\n        // TODO Auto-generated method stub\n        Log.i(TAG, \n电影文件上传成功，返回的名称--\n+bmobFile.getFileUrl(MainActivity.this));\n        insertObject(new Movie(\n冰封：重生之门\n,bmobFile));\n    }\n\n    @Override\n    public void onProgress(Integer arg0) {\n        // TODO Auto-generated method stub\n    }\n\n    @Override\n    public void onFailure(int arg0, String arg1) {\n        // TODO Auto-generated method stub\n        ShowToast(\n--\nuploadMovoieFile--\nonFailure:\n + arg0+\n,msg = \n+arg1);\n    }\n\n});\n\n\n\n\n\n批量上传多条单个文件的数据\n\n\n往Movie表中插入多条数据时，本案例的实现逻辑是：先调用Bmob提供的批量上传文件的方法，等所有文件都上传成功之后，再进行数据的批量添加操作（见下面的代码片段B）。代码片段A如下：\n\n\n\npublic void insertBatchDatasWithOne(){\nString[] filePaths = new String[2];\nfilePaths[0] = filePath_mp3;\nfilePaths[1] = filePath_lrc;\n//批量上传是会依次上传文件夹里面的文件\nBmob.uploadBatch(this, filePaths, new UploadBatchListener() {\n\n    @Override\n    public void onSuccess(List\nBmobFile\n files,List\nString\n urls) {\n        // TODO Auto-generated method stub\n        Log.i(\nlife\n,\ninsertBatchDatasWithOne -onSuccess :\n+urls.size()+\n-----\n+files+\n----\n+urls);\n        if(urls.size()==1){//如果第一个文件上传完成\n            Movie movie =new Movie(\n哈利波特1\n,files.get(0));\n            movies.add(movie);\n        }else if(urls.size()==2){//第二个文件上传成功\n            Movie movie1 =new Movie(\n哈利波特2\n,files.get(1));\n            movies.add(movie1);\n            insertBatch(movies);\n        }\n    }\n\n    @Override\n    public void onError(int statuscode, String errormsg) {\n        // TODO Auto-generated method stub\n        ShowToast(\n错误码\n+statuscode +\n,错误描述：\n+errormsg);\n    }\n\n    @Override\n    public void onProgress(int curIndex, int curPercent, int total,\n            int totalPercent) {\n        // TODO Auto-generated method stub\n        Log.i(\nlife\n,\ninsertBatchDatasWithOne -onProgress :\n+curIndex+\n---\n+curPercent+\n---\n+total+\n----\n+totalPercent);\n    }\n});\n\n}\n\n\n\n\n代码片段B如下：\n\n\n\npublic void insertBatch(List\nBmobObject\n files){\n    new BmobObject().insertBatch(MainActivity.this, files, new SaveListener() {\n\n        @Override\n        public void onSuccess() {\n            // TODO Auto-generated method stub\n            ShowToast(\n----\n批量更新成功\n);\n        }\n\n        @Override\n        public void onFailure(int arg0, String arg1) {\n            // TODO Auto-generated method stub\n            ShowToast(\n----\n批量更新失败\n+arg0);\n\n        }\n    });\n}\n\n\n\n\n注：BmobSDK_v3.2.7版本提供了文件批量上传的方法，支持一键上传多个文件，非常方便和实用。\n\n\n上传一条多个文件的数据\n\n\n往Music表中插入一条有两个文件的数据的逻辑跟前面的类似，首先进行文件的同步上传操作，示例代码如下：\n\n\n\nString[] filePaths = new String[2];\nfilePaths[0] = filePath_mp3;\nfilePaths[1] = filePath_lrc;\nBmob.uploadBatch(this, filePaths, new UploadBatchListener() {\n\n    @Override\n    public void onSuccess(List\nBmobFile\n files,List\nString\n urls) {\n        // TODO Auto-generated method stub\n        Log.i(\nlife\n,\ninsertDataWithMany -onSuccess :\n+urls.size()+\n-----\n+files+\n----\n+urls);\n        if(urls.size()==2){//如果全部上传完，则更新该条记录\n            Song song =new Song(\n汪峰0\n,\n北京北京0\n,files.get(0),files.get(1));\n            insertObject(song);\n        }else{\n            //有可能上传不完整，中间可能会存在未上传成功的情况，你可以自行处理\n        }\n    }\n\n    @Override\n    public void onError(int statuscode, String errormsg) {\n        // TODO Auto-generated method stub\n        ShowToast(\n错误码\n+statuscode +\n,错误描述：\n+errormsg);\n    }\n\n    @Override\n    public void onProgress(int curIndex, int curPercent, int total,\n            int totalPercent) {\n        // TODO Auto-generated method stub\n        Log.i(\nlife\n,\ninsertBatchDatasWithOne -onProgress :\n+curIndex+\n---\n+curPercent+\n---\n+total+\n----\n+totalPercent);\n    }\n});\n\n\n\n\n上传成功之后，再进行数据的添加操作。示例代码如下：\n\n\n\nprivate void insertObject(final BmobObject obj){\n    obj.save(MainActivity.this, new SaveListener() {\n\n        @Override\n        public void onSuccess() {\n            // TODO Auto-generated method stub\n            ShowToast(\n--\n创建数据成功：\n + obj.getObjectId());\n\n        }\n\n        @Override\n        public void onFailure(int arg0, String arg1) {\n            // TODO Auto-generated method stub\n            ShowToast(\n--\n创建数据失败：\n + arg0+\n,msg = \n+arg1);\n        }\n    });\n}\n\n\n\n\n\n批量上传多条多个文件的数据\n\n\n往Music表中插入多条有两个文件的逻辑也一样，同样先进行文件的批量上传操作，最后进行批量更新操作。由于代码都非常相似，这里就不再一一详细阐述，想要知道实现代码的朋友可以直接下载我们的案例代码进行查看。\n\n\n上传文件后记\n\n\n文件上传是移动领域最基础的服务，BmobSDK_v3.2.7提供了批量上传文件的方法，此方法大大简化了开发者对文件的批量操作，也欢迎大家提出更多的意见和建议帮助Bmob更好的发展。谢谢～\n\n\n注：如需查看该文的相关代码，可自行去官网下载的BmobSDK_v3.2.7版本下的BmobExample示例工程中BmobFileActivity类查看。也可以去bodismile的github地址\nhttps://github.com/bodismile/bmob-android-upload-file\n 查看。\n\n\n反馈案例教程\n\n\n反馈案例需求描述\n\n\n用户反馈是移动开发中最常见的功能，可以用来收集我们的用户对软件的意见和建议。通常在开发用户反馈功能时，我们都会将用户反馈的信息保存到服务器中，定期登录后台管理系统查看，这样很难做到实时查看用户反馈信息。本文结合Bmob推送服务和数据存储服务开发用户反馈功能，实现用户提交反馈信息保存在Bmob云数据库的同时，也将用户的反馈信息推送到运营/研发人员的设备中。\n\n\n本案例将使用到Bmob的如下功能：\n\n\n1.推送服务\n将用户的反馈信息实时推送到订阅了接收反馈信息的设备中，实现端到端的消息传递。\n\n\n2.数据存储服务\n\n\n添加和查看反馈信息，使用到了添加、查询和按时间排序的功能。\n\n\n本案例最终实现的界面效果如下：\n\n\n \n\n\n发送反馈截图\n\n\n \n\n\n查看反馈意见截图\n\n\n反馈案例数据结构设计\n\n\n在Bmob开发者后台创建一个应用（还不知道怎么创建应用和添加数据表的开发朋友请先移步\n快速入门指南\n查看相关教程），添加两个表，分别是Feedback（用户反馈信息表，存储用户提交的反馈信息）和Installation（设备安装表，存储需要接收推送信息的设备信息）。以下是对这两个表的数据结构的详细描述（省略对常用默认字段objectId、createAt、updateAt的描述）\n\n\nFeedback表\n\n\n\n\n\n\n\n\n字段名\n\n\n类型\n\n\n描述\n\n\n\n\n\n\n\n\n\n\nContact\n\n\nString\n\n\n用户的联系方式\n\n\n\n\n\n\ndeviceType\n\n\nString\n\n\n系统字段，是一个必须的字段, 必须被设置为 \"ios\" 或者 \"android\", 而且自这个对象生成以后就不能变化\n\n\n\n\n\n\n\n\nInstallation表\n\n\n\n\n\n\n\n\n字段名\n\n\n类型\n\n\n描述\n\n\n\n\n\n\n\n\n\n\ninstallationId\n\n\nString\n\n\n系统字段，是一个Bmob生成的字符串标志, 而且如果 deviceType 是 android 的话是一个必填字段, 如果是 ios 的话则可选. 它只要对象被生成了就不能发生改变, 而且对一个 app 来说是不可重复的\n\n\n\n\n\n\ndeviceToken\n\n\nString\n\n\n系统字段，是一个 Apple 生成的字符串标志, 在 deviceType 为 ios 上的设备是必须的, 而且自对象生成开始就不能改动, 对于一个 app 来说也是不可重复的\n\n\n\n\n\n\nbadge\n\n\nNumber\n\n\n系统字段，表示iOS 设备最新已知的应用badge\n\n\n\n\n\n\ntimeZone\n\n\nString\n\n\n系统字段，表示安装的这个设备的系统时区\n\n\n\n\n\n\nchannels\n\n\nArray\n\n\n系统字段，表示这个安装对象的订阅频道列表\n\n\n\n\n\n\nappIdentifiter\n\n\nString\n\n\niOS应用的Bundle identifier\n\n\n\n\n\n\nisDeveloper\n\n\nBoolean\n\n\n是否是开发者（是的话则用于接收推送信息）\n\n\n\n\n\n\n\n\n安装和初始化\n\n\n还不知道怎么安装使用Bmob数据存储Sdk的开发朋友请先移步快速入门指南查看相关教程。\n推送服务的SDK初始化和Bmob数据存储SDK一样，只需要在Activity的onCreate方法中简单调用BmobPush.startWork方法就可以了，代码如下（详细代码见MainActivity类）：\n\n\n//这里替换为你的APP Key\n    public static String APPID = \n;    \n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        Bmob.initialize(this, APPID);\n        BmobPush.startWork(this, APPID);    \n    }\n\n\n\n\n发送反馈功能的开发\n\n\n这里要实现的是当用户点击“发送”反馈按钮之后，先把用户的反馈信息上传到Bmob云数据库中，然后发送一条推送信息到Installation表中isDeveloper为true的设备中去。\n\n\n为实现将数据保存到云数据库的功能，你首先需要先创建一个Feedback类（需要与刚刚创建的数据表Feedback名称对应一致），该类继承自BmobObject类，实现contact和content的set和get方法。实现代码如下（详细代码见Feedback类）：\n\n\npublic class Feedback extends BmobObject {\n    //反馈内容\n    private String content;\n    //联系方式\n    private String contacts;\n    public String getContent() {\n        return content;\n    }\n    public void setContent(String content) {\n        this.content = content;\n    }\n    public String getContacts() {\n        return contacts;\n    }\n    public void setContacts(String contacts) {\n        this.contacts = contacts;\n    }\n}\n\n\n\n\n有了Feedback类，你就可以方便的通过BmobObject的insertObject方法操作云数据库，将数据保存上去了。实现代码如下（详细代码见ActSendFeedback类）：\n\n\n    /**\n     * 保存反馈信息到Bmob云数据库中\n     * @param msg 反馈信息\n     */\n    private void saveFeedbackMsg(String msg){\n        Feedback feedback = new Feedback();\n        feedback.setContent(msg);\n        feedback.save(this, new SaveListener() {\n\n            @Override\n            public void onSuccess() {\n                Log.i(\nbmob\n, \n反馈信息已保存到服务器\n);\n                //发送推送信息\n                saveFeedbackMsg(message);\n            }\n\n            @Override\n            public void onFailure(int code, String arg0) {\n                // TODO Auto-generated method stub\n                Log.e(\nbmob\n, \n保存反馈信息失败：\n+arg0);\n            }\n        });\n    }\n\n\n\n\n    /**\n     * 推送反馈信息给isDeveloper的设备\n     * @param message 反馈信息\n     */\n    private void sendMessage(String message){\n        BmobPushManager bmobPush = new BmobPushManager(this);\n        BmobQuery\nBmobInstallation\n query = BmobInstallation.getQuery();\n        query.addWhereEqualTo(\nisDeveloper\n, true);\n        bmobPush.setQuery(query);\n        bmobPush.pushMessage(message);\n    }\n\n\n\n\n查看反馈功能的开发\n\n\n为了接收用户端推送过来的反馈信息，查看反馈端需要自定义一个继承自BmobPushMessageReceiver的类，用于处理接收到的推送信息。实现代码如下：\n\n\npublic class MyMessageReceiver extends BmobPushMessageReceiver {\n\n    @Override\n    public void onMessage(Context context, String message) {\n        Log.d(\nbmob\n, \n收到反馈消息 = \n+message);\n        //通知栏显示收到的反馈信息\n        NotificationManager nm = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);\n        Notification n = new Notification();  \n        n.icon = R.drawable.ic_launcher;  \n        n.tickerText = \n收到反馈消息\n;  \n        n.when = System.currentTimeMillis();  \n        Intent intent = new Intent(context, ActFeedbackList.class);  \n        PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);  \n        n.setLatestEventInfo(context, \n消息\n, message, pi);  \n        n.defaults |= Notification.DEFAULT_SOUND;\n        n.flags = Notification.FLAG_AUTO_CANCEL;\n        nm.notify(1, n);\n    }\n}\n\n\n\n\n查看反馈列表的功能实现也很简单，只需要调用BmobObject的findObjects方法就可以了，实现代码如下（详细代码见ActFeedbackList类）：\n\n\nBmobQuery\nFeedback\n query = new BmobQuery\nFeedback\n();\n//按createAt降序排列\nquery.order(\n-createdAt\n);\nquery.findObjects(this, new FindListener\nFeedback\n() {\n\n    @Override\n    public void onSuccess(List\nFeedback\n arg0) {\n        //显示反馈列表信息\n        adapter = new FeedbackAdapter(ActFeedbackList.this, arg0);\n        listView.setAdapter(adapter);\n    }\n\n    @Override\n    public void onError(int code, String arg0) {\n        emptyView.setText(arg0);\n    }\n});\n\n\n\n\n反馈案例后记\n\n\n当然了，实际使用过程的反馈功能可能并没有那么简单，或许你需要实现能够直接跟用户对话的反馈功能，或许你想要实现智能化的机器回答，这些都可以使用Bmob移动云服务平台进行快速设计和开发的。欢迎各位砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～\n\n\n反馈案例案例下载\n\n\n反馈案例下载\n\n\n其它案例\n\n\n快速入门相关源码下载\nhttp://www.bmob.cn/static/Bmob_android_quickstart.zip\n\n\n即时聊天案例源码\nhttps://github.com/bmob/BmobIMSDK4Android\n\n\n图文社区案例源码：\nhttps://git.oschina.net/v7/Wonderful\n  这个案例是猿圈媛圈开发团队提供的。\n\n\n图文分享案例源码：\nhttps://github.com/smartbetter/AndroidWonderful\n 这个案例是一个叫郭朝的开发者提供的。\n\n\n校园小菜案例源码：\nhttps://github.com/bmob/Shop\n 这个案例是湖工大的朋友提供的。\n\n\n社交分享案例源码：\nhttps://github.com/bmob/bmob-android-social-share\n 这个是金刚锁开发者提供的\n\n\n第三方登录案例源码：\nhttps://github.com/bmob/bmob-android-demo-thirdpartylogin\n  包含第三方登录和登录后获取用户信息的源码。\n\n\n自定义表名情况下增删改查数据的Demo，下载地址是：\nhttps://github.com/bmob/bmob-android-demo-dynamic-tablename\n。\n\n\n使用分页查询，结合ListView开发下拉刷新查看更多内容\nhttps://github.com/bmob/bmob-android-demo-paging\n。\n\n\n短信验证的demo：\nhttps://github.com/bmob/bmob_android_demo_sms\n 。\n\n\n缩略图案例源码：\nhttps://github.com/bmob/bmob-android-demo-thumbnail\n\n\n数据的实时同步服务应用实例（ \nhttps://github.com/bmob/bmob-android-demo-realtime-data\n ）供大家参考。\n\n\nACL相关的案例源码：\nhttps://github.com/bmob/bmob-android-demo-acl\n\n\n推送案例Demo:\nhttps://github.com/bmob/bmob-android-demo-push\n\n\nBmobSDK自动更新实例程序源码：\nhttps://github.com/bmob/bmob-android-demo-autoupdate\n\n\n踢球吧源码\nhttps://github.com/bmob/BmobTiQiuBa\n\n\nandroid云端逻辑案例:\nhttp://www.bmob.cn/static/Bmob_Sample_android_cloud.zip\n\n\n基于Bmob的二维码扫描工具:\nhttps://github.com/bmob/FindLook", 
            "title": "示例/功能"
        }, 
        {
            "location": "/data/android/example/#_1", 
            "text": "", 
            "title": "失物招领案例教程"
        }, 
        {
            "location": "/data/android/example/#_2", 
            "text": "为演示Bmob提供的云数据库的功能，本文制作了一个失物招领的简单案例，实现物品的发布、修改、呈现和删除，展示如何使用Bmob快速开发一个有后端数据库的应用软件。使用场景如下：用户捡到物品，打开手机软件，填写物品的招领信息（标题、描述和联系方式）；用户丢失物品，打开手机软件，填写物品的丢失信息（标题、描述和联系方式）；任何人都可以查看到失物和招领的信息列表，可以对发布的信息进行删除。  说明一点的是，因为是演示案例，所以信息的添加和删除并没有进行用户身份验证。  本案例将使用到Bmob的如下功能：  1.添加数据  添加失物/招领信息到服务器中。  2.查找数据  在列表中显示所有用户发布的失物/招领信息。  3.删除数据  删除已发布的失物/招领信息。  本案例最终实现的部分界面效果如下：     失物招领软件闪图     招领列表页     失物编辑删除功能     添加失物信息", 
            "title": "需求描述"
        }, 
        {
            "location": "/data/android/example/#_3", 
            "text": "本案例的数据结构非常简单，只需要设计两个表，一个是失物表（Lost表），一个是招领表（Found表），对应的数据结构如下（省略对常用默认字段objectId、createAt、updateAt的描述，对于还不知道怎么创建应用和添加数据表的开发朋友请先移步 快速入门指南 查看相关教程）：  失物表（Lost）     字段名  类型  描述      describe  String  失物的描述信息    phone  String  联系的手机号码    title  String  失物的标题信息     招领表（Found）     字段名  类型  描述      describe  String  招领的描述信息    phone  String  联系的手机号码    title  String  招领的标题信息", 
            "title": "数据结构设计"
        }, 
        {
            "location": "/data/android/example/#sdk", 
            "text": "Bmob为每个应用都提供了一个唯一标识（对应为开发者后台应用中的“应用密钥- Application ID”），使用Bmob开发的应用都要首先使用这个Application ID”进行初始化。对应代码如下（详细代码实现参看BaseActivity类）：  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    //初始化 Bmob SDK，第一个参数为上下文，第二个参数为Application ID\n    Bmob.initialize(this, Constants.Bmob_APPID);\n    //其他代码\n}", 
            "title": "初始化SDK"
        }, 
        {
            "location": "/data/android/example/#_4", 
            "text": "为操作Bmob的云端数据库，SDK首先需要创建数据表对应的模型类（模型类的名称必须和云端数据表的名称一致），该类需要继承自BmobObject，实现刚刚创建的数据表字段的set和get方法（系统默认字段objectId、createAt、updateAt不需要声明）。因为本案例需要操作Lost表和Found表，因此需要创建Lost类和Found类。下面是Lost模型类的实现代码（Found模型类的实现代码略）：  public class Lost extends BmobObject{\n\n    private String title;//标题\n    private String describe;//描述\n    private String phone;//联系手机\n    public String getTitle() {\n        return title;\n    }\n    public void setTitle(String title) {\n        this.title = title;\n    }\n    public String getDescribe() {\n        return describe;\n    }\n    public void setDescribe(String describe) {\n        this.describe = describe;\n    }\n    public String getPhone() {\n        return phone;\n    }\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n}", 
            "title": "创建数据模型类"
        }, 
        {
            "location": "/data/android/example/#_5", 
            "text": "用户填写了失物信息之后，只需要构造一个Lost实例，然后简单调用模型类的insertObject方法（第一个参数是上下文，第二个参数是插入信息的回调类）就可以将信息添加到云数据库中，实现代码如下（详细代码实现参看AddActivity类）：          Lost lost = new Lost();\n        lost.setDescribe(describe);\n        lost.setPhone(photo);\n        lost.setTitle(title);\n        lost.save(this, new SaveListener() {\n\n            @Override\n            public void onSuccess() {\n                ShowToast( 失物信息添加成功! );\n                //其他代码\n            }\n\n            @Override\n            public void onFailure(int code, String arg0) {\n                ShowToast( 添加失败: +arg0);\n            }\n        });", 
            "title": "添加失物及招领信息"
        }, 
        {
            "location": "/data/android/example/#_6", 
            "text": "Bmob提供了复杂和简单的查询方法，可以对查询结果进行排序，可以对结果进行缓存。本案例只使用到Bmob提供的最简单的查询和排序功能，直接调用BmobQuery类的findObjects方法和order方法来获取失物列表，实现代码如下（详细代码实现参看MainActivity类）：          BmobQuery Lost  query = new BmobQuery Lost ();\n        //按照时间降序\n        query.order( -createdAt );\n        //执行查询，第一个参数为上下文，第二个参数为查找的回调\n        query.findObjects(this, new FindListener Lost () {\n\n            @Override\n            public void onSuccess(List Lost  losts) {\n                .....\n                //将结果显示在列表中\n                LostAdapter.addAll(losts);\n                .....\n            }\n\n            @Override\n            public void onError(int code, String arg0) {\n                showErrorView(0);\n            }\n        });", 
            "title": "获取失物及招领列表"
        }, 
        {
            "location": "/data/android/example/#_7", 
            "text": "Bmob云数据库对每条新增的数据都有一个唯一标识（objectId），这类似于传统SQL数据库中的唯一主键的性质。从云数据库中删除某条记录需要设置这个要删除的ObjectId的信息，再调用模型类的deleteObject方法就可以了，实现代码如下（详细代码实现参看MainActivity类的deleteLost方法）：          Lost lost = new Lost();\n        //设置ObjectId信息\n        lost.setObjectId(LostAdapter.getItem(position).getObjectId());\n        //执行删除方法，第一个参数为上下文，第二个参数为删除的回调\n        lost.delete(this, new DeleteListener() {\n\n            @Override\n            public void onSuccess() {\n                //删除成功\n                LostAdapter.remove(position);\n            }\n\n            @Override\n            public void onFailure(int code, String arg0) {\n                //删除失败\n            }\n        });", 
            "title": "删除失物及招领信息"
        }, 
        {
            "location": "/data/android/example/#_8", 
            "text": "本案例只是演示如何用Bmob进行快速的数据增删改查，在真实的应用环境下，你还可能还需要使用到用户系统、文件服务、更复杂的数据结构和服务，这些都可以使用Bmob就可以实现。如果想要获取更多的信息，请各位查看Bmob的 开发文档 或者联系技术客服。欢迎砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～", 
            "title": "后记"
        }, 
        {
            "location": "/data/android/example/#_9", 
            "text": "失物招领案例下载", 
            "title": "案例下载"
        }, 
        {
            "location": "/data/android/example/#_10", 
            "text": "", 
            "title": "上传文件案例教程"
        }, 
        {
            "location": "/data/android/example/#_11", 
            "text": "相对于移动网络和数据服务而言，文件服务往往需要更长的i/o时间，因此也就涉及到更多的异步操作的问题。不少朋友在用到Bmob文件服务的时候出错，原因就是没有充分理解同步和异步的本质。为方便大家理解Bmob的文件服务，这里提供一个上传文件的案例，从如何往一个只有一列文件字段的表中插入一条或者多条，到如何往一个有两列甚至多列文件字段的表中插入一条或者多条数据进行详细阐述。  案例的界面效果如下：", 
            "title": "上传文件需求描述"
        }, 
        {
            "location": "/data/android/example/#_12", 
            "text": "本案例的数据结构非常简单，只需要设计两个表，一个是电影表（Movie表，只有一个File字段），一个是音乐表（Music表，有两个File字段），对应的数据结构如下（省略对常用默认字段objectId、createAt、updateAt的描述，对于还不知道怎么创建应用和添加数据表的开发朋友请先移步 快速入门指南 查看相关教程）：  电影表（Movie表）     字段名  类型  描述      name  String  电影名称    file  File  电影文件     音乐表（Music表）     字段名  类型  描述      name  String  歌曲名称    artist  String  艺术家    mp3  File  mp3文件    lrc  File  歌词文件", 
            "title": "上传文件数据结构设计"
        }, 
        {
            "location": "/data/android/example/#sdk_1", 
            "text": "Bmob为每个应用都提供了一个唯一标识（对应为开发者后台应用中的“应用密钥- Application ID”），使用Bmob开发的应用都要首先使用这个Application ID”进行初始化。对应代码如下（详细代码实现参看BaseActivity类，PS：大家可以顺便体会下创建BaseActivity类的好处^_^）：  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    //初始化 Bmob SDK，第一个参数为上下文，第二个参数为Application ID\n    Bmob.initialize(this, Constants.Bmob_APPID);\n    //其他代码\n}", 
            "title": "安装和初始化SDK"
        }, 
        {
            "location": "/data/android/example/#_13", 
            "text": "为操作Bmob的云端数据库，SDK首先需要创建数据表对应的模型类（模型类的名称必须和云端数据表的名称一致），该类需要继承自BmobObject，实现刚刚创建的数据表字段的set和get方法（系统默认字段objectId、createAt、updateAt不需要声明）。因为本案例需要操作Movie表和Music表，因此需要创建Movie类和Music类。下面是Movie模型类的实现代码（Music模型类的实现代码略）：  \npublic class Movie extends BmobObject {\nprivate String name;//电影名称\nprivate BmobFile file;//电影文件\n\npublic Movie(){\n}\n\npublic Movie(String name,BmobFile file){\n    this.name =name;\n    this.file = file;\n}\n\npublic String getName() {\n    return name;\n}\n\npublic void setName(String name) {\n    this.name = name;\n}\n\npublic BmobFile getFile() {\n    return file;\n}\n\npublic void setFile(BmobFile file) {\n    this.file = file;\n}\n}", 
            "title": "创建模型类文件"
        }, 
        {
            "location": "/data/android/example/#_14", 
            "text": "往Movie表中添加一条数据非常简单，只需要等到文件上传（BmobFile类的upload方法上传）成功之后，再调用数据服务的insertObject方法将这条数据插入到云数据库中就可以了。实现代码如下：  \nfinal BmobFile bmobFile = new BmobFile(file);\nbmobFile.uploadblock(this, new UploadFileListener() {\n\n    @Override\n    public void onSuccess() {\n        // TODO Auto-generated method stub\n        Log.i(TAG,  电影文件上传成功，返回的名称-- +bmobFile.getFileUrl(MainActivity.this));\n        insertObject(new Movie( 冰封：重生之门 ,bmobFile));\n    }\n\n    @Override\n    public void onProgress(Integer arg0) {\n        // TODO Auto-generated method stub\n    }\n\n    @Override\n    public void onFailure(int arg0, String arg1) {\n        // TODO Auto-generated method stub\n        ShowToast( -- uploadMovoieFile-- onFailure:  + arg0+ ,msg =  +arg1);\n    }\n\n});", 
            "title": "上传一条单个文件的数据"
        }, 
        {
            "location": "/data/android/example/#_15", 
            "text": "往Movie表中插入多条数据时，本案例的实现逻辑是：先调用Bmob提供的批量上传文件的方法，等所有文件都上传成功之后，再进行数据的批量添加操作（见下面的代码片段B）。代码片段A如下：  \npublic void insertBatchDatasWithOne(){\nString[] filePaths = new String[2];\nfilePaths[0] = filePath_mp3;\nfilePaths[1] = filePath_lrc;\n//批量上传是会依次上传文件夹里面的文件\nBmob.uploadBatch(this, filePaths, new UploadBatchListener() {\n\n    @Override\n    public void onSuccess(List BmobFile  files,List String  urls) {\n        // TODO Auto-generated method stub\n        Log.i( life , insertBatchDatasWithOne -onSuccess : +urls.size()+ ----- +files+ ---- +urls);\n        if(urls.size()==1){//如果第一个文件上传完成\n            Movie movie =new Movie( 哈利波特1 ,files.get(0));\n            movies.add(movie);\n        }else if(urls.size()==2){//第二个文件上传成功\n            Movie movie1 =new Movie( 哈利波特2 ,files.get(1));\n            movies.add(movie1);\n            insertBatch(movies);\n        }\n    }\n\n    @Override\n    public void onError(int statuscode, String errormsg) {\n        // TODO Auto-generated method stub\n        ShowToast( 错误码 +statuscode + ,错误描述： +errormsg);\n    }\n\n    @Override\n    public void onProgress(int curIndex, int curPercent, int total,\n            int totalPercent) {\n        // TODO Auto-generated method stub\n        Log.i( life , insertBatchDatasWithOne -onProgress : +curIndex+ --- +curPercent+ --- +total+ ---- +totalPercent);\n    }\n});\n\n}  代码片段B如下：  \npublic void insertBatch(List BmobObject  files){\n    new BmobObject().insertBatch(MainActivity.this, files, new SaveListener() {\n\n        @Override\n        public void onSuccess() {\n            // TODO Auto-generated method stub\n            ShowToast( ---- 批量更新成功 );\n        }\n\n        @Override\n        public void onFailure(int arg0, String arg1) {\n            // TODO Auto-generated method stub\n            ShowToast( ---- 批量更新失败 +arg0);\n\n        }\n    });\n}  注：BmobSDK_v3.2.7版本提供了文件批量上传的方法，支持一键上传多个文件，非常方便和实用。", 
            "title": "批量上传多条单个文件的数据"
        }, 
        {
            "location": "/data/android/example/#_16", 
            "text": "往Music表中插入一条有两个文件的数据的逻辑跟前面的类似，首先进行文件的同步上传操作，示例代码如下：  \nString[] filePaths = new String[2];\nfilePaths[0] = filePath_mp3;\nfilePaths[1] = filePath_lrc;\nBmob.uploadBatch(this, filePaths, new UploadBatchListener() {\n\n    @Override\n    public void onSuccess(List BmobFile  files,List String  urls) {\n        // TODO Auto-generated method stub\n        Log.i( life , insertDataWithMany -onSuccess : +urls.size()+ ----- +files+ ---- +urls);\n        if(urls.size()==2){//如果全部上传完，则更新该条记录\n            Song song =new Song( 汪峰0 , 北京北京0 ,files.get(0),files.get(1));\n            insertObject(song);\n        }else{\n            //有可能上传不完整，中间可能会存在未上传成功的情况，你可以自行处理\n        }\n    }\n\n    @Override\n    public void onError(int statuscode, String errormsg) {\n        // TODO Auto-generated method stub\n        ShowToast( 错误码 +statuscode + ,错误描述： +errormsg);\n    }\n\n    @Override\n    public void onProgress(int curIndex, int curPercent, int total,\n            int totalPercent) {\n        // TODO Auto-generated method stub\n        Log.i( life , insertBatchDatasWithOne -onProgress : +curIndex+ --- +curPercent+ --- +total+ ---- +totalPercent);\n    }\n});  上传成功之后，再进行数据的添加操作。示例代码如下：  \nprivate void insertObject(final BmobObject obj){\n    obj.save(MainActivity.this, new SaveListener() {\n\n        @Override\n        public void onSuccess() {\n            // TODO Auto-generated method stub\n            ShowToast( -- 创建数据成功：  + obj.getObjectId());\n\n        }\n\n        @Override\n        public void onFailure(int arg0, String arg1) {\n            // TODO Auto-generated method stub\n            ShowToast( -- 创建数据失败：  + arg0+ ,msg =  +arg1);\n        }\n    });\n}", 
            "title": "上传一条多个文件的数据"
        }, 
        {
            "location": "/data/android/example/#_17", 
            "text": "往Music表中插入多条有两个文件的逻辑也一样，同样先进行文件的批量上传操作，最后进行批量更新操作。由于代码都非常相似，这里就不再一一详细阐述，想要知道实现代码的朋友可以直接下载我们的案例代码进行查看。", 
            "title": "批量上传多条多个文件的数据"
        }, 
        {
            "location": "/data/android/example/#_18", 
            "text": "文件上传是移动领域最基础的服务，BmobSDK_v3.2.7提供了批量上传文件的方法，此方法大大简化了开发者对文件的批量操作，也欢迎大家提出更多的意见和建议帮助Bmob更好的发展。谢谢～  注：如需查看该文的相关代码，可自行去官网下载的BmobSDK_v3.2.7版本下的BmobExample示例工程中BmobFileActivity类查看。也可以去bodismile的github地址 https://github.com/bodismile/bmob-android-upload-file  查看。", 
            "title": "上传文件后记"
        }, 
        {
            "location": "/data/android/example/#_19", 
            "text": "", 
            "title": "反馈案例教程"
        }, 
        {
            "location": "/data/android/example/#_20", 
            "text": "用户反馈是移动开发中最常见的功能，可以用来收集我们的用户对软件的意见和建议。通常在开发用户反馈功能时，我们都会将用户反馈的信息保存到服务器中，定期登录后台管理系统查看，这样很难做到实时查看用户反馈信息。本文结合Bmob推送服务和数据存储服务开发用户反馈功能，实现用户提交反馈信息保存在Bmob云数据库的同时，也将用户的反馈信息推送到运营/研发人员的设备中。  本案例将使用到Bmob的如下功能：  1.推送服务\n将用户的反馈信息实时推送到订阅了接收反馈信息的设备中，实现端到端的消息传递。  2.数据存储服务  添加和查看反馈信息，使用到了添加、查询和按时间排序的功能。  本案例最终实现的界面效果如下：     发送反馈截图     查看反馈意见截图", 
            "title": "反馈案例需求描述"
        }, 
        {
            "location": "/data/android/example/#_21", 
            "text": "在Bmob开发者后台创建一个应用（还不知道怎么创建应用和添加数据表的开发朋友请先移步 快速入门指南 查看相关教程），添加两个表，分别是Feedback（用户反馈信息表，存储用户提交的反馈信息）和Installation（设备安装表，存储需要接收推送信息的设备信息）。以下是对这两个表的数据结构的详细描述（省略对常用默认字段objectId、createAt、updateAt的描述）  Feedback表     字段名  类型  描述      Contact  String  用户的联系方式    deviceType  String  系统字段，是一个必须的字段, 必须被设置为 \"ios\" 或者 \"android\", 而且自这个对象生成以后就不能变化     Installation表     字段名  类型  描述      installationId  String  系统字段，是一个Bmob生成的字符串标志, 而且如果 deviceType 是 android 的话是一个必填字段, 如果是 ios 的话则可选. 它只要对象被生成了就不能发生改变, 而且对一个 app 来说是不可重复的    deviceToken  String  系统字段，是一个 Apple 生成的字符串标志, 在 deviceType 为 ios 上的设备是必须的, 而且自对象生成开始就不能改动, 对于一个 app 来说也是不可重复的    badge  Number  系统字段，表示iOS 设备最新已知的应用badge    timeZone  String  系统字段，表示安装的这个设备的系统时区    channels  Array  系统字段，表示这个安装对象的订阅频道列表    appIdentifiter  String  iOS应用的Bundle identifier    isDeveloper  Boolean  是否是开发者（是的话则用于接收推送信息）", 
            "title": "反馈案例数据结构设计"
        }, 
        {
            "location": "/data/android/example/#_22", 
            "text": "还不知道怎么安装使用Bmob数据存储Sdk的开发朋友请先移步快速入门指南查看相关教程。\n推送服务的SDK初始化和Bmob数据存储SDK一样，只需要在Activity的onCreate方法中简单调用BmobPush.startWork方法就可以了，代码如下（详细代码见MainActivity类）：  //这里替换为你的APP Key\n    public static String APPID =  ;    \n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        Bmob.initialize(this, APPID);\n        BmobPush.startWork(this, APPID);    \n    }", 
            "title": "安装和初始化"
        }, 
        {
            "location": "/data/android/example/#_23", 
            "text": "这里要实现的是当用户点击“发送”反馈按钮之后，先把用户的反馈信息上传到Bmob云数据库中，然后发送一条推送信息到Installation表中isDeveloper为true的设备中去。  为实现将数据保存到云数据库的功能，你首先需要先创建一个Feedback类（需要与刚刚创建的数据表Feedback名称对应一致），该类继承自BmobObject类，实现contact和content的set和get方法。实现代码如下（详细代码见Feedback类）：  public class Feedback extends BmobObject {\n    //反馈内容\n    private String content;\n    //联系方式\n    private String contacts;\n    public String getContent() {\n        return content;\n    }\n    public void setContent(String content) {\n        this.content = content;\n    }\n    public String getContacts() {\n        return contacts;\n    }\n    public void setContacts(String contacts) {\n        this.contacts = contacts;\n    }\n}  有了Feedback类，你就可以方便的通过BmobObject的insertObject方法操作云数据库，将数据保存上去了。实现代码如下（详细代码见ActSendFeedback类）：      /**\n     * 保存反馈信息到Bmob云数据库中\n     * @param msg 反馈信息\n     */\n    private void saveFeedbackMsg(String msg){\n        Feedback feedback = new Feedback();\n        feedback.setContent(msg);\n        feedback.save(this, new SaveListener() {\n\n            @Override\n            public void onSuccess() {\n                Log.i( bmob ,  反馈信息已保存到服务器 );\n                //发送推送信息\n                saveFeedbackMsg(message);\n            }\n\n            @Override\n            public void onFailure(int code, String arg0) {\n                // TODO Auto-generated method stub\n                Log.e( bmob ,  保存反馈信息失败： +arg0);\n            }\n        });\n    }      /**\n     * 推送反馈信息给isDeveloper的设备\n     * @param message 反馈信息\n     */\n    private void sendMessage(String message){\n        BmobPushManager bmobPush = new BmobPushManager(this);\n        BmobQuery BmobInstallation  query = BmobInstallation.getQuery();\n        query.addWhereEqualTo( isDeveloper , true);\n        bmobPush.setQuery(query);\n        bmobPush.pushMessage(message);\n    }", 
            "title": "发送反馈功能的开发"
        }, 
        {
            "location": "/data/android/example/#_24", 
            "text": "为了接收用户端推送过来的反馈信息，查看反馈端需要自定义一个继承自BmobPushMessageReceiver的类，用于处理接收到的推送信息。实现代码如下：  public class MyMessageReceiver extends BmobPushMessageReceiver {\n\n    @Override\n    public void onMessage(Context context, String message) {\n        Log.d( bmob ,  收到反馈消息 =  +message);\n        //通知栏显示收到的反馈信息\n        NotificationManager nm = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);\n        Notification n = new Notification();  \n        n.icon = R.drawable.ic_launcher;  \n        n.tickerText =  收到反馈消息 ;  \n        n.when = System.currentTimeMillis();  \n        Intent intent = new Intent(context, ActFeedbackList.class);  \n        PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);  \n        n.setLatestEventInfo(context,  消息 , message, pi);  \n        n.defaults |= Notification.DEFAULT_SOUND;\n        n.flags = Notification.FLAG_AUTO_CANCEL;\n        nm.notify(1, n);\n    }\n}  查看反馈列表的功能实现也很简单，只需要调用BmobObject的findObjects方法就可以了，实现代码如下（详细代码见ActFeedbackList类）：  BmobQuery Feedback  query = new BmobQuery Feedback ();\n//按createAt降序排列\nquery.order( -createdAt );\nquery.findObjects(this, new FindListener Feedback () {\n\n    @Override\n    public void onSuccess(List Feedback  arg0) {\n        //显示反馈列表信息\n        adapter = new FeedbackAdapter(ActFeedbackList.this, arg0);\n        listView.setAdapter(adapter);\n    }\n\n    @Override\n    public void onError(int code, String arg0) {\n        emptyView.setText(arg0);\n    }\n});", 
            "title": "查看反馈功能的开发"
        }, 
        {
            "location": "/data/android/example/#_25", 
            "text": "当然了，实际使用过程的反馈功能可能并没有那么简单，或许你需要实现能够直接跟用户对话的反馈功能，或许你想要实现智能化的机器回答，这些都可以使用Bmob移动云服务平台进行快速设计和开发的。欢迎各位砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～", 
            "title": "反馈案例后记"
        }, 
        {
            "location": "/data/android/example/#_26", 
            "text": "反馈案例下载", 
            "title": "反馈案例案例下载"
        }, 
        {
            "location": "/data/android/example/#_27", 
            "text": "快速入门相关源码下载 http://www.bmob.cn/static/Bmob_android_quickstart.zip  即时聊天案例源码 https://github.com/bmob/BmobIMSDK4Android  图文社区案例源码： https://git.oschina.net/v7/Wonderful   这个案例是猿圈媛圈开发团队提供的。  图文分享案例源码： https://github.com/smartbetter/AndroidWonderful  这个案例是一个叫郭朝的开发者提供的。  校园小菜案例源码： https://github.com/bmob/Shop  这个案例是湖工大的朋友提供的。  社交分享案例源码： https://github.com/bmob/bmob-android-social-share  这个是金刚锁开发者提供的  第三方登录案例源码： https://github.com/bmob/bmob-android-demo-thirdpartylogin   包含第三方登录和登录后获取用户信息的源码。  自定义表名情况下增删改查数据的Demo，下载地址是： https://github.com/bmob/bmob-android-demo-dynamic-tablename 。  使用分页查询，结合ListView开发下拉刷新查看更多内容 https://github.com/bmob/bmob-android-demo-paging 。  短信验证的demo： https://github.com/bmob/bmob_android_demo_sms  。  缩略图案例源码： https://github.com/bmob/bmob-android-demo-thumbnail  数据的实时同步服务应用实例（  https://github.com/bmob/bmob-android-demo-realtime-data  ）供大家参考。  ACL相关的案例源码： https://github.com/bmob/bmob-android-demo-acl  推送案例Demo: https://github.com/bmob/bmob-android-demo-push  BmobSDK自动更新实例程序源码： https://github.com/bmob/bmob-android-demo-autoupdate  踢球吧源码 https://github.com/bmob/BmobTiQiuBa  android云端逻辑案例: http://www.bmob.cn/static/Bmob_Sample_android_cloud.zip  基于Bmob的二维码扫描工具: https://github.com/bmob/FindLook", 
            "title": "其它案例"
        }, 
        {
            "location": "/data/android/auto_update/", 
            "text": "快速入门\n\n\n1、添加资源文件\n\n\n下载SDK提供的res文件夹拷入工程目录下，和工程本身res目录合并。\n\n\nres文件夹下载地址：\nhttp://www.bmob.cn/static/res.zip\n\n\n这里需要注意的是：\n\n\n\n\n请不要随便删除其中的文件。\n\n\nBmobSDK提供的资源文件都以bmob_开头。\n\n\n如果是在AndroidStudio中用远程依赖的方式就可以跳过这个步骤，因为这些资源都在下载到本地的aar包中。\n\n\n\n\n2、配置AndroidManifest.xml\n\n\n1.打开AndroidManifest.xml，添加SDK需要的权限到\n标签下：\n\n\nuses-permission android:name=\nandroid.permission.WRITE_EXTERNAL_STORAGE\n/uses-permission\n\n\nuses-permission android:name=\nandroid.permission.ACCESS_NETWORK_STATE\n/uses-permission\n\n\nuses-permission android:name=\nandroid.permission.INTERNET\n/uses-permission\n\n\n\n\n\n说明：\n- android.permission.WRITE_EXTERNAL_STORAGE 权限允许将下载的apk保存到sd卡中。\n- android.permission.ACCESS_NETWORK_STATE 权限允许检查网络状态，从而根据不同网络环境决定何种下载策略,务必添加该权限。\n\n\n2.添加渠道到\n标签下： \n\n\nmeta-data android:value=\nChannel ID\n android:name=\nBMOB_CHANNEL\n/\n\n\n\n\n\n说明：\nBMOB_CHANNEL\n用来标注应用推广渠道，不同渠道可以上传不同更新包，您可以使用20位以内的英文和数字为渠道定名，替换value中的\nChannel ID\n。如果不添加，将不区分渠道。(注意不要出现在manifest中标识了渠道但后端控制台没写渠道值，这样是无法自动更新的，因为没匹配上)\n\n\n3.添加Activity到\n标签下：\n\n\nactivity \n            android:name=\ncn.bmob.v3.update.UpdateDialogActivity\n\n            android:theme=\n@android:style/Theme.Translucent.NoTitleBar\n \n\n        \n/activity\n\n\n\n\n\n3、初始化AppVersion表\n\n\n一行代码轻松搞定\nAppVersion\n表（\n注意：请务必将该表在WEB端设置为只读模式\n）：\n\n\nSDK提供了初始化自动创建\nAppVersion\n表的方法，不再需要开发者手动在web端创建。只需要在你使用自动更新功能的地方调用如下代码：\n\n\n    BmobUpdateAgent.initAppVersion();\n\n\n\n\n注：\n\n\n1、initAppVersion方法适合开发者调试自动更新功能时使用，一旦AppVersion表在后台创建成功，建议屏蔽或删除此方法，否则会生成多行记录。\n\n\n2、如果调用了此方法后，在管理后台没有看见AppVersion表生成，建议到手机的应用管理界面\n清除该应用的数据，并再次调用该方法\n，也可到LogCat中查看与\nbmob\n相关错误日志。\n\n\n3、如果\n2\n方法尝试多次之后仍然无效，请\n手动创建AppVersion表\n，表的各个字段名称请查看下表。\n\n\n4、调用自动更新接口\n\n\n最常见的自动更新模式是：当用户进入应用首页后，如果处于wifi环境则检测更新，如果有更新，弹出对话框提示有新版本，用户点选更新开始下载更新。实现的方法是，在应用程序入口Activity里的\nOnCreate()\n方法中调用如下代码：\n\n\npublic void onCreate(Bundle  savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    BmobUpdateAgent.update(this);\n}\n\n\n\n\n\n\n考虑到用户流量的限制，目前我们默认在WiFi接入情况下才进行自动提醒。如需要在任意网络环境下都进行更新自动提醒，则请在update调用之前添加以下代码：\n\n\n\n\nBmobUpdateAgent.setUpdateOnlyWifi(false)\n\n\n\n\n\n\n如果你发现调用update方法无反应，可使用下面\n自定义功能\n中的\n监听检测更新的结果\n提到的方法来监听自动更新的结果,具体如下：\n\n\n\n\nBmobUpdateAgent.setUpdateListener(new BmobUpdateListener() {\n\n    @Override\n    public void onUpdateReturned(int updateStatus, UpdateResponse updateInfo) {\n        // TODO Auto-generated method stub\n        //根据updateStatus来判断更新是否成功\n    }\n})\n\n\n\n\n强制更新\n\n\n应用场景：如果应用需要屏蔽旧版本，强制用户必须更新升级到最新版才能继续使用。\n\n\nSDK中为自动更新方式提供了\n强制更新\n功能，当开发者开启强制更新功能（即将后台的\nAppVersion\n表中的isforce字段置为true）时，客户端调用\nBmobUpdateAgent.update(context)\n方法后，更新对话框只保留“立即更新”按钮且不再支持回退操作。其效果图如下：\n\n\n\n\n忽略版本更新\n\n\nSDK中为自动更新方式提供了\n忽略版本更新\n功能，当用户勾选”忽略该版“选项时，再次调用\nBmobUpdateAgent.update(context)\n则不再出现版本更新对话框。\n\n\n注：强制更新和忽略版本更新只支持自动更新方式。\n\n\n5、上传APK文件或填写apk文件的url地址\n\n\n初始化AppVersion表成功后，开发者在管理后台的\n数据浏览\n页中就可以看见AppVersion表了,该表的结构如下：\n\n\n\n\n\n\n\n\n字段名称\n\n\n字段类型\n\n\n是否必填\n\n\n字段说明\n\n\n\n\n\n\n\n\n\n\nupdate_log\n\n\nString\n\n\n是\n\n\n更新日志\n\n\n\n\n\n\nversion\n\n\nString\n\n\n是\n\n\n版本名称\n\n\n\n\n\n\nversion_i\n\n\nNumber\n\n\n是\n\n\n版本号\n\n\n\n\n\n\nplatform\n\n\nString\n\n\n是\n\n\n平台，注意：\"Android\"为安卓平台标示，\"ios\"为ios平台标示\n\n\n\n\n\n\ntarget_size\n\n\nString\n\n\n是\n\n\nApk文件大小\n\n\n\n\n\n\nisforce\n\n\nBoolean\n\n\n否\n\n\n是否强制更新\n\n\n\n\n\n\npath\n\n\nFile\n\n\n是/否\n\n\nApk文件\n\n\n\n\n\n\nandroid_url\n\n\nString\n\n\n是/否\n\n\napk市场地址（path字段和本字段必填其中一个）\n\n\n\n\n\n\nchannel\n\n\nString\n\n\n否\n\n\n渠道标示\n\n\n\n\n\n\nios_url\n\n\nString\n\n\n否\n\n\niOS app store地址（如果是ios记录一定要填写）\n\n\n\n\n\n\n\n\n创建好这个表结构之后就可以新增一些记录，把应用的信息和下载地址（或者上传文件）填写上去，如下图所示：\n\n\n\n\n注：\n\n\n1、target_size为必填项，是为了解决当apk下载过程中切换网络导致的解析包出现错误问题，请手动填入apk文件的字节大小。可通过鼠标右键apk文件--\n属性--\n大小（不是占用空间）获取到的target_size值（不需要单位）：\n\n\n\n\n如上例，只需要在\ntarget_size\n字段中填写\n5032788\n就行。\n\n\n2、新添加的数据记录的version_i（对应应用中的version code，如下图）的数值要大于手机中安装的应用的version number，否则无法生效。另外，platform需要根据实际情况填写平台信息。\n\n\n\n\n3、新版SDKV3.3.2调用initAppVersion方法后，你会看到AppVersion表的path字段有一个test.apk的文件，其实这个文件是个空的文件，不必过于纠结，将test.apk删除后再上传自己的apk文件即可。\n\n\n4、新版SDKV3.3.4允许下载已上传到应用市场上的apk文件，因此，path和android_url两者填任意一个即可，若都填写，默认优先下载path字段下的apk文件。\n\n\n5、新版SDKV3.3.4新增对update_log字段内容进行文字排版的功能，只需要在分段处加上分隔符\n；\n即可（UI效果如下图）\n\n\n具体格式参考如下范例：1、修复第三方登陆成功后无法获取本地用户信息的问题\n；\n2、修复设置缓存策略后无法获取本地缓存信息的问题\n；\n3、修复调用云端逻辑（callEndpoint）方法的成功回调的返回值中含有“results”的问题\n；\n4、新版文件管理中对本地缩略图的处理方法新增压缩质量的参数。\n\n\n\n\n6、如果在web后台上传apk文件，然后在使用了v3.4.6之前版本的sdk的应用上调用自动更新功能出现 \n解析包出错\n 的问题，解决方法如下：\n\n\n请不要上传apk文件到\npath\n字段，改为\n填写apk文件的url地址\n到\nandroid_url\n字段。\n\n\n具体原因请查看 \n常见问题\n。\n\n\n6、集成检测\n\n\nSDK中默认开启了集成检测功能，在调用任意的更新接口后，我们将替您自动检查上述集成过程中2、3两个步骤是否被正确完成。 如果正确完成不会出现任何提示，否则会以如下的toast提示您。\n\n\n你可以通过调用\nBmobUpdateAgent.setUpdateCheckConfig(false)\n来禁用此功能。\n\n\ntoast的含义如下：\n\n\n\"Please copy all resources (res/) from SDK to your project!\"：请检查是不是把res文件夹下所有的资源文件都放到了工程中。\n\n\"Please add Permission in AndroidManifest!\"：请检查上述步骤中的相关权限是否正确添加。\n\n\"Please add Activity in AndroidManifest!\"：请检查上述步骤中的Activity是否正确添加。\n\n\n\n其他更新方式\n\n\n除了在快速入门中提到的自动更新之外，Bmob自动更新SDK还支持另外两种场景：手动更新、静默更新。\n下面将详细介绍这两种场景的接口及默认行为。\n\n\n手动更新\n\n\n许多应用的设置界面中都会有检查更新等类似功能，需要用户主动触发而检测更新。它的默认行为基本和自动更新基本一致。它和自动更新的主要区别是：在这种手动更新的情况下，无论网络状况是否Wifi，无论用户是否忽略过该版本的更新，都可以像下面的示例一样在按钮的回调中发起更新检查，代替update(Context context)：\n\n\npublic void onClick(View v) {\n    BmobUpdateAgent.forceUpdate(mContext);\n}\n\n\n\n静默下载更新\n\n\n当用户进入应用首页后如果处于wifi环境检测更新，如果有更新，后台下载新版本，如果下载成功，则进行通知栏展示，用户点击通知栏开始安装。静默下载过程中如果wifi断开，则会停止下载。实现的方法是：在应用程序入口Activity里的\nOnCreate()\n方法中调用如下代码：\n\n\npublic void onCreate(Bundle  savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    BmobUpdateAgent.silentUpdate(this);\n}\n\n\n\n自定义功能\n\n\n恢复默认设置\n\n\nBmobUpdateAgent.setDefault();\n\n\n设置更新的网络条件\n\n\nBmobUpdateAgent.setUpdateOnlyWifi（boolean updateOnlyWifi）\n\n\n注：updateOnlyWifi:true表示只在wifi环境下检测更新，false表示所有环境下均可检测更新\n\n\n监听检测更新的结果\n\n\n如果开发者想自己处理检测更新的结果，可以按如下步骤，实现更新监听接口，自主处理更新事件：\n\n\n    BmobUpdateAgent.setUpdateListener(new BmobUpdateListener() {\n\n        @Override\n        public void onUpdateReturned(int updateStatus, UpdateResponse updateInfo) {\n            // TODO Auto-generated method stub\n            if (updateStatus == UpdateStatus.Yes) {//版本有更新\n\n            }else if(updateStatus == UpdateStatus.No){\n                Toast.makeText(ActAutoUpdate.this, \n版本无更新\n, Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.EmptyField){//此提示只是提醒开发者关注那些必填项，测试成功后，无需对用户提示\n                Toast.makeText(ActAutoUpdate.this, \n请检查你AppVersion表的必填项，1、target_size（文件大小）是否填写；2、path或者android_url两者必填其中一项。\n, Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.IGNORED){\n                Toast.makeText(ActAutoUpdate.this, \n该版本已被忽略更新\n, Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.ErrorSizeFormat){\n                Toast.makeText(ActAutoUpdate.this, \n请检查target_size填写的格式，请使用file.length()方法获取apk大小。\n, Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.TimeOut){\n                Toast.makeText(ActAutoUpdate.this, \n查询出错或查询超时\n, Toast.LENGTH_SHORT).show();\n            }\n        }\n    });\n    //发起自动更新\n    BmobUpdateAgent.update(this);\n\n\n\n\n监听对话框按键操作\n\n\n有时候开发者需要知道用户点击了哪个按钮，开发者可设置监听对话框的按钮点击事件。\n\n\n    //设置对对话框按钮的点击事件的监听\n    BmobUpdateAgent.setDialogListener(new BmobDialogButtonListener() {\n\n        @Override\n        public void onClick(int status) {\n            // TODO Auto-generated method stub\n            switch (status) {\n            case UpdateStatus.Update:\n                Toast.makeText(ActAutoUpdate.this, \n点击了立即更新按钮\n , Toast.LENGTH_SHORT).show();\n                break;\n            case UpdateStatus.NotNow:\n                Toast.makeText(ActAutoUpdate.this, \n点击了以后再说按钮\n , Toast.LENGTH_SHORT).show();\n                break;\n            case UpdateStatus.Close://只有在强制更新状态下才会在更新对话框的右上方出现close按钮,如果用户不点击”立即更新“按钮，这时候开发者可做些操作，比如直接退出应用等\n                Toast.makeText(ActAutoUpdate.this, \n点击了对话框关闭按钮\n , Toast.LENGTH_SHORT).show();\n                break;\n            }\n        }\n    });\n\n\n\n\n注：UpdateStatus列表\n\n\nUpdateStatus.TimeOut    =-1：查询出错或超时\nUpdateStatus.Yes        = 0：有更新\nUpdateStatus.No         = 1：没有更新\nUpdateStatus.IGNORED    = 3：该版本已被忽略更新\nUpdateStatus.EmptyField = 2：字段值为空，请检查以下内容：\n                            1)、是否已填写target_size目标apk大小（以字节为单位）；\n                            2)、path或者android_url两者是否必填其中一项（若两者都填写，则默认下载path字段下的apk文件）\nUpdateStatus.ErrorSizeFormat = 4：请检查target_size填写的格式，请使用file.length()方法获取apk大小\nUpdateStatus.Update     =6： 代表点击的是“立即更新”\nUpdateStatus.NotNow     =7： 代表点击的是“以后再说”\nUpdateStatus.Close      =8： 代表关闭对话框--\n只有在强制更新状态下才会在更新对话框的右上方出现close按钮,如果用户不点击”立即更新“按钮，这时候开发者可做些操作，比如直接退出应用等\n\n\n\n常见问题\n\n\n一、\n上传新的APK文件之后，为什么使用 \nv3.4.6以前版本的SDK开发的旧应用\n 的自动更新功能出现\n解析包出错\n问题？\n\n\n1、表现：\n\n\n只下载58字节后就弹出安装界面，点击安装出现`解析包出错`的错误。\n\n\n\n2、原因：\n\n\n 自4月13日上线CDN文件服务以来，通过Web后台上传的apk文件都会自动上传到CDN服务提供商那里，而`v3.4.6以前版本的SDK`的自动更新功能中得到`用于下载的url地址会将Bmob原有的文件域名拼接到BmobFile的url前面`。\n\n因此，最终拼接成的用于下载的地址是类似这样的：`http://file.bmob.cn/http://bmob-cdn-82.b0.upaiyun.com/2016/04/20/xxx.apk`，由此导致 `解析包出错`。\n\n\n\n3、解决方法：\n\n\n不要上传apk文件到`AppVersion`表的`path`字段，改为填写url地址到`AppVersion`表的`android_url`字段，以此来恢复旧应用的自动更新功能。\n\n\n\n其中，\nandroid_url\n可以是以下两种之一：\n\n\n1）、`各大应用市场的应用下载地址`\n2）、`上传新的apk文件到bmob的其他表的文件字段中，然后通过getFileUrl(context)获取到的url地址`\n\n\n\n注：如果是新发布的应用(使用BmobV3.4.6后的版本开发的应用)，则仍然可以上传apk文件到\nAppVersion\n表的\npath\n字段中。\n\n\n二、 \n为什么调用\nBmobUpdateAgent.update(this)\n方法后没有弹出更新对话框？\n\n\n请仔细检查以下几方面：\n\n\n1）、如果是通过`手动方法`在后台创建的AppVersion表的话，则仔细对照文档检查各个字段的名称是否正确填写，注意大小写;\n\n2）、`AndroidManifest.xml`中的的`android:versionCode`的值是否比后台的`AppVersion`表中填写的`version_i`的值`小`;\n\n3）、`target_size`的值是否正确填写，填写的是apk的字节大小，没有单位，例如：很多开发者填写的是'x.xxM',这个格式是错误的;\n\n4)、`AndroidManifest.xml`中的`BMOB_CHANNEL`的值是否和后台的`AppVersion`表中填写的`channel`的值`相等`。\n\n \n!-- 设置应用渠道，如果应用不需要区分渠道，则建议删除此行 --\n\n\nmeta-data android:name=\"BMOB_CHANNEL\" android:value=\"bmob\"/\n\n\n\n\n案例源码\n\n\n这里我们提供了一个使用BmobSDK自动更新功能的实例程序供大家参考。下载地址如下：\nhttps://github.com/bmob/bmob-android-demo-autoupdate", 
            "title": "自动更新"
        }, 
        {
            "location": "/data/android/auto_update/#_1", 
            "text": "", 
            "title": "快速入门"
        }, 
        {
            "location": "/data/android/auto_update/#1", 
            "text": "下载SDK提供的res文件夹拷入工程目录下，和工程本身res目录合并。  res文件夹下载地址： http://www.bmob.cn/static/res.zip  这里需要注意的是：   请不要随便删除其中的文件。  BmobSDK提供的资源文件都以bmob_开头。  如果是在AndroidStudio中用远程依赖的方式就可以跳过这个步骤，因为这些资源都在下载到本地的aar包中。", 
            "title": "1、添加资源文件"
        }, 
        {
            "location": "/data/android/auto_update/#2androidmanifestxml", 
            "text": "1.打开AndroidManifest.xml，添加SDK需要的权限到 标签下：  uses-permission android:name= android.permission.WRITE_EXTERNAL_STORAGE /uses-permission  uses-permission android:name= android.permission.ACCESS_NETWORK_STATE /uses-permission  uses-permission android:name= android.permission.INTERNET /uses-permission   说明：\n- android.permission.WRITE_EXTERNAL_STORAGE 权限允许将下载的apk保存到sd卡中。\n- android.permission.ACCESS_NETWORK_STATE 权限允许检查网络状态，从而根据不同网络环境决定何种下载策略,务必添加该权限。  2.添加渠道到 标签下：   meta-data android:value= Channel ID  android:name= BMOB_CHANNEL /   说明： BMOB_CHANNEL 用来标注应用推广渠道，不同渠道可以上传不同更新包，您可以使用20位以内的英文和数字为渠道定名，替换value中的 Channel ID 。如果不添加，将不区分渠道。(注意不要出现在manifest中标识了渠道但后端控制台没写渠道值，这样是无法自动更新的，因为没匹配上)  3.添加Activity到 标签下：  activity \n            android:name= cn.bmob.v3.update.UpdateDialogActivity \n            android:theme= @android:style/Theme.Translucent.NoTitleBar   \n         /activity", 
            "title": "2、配置AndroidManifest.xml"
        }, 
        {
            "location": "/data/android/auto_update/#3appversion", 
            "text": "一行代码轻松搞定 AppVersion 表（ 注意：请务必将该表在WEB端设置为只读模式 ）：  SDK提供了初始化自动创建 AppVersion 表的方法，不再需要开发者手动在web端创建。只需要在你使用自动更新功能的地方调用如下代码：      BmobUpdateAgent.initAppVersion();  注：  1、initAppVersion方法适合开发者调试自动更新功能时使用，一旦AppVersion表在后台创建成功，建议屏蔽或删除此方法，否则会生成多行记录。  2、如果调用了此方法后，在管理后台没有看见AppVersion表生成，建议到手机的应用管理界面 清除该应用的数据，并再次调用该方法 ，也可到LogCat中查看与 bmob 相关错误日志。  3、如果 2 方法尝试多次之后仍然无效，请 手动创建AppVersion表 ，表的各个字段名称请查看下表。", 
            "title": "3、初始化AppVersion表"
        }, 
        {
            "location": "/data/android/auto_update/#4", 
            "text": "最常见的自动更新模式是：当用户进入应用首页后，如果处于wifi环境则检测更新，如果有更新，弹出对话框提示有新版本，用户点选更新开始下载更新。实现的方法是，在应用程序入口Activity里的 OnCreate() 方法中调用如下代码：  public void onCreate(Bundle  savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    BmobUpdateAgent.update(this);\n}   考虑到用户流量的限制，目前我们默认在WiFi接入情况下才进行自动提醒。如需要在任意网络环境下都进行更新自动提醒，则请在update调用之前添加以下代码：   BmobUpdateAgent.setUpdateOnlyWifi(false)   如果你发现调用update方法无反应，可使用下面 自定义功能 中的 监听检测更新的结果 提到的方法来监听自动更新的结果,具体如下：   BmobUpdateAgent.setUpdateListener(new BmobUpdateListener() {\n\n    @Override\n    public void onUpdateReturned(int updateStatus, UpdateResponse updateInfo) {\n        // TODO Auto-generated method stub\n        //根据updateStatus来判断更新是否成功\n    }\n})", 
            "title": "4、调用自动更新接口"
        }, 
        {
            "location": "/data/android/auto_update/#_2", 
            "text": "应用场景：如果应用需要屏蔽旧版本，强制用户必须更新升级到最新版才能继续使用。  SDK中为自动更新方式提供了 强制更新 功能，当开发者开启强制更新功能（即将后台的 AppVersion 表中的isforce字段置为true）时，客户端调用 BmobUpdateAgent.update(context) 方法后，更新对话框只保留“立即更新”按钮且不再支持回退操作。其效果图如下：", 
            "title": "强制更新"
        }, 
        {
            "location": "/data/android/auto_update/#_3", 
            "text": "SDK中为自动更新方式提供了 忽略版本更新 功能，当用户勾选”忽略该版“选项时，再次调用 BmobUpdateAgent.update(context) 则不再出现版本更新对话框。  注：强制更新和忽略版本更新只支持自动更新方式。", 
            "title": "忽略版本更新"
        }, 
        {
            "location": "/data/android/auto_update/#5apkapkurl", 
            "text": "初始化AppVersion表成功后，开发者在管理后台的 数据浏览 页中就可以看见AppVersion表了,该表的结构如下：     字段名称  字段类型  是否必填  字段说明      update_log  String  是  更新日志    version  String  是  版本名称    version_i  Number  是  版本号    platform  String  是  平台，注意：\"Android\"为安卓平台标示，\"ios\"为ios平台标示    target_size  String  是  Apk文件大小    isforce  Boolean  否  是否强制更新    path  File  是/否  Apk文件    android_url  String  是/否  apk市场地址（path字段和本字段必填其中一个）    channel  String  否  渠道标示    ios_url  String  否  iOS app store地址（如果是ios记录一定要填写）     创建好这个表结构之后就可以新增一些记录，把应用的信息和下载地址（或者上传文件）填写上去，如下图所示：   注：  1、target_size为必填项，是为了解决当apk下载过程中切换网络导致的解析包出现错误问题，请手动填入apk文件的字节大小。可通过鼠标右键apk文件-- 属性-- 大小（不是占用空间）获取到的target_size值（不需要单位）：   如上例，只需要在 target_size 字段中填写 5032788 就行。  2、新添加的数据记录的version_i（对应应用中的version code，如下图）的数值要大于手机中安装的应用的version number，否则无法生效。另外，platform需要根据实际情况填写平台信息。   3、新版SDKV3.3.2调用initAppVersion方法后，你会看到AppVersion表的path字段有一个test.apk的文件，其实这个文件是个空的文件，不必过于纠结，将test.apk删除后再上传自己的apk文件即可。  4、新版SDKV3.3.4允许下载已上传到应用市场上的apk文件，因此，path和android_url两者填任意一个即可，若都填写，默认优先下载path字段下的apk文件。  5、新版SDKV3.3.4新增对update_log字段内容进行文字排版的功能，只需要在分段处加上分隔符 ； 即可（UI效果如下图）  具体格式参考如下范例：1、修复第三方登陆成功后无法获取本地用户信息的问题 ； 2、修复设置缓存策略后无法获取本地缓存信息的问题 ； 3、修复调用云端逻辑（callEndpoint）方法的成功回调的返回值中含有“results”的问题 ； 4、新版文件管理中对本地缩略图的处理方法新增压缩质量的参数。   6、如果在web后台上传apk文件，然后在使用了v3.4.6之前版本的sdk的应用上调用自动更新功能出现  解析包出错  的问题，解决方法如下：  请不要上传apk文件到 path 字段，改为 填写apk文件的url地址 到 android_url 字段。  具体原因请查看  常见问题 。", 
            "title": "5、上传APK文件或填写apk文件的url地址"
        }, 
        {
            "location": "/data/android/auto_update/#6", 
            "text": "SDK中默认开启了集成检测功能，在调用任意的更新接口后，我们将替您自动检查上述集成过程中2、3两个步骤是否被正确完成。 如果正确完成不会出现任何提示，否则会以如下的toast提示您。  你可以通过调用 BmobUpdateAgent.setUpdateCheckConfig(false) 来禁用此功能。  toast的含义如下：  \"Please copy all resources (res/) from SDK to your project!\"：请检查是不是把res文件夹下所有的资源文件都放到了工程中。\n\n\"Please add Permission in AndroidManifest!\"：请检查上述步骤中的相关权限是否正确添加。\n\n\"Please add Activity in AndroidManifest!\"：请检查上述步骤中的Activity是否正确添加。", 
            "title": "6、集成检测"
        }, 
        {
            "location": "/data/android/auto_update/#_4", 
            "text": "除了在快速入门中提到的自动更新之外，Bmob自动更新SDK还支持另外两种场景：手动更新、静默更新。\n下面将详细介绍这两种场景的接口及默认行为。", 
            "title": "其他更新方式"
        }, 
        {
            "location": "/data/android/auto_update/#_5", 
            "text": "许多应用的设置界面中都会有检查更新等类似功能，需要用户主动触发而检测更新。它的默认行为基本和自动更新基本一致。它和自动更新的主要区别是：在这种手动更新的情况下，无论网络状况是否Wifi，无论用户是否忽略过该版本的更新，都可以像下面的示例一样在按钮的回调中发起更新检查，代替update(Context context)：  public void onClick(View v) {\n    BmobUpdateAgent.forceUpdate(mContext);\n}", 
            "title": "手动更新"
        }, 
        {
            "location": "/data/android/auto_update/#_6", 
            "text": "当用户进入应用首页后如果处于wifi环境检测更新，如果有更新，后台下载新版本，如果下载成功，则进行通知栏展示，用户点击通知栏开始安装。静默下载过程中如果wifi断开，则会停止下载。实现的方法是：在应用程序入口Activity里的 OnCreate() 方法中调用如下代码：  public void onCreate(Bundle  savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    BmobUpdateAgent.silentUpdate(this);\n}", 
            "title": "静默下载更新"
        }, 
        {
            "location": "/data/android/auto_update/#_7", 
            "text": "", 
            "title": "自定义功能"
        }, 
        {
            "location": "/data/android/auto_update/#_8", 
            "text": "BmobUpdateAgent.setDefault();", 
            "title": "恢复默认设置"
        }, 
        {
            "location": "/data/android/auto_update/#_9", 
            "text": "BmobUpdateAgent.setUpdateOnlyWifi（boolean updateOnlyWifi）  注：updateOnlyWifi:true表示只在wifi环境下检测更新，false表示所有环境下均可检测更新", 
            "title": "设置更新的网络条件"
        }, 
        {
            "location": "/data/android/auto_update/#_10", 
            "text": "如果开发者想自己处理检测更新的结果，可以按如下步骤，实现更新监听接口，自主处理更新事件：      BmobUpdateAgent.setUpdateListener(new BmobUpdateListener() {\n\n        @Override\n        public void onUpdateReturned(int updateStatus, UpdateResponse updateInfo) {\n            // TODO Auto-generated method stub\n            if (updateStatus == UpdateStatus.Yes) {//版本有更新\n\n            }else if(updateStatus == UpdateStatus.No){\n                Toast.makeText(ActAutoUpdate.this,  版本无更新 , Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.EmptyField){//此提示只是提醒开发者关注那些必填项，测试成功后，无需对用户提示\n                Toast.makeText(ActAutoUpdate.this,  请检查你AppVersion表的必填项，1、target_size（文件大小）是否填写；2、path或者android_url两者必填其中一项。 , Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.IGNORED){\n                Toast.makeText(ActAutoUpdate.this,  该版本已被忽略更新 , Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.ErrorSizeFormat){\n                Toast.makeText(ActAutoUpdate.this,  请检查target_size填写的格式，请使用file.length()方法获取apk大小。 , Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.TimeOut){\n                Toast.makeText(ActAutoUpdate.this,  查询出错或查询超时 , Toast.LENGTH_SHORT).show();\n            }\n        }\n    });\n    //发起自动更新\n    BmobUpdateAgent.update(this);", 
            "title": "监听检测更新的结果"
        }, 
        {
            "location": "/data/android/auto_update/#_11", 
            "text": "有时候开发者需要知道用户点击了哪个按钮，开发者可设置监听对话框的按钮点击事件。      //设置对对话框按钮的点击事件的监听\n    BmobUpdateAgent.setDialogListener(new BmobDialogButtonListener() {\n\n        @Override\n        public void onClick(int status) {\n            // TODO Auto-generated method stub\n            switch (status) {\n            case UpdateStatus.Update:\n                Toast.makeText(ActAutoUpdate.this,  点击了立即更新按钮  , Toast.LENGTH_SHORT).show();\n                break;\n            case UpdateStatus.NotNow:\n                Toast.makeText(ActAutoUpdate.this,  点击了以后再说按钮  , Toast.LENGTH_SHORT).show();\n                break;\n            case UpdateStatus.Close://只有在强制更新状态下才会在更新对话框的右上方出现close按钮,如果用户不点击”立即更新“按钮，这时候开发者可做些操作，比如直接退出应用等\n                Toast.makeText(ActAutoUpdate.this,  点击了对话框关闭按钮  , Toast.LENGTH_SHORT).show();\n                break;\n            }\n        }\n    });  注：UpdateStatus列表  UpdateStatus.TimeOut    =-1：查询出错或超时\nUpdateStatus.Yes        = 0：有更新\nUpdateStatus.No         = 1：没有更新\nUpdateStatus.IGNORED    = 3：该版本已被忽略更新\nUpdateStatus.EmptyField = 2：字段值为空，请检查以下内容：\n                            1)、是否已填写target_size目标apk大小（以字节为单位）；\n                            2)、path或者android_url两者是否必填其中一项（若两者都填写，则默认下载path字段下的apk文件）\nUpdateStatus.ErrorSizeFormat = 4：请检查target_size填写的格式，请使用file.length()方法获取apk大小\nUpdateStatus.Update     =6： 代表点击的是“立即更新”\nUpdateStatus.NotNow     =7： 代表点击的是“以后再说”\nUpdateStatus.Close      =8： 代表关闭对话框-- 只有在强制更新状态下才会在更新对话框的右上方出现close按钮,如果用户不点击”立即更新“按钮，这时候开发者可做些操作，比如直接退出应用等", 
            "title": "监听对话框按键操作"
        }, 
        {
            "location": "/data/android/auto_update/#_12", 
            "text": "一、 上传新的APK文件之后，为什么使用  v3.4.6以前版本的SDK开发的旧应用  的自动更新功能出现 解析包出错 问题？  1、表现：  只下载58字节后就弹出安装界面，点击安装出现`解析包出错`的错误。  2、原因：   自4月13日上线CDN文件服务以来，通过Web后台上传的apk文件都会自动上传到CDN服务提供商那里，而`v3.4.6以前版本的SDK`的自动更新功能中得到`用于下载的url地址会将Bmob原有的文件域名拼接到BmobFile的url前面`。\n\n因此，最终拼接成的用于下载的地址是类似这样的：`http://file.bmob.cn/http://bmob-cdn-82.b0.upaiyun.com/2016/04/20/xxx.apk`，由此导致 `解析包出错`。  3、解决方法：  不要上传apk文件到`AppVersion`表的`path`字段，改为填写url地址到`AppVersion`表的`android_url`字段，以此来恢复旧应用的自动更新功能。  其中， android_url 可以是以下两种之一：  1）、`各大应用市场的应用下载地址`\n2）、`上传新的apk文件到bmob的其他表的文件字段中，然后通过getFileUrl(context)获取到的url地址`  注：如果是新发布的应用(使用BmobV3.4.6后的版本开发的应用)，则仍然可以上传apk文件到 AppVersion 表的 path 字段中。  二、  为什么调用 BmobUpdateAgent.update(this) 方法后没有弹出更新对话框？  请仔细检查以下几方面：  1）、如果是通过`手动方法`在后台创建的AppVersion表的话，则仔细对照文档检查各个字段的名称是否正确填写，注意大小写;\n\n2）、`AndroidManifest.xml`中的的`android:versionCode`的值是否比后台的`AppVersion`表中填写的`version_i`的值`小`;\n\n3）、`target_size`的值是否正确填写，填写的是apk的字节大小，没有单位，例如：很多开发者填写的是'x.xxM',这个格式是错误的;\n\n4)、`AndroidManifest.xml`中的`BMOB_CHANNEL`的值是否和后台的`AppVersion`表中填写的`channel`的值`相等`。\n\n  !-- 设置应用渠道，如果应用不需要区分渠道，则建议删除此行 --  meta-data android:name=\"BMOB_CHANNEL\" android:value=\"bmob\"/", 
            "title": "常见问题"
        }, 
        {
            "location": "/data/android/auto_update/#_13", 
            "text": "这里我们提供了一个使用BmobSDK自动更新功能的实例程序供大家参考。下载地址如下： https://github.com/bmob/bmob-android-demo-autoupdate", 
            "title": "案例源码"
        }, 
        {
            "location": "/data/android/class_doc/", 
            "text": "类库文档\n\n\n数据服务 Android SDK 类库文档 \nhttp://docs.bmob.cn/data/Android/i_doc/doc/index.html", 
            "title": "类库文档"
        }, 
        {
            "location": "/data/android/class_doc/#_1", 
            "text": "数据服务 Android SDK 类库文档  http://docs.bmob.cn/data/Android/i_doc/doc/index.html", 
            "title": "类库文档"
        }, 
        {
            "location": "/data/android/update_log/", 
            "text": "v3.5.5 (2017年04月20日)\n\n\n\n\nsdk新增重新设置主域名，类似之前的数据迁移。\n注:此次更新开发者不用修改之前的常用代码。\n\n\n\n\nv3.5.4 (2017年04月12日)\n\n\n\n\n修复若干bug；\n\n\nSDK内部改进。\n注:此次更新开发者不用修改之前的常用代码。\n\n\n\n\nv3.5.3 (2016年11月09日)\n\n\n\n\n增加了对新的短信服务的支持；\n\n\n修复了旧版本使用推送调用BmobInstallation的save()方法导致的内存吃紧问题。\n注:此次更新开发者不用修改之前的常用代码。\n\n\n\n\nv3.5.2 (2016年10月27日)\n\n\n\n\n集成了统计SDK功能,开发者不用额外集成；\n\n\n修复了一键注册登录的用户扩展字段信息没有保存到本地的bug；\n\n\n对文件上传到又拍云回调成功但返回的path为\"null\"的低概率情况加了判断并提示重传；\n\n\n修改了BmobQuery等部分细节代码；\n注:此次更新开发者不用修改之前的常用代码 \n\n\n\n\nv3.5.1 (2016年07月20日)\n\n\n\n\n新增对数据迁移的支持。\n\n\n\n\nv3.5.0 (2016年06月27日)\n\n\n\n\n使用\nRx+okhttp3\n全面重构BmobSDK，所有方法均额外提供Observable形式调用；\n\n\nContext参数变化：除初始化方法外，其余方法均不再需要传递Context参数\n\n\n\n\n回调函数变化：\n    1)、所有回调函数的onSuccess、onFailure方法统一调整为done(T t,BmobException e)形式；\n    2）、合并以下回调函数：\n        GetListener\n-\nQueryListener\n\n        GetCallbackGetCallback-\nQueryListener\n\n        FindCallback-\nQueryListener\n\n        DeleteListener、EmailVerifyListener、ResetPasswordByCodeListener、ResetPasswordByEmailListener、VerifySMSCodeListener-\nUpdateListener\n        GetServerTimeListener-\nQueryListener\n\n        OtherLoginListener--\nLogInListener\n\n        StatisticQueryListener、FindStatisticsListener-\nQueryListener\n\n        GetTableSchemaListener-\nQueryListener\n\n        GetAllTableSchemaListener-\nQueryListListener\n\n        QuerySMSStateListener-\nQueryListener\n\n        RequestSMSCodeListener-\nQueryListener\n\n\n\n\n\n\n新增\nBmobBatch\n批量操作类，\n支持批量添加、批量更新、批量删除的同步提交\n，且批量添加的请求返回objectId字段；\n\n\n\n\n修复由于手机时间与服务器时间相差较大引起的调用文件的upload方法返回\n401 signature error\n错误；\n\n\n解决\nAndroidStudio\n运行BmobSDK后出现\nIgnoring InnerClasses attribute for an anonymous inner class\n的警告；\n\n\n同步更新\nBmobPush_v1.0.0\n推送SDK。\n\n\n\n\nv3.4.7 (2016年5月27日)\n\n\n\n\n文件服务的依赖库升级到okhttp3;\n\n\n修复调用文件的download方法有时成功有时却提示\nfile download error(9015)\n的错误;\n\n\n修复连接网络不稳定的wifi进行文件上传操作时出现\nRuntimeException: json 解析出错\n的问题;\n\n\n数据加解密改用底层so库实现，进一步保证数据安全;\n\n\n将权限管理类PermissionManager分离出SDK以减少依赖关系;\n\n\n修复部分机型出现的z.so无法加载的问题;\n\n\n同步更新BmobPush_v0.9的SDK。\n\n\n\n\nv3.4.6 (2016年4月20日)\n\n\n附加：\n\n\n\n\n关于旧版本自动更新组件出现解析包出错问题的解决方法\n；\n\n\n修复v3.4.6_0413版本中自动更新组件出现的AndroidRuntimeException问题；\n\n\n增加文件服务的AppKey和Wake_Lock权限检测。\n\n\n\n\n新增：\n\n\n\n\n新增CDN文件服务，废弃原来的新旧文件服务，但上传方法名不变；\n\n\n新增文件下载download方法，允许设定文件的下载目录；\n\n\n新增文件批量删除接口（只针对于通过CDN文件服务上传的文件）；\n\n\n新增BmobConfig类，允许开发者设置查询超时时间及文件上传时的每片大小；\n\n\n全面兼容Android6.0系统，并增加权限管理工具类(PermissionManager)，方便开发者对权限进行控制和管理。\n转移：\n文件的批量上传的静态uploadBatch方法由Bmob类转移至BmobFile类。\n修复：\n\n\n修复调用add、addUnique、remove、removeAll、increment、setValue等方法成功后本地用户信息未及时更新的问题；\n\n\n修复自动更新组件中target_size填成英文导致应用奔溃的问题；\n\n\n修复部分机型出现的缓存查询失效的问题；\n\n\n修复同时发送多个查询请求时会出现多次初始化的问题；\n\n\n修复由手机系统时间的修改而导致的sdk time error的问题（需要在应用启动页面的onCreate方法中调用Bmob.getInstance().synchronizeTime(context)方法）。\n\n\n\n\nv3.4.5 (2015年11月11日)\n\n\n\n\n修复特殊网络情况下出现400错误的问题；\n\n\n新增getObjectByKey方法获取当前登陆用户的某一列的值；\n\n\nsetValue方法支持java基本数据类型；\n\n\n强制更新模式下隐藏右上角关闭按钮。\n\n\n\n\nv3.4.4 (2015年9月30日)\n\n\n\n\n新增数组更新方式，并同步支持所有类型的字段更新；\n\n\n自动更新组件回调方法中添加更新错误提示\n\n\n\n\nv3.4.3 (2015年8月20日)\n\n\n\n\n新增修改当前用户密码的方法；\n\n\n修复V3.4.3_0820版本中一键注册或登录方法出错的问题；\n\n\n推送的频道订阅增加去重操作；\n\n\n使用okhttp优化网络框架，提升网络效率。\n\n\n\n\nv3.4.2 (2015年7月27日)\n\n\n\n\n新增获取表结构信息的方法 \n\n\n\n\nv3.4.1 (2015年7月10日)\n\n\n\n\n短信服务允许自定义短信内容； \n\n\n新版文件服务新增获取文件地址的方法；\n\n\n新版文件服务新增文件删除功能；\n\n\n新旧文件服务同步兼容BmobFile对象；\n\n\n优化新版文件上传与下载的进度提示。\n\n\n\n\nv3.4.0 (2015年6月16日)\n\n\n\n\n短信验证统一采用BmobSMS类； \n\n\n修复其他bug。\n\n\n\n\nv3.3.9 (2015年6月12日)\n\n\n\n\n新增短信验证API； \n\n\n用户登录新增多种登录方式：邮箱+密码、手机号码+密码、手机号码+短信验证码； \n\n\n修改第三方账号登录方式，并新增对微信登录的支持；\n\n\n修复自动更新组件多次点击忽略版本的更新按钮报错的bug。\n\n\n\n\nv3.3.8 (2015年5月21日)\n\n\n\n\naddWhereEqualTo方法支持一对多关联关系查询；\n\n\n缓存查询方法允许单独使用； \n\n\n修复BQL查询设置缓存策略后查询出错的问题。\n\n\n\n\nv3.3.7 (2015年5月13日)\n\n\n\n\n新增SQL语句查询，让查询更简单；\n\n\n解决新版文件管理处理本地缩略图时出现OOM的问题； \n\n\n解决新版文件管理提交缩略图任务时modelId无效的问题。\n\n\n\n\nv3.3.6 (2015年4月27日)\n\n\n\n\n新增统计查询方法，可查询总和、平均值、最大值、最小值并支持分组和添加过滤条件。 \n\n\n\n\nv3.3.5 (2015年4月08日)\n\n\n\n\n自动更新组件中修复自动更新方式下无法强制用户更新应用的问题；\n\n\n自动更新组件中支持监听对话框按键操作；\n\n\nBmobPush同步更新到V0.6版本。\n\n\n\n\nv3.3.4 (2015年3月10日)\n\n\n\n\n修复自动更新组件的自动更新方式下“忽略该版”按钮选中再取消后无法再次出现版本更新提示的问题；\n\n\n自动更新组件中允许下载已上传到应用市场的apk文件（须填写应用市场下载地址android_url）;\n\n\n自动更新组件中支持对更新内容根据分隔符“；”进行文字排版;\n\n\n修复某些特定情况下调用BmobUser的update方法后无法获取最近更新的用户信息;\n\n\n修复新版文件管理中开启URL签名认证后无法获取签名地址的问题。\n\n\n\n\nv3.3.3 (2015年2月11日)\n\n\n\n\n修复第三方登陆成功后无法获取本地用户信息的问题；\n\n\n修复设置缓存策略后无法获取本地缓存信息的问题；\n\n\n修复调用云端代码（callEndpoint）方法的成功回调的返回值中含有“results”的问题；\n\n\n新版文件管理中对本地缩略图的处理方法新增压缩质量的参数。\n\n\n\n\nv3.3.2 (2015年1月27日)\n\n\n\n\n整体优化新版文件管理的代码结构和处理流程；\n\n\n修复自动更新的初始化方法无法自动创建AppVersion表的问题。\n\n\n\n\nv3.3.1 (2015年1月21日)\n\n\n\n\n修复新版SDK由于初始化方法未成功返回而导致的sdk time error、internal error等错误；\n\n\n修复调用BmobUser的update方法成功之后再调用getCurrentUser方法无法获取已更新信息的问题。\n\n\n\n\nv3.3.0 (2015年1月19日)\n\n\n\n\n新增数据加密功能，保障数据安全，强烈建议更新SDK；\n\n\n新增文件删除功能；\n\n\nBmobProFile类增加URL签名方法；\n\n\n修复BmobProFile类获取本地缩略图的方法出错的问题；\n\n\n\n\nv3.2.9 (2015年1月12日)\n\n\n\n\n新增新版文件管理BmobProFile类，提供了单一上传、批量上传、下载文件、生成缩略图等功能。\n\n\n\n\nv3.2.8 (2015年1月05日)\n\n\n\n\n修改单一文件upload方法报NullPointerException错误的问题；\n\n\n修改调用loadImageThumbnail来加载缩略图报can not draw recycle bitmap错误的问题。\n\n\n\n\nv3.2.7 (2014年12月09日)\n\n\n\n\n新增安全认证功能，增加SDK安全性；\n\n\n新增批量上传文件的功能；\n\n\n为单一文件上传补充进度提醒（onProgress）方法；\n\n\n解决第三方登陆成功之后无法修改用户信息的问题；\n\n\n支持复合与查询方式。\n\n\n\n\nv3.2.6 (2014年11月03日)\n\n\n\n\n修改Bmob的应用Application ID的本地存储方式。\n\n\n\n\nv3.2.5 (2014年10月27日)\n\n\n\n\n修复SDK调用云端代码出现ArrayIndexOutOfBoundsException(对应的错误码为9015)的问题；\n\n\n修复自动更新组件在切换网络之后出现的解析包错误的问题，增加target_size必填项；\n\n\n更新BmobpushSDK到V0.5，优化推送服务频繁重启的问题，建议使用此版本推送服务。\n\n\n\n\nv3.2.4 (2014年10月13日)\n\n\n\n\n修改调用addWhereWithinGeoBox（查询指定位置的某矩形范围内）和addWhereWithinRadians（查询指定半径范围内）方法查询数据时出错的bug；\n\n\n修改调用BmobObject和BmobUser的update和delete方法出错的bug；\n\n\n第三方账号登录增加OnCancel回调方法；\n\n\n修改批量插入带pointer类型的数据时出现上传后的pointer类型的字段变成BmobObject类型的bug；\n\n\n更新BmobpushSDK到V0.4，优化导致推送延迟或无法接收到推送的问题。\n\n\n\n\nv3.2.3 (2014年9月18日)\n\n\n\n\n第三方账号登陆增加QQ、新浪微博关联与取消关联的方法；\n\n\n自动更新组件新增初始化创建AppVersion表，不再需要手动创建；\n\n\n自动更新组件新增强制更新和忽略版本更新功能；\n\n\n修复调用BmobUser的update(context)方法和BmobObject的save(context)方法报错的bug；\n\n\n修复其他bug。 \n\n\n\n\nv3.2.2 (2014年9月15日)\n\n\n\n\n修改V3.2.1版本文件上传出错的问题； \n\n\n更新Bmobpush到V0.3，增加推送服务稳定性；\n\n\n修复其他bug。 \n\n\n\n\nv3.2.1 (2014年9月02日)\n\n\n\n\n增加删除字段功能\n\n\n增加对数组字段的增删改查功能\n\n\n去除insertObject、updateObject等过期方法\n\n\n修改云端代码返回Json数据时带反斜杠的问题\n\n\n修复其他Bug \n\n\n\n\nv3.2.0 (2014年8月08日)\n\n\n\n\n增加数据实时功能\n\n\n\n\nv3.1.9 (2014年8月05日)\n\n\n\n\n修复文件分片上传失败无限重试的bug\n\n\n增加新浪微博、手机QQ的第三方账号登陆\n\n\n\n\nv3.1.8 (2014年7月23日)\n\n\n\n\n修复文件上传失败的bug\n\n\n更新BmobPushSDK到0.2beta\n\n\n\n\nv3.1.7_Beta (2014年7月17日)\n\n\n\n\n增加BmobQuery对象getObject时include、addQueryKeys等操作的支持\n\n\n\n\nv3.1.6_Beta (2014年7月14日)\n\n\n\n\n修复Pointer类型创建错误的bug\n\n\n修复自动更新点击通知栏崩溃的bug\n\n\n增加推送JSONObject数据的支持\n\n\n修复注册用户成功后在onSuccess回调中获取本地用户为null的bug\n\n\n\n\nv3.1.5_Beta (2014年6月28日)\n\n\n\n\n修复初始化设备表失败的bug\n\n\n恢复NETWORK_ELSE_CACHE查询缓存策略\n\n\n\n\nv3.1.4_Beta (2014年6月19日)\n\n\n\n\n修复findObjects查询无缓存数据时的错误回调\n\n\n修复BmobUser类中Number类型字段增量更新无效的bug\n\n\n修复创建数据对象中包含指针类型为BmobUser时创建失败的bug\n\n\n修复查询对象多继承时，表名获取错误的bug\n\n\n修复第一次保存Installation信息失败的bug\n\n\n增加应用自动更新功能\n\n\n\n\nv3.1.3_Beta (2014年6月10日)\n\n\n\n\n修复同一字段的and查询操作\n\n\n增加用户注册成功后的缓存操作\n\n\n修复同一对象中多个Pointer类型的include查询失效的bug\n\n\nBmobObject对象添加setTableName方法，可自定义表名\n\n\n增加对老版本创建、查询数据方式的支持\n\n\n\n\nv3.1.2_Beta (2014年6月04日)\n\n\n\n\n修复Context为null时的bug\n\n\n修复在onSuccess方法中出现异常时调用onFailure的bug\n\n\nBmobObject实现Serializable支持序列化\n\n\n\n\nv3.1.1_Beta (2014年6月03日)\n\n\n\n\nSaveListener替代InsertListener\n\n\n修复无网络情况下崩溃的bug\n\n\n\n\nv3.1.0_Beta (2014年5月27日)\n\n\n\n\n修复同一个对象不能自增多列的bug\n\n\n增加错误代码机制\n\n\nBmobFile增加获取缩略图功能\n\n\nBmobFile增加分片上传功能\n\n\nBmobObject增加ACL权限控制\n\n\n增加BmobRole角色管理类\n\n\n修复扩展BmobInstallation属性后查询不到的bug\n\n\n\n\nv3.0.9_Beta (2014年5月21日)\n\n\n\n\n添加无初始化时的提示信息\n\n\n修复BmobUser类不支持Pointer类型的bug\n\n\n修复云端代码不支持返回数据类型为String的bug\n\n\n\n\nv3.0.8_Beta (2014年5月14日)\n\n\n\n\n修复重复查询N次后出现内存溢出的bug\n\n\n修复count查询不支持条件的bug\n\n\nBmobFile增加文件上传进度的支持\n\n\n\n\nv3.0.7_Beta (2014年5月05日)\n\n\n\n\n修复云端代码请求失败的bug\n\n\n\n\nv3.0.6_Beta (2014年4月30日)\n\n\n\n\n增加BmobPushManager类, 实现客户端推送消息功能\n\n\n增加BmobInstallation类, 可实现自定义推送\n\n\n同步推出Bmob消息推送SDK 0.1.0Beta版本\n\n\n\n\nv3.0.5_Beta (2014年4月29日)\n\n\n\n\n修复登陆成功时出现空指针异常的bug\n\n\n\n\nv3.0.4_Beta  (2014年4月22日)\n\n\n\n\nBmobUser增加邮件验证功能\n\n\nBmobObject增加批量操作功能，可批量添加、更新、删除\n\n\n\n\nv3.0.3_Beta (2014年4月17日)\n\n\n\n\n增加网络数据包压缩功能，更好的节省客户端流量。\n\n\n增加缓存数据的加密、压缩功能，更好的节省了缓存空间和提高数据的安全性。\n\n\nBmobObject对象增加计数器，可以对任何数字字段进行原子增加（或减少）的功能。\n\n\nBmobObject对象增加关联数据类型的支持，可实现不同对象间的一对一、一对多的数据关联。\n\n\nBmobQuery对象增加对关联数据类型查询的支持，可实现关系查询。\n\n\n修复更新对象时存在系统字段的情况导致更新失败的bug。\n\n\nBmobQuery对象增加复合查询支持，可实现or条件查询。\n\n\n\n\nv3.0.2_Beta (2014年4月10日)\n\n\n\n\n修复addWhereContainedIn和addWhereNotContainedIn添加条件无效的bug\n\n\nBmobQuery对象新增addWhereMatches、addWhereContains、addWhereStartsWith、addWhereEndsWith条件添加方法\n\n\nBmobQuery对象新增地理位置查询等方法\n\n\n修改BmobFile实例化方法\n\n\nBmobUser对象新增getCurrentUser、logOut方法\n\n\n修改BmobUser.resetPassword为静态方法\n\n\nBmobQuery对象增加查询用户表的特殊处理\n\n\nBmobQuery对象新增查询时的缓存策略。\n\n\n\n\nv3.0.1_Beta (2014年4月08日)\n\n\n\n\n优化BmobQuery查询方法getObject、findObjects\n\n\n\n\nv3.0_Beta (2014年4月04日)\n\n\n\n\n新版本3.0beta和之前的版本使用方式有所不同，新的版本使用更加方便和稳定。\n\n\n新版已解决之前在主线程执行操作时抛出的android.os.NetworkOnMainThreadException异常\n\n\n新版的数据请求模块基于Volley网络通信框架，能使网络通信更快，更简单，更健壮。\n\n\n新版的对象解析模块基于Gson,提高接口数据和javaBean之间的转换速度。\n\n\n新增查询指定数据列的功能。\n\n\n具体使用方法请参考示例程序。\n\n\n\n\nv2.2.8_Beta (2014年3月24日)\n\n\n\n\n修复保存文件失败的bug\n\n\n增加获取服务器时间的方法Bmob.getServerTime \n\n\n增加华为云推送功能 \n\n\n\n\nv2.2.7_Beta (2014年1月07日)\n\n\n\n\n修复调用云端代码时BmobClientCallback不能引用的bug \n\n\n修复CountCallback不能引用的bug \n\n\n\n\nv2.2.6_Beta (2013年12月27日)\n\n\n\n\n修正无网络情况下，获取BmobFileUrl为null的bug\n\n\n改善Context为null时出现的bug 3.新增云端代码功能 \n\n\n\n\nv2.2.5_Beta (2013年11月15日)\n\n\n\n\n修正updateAt为null的bug\n\n\n\n\nv2.2.4_Beta (2013年11月13日)\n\n\n\n\n修正Date类型数据格式\n\n\n新增getDate方法获取Date类型数据\n\n\n新增ACL功能，提高数据安全性\n\n\n新增加密码重置功能\n\n\n\n\nv2.2.3_Beta (2013年9月27日)\n\n\n\n\n新增Count查询功能\n\n\n新增地理位置查询功能 \n\n\n修正BmobGeoPoint数据类型的存储格式\n\n\n修正上传文件失败的bug\n\n\n\n\nv2.2.2_Beta (2013年9月18日)\n\n\n\n\n完善缓存策略功能，提供自定义缓存时间，默认缓存时间为5小时\n\n\n更新接口服务，提升响应速度\n\n\n\n\nv2.2.1_Beta  (2013年9月04日)\n\n\n\n\n修正一些崩溃的bug \n\n\n修正更新数据成功后返回的数据结构体 \n\n\n修正查询数据成功后返回的file、GeoPoint、Data等数据类型结构错误的bug \n\n\n修正无效objectId删除成功的bug \n\n\n修正分页查询数据不正确的bug \n\n\n修正未添加网络权限及无网络状态时引起崩溃的bug \n\n\n修正用户使用正确用户名、密码登陆失败的bug \n\n\n修改创建数据成功后返回的数据内容 \n\n\n新增查询数据默认的limit为100，最大limit值不可超过1000 \n\n\n新增查询数据时提供6种缓存策略的功能 \n\n\n增加服务器以扩大集群来支撑更大用户量，明显提高响应速度 \n\n\n\n\nv2.2.0_Beta (2013年4月23日)\n\n\n\n\n修复重复添加数据的bug.\n\n\n更新完善开发者指南，如文件查询方式等.\n\n\n对内部流程的优化精简，减少冗余步骤，提供执行效率.\n\n\n增加一些操作的callback回调方法.\n\n\n优化数据传输格式.\n\n\n提升每一项操作的安全性.\n\n\n\n\nv2.1.0_Beta (2013年2月05日)\n\n\n\n\n修复旧版本发现和反馈的bug.\n\n\n优化SDK的性能，压缩了网络请求的流量损耗.\n\n\n提升了SDK在网络传输过程中的数据安全.\n\n\n进一步提升了后端云的并发承载和存储能力，确保服务高效运行.\n\n\n暂停推送服务，寻求erlang解决方案.\n\n\n\n\nv1.0.4_Beta (2012年4月28日)\n\n\n\n\n修复文件类型、地理坐标类型、JsonArray类型、JsonObject类型更新时出现的错误。\n\n\n\n\nv1.0.3_Beta (2012年4月27日)\n\n\n\n\n修复用户注册功能中存在的Bug。\n\n\n修复更新数据失败的重要Bug。\n\n\n修复更新数据后updateAt(更新时间)字段的值未修改的Bug。\n\n\n修复Bmob初始化等方法中的参数名称顺序颠倒的问题。\n\n\n增加用户登录功能。\n\n\n增加本地用户登录、注销功能。\n\n\n\n\nv1.0.2_Beta (2012年4月24日)\n\n\n\n\n修复创建用户对象时，提示数据表名称不正确的Bug。\n\n\n提供BmobObject数据对象的创建时间、更新时间两个字段值的获取。（BmobObject.getCreatedAt(),BmobObject.getUpdatedAt()）\n\n\n完善文件类型、地理坐标类型、JsonArray类型、JsonObject这几种数据类型的封装，便于更好的从查询结果中获取数据。\n\n\n\n\nv1.0.0_Beta (2012年4月08日)\n\n\n\n\n产品上线", 
            "title": "更新日志"
        }, 
        {
            "location": "/data/android/update_log/#v355-20170420", 
            "text": "sdk新增重新设置主域名，类似之前的数据迁移。\n注:此次更新开发者不用修改之前的常用代码。", 
            "title": "v3.5.5 (2017年04月20日)"
        }, 
        {
            "location": "/data/android/update_log/#v354-20170412", 
            "text": "修复若干bug；  SDK内部改进。\n注:此次更新开发者不用修改之前的常用代码。", 
            "title": "v3.5.4 (2017年04月12日)"
        }, 
        {
            "location": "/data/android/update_log/#v353-20161109", 
            "text": "增加了对新的短信服务的支持；  修复了旧版本使用推送调用BmobInstallation的save()方法导致的内存吃紧问题。\n注:此次更新开发者不用修改之前的常用代码。", 
            "title": "v3.5.3 (2016年11月09日)"
        }, 
        {
            "location": "/data/android/update_log/#v352-20161027", 
            "text": "集成了统计SDK功能,开发者不用额外集成；  修复了一键注册登录的用户扩展字段信息没有保存到本地的bug；  对文件上传到又拍云回调成功但返回的path为\"null\"的低概率情况加了判断并提示重传；  修改了BmobQuery等部分细节代码；\n注:此次更新开发者不用修改之前的常用代码", 
            "title": "v3.5.2 (2016年10月27日)"
        }, 
        {
            "location": "/data/android/update_log/#v351-20160720", 
            "text": "新增对数据迁移的支持。", 
            "title": "v3.5.1 (2016年07月20日)"
        }, 
        {
            "location": "/data/android/update_log/#v350-20160627", 
            "text": "使用 Rx+okhttp3 全面重构BmobSDK，所有方法均额外提供Observable形式调用；  Context参数变化：除初始化方法外，其余方法均不再需要传递Context参数   回调函数变化：\n    1)、所有回调函数的onSuccess、onFailure方法统一调整为done(T t,BmobException e)形式；\n    2）、合并以下回调函数：\n        GetListener - QueryListener \n        GetCallbackGetCallback- QueryListener \n        FindCallback- QueryListener \n        DeleteListener、EmailVerifyListener、ResetPasswordByCodeListener、ResetPasswordByEmailListener、VerifySMSCodeListener- UpdateListener\n        GetServerTimeListener- QueryListener \n        OtherLoginListener-- LogInListener \n        StatisticQueryListener、FindStatisticsListener- QueryListener \n        GetTableSchemaListener- QueryListener \n        GetAllTableSchemaListener- QueryListListener \n        QuerySMSStateListener- QueryListener \n        RequestSMSCodeListener- QueryListener    新增 BmobBatch 批量操作类， 支持批量添加、批量更新、批量删除的同步提交 ，且批量添加的请求返回objectId字段；   修复由于手机时间与服务器时间相差较大引起的调用文件的upload方法返回 401 signature error 错误；  解决 AndroidStudio 运行BmobSDK后出现 Ignoring InnerClasses attribute for an anonymous inner class 的警告；  同步更新 BmobPush_v1.0.0 推送SDK。", 
            "title": "v3.5.0 (2016年06月27日)"
        }, 
        {
            "location": "/data/android/update_log/#v347-2016527", 
            "text": "文件服务的依赖库升级到okhttp3;  修复调用文件的download方法有时成功有时却提示 file download error(9015) 的错误;  修复连接网络不稳定的wifi进行文件上传操作时出现 RuntimeException: json 解析出错 的问题;  数据加解密改用底层so库实现，进一步保证数据安全;  将权限管理类PermissionManager分离出SDK以减少依赖关系;  修复部分机型出现的z.so无法加载的问题;  同步更新BmobPush_v0.9的SDK。", 
            "title": "v3.4.7 (2016年5月27日)"
        }, 
        {
            "location": "/data/android/update_log/#v346-2016420", 
            "text": "附加：   关于旧版本自动更新组件出现解析包出错问题的解决方法 ；  修复v3.4.6_0413版本中自动更新组件出现的AndroidRuntimeException问题；  增加文件服务的AppKey和Wake_Lock权限检测。   新增：   新增CDN文件服务，废弃原来的新旧文件服务，但上传方法名不变；  新增文件下载download方法，允许设定文件的下载目录；  新增文件批量删除接口（只针对于通过CDN文件服务上传的文件）；  新增BmobConfig类，允许开发者设置查询超时时间及文件上传时的每片大小；  全面兼容Android6.0系统，并增加权限管理工具类(PermissionManager)，方便开发者对权限进行控制和管理。\n转移：\n文件的批量上传的静态uploadBatch方法由Bmob类转移至BmobFile类。\n修复：  修复调用add、addUnique、remove、removeAll、increment、setValue等方法成功后本地用户信息未及时更新的问题；  修复自动更新组件中target_size填成英文导致应用奔溃的问题；  修复部分机型出现的缓存查询失效的问题；  修复同时发送多个查询请求时会出现多次初始化的问题；  修复由手机系统时间的修改而导致的sdk time error的问题（需要在应用启动页面的onCreate方法中调用Bmob.getInstance().synchronizeTime(context)方法）。", 
            "title": "v3.4.6 (2016年4月20日)"
        }, 
        {
            "location": "/data/android/update_log/#v345-20151111", 
            "text": "修复特殊网络情况下出现400错误的问题；  新增getObjectByKey方法获取当前登陆用户的某一列的值；  setValue方法支持java基本数据类型；  强制更新模式下隐藏右上角关闭按钮。", 
            "title": "v3.4.5 (2015年11月11日)"
        }, 
        {
            "location": "/data/android/update_log/#v344-2015930", 
            "text": "新增数组更新方式，并同步支持所有类型的字段更新；  自动更新组件回调方法中添加更新错误提示", 
            "title": "v3.4.4 (2015年9月30日)"
        }, 
        {
            "location": "/data/android/update_log/#v343-2015820", 
            "text": "新增修改当前用户密码的方法；  修复V3.4.3_0820版本中一键注册或登录方法出错的问题；  推送的频道订阅增加去重操作；  使用okhttp优化网络框架，提升网络效率。", 
            "title": "v3.4.3 (2015年8月20日)"
        }, 
        {
            "location": "/data/android/update_log/#v342-2015727", 
            "text": "新增获取表结构信息的方法", 
            "title": "v3.4.2 (2015年7月27日)"
        }, 
        {
            "location": "/data/android/update_log/#v341-2015710", 
            "text": "短信服务允许自定义短信内容；   新版文件服务新增获取文件地址的方法；  新版文件服务新增文件删除功能；  新旧文件服务同步兼容BmobFile对象；  优化新版文件上传与下载的进度提示。", 
            "title": "v3.4.1 (2015年7月10日)"
        }, 
        {
            "location": "/data/android/update_log/#v340-2015616", 
            "text": "短信验证统一采用BmobSMS类；   修复其他bug。", 
            "title": "v3.4.0 (2015年6月16日)"
        }, 
        {
            "location": "/data/android/update_log/#v339-2015612", 
            "text": "新增短信验证API；   用户登录新增多种登录方式：邮箱+密码、手机号码+密码、手机号码+短信验证码；   修改第三方账号登录方式，并新增对微信登录的支持；  修复自动更新组件多次点击忽略版本的更新按钮报错的bug。", 
            "title": "v3.3.9 (2015年6月12日)"
        }, 
        {
            "location": "/data/android/update_log/#v338-2015521", 
            "text": "addWhereEqualTo方法支持一对多关联关系查询；  缓存查询方法允许单独使用；   修复BQL查询设置缓存策略后查询出错的问题。", 
            "title": "v3.3.8 (2015年5月21日)"
        }, 
        {
            "location": "/data/android/update_log/#v337-2015513", 
            "text": "新增SQL语句查询，让查询更简单；  解决新版文件管理处理本地缩略图时出现OOM的问题；   解决新版文件管理提交缩略图任务时modelId无效的问题。", 
            "title": "v3.3.7 (2015年5月13日)"
        }, 
        {
            "location": "/data/android/update_log/#v336-2015427", 
            "text": "新增统计查询方法，可查询总和、平均值、最大值、最小值并支持分组和添加过滤条件。", 
            "title": "v3.3.6 (2015年4月27日)"
        }, 
        {
            "location": "/data/android/update_log/#v335-2015408", 
            "text": "自动更新组件中修复自动更新方式下无法强制用户更新应用的问题；  自动更新组件中支持监听对话框按键操作；  BmobPush同步更新到V0.6版本。", 
            "title": "v3.3.5 (2015年4月08日)"
        }, 
        {
            "location": "/data/android/update_log/#v334-2015310", 
            "text": "修复自动更新组件的自动更新方式下“忽略该版”按钮选中再取消后无法再次出现版本更新提示的问题；  自动更新组件中允许下载已上传到应用市场的apk文件（须填写应用市场下载地址android_url）;  自动更新组件中支持对更新内容根据分隔符“；”进行文字排版;  修复某些特定情况下调用BmobUser的update方法后无法获取最近更新的用户信息;  修复新版文件管理中开启URL签名认证后无法获取签名地址的问题。", 
            "title": "v3.3.4 (2015年3月10日)"
        }, 
        {
            "location": "/data/android/update_log/#v333-2015211", 
            "text": "修复第三方登陆成功后无法获取本地用户信息的问题；  修复设置缓存策略后无法获取本地缓存信息的问题；  修复调用云端代码（callEndpoint）方法的成功回调的返回值中含有“results”的问题；  新版文件管理中对本地缩略图的处理方法新增压缩质量的参数。", 
            "title": "v3.3.3 (2015年2月11日)"
        }, 
        {
            "location": "/data/android/update_log/#v332-2015127", 
            "text": "整体优化新版文件管理的代码结构和处理流程；  修复自动更新的初始化方法无法自动创建AppVersion表的问题。", 
            "title": "v3.3.2 (2015年1月27日)"
        }, 
        {
            "location": "/data/android/update_log/#v331-2015121", 
            "text": "修复新版SDK由于初始化方法未成功返回而导致的sdk time error、internal error等错误；  修复调用BmobUser的update方法成功之后再调用getCurrentUser方法无法获取已更新信息的问题。", 
            "title": "v3.3.1 (2015年1月21日)"
        }, 
        {
            "location": "/data/android/update_log/#v330-2015119", 
            "text": "新增数据加密功能，保障数据安全，强烈建议更新SDK；  新增文件删除功能；  BmobProFile类增加URL签名方法；  修复BmobProFile类获取本地缩略图的方法出错的问题；", 
            "title": "v3.3.0 (2015年1月19日)"
        }, 
        {
            "location": "/data/android/update_log/#v329-2015112", 
            "text": "新增新版文件管理BmobProFile类，提供了单一上传、批量上传、下载文件、生成缩略图等功能。", 
            "title": "v3.2.9 (2015年1月12日)"
        }, 
        {
            "location": "/data/android/update_log/#v328-2015105", 
            "text": "修改单一文件upload方法报NullPointerException错误的问题；  修改调用loadImageThumbnail来加载缩略图报can not draw recycle bitmap错误的问题。", 
            "title": "v3.2.8 (2015年1月05日)"
        }, 
        {
            "location": "/data/android/update_log/#v327-20141209", 
            "text": "新增安全认证功能，增加SDK安全性；  新增批量上传文件的功能；  为单一文件上传补充进度提醒（onProgress）方法；  解决第三方登陆成功之后无法修改用户信息的问题；  支持复合与查询方式。", 
            "title": "v3.2.7 (2014年12月09日)"
        }, 
        {
            "location": "/data/android/update_log/#v326-20141103", 
            "text": "修改Bmob的应用Application ID的本地存储方式。", 
            "title": "v3.2.6 (2014年11月03日)"
        }, 
        {
            "location": "/data/android/update_log/#v325-20141027", 
            "text": "修复SDK调用云端代码出现ArrayIndexOutOfBoundsException(对应的错误码为9015)的问题；  修复自动更新组件在切换网络之后出现的解析包错误的问题，增加target_size必填项；  更新BmobpushSDK到V0.5，优化推送服务频繁重启的问题，建议使用此版本推送服务。", 
            "title": "v3.2.5 (2014年10月27日)"
        }, 
        {
            "location": "/data/android/update_log/#v324-20141013", 
            "text": "修改调用addWhereWithinGeoBox（查询指定位置的某矩形范围内）和addWhereWithinRadians（查询指定半径范围内）方法查询数据时出错的bug；  修改调用BmobObject和BmobUser的update和delete方法出错的bug；  第三方账号登录增加OnCancel回调方法；  修改批量插入带pointer类型的数据时出现上传后的pointer类型的字段变成BmobObject类型的bug；  更新BmobpushSDK到V0.4，优化导致推送延迟或无法接收到推送的问题。", 
            "title": "v3.2.4 (2014年10月13日)"
        }, 
        {
            "location": "/data/android/update_log/#v323-2014918", 
            "text": "第三方账号登陆增加QQ、新浪微博关联与取消关联的方法；  自动更新组件新增初始化创建AppVersion表，不再需要手动创建；  自动更新组件新增强制更新和忽略版本更新功能；  修复调用BmobUser的update(context)方法和BmobObject的save(context)方法报错的bug；  修复其他bug。", 
            "title": "v3.2.3 (2014年9月18日)"
        }, 
        {
            "location": "/data/android/update_log/#v322-2014915", 
            "text": "修改V3.2.1版本文件上传出错的问题；   更新Bmobpush到V0.3，增加推送服务稳定性；  修复其他bug。", 
            "title": "v3.2.2 (2014年9月15日)"
        }, 
        {
            "location": "/data/android/update_log/#v321-2014902", 
            "text": "增加删除字段功能  增加对数组字段的增删改查功能  去除insertObject、updateObject等过期方法  修改云端代码返回Json数据时带反斜杠的问题  修复其他Bug", 
            "title": "v3.2.1 (2014年9月02日)"
        }, 
        {
            "location": "/data/android/update_log/#v320-2014808", 
            "text": "增加数据实时功能", 
            "title": "v3.2.0 (2014年8月08日)"
        }, 
        {
            "location": "/data/android/update_log/#v319-2014805", 
            "text": "修复文件分片上传失败无限重试的bug  增加新浪微博、手机QQ的第三方账号登陆", 
            "title": "v3.1.9 (2014年8月05日)"
        }, 
        {
            "location": "/data/android/update_log/#v318-2014723", 
            "text": "修复文件上传失败的bug  更新BmobPushSDK到0.2beta", 
            "title": "v3.1.8 (2014年7月23日)"
        }, 
        {
            "location": "/data/android/update_log/#v317_beta-2014717", 
            "text": "增加BmobQuery对象getObject时include、addQueryKeys等操作的支持", 
            "title": "v3.1.7_Beta (2014年7月17日)"
        }, 
        {
            "location": "/data/android/update_log/#v316_beta-2014714", 
            "text": "修复Pointer类型创建错误的bug  修复自动更新点击通知栏崩溃的bug  增加推送JSONObject数据的支持  修复注册用户成功后在onSuccess回调中获取本地用户为null的bug", 
            "title": "v3.1.6_Beta (2014年7月14日)"
        }, 
        {
            "location": "/data/android/update_log/#v315_beta-2014628", 
            "text": "修复初始化设备表失败的bug  恢复NETWORK_ELSE_CACHE查询缓存策略", 
            "title": "v3.1.5_Beta (2014年6月28日)"
        }, 
        {
            "location": "/data/android/update_log/#v314_beta-2014619", 
            "text": "修复findObjects查询无缓存数据时的错误回调  修复BmobUser类中Number类型字段增量更新无效的bug  修复创建数据对象中包含指针类型为BmobUser时创建失败的bug  修复查询对象多继承时，表名获取错误的bug  修复第一次保存Installation信息失败的bug  增加应用自动更新功能", 
            "title": "v3.1.4_Beta (2014年6月19日)"
        }, 
        {
            "location": "/data/android/update_log/#v313_beta-2014610", 
            "text": "修复同一字段的and查询操作  增加用户注册成功后的缓存操作  修复同一对象中多个Pointer类型的include查询失效的bug  BmobObject对象添加setTableName方法，可自定义表名  增加对老版本创建、查询数据方式的支持", 
            "title": "v3.1.3_Beta (2014年6月10日)"
        }, 
        {
            "location": "/data/android/update_log/#v312_beta-2014604", 
            "text": "修复Context为null时的bug  修复在onSuccess方法中出现异常时调用onFailure的bug  BmobObject实现Serializable支持序列化", 
            "title": "v3.1.2_Beta (2014年6月04日)"
        }, 
        {
            "location": "/data/android/update_log/#v311_beta-2014603", 
            "text": "SaveListener替代InsertListener  修复无网络情况下崩溃的bug", 
            "title": "v3.1.1_Beta (2014年6月03日)"
        }, 
        {
            "location": "/data/android/update_log/#v310_beta-2014527", 
            "text": "修复同一个对象不能自增多列的bug  增加错误代码机制  BmobFile增加获取缩略图功能  BmobFile增加分片上传功能  BmobObject增加ACL权限控制  增加BmobRole角色管理类  修复扩展BmobInstallation属性后查询不到的bug", 
            "title": "v3.1.0_Beta (2014年5月27日)"
        }, 
        {
            "location": "/data/android/update_log/#v309_beta-2014521", 
            "text": "添加无初始化时的提示信息  修复BmobUser类不支持Pointer类型的bug  修复云端代码不支持返回数据类型为String的bug", 
            "title": "v3.0.9_Beta (2014年5月21日)"
        }, 
        {
            "location": "/data/android/update_log/#v308_beta-2014514", 
            "text": "修复重复查询N次后出现内存溢出的bug  修复count查询不支持条件的bug  BmobFile增加文件上传进度的支持", 
            "title": "v3.0.8_Beta (2014年5月14日)"
        }, 
        {
            "location": "/data/android/update_log/#v307_beta-2014505", 
            "text": "修复云端代码请求失败的bug", 
            "title": "v3.0.7_Beta (2014年5月05日)"
        }, 
        {
            "location": "/data/android/update_log/#v306_beta-2014430", 
            "text": "增加BmobPushManager类, 实现客户端推送消息功能  增加BmobInstallation类, 可实现自定义推送  同步推出Bmob消息推送SDK 0.1.0Beta版本", 
            "title": "v3.0.6_Beta (2014年4月30日)"
        }, 
        {
            "location": "/data/android/update_log/#v305_beta-2014429", 
            "text": "修复登陆成功时出现空指针异常的bug", 
            "title": "v3.0.5_Beta (2014年4月29日)"
        }, 
        {
            "location": "/data/android/update_log/#v304_beta-2014422", 
            "text": "BmobUser增加邮件验证功能  BmobObject增加批量操作功能，可批量添加、更新、删除", 
            "title": "v3.0.4_Beta  (2014年4月22日)"
        }, 
        {
            "location": "/data/android/update_log/#v303_beta-2014417", 
            "text": "增加网络数据包压缩功能，更好的节省客户端流量。  增加缓存数据的加密、压缩功能，更好的节省了缓存空间和提高数据的安全性。  BmobObject对象增加计数器，可以对任何数字字段进行原子增加（或减少）的功能。  BmobObject对象增加关联数据类型的支持，可实现不同对象间的一对一、一对多的数据关联。  BmobQuery对象增加对关联数据类型查询的支持，可实现关系查询。  修复更新对象时存在系统字段的情况导致更新失败的bug。  BmobQuery对象增加复合查询支持，可实现or条件查询。", 
            "title": "v3.0.3_Beta (2014年4月17日)"
        }, 
        {
            "location": "/data/android/update_log/#v302_beta-2014410", 
            "text": "修复addWhereContainedIn和addWhereNotContainedIn添加条件无效的bug  BmobQuery对象新增addWhereMatches、addWhereContains、addWhereStartsWith、addWhereEndsWith条件添加方法  BmobQuery对象新增地理位置查询等方法  修改BmobFile实例化方法  BmobUser对象新增getCurrentUser、logOut方法  修改BmobUser.resetPassword为静态方法  BmobQuery对象增加查询用户表的特殊处理  BmobQuery对象新增查询时的缓存策略。", 
            "title": "v3.0.2_Beta (2014年4月10日)"
        }, 
        {
            "location": "/data/android/update_log/#v301_beta-2014408", 
            "text": "优化BmobQuery查询方法getObject、findObjects", 
            "title": "v3.0.1_Beta (2014年4月08日)"
        }, 
        {
            "location": "/data/android/update_log/#v30_beta-2014404", 
            "text": "新版本3.0beta和之前的版本使用方式有所不同，新的版本使用更加方便和稳定。  新版已解决之前在主线程执行操作时抛出的android.os.NetworkOnMainThreadException异常  新版的数据请求模块基于Volley网络通信框架，能使网络通信更快，更简单，更健壮。  新版的对象解析模块基于Gson,提高接口数据和javaBean之间的转换速度。  新增查询指定数据列的功能。  具体使用方法请参考示例程序。", 
            "title": "v3.0_Beta (2014年4月04日)"
        }, 
        {
            "location": "/data/android/update_log/#v228_beta-2014324", 
            "text": "修复保存文件失败的bug  增加获取服务器时间的方法Bmob.getServerTime   增加华为云推送功能", 
            "title": "v2.2.8_Beta (2014年3月24日)"
        }, 
        {
            "location": "/data/android/update_log/#v227_beta-2014107", 
            "text": "修复调用云端代码时BmobClientCallback不能引用的bug   修复CountCallback不能引用的bug", 
            "title": "v2.2.7_Beta (2014年1月07日)"
        }, 
        {
            "location": "/data/android/update_log/#v226_beta-20131227", 
            "text": "修正无网络情况下，获取BmobFileUrl为null的bug  改善Context为null时出现的bug 3.新增云端代码功能", 
            "title": "v2.2.6_Beta (2013年12月27日)"
        }, 
        {
            "location": "/data/android/update_log/#v225_beta-20131115", 
            "text": "修正updateAt为null的bug", 
            "title": "v2.2.5_Beta (2013年11月15日)"
        }, 
        {
            "location": "/data/android/update_log/#v224_beta-20131113", 
            "text": "修正Date类型数据格式  新增getDate方法获取Date类型数据  新增ACL功能，提高数据安全性  新增加密码重置功能", 
            "title": "v2.2.4_Beta (2013年11月13日)"
        }, 
        {
            "location": "/data/android/update_log/#v223_beta-2013927", 
            "text": "新增Count查询功能  新增地理位置查询功能   修正BmobGeoPoint数据类型的存储格式  修正上传文件失败的bug", 
            "title": "v2.2.3_Beta (2013年9月27日)"
        }, 
        {
            "location": "/data/android/update_log/#v222_beta-2013918", 
            "text": "完善缓存策略功能，提供自定义缓存时间，默认缓存时间为5小时  更新接口服务，提升响应速度", 
            "title": "v2.2.2_Beta (2013年9月18日)"
        }, 
        {
            "location": "/data/android/update_log/#v221_beta-2013904", 
            "text": "修正一些崩溃的bug   修正更新数据成功后返回的数据结构体   修正查询数据成功后返回的file、GeoPoint、Data等数据类型结构错误的bug   修正无效objectId删除成功的bug   修正分页查询数据不正确的bug   修正未添加网络权限及无网络状态时引起崩溃的bug   修正用户使用正确用户名、密码登陆失败的bug   修改创建数据成功后返回的数据内容   新增查询数据默认的limit为100，最大limit值不可超过1000   新增查询数据时提供6种缓存策略的功能   增加服务器以扩大集群来支撑更大用户量，明显提高响应速度", 
            "title": "v2.2.1_Beta  (2013年9月04日)"
        }, 
        {
            "location": "/data/android/update_log/#v220_beta-2013423", 
            "text": "修复重复添加数据的bug.  更新完善开发者指南，如文件查询方式等.  对内部流程的优化精简，减少冗余步骤，提供执行效率.  增加一些操作的callback回调方法.  优化数据传输格式.  提升每一项操作的安全性.", 
            "title": "v2.2.0_Beta (2013年4月23日)"
        }, 
        {
            "location": "/data/android/update_log/#v210_beta-2013205", 
            "text": "修复旧版本发现和反馈的bug.  优化SDK的性能，压缩了网络请求的流量损耗.  提升了SDK在网络传输过程中的数据安全.  进一步提升了后端云的并发承载和存储能力，确保服务高效运行.  暂停推送服务，寻求erlang解决方案.", 
            "title": "v2.1.0_Beta (2013年2月05日)"
        }, 
        {
            "location": "/data/android/update_log/#v104_beta-2012428", 
            "text": "修复文件类型、地理坐标类型、JsonArray类型、JsonObject类型更新时出现的错误。", 
            "title": "v1.0.4_Beta (2012年4月28日)"
        }, 
        {
            "location": "/data/android/update_log/#v103_beta-2012427", 
            "text": "修复用户注册功能中存在的Bug。  修复更新数据失败的重要Bug。  修复更新数据后updateAt(更新时间)字段的值未修改的Bug。  修复Bmob初始化等方法中的参数名称顺序颠倒的问题。  增加用户登录功能。  增加本地用户登录、注销功能。", 
            "title": "v1.0.3_Beta (2012年4月27日)"
        }, 
        {
            "location": "/data/android/update_log/#v102_beta-2012424", 
            "text": "修复创建用户对象时，提示数据表名称不正确的Bug。  提供BmobObject数据对象的创建时间、更新时间两个字段值的获取。（BmobObject.getCreatedAt(),BmobObject.getUpdatedAt()）  完善文件类型、地理坐标类型、JsonArray类型、JsonObject这几种数据类型的封装，便于更好的从查询结果中获取数据。", 
            "title": "v1.0.2_Beta (2012年4月24日)"
        }, 
        {
            "location": "/data/android/update_log/#v100_beta-2012408", 
            "text": "产品上线", 
            "title": "v1.0.0_Beta (2012年4月08日)"
        }, 
        {
            "location": "/data/ios/", 
            "text": "注册Bmob帐号\n\n\n在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。\n\n\n\n\n网站后台创建应用\n\n\n登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。\n\n\n\n\n获取应用密钥和下载SDK\n\n\n选择你要开发的应用，进入该应用\n\n\n\n\n在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID\n\n\n\n\n获取Application ID后，下载SDK，开发者可以根据自己的需求选择相应的iOS SDK 或Android SDK，点击下载即可。\n\n\n\n\n安装BmobSDK\n\n\n直接添加类库方式使用BmobSDK\n\n\n1)将BmobSDK引入项目:\n\n\n在你的XCode项目工程中，添加BmobSDK.framework\n\n\n2)添加使用的系统framework:\n\n\n在你的XCode工程中Project -\nTARGETS -\n Build Phases-\nLink Binary With Libraries引入CoreLocation.framework、Security.framework、CoreGraphics.framework、MobileCoreServices.framework、CFNetwork.framework、CoreTelephony.framework、SystemConfiguration.framework、libz.1.2.5.tbd、libicucore.tbd、libsqlite3.tbd、libc++.tbd 、\nlibWeChatSDK.a\n (可以直接点击下载)\n\n\n使用CocoaPods安装BmobSDK\n\n\n如何使用CocoaPods安装BmobSDK可查看 \n我们提供的文档\n\n\n设置应用的BmobKey\n\n\n在你的XCode工程中的AppDelegate.m文件中创建应用Key，填入申请的授权Key（SDK使用的是应用密钥里的Application ID），示例如下：\n\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{\n    [Bmob registerWithAppKey:@\n申请的Application ID\n];\n    return YES;\n}\n\n\n\n\n也可以在在main.m文件中，引入头文件 \n#import \nBmobSDK/Bmob.h\n\n\nint main(int argc, char * argv[])\n{\n\n    @autoreleasepool {\n         NSString *appKey = @\n申请的Application ID\n;\n         [Bmob registerWithAppKey:appKey];\n\n       return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate                     class]));\n    }\n}\n\n\n\n\n添加一行数据\n\n\n//往GameScore表添加一条playerName为小明，分数为78的数据\nBmobObject *gameScore = [BmobObject objectWithClassName:@\nGameScore\n];\n[gameScore setObject:@\n小明\n forKey:@\nplayerName\n];\n[gameScore setObject:@78 forKey:@\nscore\n];\n[gameScore setObject:[NSNumber numberWithBool:YES] forKey:@\ncheatMode\n];\n[gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    //进行操作\n}];\n\n\n\n\n获取一行数据\n\n\n//查找GameScore表\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n//查找GameScore表里面id为0c6db13c的数据\n[bquery getObjectInBackgroundWithId:@\n0c6db13c\n block:^(BmobObject *object,NSError *error){\n  if (error){\n          //进行错误处理\n  }else{\n        //表里有id为0c6db13c的数据\n      if (object) {\n            //得到playerName和cheatMode\n          NSString *playerName = [object objectForKey:@\nplayerName\n];\n          BOOL cheatMode = [[object objectForKey:@\ncheatMode\n] boolValue];\n          NSLog(@\n%@----%i\n,playerName,cheatMode);\n      }\n  }\n}];\n\n\n\n\n修改一行数据\n\n\n//查找GameScore表\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n//查找GameScore表里面id为0c6db13c的数据\n[bquery getObjectInBackgroundWithId:@\n0c6db13c\n block:^(BmobObject *object,NSError *error){\n  //没有返回错误\n  if (!error) {\n      //对象存在\n      if (object) {\n            BmobObject *obj1 = [BmobObject objectWithoutDatatWithClassName:object.className objectId:object.objectId];\n           //设置cheatMode为YES\n          [obj1 setObject:[NSNumber numberWithBool:YES] forKey:@\ncheatMode\n];\n          //异步更新数据\n          [obj1 updateInBackground];\n      }\n  }else{\n    //进行错误处理\n  }\n}];\n\n\n\n\n删除一行数据\n\n\nBmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n[bquery getObjectInBackgroundWithId:@\n0c6db13c\n block:^(BmobObject *object, NSError *error){\n    if (error) {\n        //进行错误处理\n    }\n    else{\n        if (object) {\n            //异步删除object\n            [object deleteInBackground];\n        }\n    }\n}];\n\n\n\n\n源码下载\n\n\n快速入门相关源码下载\n\n\n案例教程和源码是快速入门的最简单方法，Bmob也为大家准备了相关的\n案例教程和源码\n，欢迎大家下载和查看。", 
            "title": "快速入门"
        }, 
        {
            "location": "/data/ios/#bmob", 
            "text": "在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。", 
            "title": "注册Bmob帐号"
        }, 
        {
            "location": "/data/ios/#_1", 
            "text": "登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。", 
            "title": "网站后台创建应用"
        }, 
        {
            "location": "/data/ios/#sdk", 
            "text": "选择你要开发的应用，进入该应用   在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID   获取Application ID后，下载SDK，开发者可以根据自己的需求选择相应的iOS SDK 或Android SDK，点击下载即可。", 
            "title": "获取应用密钥和下载SDK"
        }, 
        {
            "location": "/data/ios/#bmobsdk", 
            "text": "", 
            "title": "安装BmobSDK"
        }, 
        {
            "location": "/data/ios/#bmobsdk_1", 
            "text": "1)将BmobSDK引入项目:  在你的XCode项目工程中，添加BmobSDK.framework  2)添加使用的系统framework:  在你的XCode工程中Project - TARGETS -  Build Phases- Link Binary With Libraries引入CoreLocation.framework、Security.framework、CoreGraphics.framework、MobileCoreServices.framework、CFNetwork.framework、CoreTelephony.framework、SystemConfiguration.framework、libz.1.2.5.tbd、libicucore.tbd、libsqlite3.tbd、libc++.tbd 、 libWeChatSDK.a  (可以直接点击下载)", 
            "title": "直接添加类库方式使用BmobSDK"
        }, 
        {
            "location": "/data/ios/#cocoapodsbmobsdk", 
            "text": "如何使用CocoaPods安装BmobSDK可查看  我们提供的文档", 
            "title": "使用CocoaPods安装BmobSDK"
        }, 
        {
            "location": "/data/ios/#bmobkey", 
            "text": "在你的XCode工程中的AppDelegate.m文件中创建应用Key，填入申请的授权Key（SDK使用的是应用密钥里的Application ID），示例如下：  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{\n    [Bmob registerWithAppKey:@ 申请的Application ID ];\n    return YES;\n}  也可以在在main.m文件中，引入头文件  #import  BmobSDK/Bmob.h  int main(int argc, char * argv[])\n{\n\n    @autoreleasepool {\n         NSString *appKey = @ 申请的Application ID ;\n         [Bmob registerWithAppKey:appKey];\n\n       return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate                     class]));\n    }\n}", 
            "title": "设置应用的BmobKey"
        }, 
        {
            "location": "/data/ios/#_2", 
            "text": "//往GameScore表添加一条playerName为小明，分数为78的数据\nBmobObject *gameScore = [BmobObject objectWithClassName:@ GameScore ];\n[gameScore setObject:@ 小明  forKey:@ playerName ];\n[gameScore setObject:@78 forKey:@ score ];\n[gameScore setObject:[NSNumber numberWithBool:YES] forKey:@ cheatMode ];\n[gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    //进行操作\n}];", 
            "title": "添加一行数据"
        }, 
        {
            "location": "/data/ios/#_3", 
            "text": "//查找GameScore表\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n//查找GameScore表里面id为0c6db13c的数据\n[bquery getObjectInBackgroundWithId:@ 0c6db13c  block:^(BmobObject *object,NSError *error){\n  if (error){\n          //进行错误处理\n  }else{\n        //表里有id为0c6db13c的数据\n      if (object) {\n            //得到playerName和cheatMode\n          NSString *playerName = [object objectForKey:@ playerName ];\n          BOOL cheatMode = [[object objectForKey:@ cheatMode ] boolValue];\n          NSLog(@ %@----%i ,playerName,cheatMode);\n      }\n  }\n}];", 
            "title": "获取一行数据"
        }, 
        {
            "location": "/data/ios/#_4", 
            "text": "//查找GameScore表\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n//查找GameScore表里面id为0c6db13c的数据\n[bquery getObjectInBackgroundWithId:@ 0c6db13c  block:^(BmobObject *object,NSError *error){\n  //没有返回错误\n  if (!error) {\n      //对象存在\n      if (object) {\n            BmobObject *obj1 = [BmobObject objectWithoutDatatWithClassName:object.className objectId:object.objectId];\n           //设置cheatMode为YES\n          [obj1 setObject:[NSNumber numberWithBool:YES] forKey:@ cheatMode ];\n          //异步更新数据\n          [obj1 updateInBackground];\n      }\n  }else{\n    //进行错误处理\n  }\n}];", 
            "title": "修改一行数据"
        }, 
        {
            "location": "/data/ios/#_5", 
            "text": "BmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n[bquery getObjectInBackgroundWithId:@ 0c6db13c  block:^(BmobObject *object, NSError *error){\n    if (error) {\n        //进行错误处理\n    }\n    else{\n        if (object) {\n            //异步删除object\n            [object deleteInBackground];\n        }\n    }\n}];", 
            "title": "删除一行数据"
        }, 
        {
            "location": "/data/ios/#_6", 
            "text": "快速入门相关源码下载  案例教程和源码是快速入门的最简单方法，Bmob也为大家准备了相关的 案例教程和源码 ，欢迎大家下载和查看。", 
            "title": "源码下载"
        }, 
        {
            "location": "/data/ios/develop_doc/", 
            "text": "简介\n\n\nBmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。\n\n\n安装\n\n\n使用CocoaPods安装BmobSDK\n\n\n如何使用CocoaPods安装BmobSDK可查看 \n我们提供的文档\n\n\n兼容iOS9\n\n\niOS9默认不允许进行http请求，所以在使用SDK的过程中需要往Info.plist添加一些内容，\n\n\n\n\n完全取消http请求限制\n\n\n\n\nkey\nNSAppTransportSecurity\n/key\n \n\ndict\n\n\nkey\nNSAllowsArbitraryLoads\n/key\n\n\ntrue/\n\n\n/dict\n\n\n\n\n\n\n\n指定部分网址支持http\n\n\n\n\nkey\nNSAppTransportSecurity\n/key\n \n\ndict\n\n   \nkey\nNSExceptionDomains\n/key\n\n      \ndict\n     \n            \nkey\nyourserver.com\n/key\n    \n        \ndict\n      \n            \nkey\nNSIncludesSubdomains\n/key\n\n                \ntrue/\n\n                \nkey\nNSTemporaryExceptionAllowsInsecureHTTPLoads\n/key\n\n                \ntrue/\n             \n                \nkey\nNSTemporaryExceptionMinimumTLSVersion\n/key\n       \n                \nstring\nTLSv1.1\n/string\n    \n            \n/dict\n   \n        \n/dict\n\n \n/dict\n\n\n\n\n\n另外，最新版的sdk已支持bitcode。\n\n\n其他一些需要注意兼容iOS9的地方可以 \n参照这里\n\n\n应用程序\n\n\n在Bmob平台注册的每个账户都可以创建多个应用程序，每个应用程序都有其独自的应用程序ID，在后续程序编写中，所有的应用程序将凭其ID来使用Bmob SDK。同一个应用可以分别在测试环境和生产环境中部署不同的版本。\n\n\n应用安全\n\n\n请大家在使用Bmob开发应用程序之前，认真阅读我们给大家提供的“数据与安全”的文档，确保你的应用在发布时安全。文档 \n请点击\n;\n\n\n数据迁移\n\n\n从v2.1.8开始，数据SDK新增了能重新设置请求域名的Api，类似数据迁移，调用方式如下：\n\n\n[Bmob resetDomain:@\nhttp://demo.bmob.cn/\n];\n\n\n\n\n其中，参数为开发者的域名，调用后的所有请求都指向新的域名。\n\n\n对象\n\n\n数据对象\n\n\nBmob存储的数据是建立在BmobObject基础上的，每个BmobObject包含键(Key)-值(value)对的JSON兼容数据。这个数据是无模式的，这意味着不需要提前指定每个BmobObject存在什么键。你只需要设置你想要的键值对让我们在后端存储。\n\n\n例如，假设你要记录一个游戏的得分。一个单一的BmobObject对象可能包含：score: 1337, playerName: \"Sean Plott\", cheatMode: false。键必须是字母、数字的字符串。值可以是字符串、数字、布尔值、Json数组、和BmobObject对象等。\n\n\n每个BmobObject有一个ClassName，它对应后台的表名。例如，我们可以调用的游戏分数对象的ClassName为GameScore，那么它在后台对应的表名就是GameScore。\n\n\n特殊对象\n\n\n为了提供更好的服务，BmobSDK中提供了BmobUser、BmobInstallation两个特殊的BmobObject对象来完成不同的功能，在这里我们统一称为特殊对象。\nBmobUser对象主要是针对应用中的用户功能而提供的，它对应着web端的User表，使用BmobUser对象可以很方便的在应用中实现用户的注册、登录、邮箱验证等功能，具体的使用方法可查看文档的\n用户\n部分。\nBmobInstallation对象主要用于应用的安装设备管理中，它对应着web端的Installation表，任何安装了你应用的设备都会在此表中产生一条数据标示该设备。结合Bmob提供的推送功能，还可以实现将自定义的消息推送给不同的设备终端，具体的使用方法可查看文档的\n消息推送\n部分。\n\n\n数据类型\n\n\n目前为止，我们支持的数据类型有NSString、NSNumber、NSDate、NSArray、NSDictionary以及BmobObject及其子类对象类型。对应后台的类型为String、Number、Date、Array、Object以及Pointer。\n\n\n创建BmobObject对象\n\n\nBmobObject提供以下几种方法对BmobOjbect进行初始化：\n\n\n/**\n *  创建一个带有className的BmobObject对象\n *\n *  @param  className   表示对象名称(类似数据库表名)\n *\n *  @return BmobObject\n */\n+(instancetype )objectWithClassName:(NSString*)className;\n\n\n/**\n *  创建一个带有className 和objectId的BmobObject对象\n *\n *  @param className 表名\n *  @param objectId  对象的id\n *\n *  @return BmobObject对象\n */\n+(instancetype)objectWithoutDataWithClassName:(NSString*)className objectId:(NSString *)objectId;\n\n/**\n *  从字典创建BmobObject\n *\n *  @param dictionary 字典\n *\n *  @return BmobObject 对象\n */\n-(instancetype)initWithDictionary:(NSDictionary *)dictionary;\n\n\n\n\n添加数据\n\n\n添加一条数据有两步，第一步是构造数据，第二步是保存数据至服务器上，有以下两种方法：\n\n\n/**\n *  后台保存BmobObject对象，没有返回结果\n */\n-(void)saveInBackground;\n\n/**\n *  后台保存BmobObject对象，返回保存的结果\n *\n *  @param  block   返回保存的结果是成功还是失败\n */\n-(void)saveInBackgroundWithResultBlock:(BmobBooleanResultBlock)block;\n\n\n\n\n比如，在一个游戏的应用中，当需要保存游戏分数、玩家信息到服务器中的时候，就可以创建GameScore表来添加数据，添加数据的形式类型与iOS中的NSMutableDictionary对象类似，如下：\n\n\n    //在GameScore创建一条数据，如果当前没GameScore表，则会创建GameScore表\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@\nGameScore\n];\n    //score为1200\n    [gameScore setObject:[NSNumber numberWithInt:1200] forKey:@\nscore\n];\n    //设置userName为小明\n    [gameScore setObject:@\n小明\n forKey:@\nplayerName\n];\n    //设置cheatMode为NO\n    [gameScore setObject:[NSNumber numberWithBool:NO] forKey:@\ncheatMode\n];\n    //设置age为18\n    [gameScore setObject:[NSNumber numberWithInt:18] forKey:@\nage\n];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            //创建对象成功，打印对象值\n            NSLog(@\n%@\n,gameScore);\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@\n%@\n,error);\n        } else {\n            NSLog(@\nUnknow error\n);\n        }\n    }];\n\n\n\n\n\n运行完以上代码后，数据即可保存到服务器端了。为了确认数据是否真的已经保存成功，你可以在Bmob服务器端你的应用程序的数据浏览项目中查看。你应该看到类似这样的结果：\n\n\n    objectId: \n0c6db13c\n, score: 1200, playerName: \n小明\n, cheatMode: false, createdAt:\n2012-03-29 10:32:54\n, updatedAt:\n2012-03-29 10:32:54\n\n\n\n\n\n这里需要注意几点：\n\n\n\n\n在运行以上代码时，如果服务器端你创建的应用程序中已经存在GameScore数据表和相应的score、playerName、cheatMode等字段，那么你此时添加的数据和数据类型也应该和服务器端的表结构一致，否则将保存数据失败。\n\n\n如果服务器端不存在GameScore数据表，那么Bmob将根据你第一次(也就是运行的以上代码)保存的GameSocre对象在服务器为你创建此数据表并插入相应数据。\n\n\n每个BmobObject对象有几个默认的键(数据列)是不需要开发者指定的，objectId是每个保存成功数据的唯一标识符。createAt和updateAt代表每个对象(每条数据)在服务器上创建和最后修改的时间。这些键 (数据列)的创建和数据内容是由服务器端来完成的。\n\n\n在 \n[gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error)\n中，成功创建后，error返回的是nil，可以通过 error.localizedDescription 查看返回的错误信息，之后的类似于 \nxxInBackground\n 中的error也是一样的结构。\n\n\nobjectId，updatedAt，createdAt这些系统属性在调用创建函数（saveInBackground）的时候不需要进行设置，创建成功后，会返回objectId，updatedAt，createdAt。\n\n\n\n\n上述方法中每添加一条数据需要设置一次键值对，如果觉得过于繁琐，可以通过一个NSDictionary来添加数据，利用以下方法即可:\n\n\n    -(void)saveAllWithDictionary:(NSDictionary*)dic;\n\n\n\n\n这个函数。\n\n\n如:\n\n\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@\nGameScore\n];\n    //设置playerName列的值为小黑和age列的值18\n    NSDictionary *dic = @{@\nplayerName\n:@\n小黑\n,@\nscore\n:@18};\n    [gameScore saveAllWithDictionary:dic];\n    //异步保存\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后的动作\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@\n%@\n,error);\n        } else {\n            NSLog(@\nUnknow error\n);\n        }\n    }];\n\n\n\n\n更新数据\n\n\n更新一个对象也是非常简单的，首先获取到要更新的BmobObject对象，进行修改值后再更新数据。例如：\n\n\n- (void)updateObject{\n    //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@\nGameScore\n];\n    [gameScore setObject:[NSNumber numberWithInt:1200] forKey:@\nscore\n];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            NSLog(@\n创建成功,以下为对象值\n);\n            NSLog(@\n%@\n,gameScore);\n\n            //此处是更新操作\n            [gameScore setObject:[NSNumber numberWithInt:110] forKey:@\nscore\n];\n            [gameScore updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@\n更新成功，以下为对象值，可以看到score值已经改变\n);\n                    NSLog(@\n%@\n,gameScore);\n                } else {\n                    NSLog(@\n%@\n,error);\n                }\n            }];\n\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@\n%@\n,error);\n        } else {\n            NSLog(@\nUnknow error\n);\n        }\n    }];\n}\n\n\n\n\n\n如果列存储的是符合JSON格式的字符串对象，可以单独修改该对象的某个值，如有一列名为userAttibute，其值是: {\"name\":\"John\", \"gender\":\"男\"}，如果要修改name为Mike，可以使用以下代码\n\n\n- (void)updateObjectJSONField{\n    //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@\nGameScore\n];\n    NSDictionary *json = @{@\nname\n:@\nJohn\n, @\ngender\n:@\nman\n};\n    [gameScore setObject:json forKey:@\nuserAttibute\n];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            NSLog(@\n创建成功,以下为对象值\n);\n            NSLog(@\n%@\n,gameScore);\n\n            //此处是更新操作\n            BmobObject *gameScoreChanged = [BmobObject objectWithoutDataWithClassName:@\nGameScore\n objectId:gameScore.objectId];\n            [gameScoreChanged setObject:@\nMike\n forKey:@\nuserAttibute.name\n];\n            [gameScoreChanged updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@\n更新成功，以下为对象值，可以看到json里面的name已经改变\n);\n                    NSLog(@\n%@\n,gameScoreChanged);\n                } else {\n                    NSLog(@\n%@\n,error);\n                }\n            }];\n\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@\n%@\n,error);\n        } else {\n            NSLog(@\nUnknow error\n);\n        }\n    }];\n}\n\n\n\n\n此处要注意一点，就是在上传 \ngameScore\n 之后，如果要再次进行更新，请重新构造对象，因为此时的 \ngameScore\n 对象还含有\nuserAttibute\n 的值，下面是错误的代码：\n\n\n    //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@\nGameScore\n];\n    NSDictionary *json = @{@\nname\n:@\nJohn\n, @\ngender\n:@\nman\n};\n    [gameScore setObject:json forKey:@\nuserAttibute\n];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            NSLog(@\n创建成功,以下为对象值\n);\n            NSLog(@\n%@\n,gameScore);\n\n            //错误的做法，直接使用gameScore来设置，请观察gameScore值上传时的值\n            [gameScore setObject:@\nwomen\n forKey:@\nuserAttibute.gender\n];\n            NSLog(@\n上传前的gameScore对象值\\n%@\n,gameScore);\n            [gameScore updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@\n更新成功，以下为对象值，可以看到json里面的gender已经改变\n);\n                    NSLog(@\n%@\n,gameScore);\n                } else {\n                    NSLog(@\n%@\n,error);\n                }\n            }];\n\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@\n%@\n,error);\n        } else {\n            NSLog(@\nUnknow error\n);\n        }\n    }];\n}\n\n\n\n\n运行后查看log，我们可以看到，除了userAttibute属性外，gameScore对象还有userAttibute.gender属性上传至服务器，这样服务器就无法区分客户端到底是要更新 userAttibuteg还是只更新userAttibute中的gender，从而报错。\n\n\n2015-12-14 20:45:55.417 BmobSDKDemo[16867:1430005] 创建成功,以下为对象值\n2015-12-14 20:45:55.418 BmobSDKDemo[16867:1430005] \nclassName = GameScore;\nobjectId = 0f3d45dbc5;\ncreatedAt = 2015-12-14 12:45:55 +0000;\nupdatedAt = 2015-12-14 12:45:55 +0000;\ndate = {\n    userAttibute =     {\n        gender = man;\n        name = John;\n    };\n};\n2015-12-14 20:45:55.419 BmobSDKDemo[16867:1430005] 上传前的gameScore对象值\n\nclassName = GameScore;\nobjectId = 0f3d45dbc5;\ncreatedAt = 2015-12-14 12:45:55 +0000;\nupdatedAt = 2015-12-14 12:45:55 +0000;\ndate = {\n    userAttibute =     {\n        gender = man;\n        name = John;\n    };\n    \nuserAttibute.gender\n = women;\n};\n\n\n\n\n原子计数器\n\n\n为了存储一个计数器类型的数据，Bmob提供对任何数字字段进行原子增加(或者减少)的功能，所以我们可以让score像下面一样增加一个固定的值:\n\n\n    //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@\nGameScore\n];\n    [gameScore setObject:@0 forKey:@\natomicCounter\n];\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            BmobObject *gameScoreToBeChanged = [BmobObject objectWithoutDataWithClassName:@\nGameScore\n objectId:gameScore.objectId];\n            [gameScoreToBeChanged incrementKey:@\natomicCounter\n];\n            [gameScoreToBeChanged updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@\n添加成功，可在后台查看objectID为%@的atomicCounter的值是否为1\n,gameScoreToBeChanged.objectId);\n                } else {\n                    NSLog(@\n%@\n,error);\n                }\n            }];\n        } else {\n            NSLog(@\n%@\n,error);\n        }\n    }];\n\n\n\n\n也提供了\n\n\n//列的值增加amount\n- (void)incrementKey:(NSString *)key byAmount:(NSInteger )amount\n//列的值减去一\n- (void)decrementKey:(NSString *)key\n//列的值减去amount\n- (void)decrementKey:(NSString *)key byAmount:(NSInteger )amount\n\n\n\n\n注意：需要调用更新函数才能完成计数器原子增加(或者减少)。\n\n\n删除数据\n\n\n从服务器删除对象：\n\n\n    BmobObject *bmobObject = [BmobObject objectWithoutDataWithClassName:@\nGameScore\n  objectId:@\nbaaf9cfa1b\n];\n    [bmobObject deleteInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //删除成功后的动作\n            NSLog(@\nsuccessful\n);\n        } else if (error){\n            NSLog(@\n%@\n,error);\n        } else {\n            NSLog(@\nUnKnow error\n);\n        }\n    }];\n\n\n\n\n批量数据操作\n\n\nBmob提供了批量操作的类BmobObjectsBatch,使用该类，可以批量增加，修改，删除数据，但一次请求不能超过50条数据。下面是例子程序：\n\n\nBmobObjectsBatch    *batch = [[BmobObjectsBatch alloc] init] ;\n//在GameScore表中创建一条数据\n[batch saveBmobObjectWithClassName:@\nGameScore\n parameters:@{@\naveScore\n: @{@\n数学\n:@90},@\nscore\n:@78}];\n//在GameScore表中更新objectId为27eabbcfec的数据\n[batch updateBmobObjectWithClassName:@\nGameScore\n objectId:@\n27eabbcfec\n parameters:@{@\nscore\n: @85}];\n//在GameScore表中删除objectId为30752bb92f的数据\n[batch deleteBmobObjectWithClassName:@\nGameScore\n objectId:@\n30752bb92f\n];\n[batch batchObjectsInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    NSLog(@\nbatch error %@\n,[error description]);\n}];\n\n\n\n\n查询\n\n\n查询单条数据\n\n\n在某些情况下，如果知道某条数据的objectId，而且想得知该条数据的内容，可以使用BmobQuery检索得到一个完整的BmobObject：\n\n\n//查找GameScore表\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n//查找GameScore表里面id为0c6db13c的数据\n[bquery getObjectInBackgroundWithId:@\n0c6db13c\n block:^(BmobObject *object,NSError *error){\n  if (error){\n        //进行错误处理\n  }else{\n      //表里有id为0c6db13c的数据\n      if (object) {\n          //得到playerName和cheatMode\n          NSString *playerName = [object objectForKey:@\nplayerName\n];\n          BOOL cheatMode = [[object objectForKey:@\ncheatMode\n] boolValue];\n          NSLog(@\n%@----%i\n,playerName,cheatMode);\n          //打印objectId,createdAt,updatedAt\n          NSLog(@\nobject.objectId = %@\n, [object objectId]);\n          NSLog(@\nobject.createdAt = %@\n, [object createdAt]);\n          NSLog(@\nobject.updatedAt = %@\n, [object updatedAt]);\n      }\n  }\n}];\n\n\n\n\n查询多条数据\n\n\n在某些情况下，当需要查询表中多条元素的时候，可以直接使用findObjectsInBackgroundWithBlock函数获取查询结果，默认100条。\n\n\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n//查找GameScore表的数据\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobObject *obj in array) {\n            //打印playerName\n            NSLog(@\nobj.playerName = %@\n, [obj objectForKey:@\nplayerName\n]);\n            //打印objectId,createdAt,updatedAt\n            NSLog(@\nobj.objectId = %@\n, [obj objectId]);\n            NSLog(@\nobj.createdAt = %@\n, [obj createdAt]);\n            NSLog(@\nobj.updatedAt = %@\n, [obj updatedAt]);\n    }\n}];\n\n\n\n\n这里需要注意的是：\n\n\n1.默认情况下，系统实际上并不会返回所有的数据，而是默认返回10条数据记录，你可以通过setLimit方法设置返回的记录数量。更多细节可\n点击查看查询\n一节中的分页查询。\n\n\n2.当查询的是用户表这种系统表的时候，返回的是BmobUser的数组，设备表，角色表也是这样的。\n\n\n3.查询用户表，设备表、角色表为：\n\n\nBmobQuery   *bquery = [BmobUser query]; //用户表\nBmobQuery   *bquery = [BmobInstallation query]; //设备表\nBmobQuery   *bquery = [BmobRole query]; //角色表\n\n\n\n\n条件查询\n\n\n比较查询\n\n\n当然了，在大多数情况下，开发者还是会通过特定的条件来筛选，过滤某些数据来进行查询。BmobQuery也提供了对应的查询方法。\n\n\n如果要过滤特定键的值可以使用- (void)whereKey:(NSString *)key notEqualTo:(id)object。比如需要查询playerName不等于”小明”的数据时可以这样写：\n\n\n当然，你也可以在你的查询操作中添加多个约束条件，来查询符合要求的数据。\n\n\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n//添加playerName不是小明的约束条件\n[bquery whereKey:@\nplayerName\n notEqualTo:@\n小明\n];\n\n\n\n\n各种不同条件的比较查询，还有\n\n\n各种不同的比较查询：\n[bquery whereKey:@\nage\n lessThan:[NSNumber numberWithInt:18]];//age小于18\n[bquery whereKey:@\nage\n lessThanOrEqualTo:[NSNumber numberWithInt:18]]; //age小于或等18\n[bquery whereKey:@\nage\n greaterThan:[NSNumber numberWithInt:18]]; //age大于18\n[bquery whereKey:@\nage\n greaterThanOrEqualTo:[NSNumber numberWithInt:18]]; //age大于或等于18\n\n\n\n\n这里有点需要注意的是\n\n\n时间搜索的话，等于的情况因为服务器是精确到微秒值，所以比较的值要加1秒。\n\n\n子查询\n\n\n如果你想查询匹配几个不同值的数据，如要查询“小明”，“小红”，“小白”三个人的信息是，可以使用\n\n\n- (void)whereKey:(NSString *)key containedIn:(NSArray *)array;\n\n\n\n\n函数，如下面所示：\n\n\n[bquery whereKey:@\nplayerName\n containedIn:[NSArray arrayWithObjects:@\n小明\n,@\n小红\n,@\n小白\n, nil]];\n\n\n\n\n如果是关联关系，直接在数组里面填写objectId即可，如下\n\n\n [bquery whereKey:@\nauthor\n containedIn:@[@\n063a2d739e\n,@\nb97ca382c3\n]];\n\n\n\n\n相反，要排除这几个人的信息可以用\n\n\n- (void)whereKey:(NSString *)key notContainedIn:(NSArray *)array;\n\n\n\n\n函数，如下所示：\n\n\n[bquery whereKey:@\nplayerName\n notContainedIn:[NSArray arrayWithObjects:@\n小明\n,@\n小红\n,@\n小白\n, nil]];\n\n\n\n\n列值是否存在\n\n\n其他的约束条件有\n\n\n//设置查询中该字段是有值的结果\n-(void)whereKeyExists:(NSString *)key;\n//设置查询中该字段是没有值的结果\n-(void)whereKeyDoesNotExist:(NSString *)key;\n\n\n\n\n例如:\n\n\n//查询表中score列有值的数据\n[bquery whereKeyExists:@\nscore\n];\n\n\n\n\n//查询表中score列没有值的数据\n[bquery whereKeyDoesNotExist:@\nscore\n];\n\n\n\n\n模糊查询\n\n\n对字符串值的模糊查询 比如查询包含字符串的值，有几种方法。如下：\n\n\n//使用正则表达式查询\n-(void)whereKey:(NSString*)key matchesWithRegex:(NSString*)regex;\n//查询以特定字符串开头的值\n-(void)whereKey:(NSString *)key startWithString:(NSString*)start;\n//查询以特定字符串结尾的值\n-(void)whereKey:(NSString *)key endWithString:(NSString*)end;\n\n\n\n\n注:模糊查询只对付费用户开放，付费后可直接使用。\n\n\n分页查询\n\n\n有时，在数据比较多的情况下，你希望查询出的符合要求的所有数据能按照多少条为一页来显示，这时可以使用limit方法来限制查询结果的数据条数来进行分页。默认情况下，Limit的值为100，最大有效设置值1000（设置的数值超过1000还是视为1000）。\n\n\nbquery.limit = 3;//限制得到的结果条数为3条\n\n\n\n\n在数据较多的情况下，在limit的基础上分页显示数据是比较合理的解决办法，skip属性可以做到跳过查询的前多少条数据来实现分页查询的功能。默认情况下Skip的值为0。\n\n\nbquery.skip = 3;//跳过3条数据\n\n\n\n\n排序\n\n\n对应数据的排序，如数字和字符串，可以使用升序或降序的方式来控制查询数据的结果顺序：\n\n\n// 升序\n- (void)orderByAscending:(NSString *)key ;\n// 降序\n- (void)orderByDescending:(NSString *)key ;\n\n\n\n\n例如，分数由高到低的排序可以写成\n\n\n[bquery orderByDescending:@\nscore\n];\n\n\n\n\n当需要组合排序的时候可以这样处理\n\n\n//先按照年龄升序排序，年龄一样再按照更新时间降序排序\n[bquery orderByAscending:@\nage\n]\n[bquery orderByDescending:@\nupdatedAt\n]\n\n\n\n\n复合查询\n\n\n当简单的查询条件，不能满足查询要时，BmobQuery也提供了2种复合查询的方法。\n\n\n//并查询\n-(void)addTheConstraintByAndOperationWithArray:(NSArray*)array;\n//或查询\n-(void)addTheConstraintByOrOperationWithArray:(NSArray *)array;\n\n\n\n\n数组里面存的是若干个条件字典，其格式为\n\n\n@{@\n列名\n:条件值}\n\n\n\n\n例如：\n\n\n//查询score列中值等于5且姓名为Mike的数据\nNSArray *array =  @[@{@\nscore\n:@5},@{@\nname\n:@\nMike\n}];\n[bquery addTheConstraintByAndOperationWithArray:array];\n\n\n\n\n支持的条件符号有\n\n\n\n\n\n\n\n\nKey\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n$lt\n\n\n小于\n\n\n\n\n\n\n$lte\n\n\n小于等于\n\n\n\n\n\n\n$gt\n\n\n大于\n\n\n\n\n\n\n$gte\n\n\n大于等于\n\n\n\n\n\n\n$ne\n\n\n不等于\n\n\n\n\n\n\n$in\n\n\n在数组中\n\n\n\n\n\n\n$nin\n\n\n不在数组中\n\n\n\n\n\n\n$exists\n\n\n值不为空\n\n\n\n\n\n\n$or\n\n\n合成查询中的或查询\n\n\n\n\n\n\n$and\n\n\n合成查询中的与查询\n\n\n\n\n\n\n$regex\n\n\n匹配PCRE表达式\n\n\n\n\n\n\n\n\n例如:\n\n\n//查询score列中值大于150或者小于5的数据\nNSArray *array =  @[@{@\nscore\n:@{@\n$gt\n:@150}},@{@\nscore\n:@{@\n$lt\n:@5}}];\n[bquery addTheConstraintByOrOperationWithArray:array];\n\n\n\n\n//查询score列中值大于5和小于150的数据\nNSArray *array =  @[@{@\nscore\n:@{@\n$gt\n:@5}},@{@\nscore\n:@{@\n$lt\n:@150}}];\n[bquery addTheConstraintByAndOperationWithArray:array];\n\n\n\n\n需要注意的是，如果是要查找条件为等于的数据的话，直接构造成{@\"列名\":条件}即可，例如下面的例子:\n\n\n//查找分数为90分跟分数为150分的数据\nNSArray *array =  @[@{@\nscore\n:@90},@{@\nscore\n:@150}];\n[bquery addTheConstraintByOrOperationWithArray:array];\n\n//查找名字为张三跟李四的数据\nNSArray *array =  @[@{@\nname\n:@\n张三\n},@{@\nname\n:\n李四\n}];\n[bquery addTheConstraintByOrOperationWithArray:array];\n\n\n\n\n其中日期类型和pointer类型构造的方法比较特殊。\n例如要查询要个时间段的数据，可以构造时间\n\n\n//createdAt大于或等于 2014-07-15 00:00:00\n NSDictionary *condiction1 = @{@\ncreatedAt\n:@{@\n$gte\n:@{@\n__type\n: @\nDate\n, @\niso\n: @\n2014-07-15 00:00:00\n}}}; \n//createdAt小于 2014-10-15 00:00:00\nNSDictionary *condiction2 = @{@\ncreatedAt\n:@{@\n$lt\n:@{@\n__type\n: @\nDate\n, @\niso\n: @\n2014-10-15 00:00:00\n}}};\nNSArray *condictonArray = @[condiction1,condiction2];\n//作用就是查询创建时间在2014年7月15日到2014年10月15日之间的数据\n[bquery addTheConstraintByAndOperationWithArray:condictonArray];\n\n\n\n\n如果查询的条件刚好是pointer类型的话，例如要查询某篇文章的作者是A或者B的话，可以这样构造数据:\n\n\nBmobQuery *query = [BmobQuery queryWithClassName:@\nPost\n];\n//列author为pointer类型，指向用户表\n//假设用户A的objectId为aaaa ,其中classname为表名\nNSDictionary *condiction1 = @{@\nauthor\n:@{@\n__type\n:@\nPointer\n,@\nclassName\n:@\n_User\n,@\nobjectId\n:@\naaaa\n}};\n//假设用户b的objecId为bbbb\nNSDictionary *condiction2= @{@\nauthor\n:@{@\n__type\n:@\nPointer\n,@\nclassName\n:@\n_User\n,@\nobjectId\n:@\nbbbb\n}};\nNSArray *condictionArray = @[condiction1,condiction2];\n//查找作者为用户A或者作者为用户B的数据\n[query addTheConstraintByOrOperationWithArray:condictionArray];\n[query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n}];\n\n\n\n\n另外我们还封装了以下方法，方便开发者使用，以下是与查询，注意add之前的查询只能添加一个条件，如果是或查询，将\n[main andOperation];\n换成\n[main orOperation];\n\n\n    BmobQuery   *bquery = [BmobQuery queryWithClassName:@\nGameScore_LT\n];\n    [bquery whereKey:@\nscore\n equalTo:[NSNumber numberWithDouble:10.3]];\n    BmobQuery   *bquery1 = [BmobQuery queryWithClassName:@\nGameScore_LT\n];\n    [bquery1 whereKey:@\nplayerName\n equalTo:@\ntest\n];\n\n    BmobQuery   *main = [BmobQuery queryWithClassName:@\nGameScore_LT\n];\n    [main add:bquery];\n    [main add:bquery1];\n    [main andOperation];\n    [main findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobObject *obj in array) {\n            //打印playerName\n            NSLog(@\n%@\n,obj);\n            NSLog(@\nobj.playerName = %@\n, [obj objectForKey:@\nplayerName\n]);\n        }\n    }];\n\n\n\n\n返回指定列\n\n\n有的时候，一张表的数据列比较多，而我们只想查询返回某些列的数据时，我们可以使用以下方法来只返回需要的列的值\n\n\n//设置查询后返回的字段数组  \n-(void)selectKeys:(NSArray*)keys;\n\n\n\n\n//指定返回查询的结果包括score和playerName两列的数据\n[bquery selectKeys:@[@\nscore\n,@\nplayerName\n]];\n\n\n\n\n查询结果计数\n\n\n如果你只是想统计满足查询对象的数量，你并不需要获取所有匹配的对象的具体数据信息，可以直接使用count替代find。例如，查询一个特定玩家玩的游戏场数：\n\n\nBmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n[bquery whereKey:@\nplayerName\n equalTo:@\nBarbie\n];\n[bquery countObjectsInBackgroundWithBlock:^(int number,NSError  *error){\n         NSLog(@\n%d\n,num);\n}];\n\n\n\n\n统计查询\n\n\n如果你想对表进行统计查询，可以采用以下方法。\n\n\n统计查询方法\n\n\n统计方法共有以下几种,分别用于计算总和、平均值、最大值、最小值\n\n\n- (void)sumKeys:(NSArray *)keys\n- (void)averageKeys:(NSArray *)keys\n- (void)maxKeys:(NSArray *)keys\n- (void)minKeys:(NSArray *)keys\n\n\n\n\n设置完成后使用下面的方法来返回结果。\n\n\n- (void)calcInBackgroundWithBlock:(BmobObjectArrayResultBlock)block\n\n\n\n\n例如，如果我们要计算GameScore表所有玩家的得分总和，可以使用以下代码：\n\n\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n    NSArray *sumArray = [NSArray arrayWithObject:@\nscore\n];\n    [bquery sumKeys:sumArray];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\nerror is:%@\n,error);\n        } else{\n            if (array) {\n                NSLog(@\n%@\n,array);\n                NSDictionary *dic = [[NSDictionary alloc] init];\n                dic = [array objectAtIndex:0];\n                NSLog(@\nsum of score:%d\n,[[dic objectForKey:@\n_sumScore\n] intValue] );\n            }\n        }\n    }];\n\n\n\n\n计算总和只对Number类型的列有效，列名使用数组存放。返回的字典key值为_sum+首字母大写的列名，其它计算方法与sum类似，其返回的字典key值见下表\n\n\n\n\n\n\n\n\n关键字\n\n\nkey值\n\n\n例子\n\n\n\n\n\n\n\n\n\n\nsum\n\n\n_sum+首字母大写\n\n\n_sumScore\n\n\n\n\n\n\naverage\n\n\n_avg+首字母大写\n\n\n_avgScore\n\n\n\n\n\n\nmax\n\n\n_max+首字母大写\n\n\n_maxScore\n\n\n\n\n\n\nmin\n\n\n_min+首字母大写\n\n\n_minScore\n\n\n\n\n\n\n\n\n分组统计\n\n\n分组可用于获取并不复杂的列值，如我想知道playerName列中有多少个不同的玩家名字，可使用以下代码：\n\n\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore_LT\n];\n    NSArray *groupbyArray = [NSArray arrayWithObject:@\nplayerName\n];\n    [bquery groupbyKeys:groupbyArray];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\nerror is:%@\n,error);\n        } else{\n            if (array) {\n                NSLog(@\n%@\n,array);\n                for (NSDictionary *dic in array) {\n                    NSString *playerName = [dic objectForKey:@\nplayerName\n];\n                    NSLog(@\nplayer:%@\n,playerName);\n                }\n            }\n        }\n    }];\n\n\n\n\n另外，groupby可以结合计算函数来使用，比如我想统计每个玩家的总分，可以使用以下代码：\n\n\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n    NSArray *groupbyArray = [NSArray arrayWithObject:@\nplayerName\n];\n    NSArray *sumArray = [NSArray arrayWithObject:@\nscore\n];\n    [bquery groupbyKeys:groupbyArray];\n    [bquery sumKeys:sumArray];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\nerror is:%@\n,error);\n        } else{\n            if (array) {\n                NSLog(@\n%@\n,array);\n                for (NSDictionary *dic in array) {\n                    NSString *playerName = [dic objectForKey:@\nplayerName\n];\n                    NSString *sum = [dic objectForKey:@\n_sumScore\n];\n                    NSLog(@\nplayer:%@\\tsum:%@\n,playerName,sum);\n                }\n            }\n        }\n    }];\n\n\n\n\n分组记录数\n\n\n有时候，我们还想知道分组统计时每个分组有多少条记录，设置isGroupcount为YES即可,如下：\n\n\n    bquery.isGroupcount = YES;\n\n\n\n\n这样在返回的结果中就会包含类似于以下的键值对：\n\n\n_count = 10\n\n\n\n\n添加过滤条件\n\n\n利用计算方法返回来的值可以通过限制条件来获取我们想关注的结果。添加条件使用以下方法。\n\n\n -(void)constructHavingDic:(NSDictionary *)havingDic\n\n\n\n\n该方法通过构造havingDic来添加限制条件，其使用方法与复杂查询类似。\n\n\n例如，我们统计每个玩家的总分，但我们只需要得到总分大于50的玩家，可以使用以下代码得到：\n\n\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n    NSArray *groupbyArray = [NSArray arrayWithObject:@\nplayerName\n];\n    [bquery groupbyKeys:groupbyArray];\n    NSArray *sumArray = [NSArray arrayWithObject:@\nscore\n];\n    [bquery sumKeys:sumArray];\n    NSDictionary *condication = [[NSDictionary alloc] initWithObjectsAndKeys:[NSNumber numberWithInt:50],@\n$gt\n, nil];\n    [bquery constructHavingDic:[[NSDictionary alloc] initWithObjectsAndKeys:condication,@\n_sumScore\n, nil]];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\nerror is:%@\n,error);\n        } else{\n            if (array) {\n                NSLog(@\n%@\n,array);\n                for (NSDictionary *dic in array) {\n                    NSString *playerName = [dic objectForKey:@\nplayerName\n];\n                    NSString *sum = [dic objectForKey:@\n_sumScore\n];\n                    NSLog(@\nplayer:%@\\tsum:%@\n,playerName,sum);\n                }\n            }\n        }\n    }];\n\n\n\n\n缓存查询\n\n\n缓存查询通常是将查询结果缓存在磁盘上，当用户的设备处于离线状态时，就可以从缓存中获取数据来显示。或者在应用界面刚刚启动，从网络获取数据还未得到结果时，先使用缓存数据来显示。这样可以让用户不必在按下某个按钮后进行枯燥的等待。 默认的查询操作是没有启用缓存的，开发者可以通过设置BmobCachePolicy来启用缓存功能。例如：优先从网络获取数据，如果获取失败时再从缓存获取数据，这种情况通常用在网络不可用的情况下。\n\n\nbquery.cachePolicy = kBmobCachePolicyNetworkElseCache;\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array,NSError *error){\n}];\n\n\n\n\nBmobSDK提供几种不同的缓存策略，以使用不同应用场景的需求。\n\n\n\n\nkBmobCachePolicyIgnoreCache\n\n\n\n\n只从网络获取数据，且数据不会缓存在本地，这是默认的缓存策略。\n\n\n\n\nkBmobCachePolicyCacheOnly\n\n\n\n\n只从缓存读数据，如果缓存没有数据，返回一个空数组。\n\n\n\n\nkBmobCachePolicyNetworkOnly\n\n\n\n\n只从网络获取数据，同时会在本地缓存数据。\n\n\n\n\nkBmobCachePolicyCacheElseNetwork\n\n\n\n\n先从缓存读取数据，如果没有再从网络获取。\n\n\n\n\nkBmobCachePolicyNetworkElseCache\n\n\n\n\n先从网络获取数据，如果没有，再从缓存读取。\n\n\n\n\nkBmobCachePolicyCacheThenNetwork\n\n\n\n\n先从缓存读取数据，无论结果如何都会再次从网络获取数据，在这种情况下，Block将产生两次调用。通常这种做法是先快速从缓存读取数据显示在界面，然后在后台连接网络获取最新数据，取到后再更新界面。\n\n\n|检查是否存在当前查询条件的缓存数据\n\n\n[bquery hasCachedResult];\n\n\n\n\n存在返回YES，否则返回NO\n|清除当前查询的缓存数据\n\n\n[bquery clearCachedResult];\n\n\n\n\n|清除所有查询结果的缓存数据\n\n\n[BmobQuery clearAllCachedResults];\n\n\n\n\n|设置缓存有限时间，单位为秒\n\n\nbquery.maxCacheAge = 10000;\n\n\n\n\nBQL查询\n\n\nBmob Query Language\n（简称 BQL）是 Bmob 自 \nBmobSDK V1.5.7\n 版本开始，为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 Bmob 查询 API 的成本，可以使用传统的 SQL 语法来查询 Bmob 应用内的数据。\n\n\n具体的 BQL 语法，请参考 \nBmob Query Language 详细指南\n。\n\n\n基本BQL查询\n\n\n可以通过以下方法来进行SQL查询：\n\n\n例如：需要查询所有的游戏得分记录\n\n\n    BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    NSString *bql = @\nselect * from GameScore_BQL\n;\n    [bmobQuery queryInBackgroundWithBQL:bql block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            if (result) {\n                NSLog(@\n%@\n,result.resultsAry);\n            }\n        }\n    }];\n\n\n\n\n其中result.resultsAry为BmobObject数组。\n\n\n如果需要查询个数，则可以这样：\n\n\n    NSString *bql = @\nselect count(*) from GameScore_BQL\n;\n    BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    [bmobQuery queryInBackgroundWithBQL:bql block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            if (result) {\n                NSLog(@\n%d\n,result.count);\n            }\n        }\n    }];\n\n\n\n\n其中result.count为记录条数，需要注意的是如果没有使用count关键字进行查询的话，对象result的count属性是没有意义的。\n\n\n统计BQL查询\n\n\n由于统计查询的结果是不定的，故BQL提供了另外一种查询方法来进行统计查询，可以使用  \n- (void)statisticsInBackgroundWithBQL:(NSString *)bql block:(BmobBQLArrayResultBlock)block;\n 方法来进行。\n\n\n     NSString *bql = @\nselect sum(score) from GameScore_BQL group by playerName\n;\n    [bmobQuery statisticsInBackgroundWithBQL:bql block:^(NSArray *result, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            if (result) {\n                NSLog(@\n%@\n,result);\n            }\n        }\n    }];\n\n\n\n\n目前统计查询支持的关键字如下表所示，即如果在sql语句中包含以下关键字时，则需要使用统计查询方法才能返回正确结果：\n\n\n\n\n\n\n\n\nkey\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\ngroup by\n\n\n分组操作\n\n\n\n\n\n\ngroupcount\n\n\n返回每个分组的总记录\n\n\n\n\n\n\nhaving\n\n\n分组中的过滤条件\n\n\n\n\n\n\nsum\n\n\n计算总和\n\n\n\n\n\n\naverage\n\n\n计算平均值\n\n\n\n\n\n\nmax\n\n\n计算最大值\n\n\n\n\n\n\nmin\n\n\n计算最小值\n\n\n\n\n\n\n\n\n占位符查询\n\n\n在更多的时候，一个查询语句中间会有很多的值是可变值，为此，我们也提供了类似 Java JDBC 里的 \nPreparedStatement\n 使用占位符查询的语法结构。\n\n\n注：目前只有where和limit关键字以及内置函数支持使用占位符。\n\n\n普通查询\n\n\n    BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    NSString *bql = @\nselect * from GameScore_BQL where playerName = ? and score = ?\n;\n    NSArray *placeholderArray = @[@\nname2\n,@9];\n    [bmobQuery queryInBackgroundWithBQL:bql pvalues:placeholderArray block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            if (result) {\n                NSLog(@\n%@\n,result.resultsAry);\n            }\n        }\n    }];\n\n\n\n\n数组中的数据会依次替换bql中的问号。\n\n\n内置函数\n\n\n对于包含\n内置函数\n的占位符查询，比较特殊，请使用\nBmob Query Language 详细指南\n中的\n内置函数\n中\n占位符查询用到的内置函数\n用到的内置函数列出的形式进行查询操作：\n\n\n举例：我想查询在 '2015-05-14 14:56:30' 后的创建的记录，可以这样：\n\n\n    BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    NSString *bql = @\nselect * from GameScore_BQL where createdAt \n date(?)\n;\n    NSArray *placeholderArray = @[@\n2015-05-14 14:56:30\n];\n    [bmobQuery queryInBackgroundWithBQL:bql pvalues:placeholderArray block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            if (result) {\n                NSLog(@\n%@\n,result.resultsAry);\n            }\n        }\n    }];\n\n\n\n\n注\n\n\n1、我们更推荐使用占位符语法，理论上会降低 BQL 转换的性能开销；\n\n\n2、同样的，统计查询也支持占位符,只需要\n- (void)statisticsInBackgroundWithBQL:(NSString *)bql pvalues:(NSArray*)pvalues block:(BmobBQLArrayResultBlock)block;\n方法即可。\n\n\nBQL缓存策略\n\n\n如果要使用缓存策略，可用 \n- (void)queryBQLCanCacheInBackgroundWithblock:(BmobBQLObjectResultBlock)block;\n 方法，样例代码如下：\n\n\n    NSString *bql = [NSString stringWithFormat:@\nselect * from %@ where %@ = ?\n,TABLENAME,COLPLAYERNAME];\n    NSArray *placeholder = @[@\nname1\n];\n\n    BmobQuery *bmobQueryWriteCache = [[BmobQuery alloc] init];\n    bmobQueryWriteCache.cachePolicy = kBmobCachePolicyNetworkOnly;\n    [bmobQueryWriteCache setBQL:bql];\n    [bmobQueryWriteCache setPlaceholder:placeholder];\n    [bmobQueryWriteCache queryBQLCanCacheInBackgroundWithblock:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else if (result){\n            NSLog(@\nactual:%@\n,result);\n        }\n    }];\n\n\n\n\n注意：\n\n\n\n\nBQL查询方法中，只有 \n- (void)queryBQLCanCacheInBackgroundWithblock:(BmobBQLObjectResultBlock)block;\n 才能使用缓存策略，其它方法即使设置了缓存策略也无缓存效果；\n\n\n使用\n- (void)queryBQLCanCacheInBackgroundWithblock:(BmobBQLObjectResultBlock)block;\n进行查询时，通过 \n-(void)setBQL:(NSString*)bql;\n 和 \n-(void)setPlaceholder:(NSArray*)ary;\n 来设置BQL语句和占位符。\n\n\n\n\n缓存策略只对普通查询有效，统计查询只支持从网络进行查询。具体使用可参考iOS开发文档中的\n查询\n缓存查询小节。\n\n\n数组\n\n\n为了存储数组型数据，\nBmob\n提供了3种操作来原子性地更改一个数组字段:\n\n\nAdd\n 在一个数组字段的后面添加一些指定的对象(包装在一个数组内)\n\n\nAddUnique\n 只会在原本数组字段中没有这些对象的情形下才会添加入数组，插入数组的位置不固定的\n\n\nRemove\n 从一个数组字段的值内移除指定的数组中的所有对象\n\n\n添加数组数据\n\n\n添加一行记录时创建一个普通的类似于列表的数组类型字段，可以使用以下方法添加：\n\n\nBmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@\nGameScore\n objectId:@\nxxxxxxxx\n];\n[gameScore addObjectsFromArray:@[@\nP1\n,@\nP2\n] forKey:@\nskill\n];\n[gameScore updateInBackground];\n\n\n\n\n删除数组数据\n\n\n当需要移除数组里的数据时可以使用\n\n\n-(void)removeObjectsInArray:(NSArray *)objects forKey:(NSString *)key;\n\n\n\n\n如下面就移除了P3这个元素:\n\n\nBmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@\nGameScore\n objectId:@\nxxxxxxxx\n];\n[gameScore removeObjectsInArray:@[@\nP3\n] forKey:@\nskill\n];\n[gameScore updateInBackground];\n\n\n\n\n更新数组数据\n\n\n每一种方法都会有一个objects，即包含了这些方法将被添加或删除的对象列表，举个例子，技能skills是一个类似于集合的数组类型，那么我们可以在skills中加入一些对象，只有在skills原来的对象中不包含这些值的情况下才会被加入:\n\n\nBmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@\nGameScore\n objectId:@\nxxxxxxxx\n];\n[gameScore addUniqueObjectsFromArray:@[@\nP3\n] forKey:@\nskill\n];\n[gameScore updateInBackground];\n\n\n\n\n查询数组数据\n\n\n对于Key的类型是数组的情况，可以查找Key的数组值中包含有P1的对象。代码如下：\n\n\n    //查询数组中包含某个元素的记录\n    BmobQuery *query = [BmobQuery queryWithClassName:@\nGameScore\n];\n    [query whereKey:@\nskill\n equalTo:@\nP1\n];\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            for (BmobObject *obj in array) {\n                NSLog(@\n%@\n,obj);\n            }\n        }\n    }];\n\n\n\n\n你同样可以使用\"$all\"操作符来找到类型为数组的Key的值中同时包含有P1和P2的对象:\n\n\n    //查询数组中包含某些元素的记录\n    BmobQuery *query1 = [BmobQuery queryWithClassName:@\nGameScore\n    \n];\n    NSArray *array = @[@\nP1\n,@\nP2\n];\n    [query1 whereKey:@\nskill\n equalTo:@{@\n$all\n:array}];\n    [query1 findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            for (BmobObject *obj in array) {\n                NSLog(@\n%@\n,obj);\n            }\n        }\n    }];\n\n\n\n\n当然，你也可以使用我们封装好的方法来查找\n\n\n    //查询数组中包含某些元素的记录\n    BmobQuery *query1 = [BmobQuery queryWithClassName:@\nGameScore\n];\n    NSArray *array = @[@\nP1\n,@\nP2\n];\n    [query1 whereKey:@\nskill\n containsAll:array];\n    [query1 findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            for (BmobObject *obj in array) {\n                NSLog(@\n%@\n,obj);\n            }\n        }\n    }];\n\n\n\n\n如果要查找包含P1或P2的对象，可以使用复杂查询中的或查\n\n\n    BmobQuery *query = [BmobQuery queryWithClassName:@\nPost\n];\n    NSArray *array =  @[@{@\nskill\n:@{@\n$all\n: @[@\nP1\n]}},@{@\nskill\n:@{@\n$all\n:@[@\nP2\n]}}];\n    [query addTheConstraintByOrOperationWithArray:array];\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            NSLog(@\n%d\n,array.count);\n            for (BmobObject *obj in array) {\n                 NSLog(@\n%@\n,obj);\n            }\n\n        }\n    }];\n\n\n\n\n使用索引和对象key修改数组中的对象\n\n\n比如你当前行有一列叫用户的工作经验projectExperiences，是一个Array数组列，里面包含了多个对象值：[{\"name\":\"项目名称\",\"descr\":\"项目描述\"，\"startTime\":\"开始时间\"，\"endTime\":\"结束时间\"}, ...]\n\n\n那么我们要修改projectExperiences数组中第一个对象的name值：\n\n\nBmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@\nGameScore\n objectId:@\nxxxxxxxx\n];\n[bmobObject setObject:@\n项目名称2\n forKey:@\nprojectExperiences.0.name\n];\n[gameScore updateInBackground];\n\n\n\n\n数据关联\n\n\n数据关联章节Demo下载\n\n\n关联关系描述\n\n\n在程序设计中，不同类型的数据之间可能存在某种关系。分别是以下三种：\n1. 一对一，比如车队给司机分车，1个司机对应1台车；\n2. 一对多，比如1个作者会对应多篇贴子；\n3. 多对多，比如1篇帖子会有多个喜欢的读者，而每个读者也会有多篇喜欢的帖子。\n前面的两种关系我们提供Pointer类型来表示，而最后一种关系我们使用Relation类型来表示\n\n\n在下面的讲解中我们可能会使用到以下的两张表，其表结构如下：\n\n\n_User\n\n\n\n\n\n\n\n\n字段\n\n\n类型\n\n\n含义\n\n\n\n\n\n\n\n\n\n\nobjectId\n\n\nstring\n\n\n\n\n\n\n\n\nusername\n\n\nstring\n\n\n用户名，用户可以是作者发帖子，也可以是读者发评论\n\n\n\n\n\n\n\n\nPost\n\n\n\n\n\n\n\n\n字段\n\n\n类型\n\n\n含义\n\n\n\n\n\n\n\n\n\n\nobjectId\n\n\nstring\n\n\n\n\n\n\n\n\ntitle\n\n\nstring\n\n\n帖子标题\n\n\n\n\n\n\ncontent\n\n\nstring\n\n\n帖子内容\n\n\n\n\n\n\nauthor\n\n\nPointer(_User)\n\n\n作者\n\n\n\n\n\n\nlikes\n\n\nRelation(_User)\n\n\n喜欢帖子的读者\n\n\n\n\n\n\n\n\n预先在后台添加记录\n_User表\n\n\n\n\nPost表\n\n\n\n\n\n\nPointer的使用\n\n\n添加关系\n\n\n例如，user1写了一篇帖子，需要在Post表中添加一条记录，并且该记录包含一个关联author1记录的字段数据，可采用以下代码：\n\n\n    BmobObject  *post = [BmobObject objectWithClassName:@\nPost\n];\n    //设置帖子的标题和内容\n    [post setObject:@\ntitle4\n forKey:@\ntitle\n];\n    [post setObject:@\ncontent4\n forKey:@\ncontent\n];\n\n    //设置帖子关联的作者记录\n    BmobUser *author = [BmobUser objectWithoutDataWithClassName:@\n_User\n objectId:@\nvbhGAAAY\n];\n    [post setObject:author forKey:@\nauthor\n];\n\n    //异步保存\n    [post saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功，返回objectId，updatedAt，createdAt等信息\n            //打印objectId\n            NSLog(@\nobjectid :%@\n,post.objectId);\n        }else{\n            if (error) {\n                NSLog(@\n%@\n,error);\n            }\n        }\n    }];\n\n\n\n\n添加成功后在后台的结果如下图所示，我们可以看到，author列的值是用圆框框起来的，表示这是一个Pointer，显示的值，为对应记录的objectId,点击它可以进入_User表中：\n\n\n\n\n我们可以这么理解关联关系，它就是一个类型为指针的字段，利用它可以指向其它表的某条记录。\n\n\n删除关系\n\n\n如果需要删除某篇帖子关联的作者可以使用\n\n\n- (void)deleteForKey:(id)key\n\n\n\n\n具体代码如下：\n\n\n    BmobQuery   *bquery = [BmobQuery queryWithClassName:@\nPost\n];\n    [bquery getObjectInBackgroundWithId:@\nZqQ7KKKx\n block:^(BmobObject *object,NSError *error){\n        if (error){\n            NSLog(@\n%@\n,error);\n        }else{\n            if (object) {\n                BmobObject *post = object;\n                //将author列的值置为空\n                [post deleteForKey:@\nauthor\n];\n                //进行更新\n                [post updateInBackground];\n            }\n        }\n    }];\n\n\n\n\n结果如下，可以看到，author列已经被置空\n\n\n\n\n修改关系\n\n\n如果需要修改某篇帖子关联的作者，可以使用以下代码:\n\n\n    BmobQuery   *bquery = [BmobQuery queryWithClassName:@\nPost\n];\n    //获得objectId查找出先前添加的文章\n    [bquery getObjectInBackgroundWithId:@\nZqQ7KKKx\n block:^(BmobObject *object,NSError *error){\n        if (error){\n            NSLog(@\n%@\n,error);\n        }else if (object) {\n            BmobObject *post = object;\n            //获得BmobUser对象\n            BmobUser *user = [BmobUser objectWithoutDataWithClassName:@\n_User\n objectId:@\nqXZeCCCX\n];\n            //设置post的author值为新获得的BmobUser对象\n            [post setObject:user forKey:@\nauthor\n];\n\n            //进行更新\n            [post updateInBackground];\n        }\n    }];\n\n\n\n\n可以看到关联记录已经被修改：\n\n\n\n\n查询关系\n\n\n查询某个特定作者的帖子，可以用 \n-(void)whereKey:(NSString *)key equalTo:(id)object\n,具体代码如下\n\n\n //查询帖子表\n BmobQuery *query = [BmobQuery queryWithClassName:@\nPost\n];\n //构建objectId为vbhGAAAY 的作者\n BmobUser *author = [BmobUser objectWithoutDataWithClassName:@\n_User\n objectId:@\nvbhGAAAY\n];\n //添加作者是objectId为vbhGAAAY条件\n [query whereKey:@\nauthor\n equalTo:author];\n [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else if (array){\n            for (BmobObject *post in array) {\n                NSLog(@\n%@\n,[post objectForKey:@\ntitle\n]);\n            }\n        }\n    }];\n\n\n\n\n如我们需要查询帖子，并且需要将该帖子关联的作者的信息（objectId,username）打印出来，我们可以使用以下代码：\n\n\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\nPost\n];\n\n    //声明该次查询需要将author关联对象信息一并查询出来\n    [bquery includeKey:@\nauthor\n];\n\n    [bquery getObjectInBackgroundWithId:@\nZqQ7KKKx\n block:^(BmobObject *object, NSError *error) {\n\n        //打印文章标题，内容\n        BmobObject *post = object;\n        NSLog(@\ntitle:%@\n,[post objectForKey:@\ntitle\n]);\n        NSLog(@\ncontent:%@\n,[post objectForKey:@\ncontent\n]);\n\n        //取得文章的关联作者对象\n        BmobUser *author = [post objectForKey:@\nauthor\n];\n        //打印文章的关联作者对象的相关信息\n        NSLog(@\nobjectId:%@\n,author.objectId);\n        NSLog(@\nname:%@\n,[author objectForKey:@\nusername\n]);\n    }];\n\n\n\n\n查询关系的核心在于查询前需要将关联的列名include进来，使用下列方法即可\n\n\n- (void)includeKey:(NSString *)key\n\n\n\n\n如果查询多个关联关系，可以使用以下方法，使用逗号(,)操作来使查询中包含多个属性\n\n\n[bquery includeKey:@\ncolumn1,column2,...\n];\n\n\n\n\n如果关联关系存在嵌套，可以使用以下英文字符点号(.)来操作，如下：\n\n\n[bquery includeKey:@\ncolumn1.column2\n];\n\n\n\n\n另外，include 时可以指定返回的字段，如下：\n\n\n//只返回likes列的数据\n[bquery includeKey:@\npost[likes]\n];\n\n//返回title和content列数据\n[bquery includeKey:@\npost[title|content]\n];\n\n\n\n\n约束关联对象值查询\n\n\n我们可以对关联对象的值进行约束，来进行匹配查询。例如，如果我们想找查询出所有关联了user2的文章，可以使用以下代码\n\n\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\nPost\n];\n\n    //构造约束条件\n    BmobQuery *inQuery = [BmobQuery queryWithClassName:@\n_User\n];\n    [inQuery whereKey:@\nusername\n equalTo:@\nuser2\n];\n\n    //匹配查询\n    [bquery whereKey:@\nauthor\n matchesQuery:inQuery];\n    [bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else if (array){\n            for (BmobObject *post in array) {\n                NSLog(@\n%@\n,[post objectForKey:@\ntitle\n]);\n            }\n        }\n    }];\n\n\n\n\n如果想要查询找所有没有关联user1的文章，则将\n\n\n[bquery whereKey:@\nauthor\n matchesQuery:inQuery];\n\n\n\n\n替换成\n\n\n[bquery whereKey:@\nauthor\n doesNotMatchQuery:inQuery];\n\n\n\n\n即可。\n\n\nPointer本质\n\n\nPointer可以用来表示一对一或者一对多的关系，其实可以看成是我们将一个指向某条记录的指针记录下来，我们查询时可以通过该指针以获得另外关联的对象。当然，我们也可以给这些指针指向的关联记录进行约束，只查询出符合特定条件的记录。\n\n\nRelation的使用\n\n\n添加关联关系\n\n\n如果我们需要在Post表中添加一个字段以记录喜欢该贴子的读者，我们可以使用以下代码：\n\n\n    //获取要添加关联关系的post\n    BmobObject *post = [BmobObject objectWithoutDataWithClassName:@\nPost\n objectId:@\nZqQ7KKKx\n];\n\n    //新建relation对象\n    BmobRelation *relation = [[BmobRelation alloc] init];\n    [relation addObject:[BmobObject objectWithoutDataWithClassName:@\n_User\n objectId:@\nvbhGAAAY\n]];\n    [relation addObject:[BmobObject objectWithoutDataWithClassName:@\n_User\n objectId:@\nqXZeCCCX\n]];\n\n    //添加关联关系到likes列中\n    [post addRelation:relation forKey:@\nlikes\n];\n    //异步更新obj的数据\n    [post updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@\nsuccessful\n);\n        }else{\n            NSLog(@\nerror %@\n,[error description]);\n        }\n    }];\n\n\n\n\n可以看到添加了一个 \nlikes\n 列，点击进去可以查看到该列里面存在哪些数据。\n\n\nPost表：\n\n\n\n\n从Post表中的title4记录点击关联关系框进去后查看的结果：\n\n\n\n\n删除关联关系\n\n\n如果要从刚刚的添加的likes列中删去其中一个读者，可采用以下代码。\n\n\n    BmobObject *post = [BmobObject objectWithoutDataWithClassName:@\nPost\n objectId:@\nZqQ7KKKx\n];\n\n    //新建relation对象\n    BmobRelation *relation = [[BmobRelation alloc] init];\n    [relation removeObject:[BmobObject objectWithoutDataWithClassName:@\n_User\n objectId:@\nvbhGAAAY\n]];\n\n    //添加关联关系到likes列中\n    [post addRelation:relation forKey:@\nlikes\n];\n\n    //异步更新obj的数据\n    [post updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@\nsuccessful\n);\n        }else{\n            NSLog(@\nerror %@\n,[error description]);\n        }\n    }];\n\n\n\n\n从Author表中的author1记录点击关联关系框进去后查看的结果：\n\n\n\n\n修改关联关系\n\n\n如果需要给objectId为ZqQ7KKKx的帖子添加多一个喜欢该帖子的读者可以使用以下代码\n\n\n    BmobObject *author = [BmobObject objectWithoutDataWithClassName:@\nPost\n objectId:@\nZqQ7KKKx\n];\n\n    //新建relation对象\n    BmobRelation *relation = [[BmobRelation alloc] init];\n    [relation addObject:[BmobObject objectWithoutDataWithClassName:@\n_User\n objectId:@\nJ6RU888L\n]];\n    //添加关联关系到postlist列中\n    [author addRelation:relation forKey:@\nlikes\n];\n\n    //异步更新obj的数据\n    [author updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@\nsuccessful\n);\n        }else{\n            NSLog(@\nerror %@\n,[error description]);\n        }\n    }];\n\n\n\n\n运行代码后，从Author表中的author1记录点击关联关系框进去后查看的结果：\n\n\n\n\n查询关联关系\n\n\n如果我们需要查询喜欢objectId为ZqQ7KKKx的帖子的所有读者，可以采用下列代码：\n\n\n    //关联对象表\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\n_User\n];\n\n    //需要查询的列\n    BmobObject *post = [BmobObject objectWithoutDataWithClassName:@\nPost\n objectId:@\nZqQ7KKKx\n];\n    [bquery whereObjectKey:@\nlikes\n relatedTo:post];\n\n\n    [bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            for (BmobObject *user in array) {\n                NSLog(@\n%@\n,[user objectForKey:@\nusername\n]);\n            }\n        }\n    }];\n\n\n\n\n注意：跟Pointer不同的是，这里本质上查询的是_User表。\n\n\nRelation约束关联对象值查询\n\n\n上面的查询是查找喜欢某篇帖子的所有读者，如果反过来，需要查找某个读者喜欢的所有帖子又要怎么做呢？可以参考以下代码：\n\n\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\nPost\n];\n\n    //构造约束条件\n    BmobQuery *inQuery = [BmobQuery queryWithClassName:@\n_User\n];\n    [inQuery whereKey:@\nusername\n equalTo:@\nuser3\n];\n\n    //匹配查询\n    [bquery whereKey:@\nlikes\n matchesQuery:inQuery];\n    [bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else if (array){\n            for (BmobObject *post in array) {\n                NSLog(@\n%@\n,[post objectForKey:@\ntitle\n]);\n            }\n        }\n    }];\n\n\n\n\nRelation的本质\n\n\nRelation可以理解为其存储的是一个对象，而这个对象中存储的是多个指向其它记录的指针。\n\n\n用户管理\n\n\n属性\n\n\nBmobUser除了从BmobObject继承的属性外，还有几个特定的属性：\n\n\n\n\nusername: 用户的用户名（必需）。\n\n\npassword: 用户的密码（必需）。\n\n\nemail: 用户的电子邮件地址（可选）。\n\n\n\n\nBmobUser自动处理用户账户管理所需的功能。\n\n\n-(void)setUsername:(NSString *)username;//用户名，必需\n-(void)setPassword:(NSString*)password;//密码，必需\n-(void)setEmail:(NSString *)email;//设置邮箱\n-(void)setObject:(id)obj forKey:(id)key;//设置某个属性的值\n-(id)objectForKey:(id)key;//得到某个属性的值\n\n\n\n\n注册\n\n\n应用很常见的一个功能就是，注册用户，使用BmobUser注册用户也不复杂，如下的例子所示\n\n\nBmobUser *bUser = [[BmobUser alloc] init];\n[bUser setUsername:@\n小明\n];\n[bUser setPassword:@\n123456\n];\n[bUser setObject:@18 forKey:@\nage\n];\n[bUser signUpInBackgroundWithBlock:^ (BOOL isSuccessful, NSError *error){\n    if (isSuccessful){\n        NSLog(@\nSign up successfully\n);\n    } else {\n        NSLog(@\n%@\n,error);\n    }\n}];\n\n\n\n\n需要有两点需要注意的是：\n\n\n\n\n有些时候你可能需要在用户注册时发送一封邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在应用设置-\n邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在用户注册时自动发动一封验证给用户。\n\n\n\n\n\n\n\n\nusername字段是大小写敏感的字段，如果你希望应用的用户名不区分大小写，请在注册和登录时进行大小写的统一转换。\n\n\n\n\n登录\n\n\n当用户注册成功后，需要让他们以后能够登录到他们的账户使用应用。要做到这点可以使用\n\n\n[BmobUser loginWithUsernameInBackground:@\n小明\n\n    password:@\n123456\n];\n\n\n\n\n也可以使用\n\n\n+ (void)loginWithUsernameInBackground:(NSString *)username\n                              password:(NSString *)password\n                                 block:(BmobUserResultBlock)block;\n\n\n\n\nBmob还提供了用户、email、手机号码均可作为账号进行登录的功能。使用以下方法即可\n\n\n    [BmobUser loginInbackgroundWithAccount:account andPassword:password block:^(BmobUser *user, NSError *error) {\n        if (user) {\n            NSLog(@\n%@\n,user);\n        } else {\n            NSLog(@\n%@\n,error);\n        }\n    }];\n\n\n\n\n获取当前用户\n\n\n每次你登录成功，都会在本地磁盘中有一个缓存的用户对象作为当前用户，可以获取这个缓存的用户对象来进行登录：\n\n\nBmobUser *bUser = [BmobUser getCurrentObject];\nif (bUser) {\n    //进行操作\n}else{\n    //对象为空时，可打开用户注册界面\n}\n\n\n\n\n当然，你也可以用如下的方法清除缓存用户对象：\n\n\n[BmobUser logout];\n\n\n\n\n1.这个用户对象缓存了基本的数据，所以可以通过-(id)objectForKey:(id)key; 这个方法来得到某一列的值\n\n\n2.[BmobUser getCurrentObject] 跟[BmobUser getCurrentUser]功能作用是一样的，因版本升级的原因才保留了[BmobUser getCurrentObject]\n\n\n3.由于是缓存的数据，所以web端的修改，本地是不会更新的!!!需要重新登录才会更新本地缓存数据\n\n\n4.缓存用户的有效期为1年\n\n\n更新用户\n\n\n当用户登录成功后，在本地有个缓存的用户对象，如果开发者希望更改当前用户的某个属性可按如下代码操作:\n\n\nBmobUser *bUser = [BmobUser getCurrentUser];\n//更新number为30\n[bUser setObject:@30 forKey:@\nnumber\n];\n[bUser updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    NSLog(@\nerror %@\n,[error description]);\n}];\n\n\n\n\n一般来说，使用当前用户对象来进行资料更新可能会遇到一个问题。如果当前用户上次登录的时间距离当前时间过长，存放在本地的Token就有可能会过期，导致用户更新资料失败，这是需要重新登录，登录成功后才能更新资料。\n\n\n在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发动一封邮件验证信息给用户。\n\n\n查询用户\n\n\n查询用户和查询普通对象一样，只需指定BmobUser类即可，如下：\n\n\n    BmobQuery *query = [BmobUser query];\n    [query whereKey:@\nusername\n equalTo:@\nxiaolv\n];\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobUser *user in array) {\n            NSLog(@\nobjectid %@\n,user.objectId);\n        }\n    }];\n\n\n\n\n浏览器中查看用户表\n\n\nUser表是一个特殊的表，专门存储BmobUser对象。在浏览器端，你会看到一个User表旁边有一个小人的图标。\n\n\n\n\n修改密码\n\n\n从 \nv1.6.3\n 开始，我们提供使用旧密码来重置新密码的接口，示例如下：\n\n\n    BmobUser *user = [BmobUser getCurrentUser];\n    [user updateCurrentUserPasswordWithOldPassword:@\nold password\n newPassword:@\nnew password\n block:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //用新密码登录\n            [BmobUser loginInbackgroundWithAccount:@\nname\n andPassword:@\nnew password\n block:^(BmobUser *user, NSError *error) {\n                if (error) {\n                    NSLog(@\nlogin error:%@\n,error);\n                } else {\n                    NSLog(@\nuser:%@\n,user);\n                }\n            }];\n        } else {\n            NSLog(@\nchange password error:%@\n,error);\n        }\n    }];\n\n\n\n\n找回密码\n\n\n为方便大家了解如何用Bmob开发找回密码的功能，我们为大家准备了另外一份文档，详细见我们在Github中的文档：\n\n\nhttps://github.com/bmob/bmob-cloudcode-demo/blob/master/HOW-TO-FIND-PASSWORD.md\n\n\n邮箱\n\n\n邮箱验证\n\n\n设置邮件验证是可选的一个应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会默认被设为false，如果应用设置中开启了邮箱认证功能，Bmob会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.\n\n\nBmobUser *user = [BmobUser getCurrentUser];\n//应用开启了邮箱验证功能\nif ([user objectForKey:@\nemailVerified\n]) {\n    //用户没验证过邮箱\n    if (![[user objectForKey:@\nemailVerified\n] boolValue]) {\n        [user verifyEmailInBackgroundWithEmailAddress:@\nxxxxxxxxxx\n];\n    }\n}\n\n\n\n\n邮箱修改密码\n\n\n一旦你引入了一个密码系统，那么肯定会有用户忘记密码的情况。对于这种情况，我们提供了一种方法，让用户安全地重置起密码。\n\n\n重置密码的流程很简单，开发者只需要求用户输入注册的电子邮件地址即可：\n\n\n[BmobUser requestPasswordResetInBackgroundWithEmail:@\nxxxx@qq.com\n];\n\n\n\n\n密码重置流程如下：\n\n\n\n\n用户输入他们的电子邮件，请求重置自己的密码。\n\n\nBmob向他们的邮箱发送一封包含特殊的密码重置连接的电子邮件。\n\n\n用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，根据提示，他们可以输入一个新的密码。\n\n\n用户的密码已被重置为新输入的密码。\n\n\n\n\n第三方账号登录\n\n\nBmob提供了非常简单的方法来实现使用第三方账号登陆的功能，目前支持新浪微博、手机QQ账号以及微信账号的登陆。以下是我们提供的一个demo\nThirdPartyLogin\n\n\n新浪微博账号注册登录\n\n\n在\n新浪微博开放平台\n注册应用，然后根据\n新浪微博 iOS SDK使用说明\n安装SDK以及获取，开发者通过新浪微博提供的SDK得到用户的信息后，就可以调用BmobUser提供的方法来注册登录到应用。\n\n\n//得到的新浪微博授权信息，请按照例子来生成NSDictionary\nNSDictionary *dic = @{@\naccess_token\n:token,@\nuid\n:uid,@\nexpirationDate\n:date};\n//通过授权信息注册登录\n[BmobUser loginInBackgroundWithAuthorDictionary:dic\n                                      platform:BmobSNSPlatformSinaWeibo\n                                         block:^(BmobUser *user, NSError *error) {\n                                             NSLog(@\nuser objectid is :%@\n,user.objectId);\n                                         }];\n\n\n\n\n手机QQ账号登录\n\n\n同样的，开发者通过QQ授权得到用户的信息后，同样可以调用BmobUser提供的方法来注册登录到应用。下面的例子是通过QQ提供的SDK授权得到的信息，进行登录的：\n\n\n//得到的qq授权信息，请按照例子来生成NSDictionary\n NSDictionary *responseDictionary = @{@\naccess_token\n: _tencentOauth.accessToken,@\nuid\n:_tencentOauth.openId,@\nexpirationDate\n:_tencentOauth.expirationDate};\n //通过授权信息注册登录\n[BmobUser loginInBackgroundWithAuthorDictionary:responseDictionary\n                                       platform:BmobSNSPlatformQQ\n                                          block:^(BmobUser *user, NSError *error) {\n                                            NSLog(@\nerror%@\n,[error description]);\n                                            }];\n\n\n\n\n微信账号登录\n\n\nNSDictionary *responseDictionary = @{@\naccess_token\n: accessToken,@\nuid\n:openId,@\nexpirationDate\n:expirationDate};\n[BmobUser loginInBackgroundWithAuthorDictionary:responseDictionary\n                                       platform:BmobSNSPlatformWeiXin\n                                          block:^(BmobUser *user, NSError *error) {\n                                            NSLog(@\nerror%@\n,[error description]);\n                                            }];\n\n\n\n\n第三方账号与BmobUser绑定\n\n\n如果你的应用中有其他功能已经使用到了相关第三方平台的功能，比如社交分享功能，那么你可以将已经得到的用户授权信息传递给BmobSDK来便捷地与BmobUser进行绑定。以下代码展示了将第三方账号和已经存在的BmobUser对象进行绑定：\n\n\n//新浪微博账号关联到当前用户\nNSDictionary *dic = @{@\naccess_token\n:token,@\nuid\n:uid,@\nexpirationDate\n:date};\nBmobUser *currentUser = [BmobUser getCurrentUser];\n[currentUser linkedInBackgroundWithAuthorDictionary:dic\n                                           platform:BmobSNSPlatformSinaWeibo\n                                              block:^(BOOL isSuccessful, NSError *error) {\n                                                     NSLog(@\nERROR :%@\n,[error description]);\n                                                 }];\n\n\n\n\n//手机qq账号关联到当前用户\nNSDictionary *responseDictionary = @{@\naccess_token\n: _tencentOauth.accessToken,@\nuid\n:_tencentOauth.openId,@\nexpirationDate\n:_tencentOauth.expirationDate};\nBmobUser *user = [BmobUser getCurrentUser];\n[user linkedInBackgroundWithAuthorDictionary:responseDictionary\n                                platform:BmobSNSPlatformQQ\n                                   block:^(BOOL isSuccessful, NSError *error) {\n                                       NSLog(@\nerror%@\n,[error description]);\n                                   }];\n\n\n\n\n//微信账号关联到当前用户\nNSDictionary *responseDictionary = @{@\naccess_token\n: accessToken,@\nuid\n:openId,@\nexpirationDate\n:expirationDate};\nBmobUser *user = [BmobUser getCurrentUser];\n[user linkedInBackgroundWithAuthorDictionary:responseDictionary\n                                platform:BmobSNSPlatformWeiXin\n                                   block:^(BOOL isSuccessful, NSError *error) {\n                                       NSLog(@\nerror%@\n,[error description]);\n                                   }];\n\n\n\n\n解除绑定\n\n\n解除绑定的账号，也是很简单的。下面是例子：\n\n\n//当前用户解除关联的微博账号\nBmobUser *user = [BmobUser getCurrentUser];\n[user cancelLinkedInBackgroundWithPlatform:BmobSNSPlatformSinaWeibo\n                                    block:^(BOOL isSuccessful, NSError *error) {\n                                        NSLog(@\nerror is :%@\n,[error description]);\n                                    }];\n\n\n\n\n//当前用户解除关联的手机QQ账号\nBmobUser *user = [BmobUser getCurrentUser];\n[user cancelLinkedInBackgroundWithPlatform:BmobSNSPlatformQQ\n                                     block:^(BOOL isSuccessful, NSError *error) {\n                                         NSLog(@\nerror is :%@\n,[error description]);\n                                     }];                                                                          \n\n\n\n\n//当前用户取消关联微信账号\nNSDictionary *responseDictionary = @{@\naccess_token\n: accessToken,@\nuid\n:openId,@\nexpirationDate\n:expirationDate};\nBmobUser *user = [BmobUser getCurrentUser];\n[user cancelLinkedInBackgroundWithAuthorDictionary:responseDictionary\n                                platform:BmobSNSPlatformWeiXin\n                                   block:^(BOOL isSuccessful, NSError *error) {\n                                       NSLog(@\nerror%@\n,[error description]);\n                                   }];\n\n\n\n\n手机号相关功能\n\n\n从 \nv1.5.8\n 开启Bmob加入了手机注册登录及密码重置等功能。以下介绍的功能可参考我们提供的\nBmobSmsDemo\n（使用前请先在Appdelegate.m中填入你的app id）\n\n\n注：以下的新功能如果需要填入验证码参数的，请先调用请求验证码方法。\n\n\n手机号注册\n\n\n可使用以下代码进行一键注册并登录的操作。在使用前必须先请求手机验证码，注册成功后将以当前的手机号码作为用户名，并且会缓存用户信息在本地，可使用 \n[BmobUser getCurrentUser]\n 获取。\n\n\n[BmobUser signOrLoginInbackgroundWithMobilePhoneNumber:mobilePhoneNumber andSMSCode:smsCode block:^(BmobUser *user, NSError *error) {\n        if (user) {\n            NSLog(@\n%@\n,user);\n        } else {\n            NSLog(@\n%@\n,error);\n        }\n}];\n\n\n\n\n如果希望在用手机注册时为用户添加密码或者其它信息，可以使用以下代码实现：\n\n\n    BmobUser *buser = [[BmobUser alloc] init];\n    buser.mobilePhoneNumber = @\n15123456789\n;\n    buser.password = @\n123\n;\n    buser.email = @\nxxx@gmail.com\n;\n    [buser signUpOrLoginInbackgroundWithSMSCode:@\n6位验证码\n block:^(BOOL isSuccessful, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            BmobUser *user = [BmobUser getCurrentUser];\n            NSLog(@\n%@\n,[BmobUser getCurrentUser]);\n        }\n    }];\n\n\n\n\n手机号登录\n\n\nBmob除了提供手机号验证码一键注册登录功能外，还另外提供了希望只给已存在用户用手机号进行登录的功能。代码如下：\n\n\n\n    [BmobUser loginInbackgroundWithMobilePhoneNumber:mobilePhoneNumber andSMSCode:smsCode block:^(BmobUser *user, NSError *error) {\n        if (user) {\n            NSLog(@\n%@\n,user);\n        } else {\n            NSLog(@\n%@\n,error);\n        }\n    }];\n\n\n\n\n绑定手机号\n\n\n绑定手机号的基本思路为，先获取验证码，验证取得的验证码后再更新 \nmobilePhoneNumber\n 和 \nmobilePhoneNumberVerified\n 即可，这是我们推荐的做法。当然，你也可以不通过验证码，直接使用用户输入的手机号来更新 \nmobilePhoneNumber\n 来进行绑定，不过这种方法并不推荐。\n\n\n    //验证\n    [BmobSMS verifySMSCodeInBackgroundWithPhoneNumber:mobilePhoneNumber andSMSCode:smsCode resultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //修改绑定手机\n            BmobUser *buser = [BmobUser getCurrentUser];\n            buser.mobilePhoneNumber = mobilePhoneNumber;\n            [buser setObject:[NSNumber numberWithBool:YES] forKey:@\nmobilePhoneNumberVerified\n];\n            [buser updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@\n%@\n,buser);\n                } else {\n                    NSLog(@\n%@\n,error);\n                }\n            }];\n\n        } else {\n            NSLog(@\n%@\n,error);\n        }\n    }];\n\n\n\n\n手机号修改密码\n\n\n通过请求验证码和输入验证码从而进行账号密码重置，代码如下：\n\n\n    [BmobUser resetPasswordInbackgroundWithSMSCode:smsCode andNewPassword:newPassword block:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@\n%@\n,@\n重置密码成功\n);\n        } else {\n            NSLog(@\n%@\n,error);\n        }\n    }];\n\n\n\n\n子类化\n\n\n很多时候BmobObject并不能满足用户的需求，用户可能需要继承BmobOject来定制自己的需求。但是当用户需要保存继承类的属性至后台时，还需要做一些额外的处理。因此，我们推出子类化BmobObject的选项，以让用户的代码具备更好的扩展性。\n\n\n子类化的使用\n\n\n先来定义一个BmobObject的子类。\n\n\nTest.h\n\n\n\n@interface Test : BmobObject\n@property (copy, nonatomic) NSString *title;\n@property (copy, nonatomic) NSString *name;\n@property (strong, nonatomic) NSNumber *isStudent;\n@property (strong, nonatomic) NSNumber *age;\n@end\n\n\n\n\nTest.m\n\n\n\n@implementation Test\n\n@synthesize title;\n@synthesize name;\n@synthesize isStudent;\n@synthesize age;\n\n@end\n\n\n\n\n后面你就可以像以下形式那样使用Test类了\n\n\n    Test *test = [[Test alloc] init];\n    test.title = @\ntitle2\n;\n    test.name = @\nname2\n;\n    test.isStudent = [NSNumber numberWithBool:NO];\n    test.age = @22;\n    [test sub_saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@\nerror %@\n,error);\n        NSLog(@\nobjectId %@\n,test.objectId);\n    }];\n\n\n\n\n注意：\n1.当用到添加与更新操作时，要使用类似于sub_XXX的方法，而其它方法保持不变，与BmobObject一致。\n2.子类的方法使用对象类型，不要使用基本类型。例如，要使用整型时，可以声明为NSNumber。\n\n\n针对BmobUser的特别说明\n\n\n如果要使用继承BmobUser的子类来进行登录，在构造其子类时，应用类似于以下的形式。\n\n\n TestUser *user = [[TestUser alloc] initFromBmobObject:[BmobUser getCurrentUser]];\n    user.email = @\nxxxaa@qq.com\n;\n    [user sub_updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@\nerror %@\n,error.description);\n    }];\n\n\n\n\n\n注意，此方法无法更新本地用户缓存，因此需要慎重考虑是是否子类化BmobUser。\n\n\n查询\n\n\n查询后需要使用以下方法以得到子类的对象。\n\n\n    BmobQuery *testQuery = [Test query];\n    [testQuery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobObject *obj in array) {\n            Test *t = [[Test alloc] initFromBmobObject:obj];\n\n        }\n    }];\n\n\n\n\n文件管理\n\n\n文件管理章节Demo\n\n\n创建文件对象\n\n\nBmobFile可以让你的应用程序将文件存储到服务器中，比如常见的文件类型图像文件，影像文件、音乐文件和任何其他二进制数据都可以使用。当文件上传成功后，可以通过url属性来获取文件的地址。\n\n\n上传文件\n\n\n1.6.9版本之后，上传服务使用CDN服务\n\n\n上传文件方法\n\n\n如下图的例子，是将cs.txt的文本文件保存到服务器端：\n\n\n-(void)saveInBackground:(BmobBooleanResultBlock)block;\n\n\n\n\n可以在block里面把文件添加到gameScore里面，建议使用异步上传的方法，再在block进行操作。如下面的例子：\n\n\nNSBundle    *bundle = [NSBundle mainBundle];\nNSString *fileString = [NSString stringWithFormat:@\n%@/cs.txt\n ,[bundle bundlePath] ];\nBmobObject *obj = [[BmobObject alloc] initWithClassName:@\nGameScore\n];\nBmobFile *file1 = [[BmobFile alloc] initWithFilePath:fileString];\n[file1 saveInBackground:^(BOOL isSuccessful, NSError *error) {\n     //如果文件保存成功，则把文件添加到filetype列\n     if (isSuccessful) {\n         [obj setObject:file1  forKey:@\nfiletype\n];\n         //此处相当于新建一条记录,      //关联至已有的记录请使用 [obj updateInBackground];\n         [obj saveInBackground];\n         //打印file文件的url地址\n         NSLog(@\nfile1 url %@\n,file1.url);\n     }else{\n        //进行处理\n     }\n}];\n\n\n\n\n上传文件进度\n\n\n在上传文件时，有时会需要获取上传文件进度的需求。这时，可以使用\n\n\n-(void)saveInBackground:(BmobBooleanResultBlock)block withProgressBlock:(BmobProgressBlock)progressBlock;\n\n\n\n\n如在下面的例子中，打印上传的进度\n\n\nNSBundle    *bundle = [NSBundle mainBundle];\nNSString *fileString = [NSString stringWithFormat:@\n%@/cs.txt\n ,[bundle bundlePath] ];\nBmobObject *obj = [[BmobObject alloc] initWithClassName:@\ngameScoreFile\n];\nBmobFile *file1 = [[BmobFile alloc] initWithClassName:@\nAsc\n withFilePath:fileString];\n[file1 saveInBackground:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        [obj setObject:file1  forKey:@\nuserFile\n];\n        [obj saveInBackground];\n        NSLog(@\nfile1 url %@\n,file1.url);\n    }\n} withProgressBlock:^(CGFloat progress) {\n    NSLog(@\n上传进度%.2f\n,progress);\n}];\n\n\n\n\n以分片的方式上传文件\n\n\n分片上传文件和上传整个文件的机制有所不同，是先把整个文件进行分片（256KB一片），然后再进行一片一片的上传（具体实现可查看\nRestAPI文档\n）。当文件以分片的方式上传到Bmob服务器时，具有几种优势：\n\n\n\n\n\n\n适合于尺寸较大的文件传输，通过切片来避免单个HTTP数据量过大而导致连接超时；\n\n\n\n\n\n\n在网络条件较差的环境下，较小的尺寸可以有较高的上传成功率，从而避免无休止的失败重试；\n\n\n\n\n\n\n在BmobSDK中对应的函数方法为\n\n\n-(void)saveInBackgroundByDataSharding:(BmobBooleanResultBlock)block;\n\n\n\n\n示例如下：\n\n\nNSBundle    *bundle = [NSBundle mainBundle];\n//上传cs.txt文件\nNSString *fileString = [NSString stringWithFormat:@\n%@/cs.txt\n ,[bundle bundlePath] ];\nBmobObject *obj = [[BmobObject alloc] initWithClassName:@\ngameScoreFile\n];\n//创建BmobFile对象\nBmobFile *file1 = [[BmobFile alloc] initWithFilePath:fileString];\n[file1 saveInBackgroundByDataSharding:^(BOOL isSuccessful, NSError *error) {\n   if (isSuccessful) {\n        //如果成功，保存文件到userFile\n       [obj setObject:file1  forKey:@\nuserFile\n];\n       [obj saveInBackground];\n   }else{\n       //失败，打印错误信息\n        NSLog(@\nerror: %@\n,[error description]);\n   }\n} ];\n\n\n\n\n批量上传文件\n\n\n有时，开发者需要一次性上传多个文件，这是可以使用SDK提供的多个上传文件的方法来使用\n\n\nNSBundle    *bundle = [NSBundle mainBundle];\n//文件cncc.jpg的路径\nNSString *fileString = [NSString stringWithFormat:@\n%@/cncc.jpg\n ,[bundle bundlePath] ];\n//文件cs.txt的路径\nNSString *fileString2 = [NSString stringWithFormat:@\n%@/cs.txt\n ,[bundle bundlePath] ];\n[BmobFile filesUploadBatchWithPaths:@[fileString,fileString2]\n                      progressBlock:^(int index, float progress) {\n                           //index 上传数组的下标，progress当前文件的进度\n                          NSLog(@\nindex %d progress %f\n,index,progress);\n                      } resultBlock:^(NSArray *array, BOOL isSuccessful, NSError *error) {\n                      //array 文件数组，isSuccessful 成功或者失败,error 错误信息\n                      BmobObject *obj = [[BmobObject alloc] initWithClassName:@\ngameScoreFile\n];\n                          for (int i = 0 ; i \n array.count ;i ++) {\n                              BmobFile *file = array [i];\n                              NSString *key = [NSString stringWithFormat:@\nuserFile%d\n,i];\n                              [obj setObject:file  forKey:key];\n                          }                          \n                          [obj saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) { \n                              }];\n                      }];\n\n\n\n\n下载文件\n\n\n获取文件对象只需通过-(id)objectForKey:(id)key;来得到，例如，\n\n\nBmobFile *file = (BmobFile*)[gameScore objectForKey:@\nfiletype\n];\n\n\n\n\n可用通过file的url属性(file.url)，来得到文件的地址进行下载。\n\n\n删除文件\n\n\n删除文件接口只能删除1.6.9版本之后上传的文件\n\n\n如果需要删除文件，使用以下接口即可\n\n\n/**\n *  异步请求删除文件\n *\n *  @param block 返回删除结果与信息，如果删除成功，则无返回信息\n */\n-(void)deleteInBackground:(BmobBooleanResultBlock)block;\n\n\n\n\n当开发者需要一次性删除多个文件的时候，可以调用批量删除文件的接口\n\n\n    NSArray *array = @[@\nhttp://bmob-cdn-1.b0.upaiyun.com/jpg/579c8dc6676e460b82d83c8eb5c8aaa5.jpg\n,@\nhttp://bmob-cdn-1.b0.upaiyun.com/jpg/59e3817d6cec416ba99a126c9d42768f.jpg \n]\n\n    [BmobFile filesDeleteBatchWithArray:array resultBlock:^(NSArray *array, BOOL isSuccessful, NSError *error) {\n        NSLog(@\nfail delete array %@\n,array);\n        NSLog(@\nerror %@\n,error.localizedDescription);\n        NSLog(@\nissuccessful %i\n,isSuccessful);\n    }];\n\n\n\n\n缩略图\n\n\n只需要在图片上传成功返回的url后面拼接特定参数即可实现缩放，加水印等效果，\n如图\n，\n具体可参考这里 。\n\n\n数据实时功能\n\n\nBmob提供了数据实时功能，当开发者监听某个变化事件，例如监听表更新时，表的内容一旦变化，服务器就会通知SDK，SDK提供了相应回调函数来给开发者使用。当然开发者也可以取消相对应的监听，这样就不会收到数据变化的消息了。\n\n\n监听功能\n\n\nSDK提供了两个方法来监听数据变化，其中一个方法是针对表，另一个则针对行。\n\n\n-(void)listenTableChange:(BmobActionType)actionType tableName:(NSString *)tableName;\n\n\n\n\n这个函数可以监听到表更新（包括该表的行数据的变化）、表删除的行为。例如:\n\n\n-(void)listen{\n    //创建BmobEvent对象\n    _bmobEvent          = [BmobEvent defaultBmobEvent];\n    //设置代理\n    _bmobEvent.delegate = self;\n    //启动连接\n    [_bmobEvent start];\n}\n\n\n\n\n在代理的函数，进行操作\n\n\n//可以进行监听或者取消监听事件\n-(void)bmobEventCanStartListen:(BmobEvent *)event{\n    //监听Post表更新\n    [_bmobEvent listenTableChange:BmobActionTypeUpdateTable tableName:@\nPost\n];\n}\n//接收到得数据\n-(void)bmobEvent:(BmobEvent *)event didReceiveMessage:(NSString *)message{\n    //打印数据\n    NSLog(@\ndidReceiveMessage:%@\n,message);\n}\n\n\n\n\n相对的，也有监听行更新。行删除的函数：\n\n\n-(void)listenRowChange:(BmobActionType)actionType tableName:(NSString *)tableName objectId:(NSString *)objectId;\n\n\n\n\n当然了表删除，行更新，行删除等行为也可以在代理函数-(void)bmobEventCanStartListen:(BmobEvent *)event上进行监听。例如：\n\n\n-(void)bmobEventCanStartListen:(BmobEvent *)event\n    //监听Test表删除事件，\n    [_bmobEvent listenTableChange:BmobActionTypeDeleteTable tableName:@\nTest\n];\n    //监听Post表中objectId为a1419df47a 的行更新事件\n    [_bmobEvent listenRowChange:BmobActionTypeUpdateRow tableName:@\nPost\n objectId:@\na1419df47a\n];\n    //监听Post表中objectId为wb1o000F 的行删除事件\n    [_bmobEvent listenRowChange:BmobActionTypeDeleteRow tableName:@\nPost\n objectId:@\nwb1o000F\n];\n}\n\n\n\n\n需要注意的是，监听事件后，接收到的数据是json格式的字符串，可以序列化为NSDictionary。\n\n\n取消监听功能\n\n\n当开发者想取消监听某个行为时，可以使用下面的函数\n\n\n//取消订阅表的变化事件,包括表更新，表删除\n-(void)cancleListenTableChange:(BmobActionType)actionType tableName:(NSString *)tableName;\n\n\n\n\n和\n\n\n//取消订阅行的变化事件\n-(void)cancleListenRowChange:(BmobActionType)actionType tableName:(NSString *)tableName objectId:(NSString *)objectId;\n\n\n\n\n这里有个\n实例\n可以参考下。\n\n\nACL和角色\n\n\n大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：\n\n\n\n\n对于私有数据，读写权限可以只局限于数据的所有者。\n\n\n对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。\n\n\n对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。\n\n\n属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。\n\n\n一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。\n用Bmob SDK，你可以对这些数据设置一个默认的ACL，这样，即使黑客反编译了你的应用，获取到Application Key，也仍然无法操作和破坏你的用户数据，确保了用户数据的安全可靠。而作为开发者，当你需要对这些数据进行管理时，可以通过超级权限Key（Master Key）进行。\n\n\n\n\n默认访问权限\n\n\n在没有显示指定的情况下，每一个BmobObject(表)中的ACL(列)属性的默认值是所有人可读可写的。在客户端想要修改这个权限设置，只需要简单简单调用BmobACL的setPublicReadAccess方法和setPublicWriteAccess方法，即：\n\n\nBmobACL *acl = [BmobACL ACL];\n//设置所有人读权限为true\n[acl setPublicReadAccess];\n//设置所有人写权限为true\n[acl setPublicWriteAccess];\n\n\n\n\n注意：可读可写是默认的权限，不需要写额外的代码。\n\n\n指定用户的访问权限\n\n\n假如你想实现一个分享日志类的应用时，这可能会需要针对不同的日志设定不同的访问权限。比如，公开的日志，发布者有更改和修改的权限，其他用户只有读的权限，那么可用如下代码实现：\n\n\nBmobObject *blog = [[BmobObject alloc] initWithClassName:@\nblog\n] ;\n[blog setObject:@\n论电影的七个元素\n forKey:@\ntitle\n];\n[blog setObject:@\n这是blog的具体内容\n forKey:@\ncontent\n];\nBmobACL *acl = [BmobACL ACL];\n[acl setPublicReadAccess];//设置所有人可读\n[acl setWriteAccessForUser:[BmobUser getCurrentUser]];//设置只有当前用户可写\nblog.ACL= acl;\n[blog saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];\n\n\n\n\n有时，用户想发表一篇不公开的日志，这种情况只有发布者才对这篇日志拥有读写权限，相应的代码如下：\n\n\nBmobObject *blog = [[BmobObject alloc] initWithClassName:@\nblog\n] ;\n[blog setObject:@\n一个人的秘密\n forKey:@\ntitle\n];\n[blog setObject:@\n这是blog的具体内容\n forKey:@\ncontent\n];\nBmobACL *acl = [BmobACL ACL];\n[acl setReadAccessForUser:[BmobUser getCurrentUser]];//设置只有当前用户可读\n[acl setWriteAccessForUser:[BmobUser getCurrentUser]];//设置只有当前用户可写\nblog.ACL= acl;\n[blog saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];\n\n\n\n\n角色管理\n\n\n上面的指定用户访问权限虽然很方便，但是对于有些应用可能会有一定的局限性。比如一家公司的工资系统，员工和公司的出纳们只拥有工资的读权限，而公司的人事和老板才拥有全部的读写权限。要实现这种功能，你也可以通过设置每个用户的ACL权限来实现，如下：\n\n\n//创建公司某用户的工资对象\nBmobObject *wageinfo  = [[BmobObject alloc] initWithClassName:@\nwageinfo\n];\n[wageinfo setObject:[NSNumber numberWithUnsignedInteger:100000] forKey:@\nwage\n];\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser *boss        = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\nBmobUser *hr_zhang    = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\nBmobUser *cashier_xie = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\nBmobUser *me          = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\n//创建ACL对象\nBmobACL *acl = [BmobACL ACL];\n//4个用户对象均可读\n[acl setReadAccessForUser:boss];\n[acl setReadAccessForUser:hr_zhang];\n[acl setReadAccessForUser:cashier_xie];\n[acl setReadAccessForUser:me];\n//设置boss跟hr_zhang 写的权限\n[acl setWriteAccessForUser:boss];\n[acl setWriteAccessForUser:hr_zhang];\nwageinfo.ACL= acl;\n[wageinfo saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];\n\n\n\n\n但是，一个公司的人事、出纳和员工不仅仅只有一个人，同时还会有离职、调换岗位以及新员工加入等问题存在。如果用上面的代码对公司的每个人进行一一设置的话是不现实的，既麻烦也很难维护。针对这个问题，我们可以利用BmobRole来解决。我们只需要对用户进行分类，每个分类赋予不同的权限。如下代码实现：\n\n\n//创建公司某用户的工资对象\nBmobObject *wageinfo  = [[BmobObject alloc] initWithClassName:@\nwageinfo\n];\n[wageinfo setObject:[NSNumber numberWithUnsignedInteger:100000] forKey:@\nwage\n];\n//这里创建5个用户对象，分别为老板、人事小张、人事小罗、出纳小谢和自己\nBmobUser *boss           = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\nBmobUser *hr_zhang       = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\nBmobUser *hr_luo         = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];;\nBmobUser *cashier_xie    = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\nBmobUser *me             = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\n//创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\nBmobRole *hr             = [BmobRole roleWithName:@\nHR\n];\nBmobRole *cashier        = [BmobRole roleWithName:@\nCashier\n];\n//将hr_zhang和hr_luo归属到hr角色中\nBmobRelation *hrRelation = [BmobRelation relation];\n[hrRelation addObject:hr_zhang];\n[hrRelation addObject:hr_luo];\n[hr addUsersRelation:hrRelation];\n//保存到云端角色表中（web端可以查看Role表）\n[hr saveInBackground];\n//将cashier_xie归属到cashier角色中\nBmobRelation *cashierRelation = [BmobRelation relation];\n[cashierRelation addObject:cashier_xie];\n[cashier addUsersRelation:cashierRelation];\n//保存到云端角色表中（web端可以查看Role表）\n[cashier saveInBackground];\n//创建ACL对象\nBmobACL *acl = [BmobACL ACL];\n[acl setReadAccessForUser:boss];// 假设老板只有一个, 设置读权限\n[acl setReadAccessForUser:me];// 给自己设置读权限\n[acl setReadAccessForRole:hr];// 给hr角色设置读权限\n[acl setReadAccessForRole:cashier];// 给cashier角色设置读权限\n//设置boss跟hr_zhang 写的权限\n[acl setWriteAccessForUser:boss];// 设置老板拥有写权限\n[acl setWriteAccessForRole:hr];// 设置ht角色拥有写权限\nwageinfo.ACL= acl;\n[wageinfo saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];\n\n\n\n\n需要说明一点的是，Web端的Role表也具有ACL的列，你可以将角色管理的权限赋予某些用户。\n\n\n角色之间的从属关系\n\n\n下面我们来说一下角色与角色之间的从属关系。用一个例子来说明下：一个互联网企业有移动部门，部门中有不同的小组，如Android开发组和IOS开发组。每个小组只拥有自己小组的代码读写权限，但这两个小组同时拥有核心库代码的读权限。\n\n\n//创建MobileDep（移动研发部）、AndroidTeam（android开发组）和iOSTeam（ios开发组）三个角色\nBmobRole *mobileDep =[BmobRole roleWithName:@\nMobileDep\n];\nBmobRole *androidTeam = [BmobRole roleWithName:@\nAndroidTeam\n];\nBmobRole *iosTeam     = [BmobRole roleWithName:@\niOSTeam\n];\n//保存AndroidTeam和iosTeam角色到云端\n[androidTeam saveInBackground];\n[iosTeam saveInBackground];\n//将androidTeam和iosTeam两种角色添加到移动部门角色中\nBmobRelation *relation = [BmobRelation relation];\n[relation addObject:androidTeam];\n[relation addObject:iosTeam];\n[mobileDep addRolesRelation:relation];\n// 假设创建三个代码数据对象\nBmobObject *coreCode = [BmobObject objectWithClassName:@\nCode\n];\nBmobObject *androidCode = [BmobObject objectWithClassName:@\nCode\n];\nBmobObject *iosCode = [BmobObject objectWithClassName:@\nCode\n];\n//......此处省略一些具体的属性设定\n[coreCode saveInBackground];\n[androidCode saveInBackground];\n[iosCode saveInBackground];\n//设置androidTeam角色对androidCode对象的读和写的权限\n[androidCode.ACL setReadAccessForRole:androidTeam];\n[androidCode.ACL setWriteAccessForRole:androidTeam];\n//设置iosTeam角色对iosCode对象的读和写的权限\n[iosCode.ACL setReadAccessForRole:iosTeam];\n[iosCode.ACL setWriteAccessForRole:iosTeam];\n//设置mobileDep角色可以对coreCode对象进行读操作\n[coreCode.ACL setReadAccessForRole:mobileDep];\n\n\n\n\n地理位置\n\n\nBmob允许用户根据地球的经度和纬度坐标进行基于地理位置息的信查询。你可以在BmobObject的查询中添加一个BmobGeoPoint的对象查询。你就可以实现轻松查找出离当前用户最接近的信息或地点的功能。\n\n\n地理位置对象\n\n\n首先需要创建一个BmobGeoPoint对象。例如，创建一个-东经116.39727786183357度北纬39.913768382429105度的BmobGeoPoint对象：\n\n\nBmobGeoPoint *point = [[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:39.913768382429105];\n\n\n\n\n添加地理信息\n\n\n[gameScore setObject:point forKey:@\nlocation\n];\n\n\n\n\n地理查询\n\n\n现在，你的数据表中有了一定的地理坐标对象的数据，这样可以测试找出最接近某个点的信息了。你可以使用BmobQuery对象的whereNear方法来这样做：\n\n\nBmobGeoPoint  *point = [[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:39.913768382429105];\nBmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n[bquery whereKey:@\nlocation\n nearGeoPoint:point];\n[bquery setLimit:10];\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n    //进行操作\n}];\n\n\n\n\n要限制查询指定距离范围的数据可以使用whereWithinKilometers(公里)、whereWithinMiles(英里)或whereWithinRadians(弧度)方法。 要查询一个矩形范围内的信息可以使用whereWithinGeoBox来实现：\n\n\nBmobGeoPoint *southwestOfSF = [[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:39.913768382429105];\nBmobGeoPoint* northeastOfSF =[[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:40.913768382429105];\nBmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n[bquery whereKey:@\nlocation\n withinGeoBoxFromSouthwest:southwestOfSF\n                                           toNortheast:northeastOfSF];\n[bquery setLimit:10];\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n    //进行操作\n}];\n\n\n\n\n注意事项\n\n目前有几个需要注意的地方：\n\n\n\n\n\n\n每个BmobObject数据对象中\n只能\n有一个BmobGeoPoint对象。\n\n\n\n\n\n\n地理位置的点不能超过规定的范围。\n纬度的范围\n应该是在\n-90.0到90.0\n之间。\n经度的范围\n应该是在\n-180.0到180.0\n之间。如果您添加的经纬度超出了以上范围，将导致程序错误。\n\n\n\n\n\n\n地理位置查询最大的距离根据表数据的不同有不同的限制，使用-(void)whereKey:(NSString \n)key nearGeoPoint:(BmobGeoPoint \n)geopoint;默认\n100KM\n。当需要指定距离时，最好指定一下最大距离。\n\n\n\n\n\n\n其它功能\n\n\n获取服务器时间\n\n\n获取服务器时间戳可以直接调用[Bmob getServerTimestamp]，例如：\n\n\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];\n        //设置时区\n        [dateFormatter setTimeZone:[NSTimeZone timeZoneWithName:@\nAsia/Shanghai\n]];\n        //时间格式\n        [dateFormatter setDateFormat:@\nyyyy-MM-dd hh:mm:ss\n];\n        //调用获取服务器时间接口，返回的是时间戳\n        NSString  *timeString = [Bmob getServerTimestamp];\n        //时间戳转化成时间\n        NSDate *date = [NSDate dateWithTimeIntervalSince1970:[timeString intValue]];\n        NSString *dateStr = [dateFormatter stringFromDate:date];\n        NSLog(@\n北京时间:%@\n,dateStr);\n    });\n\n\n\n\n\n设置API网络请求超时时间\n\n\n使用 \n+(void)setBmobRequestTimeOut:(CGFloat)seconds;\n 方法可以设置API中网络请求的超时时间，例如，想要设置访问Bmob后台时超过15s就返回超时错误，可以这样写.\n\n\n[Bmob setBmobRequestTimeOut:15];\n\n\n\n\n\nBmobSDK默认是20s后得不到回复就提示超时，如果没有特别的需求，建议不要设置该时间。\n\n\n获取表结构\n\n\n从 \nv1.6.1\n 开始，我们开放获取表结构的接口。\n\n\n获取特定表的结构\n\n\n可通过表名来获取特定表的结构，样例代码如下：\n\n\n    [Bmob getTableSchemasWithClassName:@\n_User\n callBack:^(BmobTableSchema *bmobTableSchema, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            //直接用description来查看表结构\n            NSLog(@\n%@\n,bmobTableSchema.description);\n\n            /*\n             分别打印表结构\n            */\n            //打印表名\n            NSLog(@\n表名:%@\n,bmobTableSchema.className);\n            //打印表结构\n            NSDictionary *fields = bmobTableSchema.fields;\n            NSArray *allKey = [fields allKeys];\n            for (NSString *key in allKey) {\n                NSLog(@\n列名:%@\n,key);\n                NSDictionary *fieldStrcut = [fields objectForKey:key];\n                NSLog(@\n列类型:%@\n,[fieldStrcut objectForKey:@\ntype\n] );\n                if ([[fieldStrcut objectForKey:@\ntype\n] isEqualToString:@\nPointer\n]) {\n                    NSLog(@\n关联关系指向的表名:%@\n,[fieldStrcut objectForKey:@\ntargetClass\n]);\n                }\n            }\n        }\n    }];\n\n\n\n\n获取所有表的结构\n\n\n可通过以下代码得到所有表的结构\n\n\n    [Bmob getAllTableSchemasWithCallBack:^(NSArray *tableSchemasArray, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            for (BmobTableSchema* bmobTableSchema in tableSchemasArray) {\n                //直接用description来查看表结构\n                NSLog(@\n%@\n,bmobTableSchema.description);\n\n                /*\n                 分别打印表结构\n                 */\n                //打印表名\n                NSLog(@\n表名:%@\n,bmobTableSchema.className);\n                //打印表结构\n                NSDictionary *fields = bmobTableSchema.fields;\n                NSArray *allKey = [fields allKeys];\n                for (NSString *key in allKey) {\n                    NSLog(@\n列名:%@\n,key);\n                    NSDictionary *fieldStrcut = [fields objectForKey:key];\n                    NSLog(@\n列类型:%@\n,[fieldStrcut objectForKey:@\ntype\n] );\n                    if ([[fieldStrcut objectForKey:@\ntype\n] isEqualToString:@\nPointer\n]) {\n                        NSLog(@\n关联关系指向的表名:%@\n,[fieldStrcut objectForKey:@\ntargetClass\n]);\n                    }\n                }\n            }\n        }\n    }];\n\n\n\n\n\n返回数据说明\n\n\n表结构以 \nBmobTableSchema\n 对象的形式返回，其中属性 \nclassName\n 表示表名，而属性 \nfields\n 是一个字典，里面包含了所有列的类型，其结构如下：\n\n\n{@\n列名1\n:dic,@“列名2”:dic}\n\n\n\n\n而dic的结构为：\n\n\n{@\ntype\n:@\ntypeName\n,@\ntargetClass\n:@\ntableName\n}\n\n\n\n\n其中 \ntype\n 指的是该类的类型， 而 \ntargetClass\n 指的是指向的表名，只有在 \ntype\n 为 \nPointer\n 或者 \nRelation\n 时才有值。\n\n\n具体形式如下：\n\n\n{\n    ACL =     {\n        type = Object;\n    };\n    author =     {\n        targetClass = \n_User\n;\n        type = Pointer;\n    };\n    content =     {\n        type = String;\n    };\n    createdAt =     {\n        type = Date;\n    };\n    likes =     {\n        targetClass = \n_User\n;\n        type = Relation;\n    };\n    objectId =     {\n        type = String;\n    };\n    skill =     {\n        type = Array;\n    };\n    title =     {\n        type = String;\n    };\n    updatedAt =     {\n        type = Date;\n    };\n};", 
            "title": "开发文档"
        }, 
        {
            "location": "/data/ios/develop_doc/#_1", 
            "text": "Bmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。", 
            "title": "简介"
        }, 
        {
            "location": "/data/ios/develop_doc/#_2", 
            "text": "", 
            "title": "安装"
        }, 
        {
            "location": "/data/ios/develop_doc/#cocoapodsbmobsdk", 
            "text": "如何使用CocoaPods安装BmobSDK可查看  我们提供的文档", 
            "title": "使用CocoaPods安装BmobSDK"
        }, 
        {
            "location": "/data/ios/develop_doc/#ios9", 
            "text": "iOS9默认不允许进行http请求，所以在使用SDK的过程中需要往Info.plist添加一些内容，   完全取消http请求限制   key NSAppTransportSecurity /key   dict  key NSAllowsArbitraryLoads /key  true/  /dict    指定部分网址支持http   key NSAppTransportSecurity /key   dict \n    key NSExceptionDomains /key \n       dict      \n             key yourserver.com /key     \n         dict       \n             key NSIncludesSubdomains /key \n                 true/ \n                 key NSTemporaryExceptionAllowsInsecureHTTPLoads /key \n                 true/              \n                 key NSTemporaryExceptionMinimumTLSVersion /key        \n                 string TLSv1.1 /string     \n             /dict    \n         /dict \n  /dict   另外，最新版的sdk已支持bitcode。  其他一些需要注意兼容iOS9的地方可以  参照这里", 
            "title": "兼容iOS9"
        }, 
        {
            "location": "/data/ios/develop_doc/#_3", 
            "text": "在Bmob平台注册的每个账户都可以创建多个应用程序，每个应用程序都有其独自的应用程序ID，在后续程序编写中，所有的应用程序将凭其ID来使用Bmob SDK。同一个应用可以分别在测试环境和生产环境中部署不同的版本。", 
            "title": "应用程序"
        }, 
        {
            "location": "/data/ios/develop_doc/#_4", 
            "text": "请大家在使用Bmob开发应用程序之前，认真阅读我们给大家提供的“数据与安全”的文档，确保你的应用在发布时安全。文档  请点击 ;", 
            "title": "应用安全"
        }, 
        {
            "location": "/data/ios/develop_doc/#_5", 
            "text": "从v2.1.8开始，数据SDK新增了能重新设置请求域名的Api，类似数据迁移，调用方式如下：  [Bmob resetDomain:@ http://demo.bmob.cn/ ];  其中，参数为开发者的域名，调用后的所有请求都指向新的域名。", 
            "title": "数据迁移"
        }, 
        {
            "location": "/data/ios/develop_doc/#_6", 
            "text": "", 
            "title": "对象"
        }, 
        {
            "location": "/data/ios/develop_doc/#_7", 
            "text": "Bmob存储的数据是建立在BmobObject基础上的，每个BmobObject包含键(Key)-值(value)对的JSON兼容数据。这个数据是无模式的，这意味着不需要提前指定每个BmobObject存在什么键。你只需要设置你想要的键值对让我们在后端存储。  例如，假设你要记录一个游戏的得分。一个单一的BmobObject对象可能包含：score: 1337, playerName: \"Sean Plott\", cheatMode: false。键必须是字母、数字的字符串。值可以是字符串、数字、布尔值、Json数组、和BmobObject对象等。  每个BmobObject有一个ClassName，它对应后台的表名。例如，我们可以调用的游戏分数对象的ClassName为GameScore，那么它在后台对应的表名就是GameScore。", 
            "title": "数据对象"
        }, 
        {
            "location": "/data/ios/develop_doc/#_8", 
            "text": "为了提供更好的服务，BmobSDK中提供了BmobUser、BmobInstallation两个特殊的BmobObject对象来完成不同的功能，在这里我们统一称为特殊对象。\nBmobUser对象主要是针对应用中的用户功能而提供的，它对应着web端的User表，使用BmobUser对象可以很方便的在应用中实现用户的注册、登录、邮箱验证等功能，具体的使用方法可查看文档的 用户 部分。\nBmobInstallation对象主要用于应用的安装设备管理中，它对应着web端的Installation表，任何安装了你应用的设备都会在此表中产生一条数据标示该设备。结合Bmob提供的推送功能，还可以实现将自定义的消息推送给不同的设备终端，具体的使用方法可查看文档的 消息推送 部分。", 
            "title": "特殊对象"
        }, 
        {
            "location": "/data/ios/develop_doc/#_9", 
            "text": "目前为止，我们支持的数据类型有NSString、NSNumber、NSDate、NSArray、NSDictionary以及BmobObject及其子类对象类型。对应后台的类型为String、Number、Date、Array、Object以及Pointer。", 
            "title": "数据类型"
        }, 
        {
            "location": "/data/ios/develop_doc/#bmobobject", 
            "text": "BmobObject提供以下几种方法对BmobOjbect进行初始化：  /**\n *  创建一个带有className的BmobObject对象\n *\n *  @param  className   表示对象名称(类似数据库表名)\n *\n *  @return BmobObject\n */\n+(instancetype )objectWithClassName:(NSString*)className;\n\n\n/**\n *  创建一个带有className 和objectId的BmobObject对象\n *\n *  @param className 表名\n *  @param objectId  对象的id\n *\n *  @return BmobObject对象\n */\n+(instancetype)objectWithoutDataWithClassName:(NSString*)className objectId:(NSString *)objectId;\n\n/**\n *  从字典创建BmobObject\n *\n *  @param dictionary 字典\n *\n *  @return BmobObject 对象\n */\n-(instancetype)initWithDictionary:(NSDictionary *)dictionary;", 
            "title": "创建BmobObject对象"
        }, 
        {
            "location": "/data/ios/develop_doc/#_10", 
            "text": "添加一条数据有两步，第一步是构造数据，第二步是保存数据至服务器上，有以下两种方法：  /**\n *  后台保存BmobObject对象，没有返回结果\n */\n-(void)saveInBackground;\n\n/**\n *  后台保存BmobObject对象，返回保存的结果\n *\n *  @param  block   返回保存的结果是成功还是失败\n */\n-(void)saveInBackgroundWithResultBlock:(BmobBooleanResultBlock)block;  比如，在一个游戏的应用中，当需要保存游戏分数、玩家信息到服务器中的时候，就可以创建GameScore表来添加数据，添加数据的形式类型与iOS中的NSMutableDictionary对象类似，如下：      //在GameScore创建一条数据，如果当前没GameScore表，则会创建GameScore表\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@ GameScore ];\n    //score为1200\n    [gameScore setObject:[NSNumber numberWithInt:1200] forKey:@ score ];\n    //设置userName为小明\n    [gameScore setObject:@ 小明  forKey:@ playerName ];\n    //设置cheatMode为NO\n    [gameScore setObject:[NSNumber numberWithBool:NO] forKey:@ cheatMode ];\n    //设置age为18\n    [gameScore setObject:[NSNumber numberWithInt:18] forKey:@ age ];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            //创建对象成功，打印对象值\n            NSLog(@ %@ ,gameScore);\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@ %@ ,error);\n        } else {\n            NSLog(@ Unknow error );\n        }\n    }];  运行完以上代码后，数据即可保存到服务器端了。为了确认数据是否真的已经保存成功，你可以在Bmob服务器端你的应用程序的数据浏览项目中查看。你应该看到类似这样的结果：      objectId:  0c6db13c , score: 1200, playerName:  小明 , cheatMode: false, createdAt: 2012-03-29 10:32:54 , updatedAt: 2012-03-29 10:32:54   这里需要注意几点：   在运行以上代码时，如果服务器端你创建的应用程序中已经存在GameScore数据表和相应的score、playerName、cheatMode等字段，那么你此时添加的数据和数据类型也应该和服务器端的表结构一致，否则将保存数据失败。  如果服务器端不存在GameScore数据表，那么Bmob将根据你第一次(也就是运行的以上代码)保存的GameSocre对象在服务器为你创建此数据表并插入相应数据。  每个BmobObject对象有几个默认的键(数据列)是不需要开发者指定的，objectId是每个保存成功数据的唯一标识符。createAt和updateAt代表每个对象(每条数据)在服务器上创建和最后修改的时间。这些键 (数据列)的创建和数据内容是由服务器端来完成的。  在  [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) 中，成功创建后，error返回的是nil，可以通过 error.localizedDescription 查看返回的错误信息，之后的类似于  xxInBackground  中的error也是一样的结构。  objectId，updatedAt，createdAt这些系统属性在调用创建函数（saveInBackground）的时候不需要进行设置，创建成功后，会返回objectId，updatedAt，createdAt。   上述方法中每添加一条数据需要设置一次键值对，如果觉得过于繁琐，可以通过一个NSDictionary来添加数据，利用以下方法即可:      -(void)saveAllWithDictionary:(NSDictionary*)dic;  这个函数。  如:      BmobObject  *gameScore = [BmobObject objectWithClassName:@ GameScore ];\n    //设置playerName列的值为小黑和age列的值18\n    NSDictionary *dic = @{@ playerName :@ 小黑 ,@ score :@18};\n    [gameScore saveAllWithDictionary:dic];\n    //异步保存\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后的动作\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@ %@ ,error);\n        } else {\n            NSLog(@ Unknow error );\n        }\n    }];", 
            "title": "添加数据"
        }, 
        {
            "location": "/data/ios/develop_doc/#_11", 
            "text": "更新一个对象也是非常简单的，首先获取到要更新的BmobObject对象，进行修改值后再更新数据。例如：  - (void)updateObject{\n    //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@ GameScore ];\n    [gameScore setObject:[NSNumber numberWithInt:1200] forKey:@ score ];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            NSLog(@ 创建成功,以下为对象值 );\n            NSLog(@ %@ ,gameScore);\n\n            //此处是更新操作\n            [gameScore setObject:[NSNumber numberWithInt:110] forKey:@ score ];\n            [gameScore updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@ 更新成功，以下为对象值，可以看到score值已经改变 );\n                    NSLog(@ %@ ,gameScore);\n                } else {\n                    NSLog(@ %@ ,error);\n                }\n            }];\n\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@ %@ ,error);\n        } else {\n            NSLog(@ Unknow error );\n        }\n    }];\n}  如果列存储的是符合JSON格式的字符串对象，可以单独修改该对象的某个值，如有一列名为userAttibute，其值是: {\"name\":\"John\", \"gender\":\"男\"}，如果要修改name为Mike，可以使用以下代码  - (void)updateObjectJSONField{\n    //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@ GameScore ];\n    NSDictionary *json = @{@ name :@ John , @ gender :@ man };\n    [gameScore setObject:json forKey:@ userAttibute ];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            NSLog(@ 创建成功,以下为对象值 );\n            NSLog(@ %@ ,gameScore);\n\n            //此处是更新操作\n            BmobObject *gameScoreChanged = [BmobObject objectWithoutDataWithClassName:@ GameScore  objectId:gameScore.objectId];\n            [gameScoreChanged setObject:@ Mike  forKey:@ userAttibute.name ];\n            [gameScoreChanged updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@ 更新成功，以下为对象值，可以看到json里面的name已经改变 );\n                    NSLog(@ %@ ,gameScoreChanged);\n                } else {\n                    NSLog(@ %@ ,error);\n                }\n            }];\n\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@ %@ ,error);\n        } else {\n            NSLog(@ Unknow error );\n        }\n    }];\n}  此处要注意一点，就是在上传  gameScore  之后，如果要再次进行更新，请重新构造对象，因为此时的  gameScore  对象还含有 userAttibute  的值，下面是错误的代码：      //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@ GameScore ];\n    NSDictionary *json = @{@ name :@ John , @ gender :@ man };\n    [gameScore setObject:json forKey:@ userAttibute ];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            NSLog(@ 创建成功,以下为对象值 );\n            NSLog(@ %@ ,gameScore);\n\n            //错误的做法，直接使用gameScore来设置，请观察gameScore值上传时的值\n            [gameScore setObject:@ women  forKey:@ userAttibute.gender ];\n            NSLog(@ 上传前的gameScore对象值\\n%@ ,gameScore);\n            [gameScore updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@ 更新成功，以下为对象值，可以看到json里面的gender已经改变 );\n                    NSLog(@ %@ ,gameScore);\n                } else {\n                    NSLog(@ %@ ,error);\n                }\n            }];\n\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@ %@ ,error);\n        } else {\n            NSLog(@ Unknow error );\n        }\n    }];\n}  运行后查看log，我们可以看到，除了userAttibute属性外，gameScore对象还有userAttibute.gender属性上传至服务器，这样服务器就无法区分客户端到底是要更新 userAttibuteg还是只更新userAttibute中的gender，从而报错。  2015-12-14 20:45:55.417 BmobSDKDemo[16867:1430005] 创建成功,以下为对象值\n2015-12-14 20:45:55.418 BmobSDKDemo[16867:1430005] \nclassName = GameScore;\nobjectId = 0f3d45dbc5;\ncreatedAt = 2015-12-14 12:45:55 +0000;\nupdatedAt = 2015-12-14 12:45:55 +0000;\ndate = {\n    userAttibute =     {\n        gender = man;\n        name = John;\n    };\n};\n2015-12-14 20:45:55.419 BmobSDKDemo[16867:1430005] 上传前的gameScore对象值\n\nclassName = GameScore;\nobjectId = 0f3d45dbc5;\ncreatedAt = 2015-12-14 12:45:55 +0000;\nupdatedAt = 2015-12-14 12:45:55 +0000;\ndate = {\n    userAttibute =     {\n        gender = man;\n        name = John;\n    };\n     userAttibute.gender  = women;\n};", 
            "title": "更新数据"
        }, 
        {
            "location": "/data/ios/develop_doc/#_12", 
            "text": "为了存储一个计数器类型的数据，Bmob提供对任何数字字段进行原子增加(或者减少)的功能，所以我们可以让score像下面一样增加一个固定的值:      //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@ GameScore ];\n    [gameScore setObject:@0 forKey:@ atomicCounter ];\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            BmobObject *gameScoreToBeChanged = [BmobObject objectWithoutDataWithClassName:@ GameScore  objectId:gameScore.objectId];\n            [gameScoreToBeChanged incrementKey:@ atomicCounter ];\n            [gameScoreToBeChanged updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@ 添加成功，可在后台查看objectID为%@的atomicCounter的值是否为1 ,gameScoreToBeChanged.objectId);\n                } else {\n                    NSLog(@ %@ ,error);\n                }\n            }];\n        } else {\n            NSLog(@ %@ ,error);\n        }\n    }];  也提供了  //列的值增加amount\n- (void)incrementKey:(NSString *)key byAmount:(NSInteger )amount\n//列的值减去一\n- (void)decrementKey:(NSString *)key\n//列的值减去amount\n- (void)decrementKey:(NSString *)key byAmount:(NSInteger )amount  注意：需要调用更新函数才能完成计数器原子增加(或者减少)。", 
            "title": "原子计数器"
        }, 
        {
            "location": "/data/ios/develop_doc/#_13", 
            "text": "从服务器删除对象：      BmobObject *bmobObject = [BmobObject objectWithoutDataWithClassName:@ GameScore   objectId:@ baaf9cfa1b ];\n    [bmobObject deleteInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //删除成功后的动作\n            NSLog(@ successful );\n        } else if (error){\n            NSLog(@ %@ ,error);\n        } else {\n            NSLog(@ UnKnow error );\n        }\n    }];", 
            "title": "删除数据"
        }, 
        {
            "location": "/data/ios/develop_doc/#_14", 
            "text": "Bmob提供了批量操作的类BmobObjectsBatch,使用该类，可以批量增加，修改，删除数据，但一次请求不能超过50条数据。下面是例子程序：  BmobObjectsBatch    *batch = [[BmobObjectsBatch alloc] init] ;\n//在GameScore表中创建一条数据\n[batch saveBmobObjectWithClassName:@ GameScore  parameters:@{@ aveScore : @{@ 数学 :@90},@ score :@78}];\n//在GameScore表中更新objectId为27eabbcfec的数据\n[batch updateBmobObjectWithClassName:@ GameScore  objectId:@ 27eabbcfec  parameters:@{@ score : @85}];\n//在GameScore表中删除objectId为30752bb92f的数据\n[batch deleteBmobObjectWithClassName:@ GameScore  objectId:@ 30752bb92f ];\n[batch batchObjectsInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    NSLog(@ batch error %@ ,[error description]);\n}];", 
            "title": "批量数据操作"
        }, 
        {
            "location": "/data/ios/develop_doc/#_15", 
            "text": "", 
            "title": "查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#_16", 
            "text": "在某些情况下，如果知道某条数据的objectId，而且想得知该条数据的内容，可以使用BmobQuery检索得到一个完整的BmobObject：  //查找GameScore表\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n//查找GameScore表里面id为0c6db13c的数据\n[bquery getObjectInBackgroundWithId:@ 0c6db13c  block:^(BmobObject *object,NSError *error){\n  if (error){\n        //进行错误处理\n  }else{\n      //表里有id为0c6db13c的数据\n      if (object) {\n          //得到playerName和cheatMode\n          NSString *playerName = [object objectForKey:@ playerName ];\n          BOOL cheatMode = [[object objectForKey:@ cheatMode ] boolValue];\n          NSLog(@ %@----%i ,playerName,cheatMode);\n          //打印objectId,createdAt,updatedAt\n          NSLog(@ object.objectId = %@ , [object objectId]);\n          NSLog(@ object.createdAt = %@ , [object createdAt]);\n          NSLog(@ object.updatedAt = %@ , [object updatedAt]);\n      }\n  }\n}];", 
            "title": "查询单条数据"
        }, 
        {
            "location": "/data/ios/develop_doc/#_17", 
            "text": "在某些情况下，当需要查询表中多条元素的时候，可以直接使用findObjectsInBackgroundWithBlock函数获取查询结果，默认100条。  BmobQuery   *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n//查找GameScore表的数据\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobObject *obj in array) {\n            //打印playerName\n            NSLog(@ obj.playerName = %@ , [obj objectForKey:@ playerName ]);\n            //打印objectId,createdAt,updatedAt\n            NSLog(@ obj.objectId = %@ , [obj objectId]);\n            NSLog(@ obj.createdAt = %@ , [obj createdAt]);\n            NSLog(@ obj.updatedAt = %@ , [obj updatedAt]);\n    }\n}];  这里需要注意的是：  1.默认情况下，系统实际上并不会返回所有的数据，而是默认返回10条数据记录，你可以通过setLimit方法设置返回的记录数量。更多细节可 点击查看查询 一节中的分页查询。  2.当查询的是用户表这种系统表的时候，返回的是BmobUser的数组，设备表，角色表也是这样的。  3.查询用户表，设备表、角色表为：  BmobQuery   *bquery = [BmobUser query]; //用户表\nBmobQuery   *bquery = [BmobInstallation query]; //设备表\nBmobQuery   *bquery = [BmobRole query]; //角色表", 
            "title": "查询多条数据"
        }, 
        {
            "location": "/data/ios/develop_doc/#_18", 
            "text": "", 
            "title": "条件查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#_19", 
            "text": "当然了，在大多数情况下，开发者还是会通过特定的条件来筛选，过滤某些数据来进行查询。BmobQuery也提供了对应的查询方法。  如果要过滤特定键的值可以使用- (void)whereKey:(NSString *)key notEqualTo:(id)object。比如需要查询playerName不等于”小明”的数据时可以这样写：  当然，你也可以在你的查询操作中添加多个约束条件，来查询符合要求的数据。  BmobQuery   *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n//添加playerName不是小明的约束条件\n[bquery whereKey:@ playerName  notEqualTo:@ 小明 ];  各种不同条件的比较查询，还有  各种不同的比较查询：\n[bquery whereKey:@ age  lessThan:[NSNumber numberWithInt:18]];//age小于18\n[bquery whereKey:@ age  lessThanOrEqualTo:[NSNumber numberWithInt:18]]; //age小于或等18\n[bquery whereKey:@ age  greaterThan:[NSNumber numberWithInt:18]]; //age大于18\n[bquery whereKey:@ age  greaterThanOrEqualTo:[NSNumber numberWithInt:18]]; //age大于或等于18  这里有点需要注意的是  时间搜索的话，等于的情况因为服务器是精确到微秒值，所以比较的值要加1秒。", 
            "title": "比较查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#_20", 
            "text": "如果你想查询匹配几个不同值的数据，如要查询“小明”，“小红”，“小白”三个人的信息是，可以使用  - (void)whereKey:(NSString *)key containedIn:(NSArray *)array;  函数，如下面所示：  [bquery whereKey:@ playerName  containedIn:[NSArray arrayWithObjects:@ 小明 ,@ 小红 ,@ 小白 , nil]];  如果是关联关系，直接在数组里面填写objectId即可，如下   [bquery whereKey:@ author  containedIn:@[@ 063a2d739e ,@ b97ca382c3 ]];  相反，要排除这几个人的信息可以用  - (void)whereKey:(NSString *)key notContainedIn:(NSArray *)array;  函数，如下所示：  [bquery whereKey:@ playerName  notContainedIn:[NSArray arrayWithObjects:@ 小明 ,@ 小红 ,@ 小白 , nil]];", 
            "title": "子查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#_21", 
            "text": "其他的约束条件有  //设置查询中该字段是有值的结果\n-(void)whereKeyExists:(NSString *)key;\n//设置查询中该字段是没有值的结果\n-(void)whereKeyDoesNotExist:(NSString *)key;  例如:  //查询表中score列有值的数据\n[bquery whereKeyExists:@ score ];  //查询表中score列没有值的数据\n[bquery whereKeyDoesNotExist:@ score ];", 
            "title": "列值是否存在"
        }, 
        {
            "location": "/data/ios/develop_doc/#_22", 
            "text": "对字符串值的模糊查询 比如查询包含字符串的值，有几种方法。如下：  //使用正则表达式查询\n-(void)whereKey:(NSString*)key matchesWithRegex:(NSString*)regex;\n//查询以特定字符串开头的值\n-(void)whereKey:(NSString *)key startWithString:(NSString*)start;\n//查询以特定字符串结尾的值\n-(void)whereKey:(NSString *)key endWithString:(NSString*)end;  注:模糊查询只对付费用户开放，付费后可直接使用。", 
            "title": "模糊查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#_23", 
            "text": "有时，在数据比较多的情况下，你希望查询出的符合要求的所有数据能按照多少条为一页来显示，这时可以使用limit方法来限制查询结果的数据条数来进行分页。默认情况下，Limit的值为100，最大有效设置值1000（设置的数值超过1000还是视为1000）。  bquery.limit = 3;//限制得到的结果条数为3条  在数据较多的情况下，在limit的基础上分页显示数据是比较合理的解决办法，skip属性可以做到跳过查询的前多少条数据来实现分页查询的功能。默认情况下Skip的值为0。  bquery.skip = 3;//跳过3条数据", 
            "title": "分页查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#_24", 
            "text": "对应数据的排序，如数字和字符串，可以使用升序或降序的方式来控制查询数据的结果顺序：  // 升序\n- (void)orderByAscending:(NSString *)key ;\n// 降序\n- (void)orderByDescending:(NSString *)key ;  例如，分数由高到低的排序可以写成  [bquery orderByDescending:@ score ];  当需要组合排序的时候可以这样处理  //先按照年龄升序排序，年龄一样再按照更新时间降序排序\n[bquery orderByAscending:@ age ]\n[bquery orderByDescending:@ updatedAt ]", 
            "title": "排序"
        }, 
        {
            "location": "/data/ios/develop_doc/#_25", 
            "text": "当简单的查询条件，不能满足查询要时，BmobQuery也提供了2种复合查询的方法。  //并查询\n-(void)addTheConstraintByAndOperationWithArray:(NSArray*)array;\n//或查询\n-(void)addTheConstraintByOrOperationWithArray:(NSArray *)array;  数组里面存的是若干个条件字典，其格式为  @{@ 列名 :条件值}  例如：  //查询score列中值等于5且姓名为Mike的数据\nNSArray *array =  @[@{@ score :@5},@{@ name :@ Mike }];\n[bquery addTheConstraintByAndOperationWithArray:array];  支持的条件符号有     Key  Operation      $lt  小于    $lte  小于等于    $gt  大于    $gte  大于等于    $ne  不等于    $in  在数组中    $nin  不在数组中    $exists  值不为空    $or  合成查询中的或查询    $and  合成查询中的与查询    $regex  匹配PCRE表达式     例如:  //查询score列中值大于150或者小于5的数据\nNSArray *array =  @[@{@ score :@{@ $gt :@150}},@{@ score :@{@ $lt :@5}}];\n[bquery addTheConstraintByOrOperationWithArray:array];  //查询score列中值大于5和小于150的数据\nNSArray *array =  @[@{@ score :@{@ $gt :@5}},@{@ score :@{@ $lt :@150}}];\n[bquery addTheConstraintByAndOperationWithArray:array];  需要注意的是，如果是要查找条件为等于的数据的话，直接构造成{@\"列名\":条件}即可，例如下面的例子:  //查找分数为90分跟分数为150分的数据\nNSArray *array =  @[@{@ score :@90},@{@ score :@150}];\n[bquery addTheConstraintByOrOperationWithArray:array];\n\n//查找名字为张三跟李四的数据\nNSArray *array =  @[@{@ name :@ 张三 },@{@ name : 李四 }];\n[bquery addTheConstraintByOrOperationWithArray:array];  其中日期类型和pointer类型构造的方法比较特殊。\n例如要查询要个时间段的数据，可以构造时间  //createdAt大于或等于 2014-07-15 00:00:00\n NSDictionary *condiction1 = @{@ createdAt :@{@ $gte :@{@ __type : @ Date , @ iso : @ 2014-07-15 00:00:00 }}}; \n//createdAt小于 2014-10-15 00:00:00\nNSDictionary *condiction2 = @{@ createdAt :@{@ $lt :@{@ __type : @ Date , @ iso : @ 2014-10-15 00:00:00 }}};\nNSArray *condictonArray = @[condiction1,condiction2];\n//作用就是查询创建时间在2014年7月15日到2014年10月15日之间的数据\n[bquery addTheConstraintByAndOperationWithArray:condictonArray];  如果查询的条件刚好是pointer类型的话，例如要查询某篇文章的作者是A或者B的话，可以这样构造数据:  BmobQuery *query = [BmobQuery queryWithClassName:@ Post ];\n//列author为pointer类型，指向用户表\n//假设用户A的objectId为aaaa ,其中classname为表名\nNSDictionary *condiction1 = @{@ author :@{@ __type :@ Pointer ,@ className :@ _User ,@ objectId :@ aaaa }};\n//假设用户b的objecId为bbbb\nNSDictionary *condiction2= @{@ author :@{@ __type :@ Pointer ,@ className :@ _User ,@ objectId :@ bbbb }};\nNSArray *condictionArray = @[condiction1,condiction2];\n//查找作者为用户A或者作者为用户B的数据\n[query addTheConstraintByOrOperationWithArray:condictionArray];\n[query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n}];  另外我们还封装了以下方法，方便开发者使用，以下是与查询，注意add之前的查询只能添加一个条件，如果是或查询，将 [main andOperation]; 换成 [main orOperation];      BmobQuery   *bquery = [BmobQuery queryWithClassName:@ GameScore_LT ];\n    [bquery whereKey:@ score  equalTo:[NSNumber numberWithDouble:10.3]];\n    BmobQuery   *bquery1 = [BmobQuery queryWithClassName:@ GameScore_LT ];\n    [bquery1 whereKey:@ playerName  equalTo:@ test ];\n\n    BmobQuery   *main = [BmobQuery queryWithClassName:@ GameScore_LT ];\n    [main add:bquery];\n    [main add:bquery1];\n    [main andOperation];\n    [main findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobObject *obj in array) {\n            //打印playerName\n            NSLog(@ %@ ,obj);\n            NSLog(@ obj.playerName = %@ , [obj objectForKey:@ playerName ]);\n        }\n    }];", 
            "title": "复合查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#_26", 
            "text": "有的时候，一张表的数据列比较多，而我们只想查询返回某些列的数据时，我们可以使用以下方法来只返回需要的列的值  //设置查询后返回的字段数组  \n-(void)selectKeys:(NSArray*)keys;  //指定返回查询的结果包括score和playerName两列的数据\n[bquery selectKeys:@[@ score ,@ playerName ]];", 
            "title": "返回指定列"
        }, 
        {
            "location": "/data/ios/develop_doc/#_27", 
            "text": "如果你只是想统计满足查询对象的数量，你并不需要获取所有匹配的对象的具体数据信息，可以直接使用count替代find。例如，查询一个特定玩家玩的游戏场数：  BmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n[bquery whereKey:@ playerName  equalTo:@ Barbie ];\n[bquery countObjectsInBackgroundWithBlock:^(int number,NSError  *error){\n         NSLog(@ %d ,num);\n}];", 
            "title": "查询结果计数"
        }, 
        {
            "location": "/data/ios/develop_doc/#_28", 
            "text": "如果你想对表进行统计查询，可以采用以下方法。", 
            "title": "统计查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#_29", 
            "text": "统计方法共有以下几种,分别用于计算总和、平均值、最大值、最小值  - (void)sumKeys:(NSArray *)keys\n- (void)averageKeys:(NSArray *)keys\n- (void)maxKeys:(NSArray *)keys\n- (void)minKeys:(NSArray *)keys  设置完成后使用下面的方法来返回结果。  - (void)calcInBackgroundWithBlock:(BmobObjectArrayResultBlock)block  例如，如果我们要计算GameScore表所有玩家的得分总和，可以使用以下代码：      BmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n    NSArray *sumArray = [NSArray arrayWithObject:@ score ];\n    [bquery sumKeys:sumArray];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ error is:%@ ,error);\n        } else{\n            if (array) {\n                NSLog(@ %@ ,array);\n                NSDictionary *dic = [[NSDictionary alloc] init];\n                dic = [array objectAtIndex:0];\n                NSLog(@ sum of score:%d ,[[dic objectForKey:@ _sumScore ] intValue] );\n            }\n        }\n    }];  计算总和只对Number类型的列有效，列名使用数组存放。返回的字典key值为_sum+首字母大写的列名，其它计算方法与sum类似，其返回的字典key值见下表     关键字  key值  例子      sum  _sum+首字母大写  _sumScore    average  _avg+首字母大写  _avgScore    max  _max+首字母大写  _maxScore    min  _min+首字母大写  _minScore", 
            "title": "统计查询方法"
        }, 
        {
            "location": "/data/ios/develop_doc/#_30", 
            "text": "分组可用于获取并不复杂的列值，如我想知道playerName列中有多少个不同的玩家名字，可使用以下代码：      BmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore_LT ];\n    NSArray *groupbyArray = [NSArray arrayWithObject:@ playerName ];\n    [bquery groupbyKeys:groupbyArray];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ error is:%@ ,error);\n        } else{\n            if (array) {\n                NSLog(@ %@ ,array);\n                for (NSDictionary *dic in array) {\n                    NSString *playerName = [dic objectForKey:@ playerName ];\n                    NSLog(@ player:%@ ,playerName);\n                }\n            }\n        }\n    }];  另外，groupby可以结合计算函数来使用，比如我想统计每个玩家的总分，可以使用以下代码：      BmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n    NSArray *groupbyArray = [NSArray arrayWithObject:@ playerName ];\n    NSArray *sumArray = [NSArray arrayWithObject:@ score ];\n    [bquery groupbyKeys:groupbyArray];\n    [bquery sumKeys:sumArray];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ error is:%@ ,error);\n        } else{\n            if (array) {\n                NSLog(@ %@ ,array);\n                for (NSDictionary *dic in array) {\n                    NSString *playerName = [dic objectForKey:@ playerName ];\n                    NSString *sum = [dic objectForKey:@ _sumScore ];\n                    NSLog(@ player:%@\\tsum:%@ ,playerName,sum);\n                }\n            }\n        }\n    }];", 
            "title": "分组统计"
        }, 
        {
            "location": "/data/ios/develop_doc/#_31", 
            "text": "有时候，我们还想知道分组统计时每个分组有多少条记录，设置isGroupcount为YES即可,如下：      bquery.isGroupcount = YES;  这样在返回的结果中就会包含类似于以下的键值对：  _count = 10", 
            "title": "分组记录数"
        }, 
        {
            "location": "/data/ios/develop_doc/#_32", 
            "text": "利用计算方法返回来的值可以通过限制条件来获取我们想关注的结果。添加条件使用以下方法。   -(void)constructHavingDic:(NSDictionary *)havingDic  该方法通过构造havingDic来添加限制条件，其使用方法与复杂查询类似。  例如，我们统计每个玩家的总分，但我们只需要得到总分大于50的玩家，可以使用以下代码得到：      BmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n    NSArray *groupbyArray = [NSArray arrayWithObject:@ playerName ];\n    [bquery groupbyKeys:groupbyArray];\n    NSArray *sumArray = [NSArray arrayWithObject:@ score ];\n    [bquery sumKeys:sumArray];\n    NSDictionary *condication = [[NSDictionary alloc] initWithObjectsAndKeys:[NSNumber numberWithInt:50],@ $gt , nil];\n    [bquery constructHavingDic:[[NSDictionary alloc] initWithObjectsAndKeys:condication,@ _sumScore , nil]];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ error is:%@ ,error);\n        } else{\n            if (array) {\n                NSLog(@ %@ ,array);\n                for (NSDictionary *dic in array) {\n                    NSString *playerName = [dic objectForKey:@ playerName ];\n                    NSString *sum = [dic objectForKey:@ _sumScore ];\n                    NSLog(@ player:%@\\tsum:%@ ,playerName,sum);\n                }\n            }\n        }\n    }];", 
            "title": "添加过滤条件"
        }, 
        {
            "location": "/data/ios/develop_doc/#_33", 
            "text": "缓存查询通常是将查询结果缓存在磁盘上，当用户的设备处于离线状态时，就可以从缓存中获取数据来显示。或者在应用界面刚刚启动，从网络获取数据还未得到结果时，先使用缓存数据来显示。这样可以让用户不必在按下某个按钮后进行枯燥的等待。 默认的查询操作是没有启用缓存的，开发者可以通过设置BmobCachePolicy来启用缓存功能。例如：优先从网络获取数据，如果获取失败时再从缓存获取数据，这种情况通常用在网络不可用的情况下。  bquery.cachePolicy = kBmobCachePolicyNetworkElseCache;\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array,NSError *error){\n}];  BmobSDK提供几种不同的缓存策略，以使用不同应用场景的需求。   kBmobCachePolicyIgnoreCache   只从网络获取数据，且数据不会缓存在本地，这是默认的缓存策略。   kBmobCachePolicyCacheOnly   只从缓存读数据，如果缓存没有数据，返回一个空数组。   kBmobCachePolicyNetworkOnly   只从网络获取数据，同时会在本地缓存数据。   kBmobCachePolicyCacheElseNetwork   先从缓存读取数据，如果没有再从网络获取。   kBmobCachePolicyNetworkElseCache   先从网络获取数据，如果没有，再从缓存读取。   kBmobCachePolicyCacheThenNetwork   先从缓存读取数据，无论结果如何都会再次从网络获取数据，在这种情况下，Block将产生两次调用。通常这种做法是先快速从缓存读取数据显示在界面，然后在后台连接网络获取最新数据，取到后再更新界面。  |检查是否存在当前查询条件的缓存数据  [bquery hasCachedResult];  存在返回YES，否则返回NO\n|清除当前查询的缓存数据  [bquery clearCachedResult];  |清除所有查询结果的缓存数据  [BmobQuery clearAllCachedResults];  |设置缓存有限时间，单位为秒  bquery.maxCacheAge = 10000;", 
            "title": "缓存查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#bql", 
            "text": "Bmob Query Language （简称 BQL）是 Bmob 自  BmobSDK V1.5.7  版本开始，为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 Bmob 查询 API 的成本，可以使用传统的 SQL 语法来查询 Bmob 应用内的数据。  具体的 BQL 语法，请参考  Bmob Query Language 详细指南 。", 
            "title": "BQL查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#bql_1", 
            "text": "可以通过以下方法来进行SQL查询：  例如：需要查询所有的游戏得分记录      BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    NSString *bql = @ select * from GameScore_BQL ;\n    [bmobQuery queryInBackgroundWithBQL:bql block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            if (result) {\n                NSLog(@ %@ ,result.resultsAry);\n            }\n        }\n    }];  其中result.resultsAry为BmobObject数组。  如果需要查询个数，则可以这样：      NSString *bql = @ select count(*) from GameScore_BQL ;\n    BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    [bmobQuery queryInBackgroundWithBQL:bql block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            if (result) {\n                NSLog(@ %d ,result.count);\n            }\n        }\n    }];  其中result.count为记录条数，需要注意的是如果没有使用count关键字进行查询的话，对象result的count属性是没有意义的。", 
            "title": "基本BQL查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#bql_2", 
            "text": "由于统计查询的结果是不定的，故BQL提供了另外一种查询方法来进行统计查询，可以使用   - (void)statisticsInBackgroundWithBQL:(NSString *)bql block:(BmobBQLArrayResultBlock)block;  方法来进行。       NSString *bql = @ select sum(score) from GameScore_BQL group by playerName ;\n    [bmobQuery statisticsInBackgroundWithBQL:bql block:^(NSArray *result, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            if (result) {\n                NSLog(@ %@ ,result);\n            }\n        }\n    }];  目前统计查询支持的关键字如下表所示，即如果在sql语句中包含以下关键字时，则需要使用统计查询方法才能返回正确结果：     key  Operation      group by  分组操作    groupcount  返回每个分组的总记录    having  分组中的过滤条件    sum  计算总和    average  计算平均值    max  计算最大值    min  计算最小值", 
            "title": "统计BQL查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#_34", 
            "text": "在更多的时候，一个查询语句中间会有很多的值是可变值，为此，我们也提供了类似 Java JDBC 里的  PreparedStatement  使用占位符查询的语法结构。  注：目前只有where和limit关键字以及内置函数支持使用占位符。", 
            "title": "占位符查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#_35", 
            "text": "BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    NSString *bql = @ select * from GameScore_BQL where playerName = ? and score = ? ;\n    NSArray *placeholderArray = @[@ name2 ,@9];\n    [bmobQuery queryInBackgroundWithBQL:bql pvalues:placeholderArray block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            if (result) {\n                NSLog(@ %@ ,result.resultsAry);\n            }\n        }\n    }];  数组中的数据会依次替换bql中的问号。", 
            "title": "普通查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#_36", 
            "text": "对于包含 内置函数 的占位符查询，比较特殊，请使用 Bmob Query Language 详细指南 中的 内置函数 中 占位符查询用到的内置函数 用到的内置函数列出的形式进行查询操作：  举例：我想查询在 '2015-05-14 14:56:30' 后的创建的记录，可以这样：      BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    NSString *bql = @ select * from GameScore_BQL where createdAt   date(?) ;\n    NSArray *placeholderArray = @[@ 2015-05-14 14:56:30 ];\n    [bmobQuery queryInBackgroundWithBQL:bql pvalues:placeholderArray block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            if (result) {\n                NSLog(@ %@ ,result.resultsAry);\n            }\n        }\n    }];  注  1、我们更推荐使用占位符语法，理论上会降低 BQL 转换的性能开销；  2、同样的，统计查询也支持占位符,只需要 - (void)statisticsInBackgroundWithBQL:(NSString *)bql pvalues:(NSArray*)pvalues block:(BmobBQLArrayResultBlock)block; 方法即可。", 
            "title": "内置函数"
        }, 
        {
            "location": "/data/ios/develop_doc/#bql_3", 
            "text": "如果要使用缓存策略，可用  - (void)queryBQLCanCacheInBackgroundWithblock:(BmobBQLObjectResultBlock)block;  方法，样例代码如下：      NSString *bql = [NSString stringWithFormat:@ select * from %@ where %@ = ? ,TABLENAME,COLPLAYERNAME];\n    NSArray *placeholder = @[@ name1 ];\n\n    BmobQuery *bmobQueryWriteCache = [[BmobQuery alloc] init];\n    bmobQueryWriteCache.cachePolicy = kBmobCachePolicyNetworkOnly;\n    [bmobQueryWriteCache setBQL:bql];\n    [bmobQueryWriteCache setPlaceholder:placeholder];\n    [bmobQueryWriteCache queryBQLCanCacheInBackgroundWithblock:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else if (result){\n            NSLog(@ actual:%@ ,result);\n        }\n    }];  注意：   BQL查询方法中，只有  - (void)queryBQLCanCacheInBackgroundWithblock:(BmobBQLObjectResultBlock)block;  才能使用缓存策略，其它方法即使设置了缓存策略也无缓存效果；  使用 - (void)queryBQLCanCacheInBackgroundWithblock:(BmobBQLObjectResultBlock)block; 进行查询时，通过  -(void)setBQL:(NSString*)bql;  和  -(void)setPlaceholder:(NSArray*)ary;  来设置BQL语句和占位符。   缓存策略只对普通查询有效，统计查询只支持从网络进行查询。具体使用可参考iOS开发文档中的 查询 缓存查询小节。", 
            "title": "BQL缓存策略"
        }, 
        {
            "location": "/data/ios/develop_doc/#_37", 
            "text": "为了存储数组型数据， Bmob 提供了3种操作来原子性地更改一个数组字段:  Add  在一个数组字段的后面添加一些指定的对象(包装在一个数组内)  AddUnique  只会在原本数组字段中没有这些对象的情形下才会添加入数组，插入数组的位置不固定的  Remove  从一个数组字段的值内移除指定的数组中的所有对象", 
            "title": "数组"
        }, 
        {
            "location": "/data/ios/develop_doc/#_38", 
            "text": "添加一行记录时创建一个普通的类似于列表的数组类型字段，可以使用以下方法添加：  BmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@ GameScore  objectId:@ xxxxxxxx ];\n[gameScore addObjectsFromArray:@[@ P1 ,@ P2 ] forKey:@ skill ];\n[gameScore updateInBackground];", 
            "title": "添加数组数据"
        }, 
        {
            "location": "/data/ios/develop_doc/#_39", 
            "text": "当需要移除数组里的数据时可以使用  -(void)removeObjectsInArray:(NSArray *)objects forKey:(NSString *)key;  如下面就移除了P3这个元素:  BmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@ GameScore  objectId:@ xxxxxxxx ];\n[gameScore removeObjectsInArray:@[@ P3 ] forKey:@ skill ];\n[gameScore updateInBackground];", 
            "title": "删除数组数据"
        }, 
        {
            "location": "/data/ios/develop_doc/#_40", 
            "text": "每一种方法都会有一个objects，即包含了这些方法将被添加或删除的对象列表，举个例子，技能skills是一个类似于集合的数组类型，那么我们可以在skills中加入一些对象，只有在skills原来的对象中不包含这些值的情况下才会被加入:  BmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@ GameScore  objectId:@ xxxxxxxx ];\n[gameScore addUniqueObjectsFromArray:@[@ P3 ] forKey:@ skill ];\n[gameScore updateInBackground];", 
            "title": "更新数组数据"
        }, 
        {
            "location": "/data/ios/develop_doc/#_41", 
            "text": "对于Key的类型是数组的情况，可以查找Key的数组值中包含有P1的对象。代码如下：      //查询数组中包含某个元素的记录\n    BmobQuery *query = [BmobQuery queryWithClassName:@ GameScore ];\n    [query whereKey:@ skill  equalTo:@ P1 ];\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            for (BmobObject *obj in array) {\n                NSLog(@ %@ ,obj);\n            }\n        }\n    }];  你同样可以使用\"$all\"操作符来找到类型为数组的Key的值中同时包含有P1和P2的对象:      //查询数组中包含某些元素的记录\n    BmobQuery *query1 = [BmobQuery queryWithClassName:@ GameScore\n     ];\n    NSArray *array = @[@ P1 ,@ P2 ];\n    [query1 whereKey:@ skill  equalTo:@{@ $all :array}];\n    [query1 findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            for (BmobObject *obj in array) {\n                NSLog(@ %@ ,obj);\n            }\n        }\n    }];  当然，你也可以使用我们封装好的方法来查找      //查询数组中包含某些元素的记录\n    BmobQuery *query1 = [BmobQuery queryWithClassName:@ GameScore ];\n    NSArray *array = @[@ P1 ,@ P2 ];\n    [query1 whereKey:@ skill  containsAll:array];\n    [query1 findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            for (BmobObject *obj in array) {\n                NSLog(@ %@ ,obj);\n            }\n        }\n    }];  如果要查找包含P1或P2的对象，可以使用复杂查询中的或查      BmobQuery *query = [BmobQuery queryWithClassName:@ Post ];\n    NSArray *array =  @[@{@ skill :@{@ $all : @[@ P1 ]}},@{@ skill :@{@ $all :@[@ P2 ]}}];\n    [query addTheConstraintByOrOperationWithArray:array];\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            NSLog(@ %d ,array.count);\n            for (BmobObject *obj in array) {\n                 NSLog(@ %@ ,obj);\n            }\n\n        }\n    }];", 
            "title": "查询数组数据"
        }, 
        {
            "location": "/data/ios/develop_doc/#key", 
            "text": "比如你当前行有一列叫用户的工作经验projectExperiences，是一个Array数组列，里面包含了多个对象值：[{\"name\":\"项目名称\",\"descr\":\"项目描述\"，\"startTime\":\"开始时间\"，\"endTime\":\"结束时间\"}, ...]  那么我们要修改projectExperiences数组中第一个对象的name值：  BmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@ GameScore  objectId:@ xxxxxxxx ];\n[bmobObject setObject:@ 项目名称2  forKey:@ projectExperiences.0.name ];\n[gameScore updateInBackground];", 
            "title": "使用索引和对象key修改数组中的对象"
        }, 
        {
            "location": "/data/ios/develop_doc/#_42", 
            "text": "数据关联章节Demo下载", 
            "title": "数据关联"
        }, 
        {
            "location": "/data/ios/develop_doc/#_43", 
            "text": "在程序设计中，不同类型的数据之间可能存在某种关系。分别是以下三种：\n1. 一对一，比如车队给司机分车，1个司机对应1台车；\n2. 一对多，比如1个作者会对应多篇贴子；\n3. 多对多，比如1篇帖子会有多个喜欢的读者，而每个读者也会有多篇喜欢的帖子。\n前面的两种关系我们提供Pointer类型来表示，而最后一种关系我们使用Relation类型来表示  在下面的讲解中我们可能会使用到以下的两张表，其表结构如下：  _User     字段  类型  含义      objectId  string     username  string  用户名，用户可以是作者发帖子，也可以是读者发评论     Post     字段  类型  含义      objectId  string     title  string  帖子标题    content  string  帖子内容    author  Pointer(_User)  作者    likes  Relation(_User)  喜欢帖子的读者     预先在后台添加记录\n_User表   Post表", 
            "title": "关联关系描述"
        }, 
        {
            "location": "/data/ios/develop_doc/#pointer", 
            "text": "", 
            "title": "Pointer的使用"
        }, 
        {
            "location": "/data/ios/develop_doc/#_44", 
            "text": "例如，user1写了一篇帖子，需要在Post表中添加一条记录，并且该记录包含一个关联author1记录的字段数据，可采用以下代码：      BmobObject  *post = [BmobObject objectWithClassName:@ Post ];\n    //设置帖子的标题和内容\n    [post setObject:@ title4  forKey:@ title ];\n    [post setObject:@ content4  forKey:@ content ];\n\n    //设置帖子关联的作者记录\n    BmobUser *author = [BmobUser objectWithoutDataWithClassName:@ _User  objectId:@ vbhGAAAY ];\n    [post setObject:author forKey:@ author ];\n\n    //异步保存\n    [post saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功，返回objectId，updatedAt，createdAt等信息\n            //打印objectId\n            NSLog(@ objectid :%@ ,post.objectId);\n        }else{\n            if (error) {\n                NSLog(@ %@ ,error);\n            }\n        }\n    }];  添加成功后在后台的结果如下图所示，我们可以看到，author列的值是用圆框框起来的，表示这是一个Pointer，显示的值，为对应记录的objectId,点击它可以进入_User表中：   我们可以这么理解关联关系，它就是一个类型为指针的字段，利用它可以指向其它表的某条记录。", 
            "title": "添加关系"
        }, 
        {
            "location": "/data/ios/develop_doc/#_45", 
            "text": "如果需要删除某篇帖子关联的作者可以使用  - (void)deleteForKey:(id)key  具体代码如下：      BmobQuery   *bquery = [BmobQuery queryWithClassName:@ Post ];\n    [bquery getObjectInBackgroundWithId:@ ZqQ7KKKx  block:^(BmobObject *object,NSError *error){\n        if (error){\n            NSLog(@ %@ ,error);\n        }else{\n            if (object) {\n                BmobObject *post = object;\n                //将author列的值置为空\n                [post deleteForKey:@ author ];\n                //进行更新\n                [post updateInBackground];\n            }\n        }\n    }];  结果如下，可以看到，author列已经被置空", 
            "title": "删除关系"
        }, 
        {
            "location": "/data/ios/develop_doc/#_46", 
            "text": "如果需要修改某篇帖子关联的作者，可以使用以下代码:      BmobQuery   *bquery = [BmobQuery queryWithClassName:@ Post ];\n    //获得objectId查找出先前添加的文章\n    [bquery getObjectInBackgroundWithId:@ ZqQ7KKKx  block:^(BmobObject *object,NSError *error){\n        if (error){\n            NSLog(@ %@ ,error);\n        }else if (object) {\n            BmobObject *post = object;\n            //获得BmobUser对象\n            BmobUser *user = [BmobUser objectWithoutDataWithClassName:@ _User  objectId:@ qXZeCCCX ];\n            //设置post的author值为新获得的BmobUser对象\n            [post setObject:user forKey:@ author ];\n\n            //进行更新\n            [post updateInBackground];\n        }\n    }];  可以看到关联记录已经被修改：", 
            "title": "修改关系"
        }, 
        {
            "location": "/data/ios/develop_doc/#_47", 
            "text": "查询某个特定作者的帖子，可以用  -(void)whereKey:(NSString *)key equalTo:(id)object ,具体代码如下   //查询帖子表\n BmobQuery *query = [BmobQuery queryWithClassName:@ Post ];\n //构建objectId为vbhGAAAY 的作者\n BmobUser *author = [BmobUser objectWithoutDataWithClassName:@ _User  objectId:@ vbhGAAAY ];\n //添加作者是objectId为vbhGAAAY条件\n [query whereKey:@ author  equalTo:author];\n [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else if (array){\n            for (BmobObject *post in array) {\n                NSLog(@ %@ ,[post objectForKey:@ title ]);\n            }\n        }\n    }];  如我们需要查询帖子，并且需要将该帖子关联的作者的信息（objectId,username）打印出来，我们可以使用以下代码：      BmobQuery *bquery = [BmobQuery queryWithClassName:@ Post ];\n\n    //声明该次查询需要将author关联对象信息一并查询出来\n    [bquery includeKey:@ author ];\n\n    [bquery getObjectInBackgroundWithId:@ ZqQ7KKKx  block:^(BmobObject *object, NSError *error) {\n\n        //打印文章标题，内容\n        BmobObject *post = object;\n        NSLog(@ title:%@ ,[post objectForKey:@ title ]);\n        NSLog(@ content:%@ ,[post objectForKey:@ content ]);\n\n        //取得文章的关联作者对象\n        BmobUser *author = [post objectForKey:@ author ];\n        //打印文章的关联作者对象的相关信息\n        NSLog(@ objectId:%@ ,author.objectId);\n        NSLog(@ name:%@ ,[author objectForKey:@ username ]);\n    }];  查询关系的核心在于查询前需要将关联的列名include进来，使用下列方法即可  - (void)includeKey:(NSString *)key  如果查询多个关联关系，可以使用以下方法，使用逗号(,)操作来使查询中包含多个属性  [bquery includeKey:@ column1,column2,... ];  如果关联关系存在嵌套，可以使用以下英文字符点号(.)来操作，如下：  [bquery includeKey:@ column1.column2 ];  另外，include 时可以指定返回的字段，如下：  //只返回likes列的数据\n[bquery includeKey:@ post[likes] ];\n\n//返回title和content列数据\n[bquery includeKey:@ post[title|content] ];", 
            "title": "查询关系"
        }, 
        {
            "location": "/data/ios/develop_doc/#_48", 
            "text": "我们可以对关联对象的值进行约束，来进行匹配查询。例如，如果我们想找查询出所有关联了user2的文章，可以使用以下代码      BmobQuery *bquery = [BmobQuery queryWithClassName:@ Post ];\n\n    //构造约束条件\n    BmobQuery *inQuery = [BmobQuery queryWithClassName:@ _User ];\n    [inQuery whereKey:@ username  equalTo:@ user2 ];\n\n    //匹配查询\n    [bquery whereKey:@ author  matchesQuery:inQuery];\n    [bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else if (array){\n            for (BmobObject *post in array) {\n                NSLog(@ %@ ,[post objectForKey:@ title ]);\n            }\n        }\n    }];  如果想要查询找所有没有关联user1的文章，则将  [bquery whereKey:@ author  matchesQuery:inQuery];  替换成  [bquery whereKey:@ author  doesNotMatchQuery:inQuery];  即可。", 
            "title": "约束关联对象值查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#pointer_1", 
            "text": "Pointer可以用来表示一对一或者一对多的关系，其实可以看成是我们将一个指向某条记录的指针记录下来，我们查询时可以通过该指针以获得另外关联的对象。当然，我们也可以给这些指针指向的关联记录进行约束，只查询出符合特定条件的记录。", 
            "title": "Pointer本质"
        }, 
        {
            "location": "/data/ios/develop_doc/#relation", 
            "text": "", 
            "title": "Relation的使用"
        }, 
        {
            "location": "/data/ios/develop_doc/#_49", 
            "text": "如果我们需要在Post表中添加一个字段以记录喜欢该贴子的读者，我们可以使用以下代码：      //获取要添加关联关系的post\n    BmobObject *post = [BmobObject objectWithoutDataWithClassName:@ Post  objectId:@ ZqQ7KKKx ];\n\n    //新建relation对象\n    BmobRelation *relation = [[BmobRelation alloc] init];\n    [relation addObject:[BmobObject objectWithoutDataWithClassName:@ _User  objectId:@ vbhGAAAY ]];\n    [relation addObject:[BmobObject objectWithoutDataWithClassName:@ _User  objectId:@ qXZeCCCX ]];\n\n    //添加关联关系到likes列中\n    [post addRelation:relation forKey:@ likes ];\n    //异步更新obj的数据\n    [post updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@ successful );\n        }else{\n            NSLog(@ error %@ ,[error description]);\n        }\n    }];  可以看到添加了一个  likes  列，点击进去可以查看到该列里面存在哪些数据。  Post表：   从Post表中的title4记录点击关联关系框进去后查看的结果：", 
            "title": "添加关联关系"
        }, 
        {
            "location": "/data/ios/develop_doc/#_50", 
            "text": "如果要从刚刚的添加的likes列中删去其中一个读者，可采用以下代码。      BmobObject *post = [BmobObject objectWithoutDataWithClassName:@ Post  objectId:@ ZqQ7KKKx ];\n\n    //新建relation对象\n    BmobRelation *relation = [[BmobRelation alloc] init];\n    [relation removeObject:[BmobObject objectWithoutDataWithClassName:@ _User  objectId:@ vbhGAAAY ]];\n\n    //添加关联关系到likes列中\n    [post addRelation:relation forKey:@ likes ];\n\n    //异步更新obj的数据\n    [post updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@ successful );\n        }else{\n            NSLog(@ error %@ ,[error description]);\n        }\n    }];  从Author表中的author1记录点击关联关系框进去后查看的结果：", 
            "title": "删除关联关系"
        }, 
        {
            "location": "/data/ios/develop_doc/#_51", 
            "text": "如果需要给objectId为ZqQ7KKKx的帖子添加多一个喜欢该帖子的读者可以使用以下代码      BmobObject *author = [BmobObject objectWithoutDataWithClassName:@ Post  objectId:@ ZqQ7KKKx ];\n\n    //新建relation对象\n    BmobRelation *relation = [[BmobRelation alloc] init];\n    [relation addObject:[BmobObject objectWithoutDataWithClassName:@ _User  objectId:@ J6RU888L ]];\n    //添加关联关系到postlist列中\n    [author addRelation:relation forKey:@ likes ];\n\n    //异步更新obj的数据\n    [author updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@ successful );\n        }else{\n            NSLog(@ error %@ ,[error description]);\n        }\n    }];  运行代码后，从Author表中的author1记录点击关联关系框进去后查看的结果：", 
            "title": "修改关联关系"
        }, 
        {
            "location": "/data/ios/develop_doc/#_52", 
            "text": "如果我们需要查询喜欢objectId为ZqQ7KKKx的帖子的所有读者，可以采用下列代码：      //关联对象表\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@ _User ];\n\n    //需要查询的列\n    BmobObject *post = [BmobObject objectWithoutDataWithClassName:@ Post  objectId:@ ZqQ7KKKx ];\n    [bquery whereObjectKey:@ likes  relatedTo:post];\n\n\n    [bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            for (BmobObject *user in array) {\n                NSLog(@ %@ ,[user objectForKey:@ username ]);\n            }\n        }\n    }];  注意：跟Pointer不同的是，这里本质上查询的是_User表。", 
            "title": "查询关联关系"
        }, 
        {
            "location": "/data/ios/develop_doc/#relation_1", 
            "text": "上面的查询是查找喜欢某篇帖子的所有读者，如果反过来，需要查找某个读者喜欢的所有帖子又要怎么做呢？可以参考以下代码：      BmobQuery *bquery = [BmobQuery queryWithClassName:@ Post ];\n\n    //构造约束条件\n    BmobQuery *inQuery = [BmobQuery queryWithClassName:@ _User ];\n    [inQuery whereKey:@ username  equalTo:@ user3 ];\n\n    //匹配查询\n    [bquery whereKey:@ likes  matchesQuery:inQuery];\n    [bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else if (array){\n            for (BmobObject *post in array) {\n                NSLog(@ %@ ,[post objectForKey:@ title ]);\n            }\n        }\n    }];", 
            "title": "Relation约束关联对象值查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#relation_2", 
            "text": "Relation可以理解为其存储的是一个对象，而这个对象中存储的是多个指向其它记录的指针。", 
            "title": "Relation的本质"
        }, 
        {
            "location": "/data/ios/develop_doc/#_53", 
            "text": "", 
            "title": "用户管理"
        }, 
        {
            "location": "/data/ios/develop_doc/#_54", 
            "text": "BmobUser除了从BmobObject继承的属性外，还有几个特定的属性：   username: 用户的用户名（必需）。  password: 用户的密码（必需）。  email: 用户的电子邮件地址（可选）。   BmobUser自动处理用户账户管理所需的功能。  -(void)setUsername:(NSString *)username;//用户名，必需\n-(void)setPassword:(NSString*)password;//密码，必需\n-(void)setEmail:(NSString *)email;//设置邮箱\n-(void)setObject:(id)obj forKey:(id)key;//设置某个属性的值\n-(id)objectForKey:(id)key;//得到某个属性的值", 
            "title": "属性"
        }, 
        {
            "location": "/data/ios/develop_doc/#_55", 
            "text": "应用很常见的一个功能就是，注册用户，使用BmobUser注册用户也不复杂，如下的例子所示  BmobUser *bUser = [[BmobUser alloc] init];\n[bUser setUsername:@ 小明 ];\n[bUser setPassword:@ 123456 ];\n[bUser setObject:@18 forKey:@ age ];\n[bUser signUpInBackgroundWithBlock:^ (BOOL isSuccessful, NSError *error){\n    if (isSuccessful){\n        NSLog(@ Sign up successfully );\n    } else {\n        NSLog(@ %@ ,error);\n    }\n}];  需要有两点需要注意的是：   有些时候你可能需要在用户注册时发送一封邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在应用设置- 邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在用户注册时自动发动一封验证给用户。     username字段是大小写敏感的字段，如果你希望应用的用户名不区分大小写，请在注册和登录时进行大小写的统一转换。", 
            "title": "注册"
        }, 
        {
            "location": "/data/ios/develop_doc/#_56", 
            "text": "当用户注册成功后，需要让他们以后能够登录到他们的账户使用应用。要做到这点可以使用  [BmobUser loginWithUsernameInBackground:@ 小明 \n    password:@ 123456 ];  也可以使用  + (void)loginWithUsernameInBackground:(NSString *)username\n                              password:(NSString *)password\n                                 block:(BmobUserResultBlock)block;  Bmob还提供了用户、email、手机号码均可作为账号进行登录的功能。使用以下方法即可      [BmobUser loginInbackgroundWithAccount:account andPassword:password block:^(BmobUser *user, NSError *error) {\n        if (user) {\n            NSLog(@ %@ ,user);\n        } else {\n            NSLog(@ %@ ,error);\n        }\n    }];", 
            "title": "登录"
        }, 
        {
            "location": "/data/ios/develop_doc/#_57", 
            "text": "每次你登录成功，都会在本地磁盘中有一个缓存的用户对象作为当前用户，可以获取这个缓存的用户对象来进行登录：  BmobUser *bUser = [BmobUser getCurrentObject];\nif (bUser) {\n    //进行操作\n}else{\n    //对象为空时，可打开用户注册界面\n}  当然，你也可以用如下的方法清除缓存用户对象：  [BmobUser logout];  1.这个用户对象缓存了基本的数据，所以可以通过-(id)objectForKey:(id)key; 这个方法来得到某一列的值  2.[BmobUser getCurrentObject] 跟[BmobUser getCurrentUser]功能作用是一样的，因版本升级的原因才保留了[BmobUser getCurrentObject]  3.由于是缓存的数据，所以web端的修改，本地是不会更新的!!!需要重新登录才会更新本地缓存数据  4.缓存用户的有效期为1年", 
            "title": "获取当前用户"
        }, 
        {
            "location": "/data/ios/develop_doc/#_58", 
            "text": "当用户登录成功后，在本地有个缓存的用户对象，如果开发者希望更改当前用户的某个属性可按如下代码操作:  BmobUser *bUser = [BmobUser getCurrentUser];\n//更新number为30\n[bUser setObject:@30 forKey:@ number ];\n[bUser updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    NSLog(@ error %@ ,[error description]);\n}];  一般来说，使用当前用户对象来进行资料更新可能会遇到一个问题。如果当前用户上次登录的时间距离当前时间过长，存放在本地的Token就有可能会过期，导致用户更新资料失败，这是需要重新登录，登录成功后才能更新资料。  在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发动一封邮件验证信息给用户。", 
            "title": "更新用户"
        }, 
        {
            "location": "/data/ios/develop_doc/#_59", 
            "text": "查询用户和查询普通对象一样，只需指定BmobUser类即可，如下：      BmobQuery *query = [BmobUser query];\n    [query whereKey:@ username  equalTo:@ xiaolv ];\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobUser *user in array) {\n            NSLog(@ objectid %@ ,user.objectId);\n        }\n    }];  浏览器中查看用户表  User表是一个特殊的表，专门存储BmobUser对象。在浏览器端，你会看到一个User表旁边有一个小人的图标。", 
            "title": "查询用户"
        }, 
        {
            "location": "/data/ios/develop_doc/#_60", 
            "text": "从  v1.6.3  开始，我们提供使用旧密码来重置新密码的接口，示例如下：      BmobUser *user = [BmobUser getCurrentUser];\n    [user updateCurrentUserPasswordWithOldPassword:@ old password  newPassword:@ new password  block:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //用新密码登录\n            [BmobUser loginInbackgroundWithAccount:@ name  andPassword:@ new password  block:^(BmobUser *user, NSError *error) {\n                if (error) {\n                    NSLog(@ login error:%@ ,error);\n                } else {\n                    NSLog(@ user:%@ ,user);\n                }\n            }];\n        } else {\n            NSLog(@ change password error:%@ ,error);\n        }\n    }];", 
            "title": "修改密码"
        }, 
        {
            "location": "/data/ios/develop_doc/#_61", 
            "text": "为方便大家了解如何用Bmob开发找回密码的功能，我们为大家准备了另外一份文档，详细见我们在Github中的文档：  https://github.com/bmob/bmob-cloudcode-demo/blob/master/HOW-TO-FIND-PASSWORD.md", 
            "title": "找回密码"
        }, 
        {
            "location": "/data/ios/develop_doc/#_62", 
            "text": "", 
            "title": "邮箱"
        }, 
        {
            "location": "/data/ios/develop_doc/#_63", 
            "text": "设置邮件验证是可选的一个应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会默认被设为false，如果应用设置中开启了邮箱认证功能，Bmob会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.  BmobUser *user = [BmobUser getCurrentUser];\n//应用开启了邮箱验证功能\nif ([user objectForKey:@ emailVerified ]) {\n    //用户没验证过邮箱\n    if (![[user objectForKey:@ emailVerified ] boolValue]) {\n        [user verifyEmailInBackgroundWithEmailAddress:@ xxxxxxxxxx ];\n    }\n}", 
            "title": "邮箱验证"
        }, 
        {
            "location": "/data/ios/develop_doc/#_64", 
            "text": "一旦你引入了一个密码系统，那么肯定会有用户忘记密码的情况。对于这种情况，我们提供了一种方法，让用户安全地重置起密码。  重置密码的流程很简单，开发者只需要求用户输入注册的电子邮件地址即可：  [BmobUser requestPasswordResetInBackgroundWithEmail:@ xxxx@qq.com ];  密码重置流程如下：   用户输入他们的电子邮件，请求重置自己的密码。  Bmob向他们的邮箱发送一封包含特殊的密码重置连接的电子邮件。  用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，根据提示，他们可以输入一个新的密码。  用户的密码已被重置为新输入的密码。", 
            "title": "邮箱修改密码"
        }, 
        {
            "location": "/data/ios/develop_doc/#_65", 
            "text": "Bmob提供了非常简单的方法来实现使用第三方账号登陆的功能，目前支持新浪微博、手机QQ账号以及微信账号的登陆。以下是我们提供的一个demo ThirdPartyLogin", 
            "title": "第三方账号登录"
        }, 
        {
            "location": "/data/ios/develop_doc/#_66", 
            "text": "在 新浪微博开放平台 注册应用，然后根据 新浪微博 iOS SDK使用说明 安装SDK以及获取，开发者通过新浪微博提供的SDK得到用户的信息后，就可以调用BmobUser提供的方法来注册登录到应用。  //得到的新浪微博授权信息，请按照例子来生成NSDictionary\nNSDictionary *dic = @{@ access_token :token,@ uid :uid,@ expirationDate :date};\n//通过授权信息注册登录\n[BmobUser loginInBackgroundWithAuthorDictionary:dic\n                                      platform:BmobSNSPlatformSinaWeibo\n                                         block:^(BmobUser *user, NSError *error) {\n                                             NSLog(@ user objectid is :%@ ,user.objectId);\n                                         }];", 
            "title": "新浪微博账号注册登录"
        }, 
        {
            "location": "/data/ios/develop_doc/#qq", 
            "text": "同样的，开发者通过QQ授权得到用户的信息后，同样可以调用BmobUser提供的方法来注册登录到应用。下面的例子是通过QQ提供的SDK授权得到的信息，进行登录的：  //得到的qq授权信息，请按照例子来生成NSDictionary\n NSDictionary *responseDictionary = @{@ access_token : _tencentOauth.accessToken,@ uid :_tencentOauth.openId,@ expirationDate :_tencentOauth.expirationDate};\n //通过授权信息注册登录\n[BmobUser loginInBackgroundWithAuthorDictionary:responseDictionary\n                                       platform:BmobSNSPlatformQQ\n                                          block:^(BmobUser *user, NSError *error) {\n                                            NSLog(@ error%@ ,[error description]);\n                                            }];", 
            "title": "手机QQ账号登录"
        }, 
        {
            "location": "/data/ios/develop_doc/#_67", 
            "text": "NSDictionary *responseDictionary = @{@ access_token : accessToken,@ uid :openId,@ expirationDate :expirationDate};\n[BmobUser loginInBackgroundWithAuthorDictionary:responseDictionary\n                                       platform:BmobSNSPlatformWeiXin\n                                          block:^(BmobUser *user, NSError *error) {\n                                            NSLog(@ error%@ ,[error description]);\n                                            }];", 
            "title": "微信账号登录"
        }, 
        {
            "location": "/data/ios/develop_doc/#bmobuser", 
            "text": "如果你的应用中有其他功能已经使用到了相关第三方平台的功能，比如社交分享功能，那么你可以将已经得到的用户授权信息传递给BmobSDK来便捷地与BmobUser进行绑定。以下代码展示了将第三方账号和已经存在的BmobUser对象进行绑定：  //新浪微博账号关联到当前用户\nNSDictionary *dic = @{@ access_token :token,@ uid :uid,@ expirationDate :date};\nBmobUser *currentUser = [BmobUser getCurrentUser];\n[currentUser linkedInBackgroundWithAuthorDictionary:dic\n                                           platform:BmobSNSPlatformSinaWeibo\n                                              block:^(BOOL isSuccessful, NSError *error) {\n                                                     NSLog(@ ERROR :%@ ,[error description]);\n                                                 }];  //手机qq账号关联到当前用户\nNSDictionary *responseDictionary = @{@ access_token : _tencentOauth.accessToken,@ uid :_tencentOauth.openId,@ expirationDate :_tencentOauth.expirationDate};\nBmobUser *user = [BmobUser getCurrentUser];\n[user linkedInBackgroundWithAuthorDictionary:responseDictionary\n                                platform:BmobSNSPlatformQQ\n                                   block:^(BOOL isSuccessful, NSError *error) {\n                                       NSLog(@ error%@ ,[error description]);\n                                   }];  //微信账号关联到当前用户\nNSDictionary *responseDictionary = @{@ access_token : accessToken,@ uid :openId,@ expirationDate :expirationDate};\nBmobUser *user = [BmobUser getCurrentUser];\n[user linkedInBackgroundWithAuthorDictionary:responseDictionary\n                                platform:BmobSNSPlatformWeiXin\n                                   block:^(BOOL isSuccessful, NSError *error) {\n                                       NSLog(@ error%@ ,[error description]);\n                                   }];", 
            "title": "第三方账号与BmobUser绑定"
        }, 
        {
            "location": "/data/ios/develop_doc/#_68", 
            "text": "解除绑定的账号，也是很简单的。下面是例子：  //当前用户解除关联的微博账号\nBmobUser *user = [BmobUser getCurrentUser];\n[user cancelLinkedInBackgroundWithPlatform:BmobSNSPlatformSinaWeibo\n                                    block:^(BOOL isSuccessful, NSError *error) {\n                                        NSLog(@ error is :%@ ,[error description]);\n                                    }];  //当前用户解除关联的手机QQ账号\nBmobUser *user = [BmobUser getCurrentUser];\n[user cancelLinkedInBackgroundWithPlatform:BmobSNSPlatformQQ\n                                     block:^(BOOL isSuccessful, NSError *error) {\n                                         NSLog(@ error is :%@ ,[error description]);\n                                     }];                                                                            //当前用户取消关联微信账号\nNSDictionary *responseDictionary = @{@ access_token : accessToken,@ uid :openId,@ expirationDate :expirationDate};\nBmobUser *user = [BmobUser getCurrentUser];\n[user cancelLinkedInBackgroundWithAuthorDictionary:responseDictionary\n                                platform:BmobSNSPlatformWeiXin\n                                   block:^(BOOL isSuccessful, NSError *error) {\n                                       NSLog(@ error%@ ,[error description]);\n                                   }];", 
            "title": "解除绑定"
        }, 
        {
            "location": "/data/ios/develop_doc/#_69", 
            "text": "从  v1.5.8  开启Bmob加入了手机注册登录及密码重置等功能。以下介绍的功能可参考我们提供的 BmobSmsDemo （使用前请先在Appdelegate.m中填入你的app id）  注：以下的新功能如果需要填入验证码参数的，请先调用请求验证码方法。", 
            "title": "手机号相关功能"
        }, 
        {
            "location": "/data/ios/develop_doc/#_70", 
            "text": "可使用以下代码进行一键注册并登录的操作。在使用前必须先请求手机验证码，注册成功后将以当前的手机号码作为用户名，并且会缓存用户信息在本地，可使用  [BmobUser getCurrentUser]  获取。  [BmobUser signOrLoginInbackgroundWithMobilePhoneNumber:mobilePhoneNumber andSMSCode:smsCode block:^(BmobUser *user, NSError *error) {\n        if (user) {\n            NSLog(@ %@ ,user);\n        } else {\n            NSLog(@ %@ ,error);\n        }\n}];  如果希望在用手机注册时为用户添加密码或者其它信息，可以使用以下代码实现：      BmobUser *buser = [[BmobUser alloc] init];\n    buser.mobilePhoneNumber = @ 15123456789 ;\n    buser.password = @ 123 ;\n    buser.email = @ xxx@gmail.com ;\n    [buser signUpOrLoginInbackgroundWithSMSCode:@ 6位验证码  block:^(BOOL isSuccessful, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            BmobUser *user = [BmobUser getCurrentUser];\n            NSLog(@ %@ ,[BmobUser getCurrentUser]);\n        }\n    }];", 
            "title": "手机号注册"
        }, 
        {
            "location": "/data/ios/develop_doc/#_71", 
            "text": "Bmob除了提供手机号验证码一键注册登录功能外，还另外提供了希望只给已存在用户用手机号进行登录的功能。代码如下：  \n    [BmobUser loginInbackgroundWithMobilePhoneNumber:mobilePhoneNumber andSMSCode:smsCode block:^(BmobUser *user, NSError *error) {\n        if (user) {\n            NSLog(@ %@ ,user);\n        } else {\n            NSLog(@ %@ ,error);\n        }\n    }];", 
            "title": "手机号登录"
        }, 
        {
            "location": "/data/ios/develop_doc/#_72", 
            "text": "绑定手机号的基本思路为，先获取验证码，验证取得的验证码后再更新  mobilePhoneNumber  和  mobilePhoneNumberVerified  即可，这是我们推荐的做法。当然，你也可以不通过验证码，直接使用用户输入的手机号来更新  mobilePhoneNumber  来进行绑定，不过这种方法并不推荐。      //验证\n    [BmobSMS verifySMSCodeInBackgroundWithPhoneNumber:mobilePhoneNumber andSMSCode:smsCode resultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //修改绑定手机\n            BmobUser *buser = [BmobUser getCurrentUser];\n            buser.mobilePhoneNumber = mobilePhoneNumber;\n            [buser setObject:[NSNumber numberWithBool:YES] forKey:@ mobilePhoneNumberVerified ];\n            [buser updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@ %@ ,buser);\n                } else {\n                    NSLog(@ %@ ,error);\n                }\n            }];\n\n        } else {\n            NSLog(@ %@ ,error);\n        }\n    }];", 
            "title": "绑定手机号"
        }, 
        {
            "location": "/data/ios/develop_doc/#_73", 
            "text": "通过请求验证码和输入验证码从而进行账号密码重置，代码如下：      [BmobUser resetPasswordInbackgroundWithSMSCode:smsCode andNewPassword:newPassword block:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@ %@ ,@ 重置密码成功 );\n        } else {\n            NSLog(@ %@ ,error);\n        }\n    }];", 
            "title": "手机号修改密码"
        }, 
        {
            "location": "/data/ios/develop_doc/#_74", 
            "text": "很多时候BmobObject并不能满足用户的需求，用户可能需要继承BmobOject来定制自己的需求。但是当用户需要保存继承类的属性至后台时，还需要做一些额外的处理。因此，我们推出子类化BmobObject的选项，以让用户的代码具备更好的扩展性。", 
            "title": "子类化"
        }, 
        {
            "location": "/data/ios/develop_doc/#_75", 
            "text": "先来定义一个BmobObject的子类。  Test.h  \n@interface Test : BmobObject\n@property (copy, nonatomic) NSString *title;\n@property (copy, nonatomic) NSString *name;\n@property (strong, nonatomic) NSNumber *isStudent;\n@property (strong, nonatomic) NSNumber *age;\n@end  Test.m  \n@implementation Test\n\n@synthesize title;\n@synthesize name;\n@synthesize isStudent;\n@synthesize age;\n\n@end  后面你就可以像以下形式那样使用Test类了      Test *test = [[Test alloc] init];\n    test.title = @ title2 ;\n    test.name = @ name2 ;\n    test.isStudent = [NSNumber numberWithBool:NO];\n    test.age = @22;\n    [test sub_saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@ error %@ ,error);\n        NSLog(@ objectId %@ ,test.objectId);\n    }];  注意：\n1.当用到添加与更新操作时，要使用类似于sub_XXX的方法，而其它方法保持不变，与BmobObject一致。\n2.子类的方法使用对象类型，不要使用基本类型。例如，要使用整型时，可以声明为NSNumber。", 
            "title": "子类化的使用"
        }, 
        {
            "location": "/data/ios/develop_doc/#bmobuser_1", 
            "text": "如果要使用继承BmobUser的子类来进行登录，在构造其子类时，应用类似于以下的形式。   TestUser *user = [[TestUser alloc] initFromBmobObject:[BmobUser getCurrentUser]];\n    user.email = @ xxxaa@qq.com ;\n    [user sub_updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@ error %@ ,error.description);\n    }];  注意，此方法无法更新本地用户缓存，因此需要慎重考虑是是否子类化BmobUser。", 
            "title": "针对BmobUser的特别说明"
        }, 
        {
            "location": "/data/ios/develop_doc/#_76", 
            "text": "查询后需要使用以下方法以得到子类的对象。      BmobQuery *testQuery = [Test query];\n    [testQuery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobObject *obj in array) {\n            Test *t = [[Test alloc] initFromBmobObject:obj];\n\n        }\n    }];", 
            "title": "查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#_77", 
            "text": "文件管理章节Demo", 
            "title": "文件管理"
        }, 
        {
            "location": "/data/ios/develop_doc/#_78", 
            "text": "BmobFile可以让你的应用程序将文件存储到服务器中，比如常见的文件类型图像文件，影像文件、音乐文件和任何其他二进制数据都可以使用。当文件上传成功后，可以通过url属性来获取文件的地址。", 
            "title": "创建文件对象"
        }, 
        {
            "location": "/data/ios/develop_doc/#_79", 
            "text": "1.6.9版本之后，上传服务使用CDN服务", 
            "title": "上传文件"
        }, 
        {
            "location": "/data/ios/develop_doc/#_80", 
            "text": "如下图的例子，是将cs.txt的文本文件保存到服务器端：  -(void)saveInBackground:(BmobBooleanResultBlock)block;  可以在block里面把文件添加到gameScore里面，建议使用异步上传的方法，再在block进行操作。如下面的例子：  NSBundle    *bundle = [NSBundle mainBundle];\nNSString *fileString = [NSString stringWithFormat:@ %@/cs.txt  ,[bundle bundlePath] ];\nBmobObject *obj = [[BmobObject alloc] initWithClassName:@ GameScore ];\nBmobFile *file1 = [[BmobFile alloc] initWithFilePath:fileString];\n[file1 saveInBackground:^(BOOL isSuccessful, NSError *error) {\n     //如果文件保存成功，则把文件添加到filetype列\n     if (isSuccessful) {\n         [obj setObject:file1  forKey:@ filetype ];\n         //此处相当于新建一条记录,      //关联至已有的记录请使用 [obj updateInBackground];\n         [obj saveInBackground];\n         //打印file文件的url地址\n         NSLog(@ file1 url %@ ,file1.url);\n     }else{\n        //进行处理\n     }\n}];", 
            "title": "上传文件方法"
        }, 
        {
            "location": "/data/ios/develop_doc/#_81", 
            "text": "在上传文件时，有时会需要获取上传文件进度的需求。这时，可以使用  -(void)saveInBackground:(BmobBooleanResultBlock)block withProgressBlock:(BmobProgressBlock)progressBlock;  如在下面的例子中，打印上传的进度  NSBundle    *bundle = [NSBundle mainBundle];\nNSString *fileString = [NSString stringWithFormat:@ %@/cs.txt  ,[bundle bundlePath] ];\nBmobObject *obj = [[BmobObject alloc] initWithClassName:@ gameScoreFile ];\nBmobFile *file1 = [[BmobFile alloc] initWithClassName:@ Asc  withFilePath:fileString];\n[file1 saveInBackground:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        [obj setObject:file1  forKey:@ userFile ];\n        [obj saveInBackground];\n        NSLog(@ file1 url %@ ,file1.url);\n    }\n} withProgressBlock:^(CGFloat progress) {\n    NSLog(@ 上传进度%.2f ,progress);\n}];", 
            "title": "上传文件进度"
        }, 
        {
            "location": "/data/ios/develop_doc/#_82", 
            "text": "分片上传文件和上传整个文件的机制有所不同，是先把整个文件进行分片（256KB一片），然后再进行一片一片的上传（具体实现可查看 RestAPI文档 ）。当文件以分片的方式上传到Bmob服务器时，具有几种优势：    适合于尺寸较大的文件传输，通过切片来避免单个HTTP数据量过大而导致连接超时；    在网络条件较差的环境下，较小的尺寸可以有较高的上传成功率，从而避免无休止的失败重试；    在BmobSDK中对应的函数方法为  -(void)saveInBackgroundByDataSharding:(BmobBooleanResultBlock)block;  示例如下：  NSBundle    *bundle = [NSBundle mainBundle];\n//上传cs.txt文件\nNSString *fileString = [NSString stringWithFormat:@ %@/cs.txt  ,[bundle bundlePath] ];\nBmobObject *obj = [[BmobObject alloc] initWithClassName:@ gameScoreFile ];\n//创建BmobFile对象\nBmobFile *file1 = [[BmobFile alloc] initWithFilePath:fileString];\n[file1 saveInBackgroundByDataSharding:^(BOOL isSuccessful, NSError *error) {\n   if (isSuccessful) {\n        //如果成功，保存文件到userFile\n       [obj setObject:file1  forKey:@ userFile ];\n       [obj saveInBackground];\n   }else{\n       //失败，打印错误信息\n        NSLog(@ error: %@ ,[error description]);\n   }\n} ];", 
            "title": "以分片的方式上传文件"
        }, 
        {
            "location": "/data/ios/develop_doc/#_83", 
            "text": "有时，开发者需要一次性上传多个文件，这是可以使用SDK提供的多个上传文件的方法来使用  NSBundle    *bundle = [NSBundle mainBundle];\n//文件cncc.jpg的路径\nNSString *fileString = [NSString stringWithFormat:@ %@/cncc.jpg  ,[bundle bundlePath] ];\n//文件cs.txt的路径\nNSString *fileString2 = [NSString stringWithFormat:@ %@/cs.txt  ,[bundle bundlePath] ];\n[BmobFile filesUploadBatchWithPaths:@[fileString,fileString2]\n                      progressBlock:^(int index, float progress) {\n                           //index 上传数组的下标，progress当前文件的进度\n                          NSLog(@ index %d progress %f ,index,progress);\n                      } resultBlock:^(NSArray *array, BOOL isSuccessful, NSError *error) {\n                      //array 文件数组，isSuccessful 成功或者失败,error 错误信息\n                      BmobObject *obj = [[BmobObject alloc] initWithClassName:@ gameScoreFile ];\n                          for (int i = 0 ; i   array.count ;i ++) {\n                              BmobFile *file = array [i];\n                              NSString *key = [NSString stringWithFormat:@ userFile%d ,i];\n                              [obj setObject:file  forKey:key];\n                          }                          \n                          [obj saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) { \n                              }];\n                      }];", 
            "title": "批量上传文件"
        }, 
        {
            "location": "/data/ios/develop_doc/#_84", 
            "text": "获取文件对象只需通过-(id)objectForKey:(id)key;来得到，例如，  BmobFile *file = (BmobFile*)[gameScore objectForKey:@ filetype ];  可用通过file的url属性(file.url)，来得到文件的地址进行下载。", 
            "title": "下载文件"
        }, 
        {
            "location": "/data/ios/develop_doc/#_85", 
            "text": "删除文件接口只能删除1.6.9版本之后上传的文件  如果需要删除文件，使用以下接口即可  /**\n *  异步请求删除文件\n *\n *  @param block 返回删除结果与信息，如果删除成功，则无返回信息\n */\n-(void)deleteInBackground:(BmobBooleanResultBlock)block;  当开发者需要一次性删除多个文件的时候，可以调用批量删除文件的接口      NSArray *array = @[@ http://bmob-cdn-1.b0.upaiyun.com/jpg/579c8dc6676e460b82d83c8eb5c8aaa5.jpg ,@ http://bmob-cdn-1.b0.upaiyun.com/jpg/59e3817d6cec416ba99a126c9d42768f.jpg  ]\n\n    [BmobFile filesDeleteBatchWithArray:array resultBlock:^(NSArray *array, BOOL isSuccessful, NSError *error) {\n        NSLog(@ fail delete array %@ ,array);\n        NSLog(@ error %@ ,error.localizedDescription);\n        NSLog(@ issuccessful %i ,isSuccessful);\n    }];", 
            "title": "删除文件"
        }, 
        {
            "location": "/data/ios/develop_doc/#_86", 
            "text": "只需要在图片上传成功返回的url后面拼接特定参数即可实现缩放，加水印等效果， 如图 ， 具体可参考这里 。", 
            "title": "缩略图"
        }, 
        {
            "location": "/data/ios/develop_doc/#_87", 
            "text": "Bmob提供了数据实时功能，当开发者监听某个变化事件，例如监听表更新时，表的内容一旦变化，服务器就会通知SDK，SDK提供了相应回调函数来给开发者使用。当然开发者也可以取消相对应的监听，这样就不会收到数据变化的消息了。", 
            "title": "数据实时功能"
        }, 
        {
            "location": "/data/ios/develop_doc/#_88", 
            "text": "SDK提供了两个方法来监听数据变化，其中一个方法是针对表，另一个则针对行。  -(void)listenTableChange:(BmobActionType)actionType tableName:(NSString *)tableName;  这个函数可以监听到表更新（包括该表的行数据的变化）、表删除的行为。例如:  -(void)listen{\n    //创建BmobEvent对象\n    _bmobEvent          = [BmobEvent defaultBmobEvent];\n    //设置代理\n    _bmobEvent.delegate = self;\n    //启动连接\n    [_bmobEvent start];\n}  在代理的函数，进行操作  //可以进行监听或者取消监听事件\n-(void)bmobEventCanStartListen:(BmobEvent *)event{\n    //监听Post表更新\n    [_bmobEvent listenTableChange:BmobActionTypeUpdateTable tableName:@ Post ];\n}\n//接收到得数据\n-(void)bmobEvent:(BmobEvent *)event didReceiveMessage:(NSString *)message{\n    //打印数据\n    NSLog(@ didReceiveMessage:%@ ,message);\n}  相对的，也有监听行更新。行删除的函数：  -(void)listenRowChange:(BmobActionType)actionType tableName:(NSString *)tableName objectId:(NSString *)objectId;  当然了表删除，行更新，行删除等行为也可以在代理函数-(void)bmobEventCanStartListen:(BmobEvent *)event上进行监听。例如：  -(void)bmobEventCanStartListen:(BmobEvent *)event\n    //监听Test表删除事件，\n    [_bmobEvent listenTableChange:BmobActionTypeDeleteTable tableName:@ Test ];\n    //监听Post表中objectId为a1419df47a 的行更新事件\n    [_bmobEvent listenRowChange:BmobActionTypeUpdateRow tableName:@ Post  objectId:@ a1419df47a ];\n    //监听Post表中objectId为wb1o000F 的行删除事件\n    [_bmobEvent listenRowChange:BmobActionTypeDeleteRow tableName:@ Post  objectId:@ wb1o000F ];\n}  需要注意的是，监听事件后，接收到的数据是json格式的字符串，可以序列化为NSDictionary。", 
            "title": "监听功能"
        }, 
        {
            "location": "/data/ios/develop_doc/#_89", 
            "text": "当开发者想取消监听某个行为时，可以使用下面的函数  //取消订阅表的变化事件,包括表更新，表删除\n-(void)cancleListenTableChange:(BmobActionType)actionType tableName:(NSString *)tableName;  和  //取消订阅行的变化事件\n-(void)cancleListenRowChange:(BmobActionType)actionType tableName:(NSString *)tableName objectId:(NSString *)objectId;  这里有个 实例 可以参考下。", 
            "title": "取消监听功能"
        }, 
        {
            "location": "/data/ios/develop_doc/#acl", 
            "text": "大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：   对于私有数据，读写权限可以只局限于数据的所有者。  对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。  对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。  属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。  一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。\n用Bmob SDK，你可以对这些数据设置一个默认的ACL，这样，即使黑客反编译了你的应用，获取到Application Key，也仍然无法操作和破坏你的用户数据，确保了用户数据的安全可靠。而作为开发者，当你需要对这些数据进行管理时，可以通过超级权限Key（Master Key）进行。", 
            "title": "ACL和角色"
        }, 
        {
            "location": "/data/ios/develop_doc/#_90", 
            "text": "在没有显示指定的情况下，每一个BmobObject(表)中的ACL(列)属性的默认值是所有人可读可写的。在客户端想要修改这个权限设置，只需要简单简单调用BmobACL的setPublicReadAccess方法和setPublicWriteAccess方法，即：  BmobACL *acl = [BmobACL ACL];\n//设置所有人读权限为true\n[acl setPublicReadAccess];\n//设置所有人写权限为true\n[acl setPublicWriteAccess];  注意：可读可写是默认的权限，不需要写额外的代码。", 
            "title": "默认访问权限"
        }, 
        {
            "location": "/data/ios/develop_doc/#_91", 
            "text": "假如你想实现一个分享日志类的应用时，这可能会需要针对不同的日志设定不同的访问权限。比如，公开的日志，发布者有更改和修改的权限，其他用户只有读的权限，那么可用如下代码实现：  BmobObject *blog = [[BmobObject alloc] initWithClassName:@ blog ] ;\n[blog setObject:@ 论电影的七个元素  forKey:@ title ];\n[blog setObject:@ 这是blog的具体内容  forKey:@ content ];\nBmobACL *acl = [BmobACL ACL];\n[acl setPublicReadAccess];//设置所有人可读\n[acl setWriteAccessForUser:[BmobUser getCurrentUser]];//设置只有当前用户可写\nblog.ACL= acl;\n[blog saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];  有时，用户想发表一篇不公开的日志，这种情况只有发布者才对这篇日志拥有读写权限，相应的代码如下：  BmobObject *blog = [[BmobObject alloc] initWithClassName:@ blog ] ;\n[blog setObject:@ 一个人的秘密  forKey:@ title ];\n[blog setObject:@ 这是blog的具体内容  forKey:@ content ];\nBmobACL *acl = [BmobACL ACL];\n[acl setReadAccessForUser:[BmobUser getCurrentUser]];//设置只有当前用户可读\n[acl setWriteAccessForUser:[BmobUser getCurrentUser]];//设置只有当前用户可写\nblog.ACL= acl;\n[blog saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];", 
            "title": "指定用户的访问权限"
        }, 
        {
            "location": "/data/ios/develop_doc/#_92", 
            "text": "上面的指定用户访问权限虽然很方便，但是对于有些应用可能会有一定的局限性。比如一家公司的工资系统，员工和公司的出纳们只拥有工资的读权限，而公司的人事和老板才拥有全部的读写权限。要实现这种功能，你也可以通过设置每个用户的ACL权限来实现，如下：  //创建公司某用户的工资对象\nBmobObject *wageinfo  = [[BmobObject alloc] initWithClassName:@ wageinfo ];\n[wageinfo setObject:[NSNumber numberWithUnsignedInteger:100000] forKey:@ wage ];\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser *boss        = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\nBmobUser *hr_zhang    = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\nBmobUser *cashier_xie = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\nBmobUser *me          = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\n//创建ACL对象\nBmobACL *acl = [BmobACL ACL];\n//4个用户对象均可读\n[acl setReadAccessForUser:boss];\n[acl setReadAccessForUser:hr_zhang];\n[acl setReadAccessForUser:cashier_xie];\n[acl setReadAccessForUser:me];\n//设置boss跟hr_zhang 写的权限\n[acl setWriteAccessForUser:boss];\n[acl setWriteAccessForUser:hr_zhang];\nwageinfo.ACL= acl;\n[wageinfo saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];  但是，一个公司的人事、出纳和员工不仅仅只有一个人，同时还会有离职、调换岗位以及新员工加入等问题存在。如果用上面的代码对公司的每个人进行一一设置的话是不现实的，既麻烦也很难维护。针对这个问题，我们可以利用BmobRole来解决。我们只需要对用户进行分类，每个分类赋予不同的权限。如下代码实现：  //创建公司某用户的工资对象\nBmobObject *wageinfo  = [[BmobObject alloc] initWithClassName:@ wageinfo ];\n[wageinfo setObject:[NSNumber numberWithUnsignedInteger:100000] forKey:@ wage ];\n//这里创建5个用户对象，分别为老板、人事小张、人事小罗、出纳小谢和自己\nBmobUser *boss           = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\nBmobUser *hr_zhang       = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\nBmobUser *hr_luo         = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];;\nBmobUser *cashier_xie    = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\nBmobUser *me             = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\n//创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\nBmobRole *hr             = [BmobRole roleWithName:@ HR ];\nBmobRole *cashier        = [BmobRole roleWithName:@ Cashier ];\n//将hr_zhang和hr_luo归属到hr角色中\nBmobRelation *hrRelation = [BmobRelation relation];\n[hrRelation addObject:hr_zhang];\n[hrRelation addObject:hr_luo];\n[hr addUsersRelation:hrRelation];\n//保存到云端角色表中（web端可以查看Role表）\n[hr saveInBackground];\n//将cashier_xie归属到cashier角色中\nBmobRelation *cashierRelation = [BmobRelation relation];\n[cashierRelation addObject:cashier_xie];\n[cashier addUsersRelation:cashierRelation];\n//保存到云端角色表中（web端可以查看Role表）\n[cashier saveInBackground];\n//创建ACL对象\nBmobACL *acl = [BmobACL ACL];\n[acl setReadAccessForUser:boss];// 假设老板只有一个, 设置读权限\n[acl setReadAccessForUser:me];// 给自己设置读权限\n[acl setReadAccessForRole:hr];// 给hr角色设置读权限\n[acl setReadAccessForRole:cashier];// 给cashier角色设置读权限\n//设置boss跟hr_zhang 写的权限\n[acl setWriteAccessForUser:boss];// 设置老板拥有写权限\n[acl setWriteAccessForRole:hr];// 设置ht角色拥有写权限\nwageinfo.ACL= acl;\n[wageinfo saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];  需要说明一点的是，Web端的Role表也具有ACL的列，你可以将角色管理的权限赋予某些用户。", 
            "title": "角色管理"
        }, 
        {
            "location": "/data/ios/develop_doc/#_93", 
            "text": "下面我们来说一下角色与角色之间的从属关系。用一个例子来说明下：一个互联网企业有移动部门，部门中有不同的小组，如Android开发组和IOS开发组。每个小组只拥有自己小组的代码读写权限，但这两个小组同时拥有核心库代码的读权限。  //创建MobileDep（移动研发部）、AndroidTeam（android开发组）和iOSTeam（ios开发组）三个角色\nBmobRole *mobileDep =[BmobRole roleWithName:@ MobileDep ];\nBmobRole *androidTeam = [BmobRole roleWithName:@ AndroidTeam ];\nBmobRole *iosTeam     = [BmobRole roleWithName:@ iOSTeam ];\n//保存AndroidTeam和iosTeam角色到云端\n[androidTeam saveInBackground];\n[iosTeam saveInBackground];\n//将androidTeam和iosTeam两种角色添加到移动部门角色中\nBmobRelation *relation = [BmobRelation relation];\n[relation addObject:androidTeam];\n[relation addObject:iosTeam];\n[mobileDep addRolesRelation:relation];\n// 假设创建三个代码数据对象\nBmobObject *coreCode = [BmobObject objectWithClassName:@ Code ];\nBmobObject *androidCode = [BmobObject objectWithClassName:@ Code ];\nBmobObject *iosCode = [BmobObject objectWithClassName:@ Code ];\n//......此处省略一些具体的属性设定\n[coreCode saveInBackground];\n[androidCode saveInBackground];\n[iosCode saveInBackground];\n//设置androidTeam角色对androidCode对象的读和写的权限\n[androidCode.ACL setReadAccessForRole:androidTeam];\n[androidCode.ACL setWriteAccessForRole:androidTeam];\n//设置iosTeam角色对iosCode对象的读和写的权限\n[iosCode.ACL setReadAccessForRole:iosTeam];\n[iosCode.ACL setWriteAccessForRole:iosTeam];\n//设置mobileDep角色可以对coreCode对象进行读操作\n[coreCode.ACL setReadAccessForRole:mobileDep];", 
            "title": "角色之间的从属关系"
        }, 
        {
            "location": "/data/ios/develop_doc/#_94", 
            "text": "Bmob允许用户根据地球的经度和纬度坐标进行基于地理位置息的信查询。你可以在BmobObject的查询中添加一个BmobGeoPoint的对象查询。你就可以实现轻松查找出离当前用户最接近的信息或地点的功能。", 
            "title": "地理位置"
        }, 
        {
            "location": "/data/ios/develop_doc/#_95", 
            "text": "首先需要创建一个BmobGeoPoint对象。例如，创建一个-东经116.39727786183357度北纬39.913768382429105度的BmobGeoPoint对象：  BmobGeoPoint *point = [[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:39.913768382429105];  添加地理信息  [gameScore setObject:point forKey:@ location ];", 
            "title": "地理位置对象"
        }, 
        {
            "location": "/data/ios/develop_doc/#_96", 
            "text": "现在，你的数据表中有了一定的地理坐标对象的数据，这样可以测试找出最接近某个点的信息了。你可以使用BmobQuery对象的whereNear方法来这样做：  BmobGeoPoint  *point = [[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:39.913768382429105];\nBmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n[bquery whereKey:@ location  nearGeoPoint:point];\n[bquery setLimit:10];\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n    //进行操作\n}];  要限制查询指定距离范围的数据可以使用whereWithinKilometers(公里)、whereWithinMiles(英里)或whereWithinRadians(弧度)方法。 要查询一个矩形范围内的信息可以使用whereWithinGeoBox来实现：  BmobGeoPoint *southwestOfSF = [[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:39.913768382429105];\nBmobGeoPoint* northeastOfSF =[[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:40.913768382429105];\nBmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n[bquery whereKey:@ location  withinGeoBoxFromSouthwest:southwestOfSF\n                                           toNortheast:northeastOfSF];\n[bquery setLimit:10];\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n    //进行操作\n}];  注意事项 \n目前有几个需要注意的地方：    每个BmobObject数据对象中 只能 有一个BmobGeoPoint对象。    地理位置的点不能超过规定的范围。 纬度的范围 应该是在 -90.0到90.0 之间。 经度的范围 应该是在 -180.0到180.0 之间。如果您添加的经纬度超出了以上范围，将导致程序错误。    地理位置查询最大的距离根据表数据的不同有不同的限制，使用-(void)whereKey:(NSString  )key nearGeoPoint:(BmobGeoPoint  )geopoint;默认 100KM 。当需要指定距离时，最好指定一下最大距离。", 
            "title": "地理查询"
        }, 
        {
            "location": "/data/ios/develop_doc/#_97", 
            "text": "", 
            "title": "其它功能"
        }, 
        {
            "location": "/data/ios/develop_doc/#_98", 
            "text": "获取服务器时间戳可以直接调用[Bmob getServerTimestamp]，例如：      dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];\n        //设置时区\n        [dateFormatter setTimeZone:[NSTimeZone timeZoneWithName:@ Asia/Shanghai ]];\n        //时间格式\n        [dateFormatter setDateFormat:@ yyyy-MM-dd hh:mm:ss ];\n        //调用获取服务器时间接口，返回的是时间戳\n        NSString  *timeString = [Bmob getServerTimestamp];\n        //时间戳转化成时间\n        NSDate *date = [NSDate dateWithTimeIntervalSince1970:[timeString intValue]];\n        NSString *dateStr = [dateFormatter stringFromDate:date];\n        NSLog(@ 北京时间:%@ ,dateStr);\n    });", 
            "title": "获取服务器时间"
        }, 
        {
            "location": "/data/ios/develop_doc/#api", 
            "text": "使用  +(void)setBmobRequestTimeOut:(CGFloat)seconds;  方法可以设置API中网络请求的超时时间，例如，想要设置访问Bmob后台时超过15s就返回超时错误，可以这样写.  [Bmob setBmobRequestTimeOut:15];  BmobSDK默认是20s后得不到回复就提示超时，如果没有特别的需求，建议不要设置该时间。", 
            "title": "设置API网络请求超时时间"
        }, 
        {
            "location": "/data/ios/develop_doc/#_99", 
            "text": "从  v1.6.1  开始，我们开放获取表结构的接口。", 
            "title": "获取表结构"
        }, 
        {
            "location": "/data/ios/develop_doc/#_100", 
            "text": "可通过表名来获取特定表的结构，样例代码如下：      [Bmob getTableSchemasWithClassName:@ _User  callBack:^(BmobTableSchema *bmobTableSchema, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            //直接用description来查看表结构\n            NSLog(@ %@ ,bmobTableSchema.description);\n\n            /*\n             分别打印表结构\n            */\n            //打印表名\n            NSLog(@ 表名:%@ ,bmobTableSchema.className);\n            //打印表结构\n            NSDictionary *fields = bmobTableSchema.fields;\n            NSArray *allKey = [fields allKeys];\n            for (NSString *key in allKey) {\n                NSLog(@ 列名:%@ ,key);\n                NSDictionary *fieldStrcut = [fields objectForKey:key];\n                NSLog(@ 列类型:%@ ,[fieldStrcut objectForKey:@ type ] );\n                if ([[fieldStrcut objectForKey:@ type ] isEqualToString:@ Pointer ]) {\n                    NSLog(@ 关联关系指向的表名:%@ ,[fieldStrcut objectForKey:@ targetClass ]);\n                }\n            }\n        }\n    }];", 
            "title": "获取特定表的结构"
        }, 
        {
            "location": "/data/ios/develop_doc/#_101", 
            "text": "可通过以下代码得到所有表的结构      [Bmob getAllTableSchemasWithCallBack:^(NSArray *tableSchemasArray, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            for (BmobTableSchema* bmobTableSchema in tableSchemasArray) {\n                //直接用description来查看表结构\n                NSLog(@ %@ ,bmobTableSchema.description);\n\n                /*\n                 分别打印表结构\n                 */\n                //打印表名\n                NSLog(@ 表名:%@ ,bmobTableSchema.className);\n                //打印表结构\n                NSDictionary *fields = bmobTableSchema.fields;\n                NSArray *allKey = [fields allKeys];\n                for (NSString *key in allKey) {\n                    NSLog(@ 列名:%@ ,key);\n                    NSDictionary *fieldStrcut = [fields objectForKey:key];\n                    NSLog(@ 列类型:%@ ,[fieldStrcut objectForKey:@ type ] );\n                    if ([[fieldStrcut objectForKey:@ type ] isEqualToString:@ Pointer ]) {\n                        NSLog(@ 关联关系指向的表名:%@ ,[fieldStrcut objectForKey:@ targetClass ]);\n                    }\n                }\n            }\n        }\n    }];", 
            "title": "获取所有表的结构"
        }, 
        {
            "location": "/data/ios/develop_doc/#_102", 
            "text": "表结构以  BmobTableSchema  对象的形式返回，其中属性  className  表示表名，而属性  fields  是一个字典，里面包含了所有列的类型，其结构如下：  {@ 列名1 :dic,@“列名2”:dic}  而dic的结构为：  {@ type :@ typeName ,@ targetClass :@ tableName }  其中  type  指的是该类的类型， 而  targetClass  指的是指向的表名，只有在  type  为  Pointer  或者  Relation  时才有值。  具体形式如下：  {\n    ACL =     {\n        type = Object;\n    };\n    author =     {\n        targetClass =  _User ;\n        type = Pointer;\n    };\n    content =     {\n        type = String;\n    };\n    createdAt =     {\n        type = Date;\n    };\n    likes =     {\n        targetClass =  _User ;\n        type = Relation;\n    };\n    objectId =     {\n        type = String;\n    };\n    skill =     {\n        type = Array;\n    };\n    title =     {\n        type = String;\n    };\n    updatedAt =     {\n        type = Date;\n    };\n};", 
            "title": "返回数据说明"
        }, 
        {
            "location": "/data/ios/example/", 
            "text": "失物招领案例教程\n\n\n需求描述\n\n\n为演示Bmob提供的云数据库的功能，本文制作了一个失物招领的简单案例，实现物品的发布和呈现，展示如何使用Bmob快速开发一个有后端数据库的应用软件。使用场景如下：用户捡到物品，打开手机软件，填写物品的招领信息（标题、描述和联系方式）；用户丢失物品，打开手机软件，填写物品的丢失信息（标题、描述和联系方式）；任何人都可以查看到失物和招领的信息列表。\n\n\n说明一点的是，因为是演示案例，所以信息的添加并没有进行用户身份验证。\n\n\n本案例将使用到Bmob的如下功能：\n\n\n1、  添加数据\n添加失物/招领信息到服务器中。\n\n\n2、  查找数据\n\n\n在列表中显示所有用户发布的失物/招领信息。\n\n\n本案例最终实现的部分界面效果如下：\n\n\n \n\n\n失物招领软件闪图\n\n\n \n\n\n招领列表页\n\n\n \n\n\n添加失物信息\n\n\n数据结构设计\n\n\n本案例的数据结构非常简单，只需要设计两个表，一个是失物表（Lost表），一个是招领表（Found表），对应的数据结构如下（省略对常用默认字段objectId、createAt、updateAt的描述，对于还不知道怎么创建应用和添加数据表的开发朋友请先移步\n快速入门指南\n查看相关教程）：\n\n\n\n    \n\n        \n失物表（Lost）\n\n    \n\n    \n\n        \n字段名\n类型\n描述\n\n    \n\n    \n\n        \ndescribe\nString\n失物的描述信息\n\n    \n\n    \n\n        \nphone\nString\n联系的手机号码\n\n    \n\n    \n\n        \ntitle\nString\n失物的标题信息\n\n    \n\n\n\n\n\n\n\n\n    \n\n        \n招领表（Found）\n\n    \n\n    \n\n        \n字段名\n类型\n描述\n\n    \n\n    \n\n        \ndescribe\nString\n招领的描述信息\n\n    \n\n    \n\n        \nphone\nString\n联系的手机号码\n\n    \n\n    \n\n        \ntitle\nString\n招领的标题信息\n\n    \n\n\n\n\n\n初始化SDK\n\n\nBmob为每个应用都提供了一个唯一标识（对应为开发者后台应用中的“应用密钥-\nApplication ID”），使用Bmob开发的应用都要首先使用这个Application ID”进行初始化。对应代码如下（详细代码实现参看main.m文件）：\n\n\nint main(int argc, char * argv[])\n{\n\n    @autoreleasepool {\n        //registerWithAppKey需要使用Application ID进行初始化\n        [Bmob registerWithAppKey:@\ne9bbe5f23a1aa1d60d525871e1d7db99\n];\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n\n\n\n\n添加失物及招领信息\n\n\n用户填写了失物信息之后，只需要构造一个BmobObject实例，然后简单调用setObject方法就可以将信息添加到云数据库中，实现代码如下（详细代码实现参看AddViewController.m文件）：\n\n\n        //创建BmobObject对象，指定对应要操作的数据表名称\n        BmobObject *obj = [[BmobObject alloc] initWithClassName:className];\n        //设置字段值\n        [obj setObject:titleTextField.text forKey:@\ntitle\n];\n        [obj setObject:phoneTextField.text forKey:@\nphone\n];\n        [obj setObject:desTextField.text forKey:@\ndescribe\n];\n        //执行保存操作\n        [obj saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n\n            if (!error) {\n                //其他代码\n            }\n\n        }];\n\n\n\n\n获取失物及招领列表\n\n\nBmob提供了复杂和简单的查询方法，可以对查询结果进行排序，可以对结果进行缓存。本案例只使用到Bmob提供的最简单的查询和排序功能，直接调用BmobQuery类的findObjects方法和orderByDescending方法来获取失物列表，实现代码如下（详细代码实现参看MainActivity类）：\n\n\n    //创建BmobQuery实例，指定对应要操作的数据表名称\n    BmobQuery *query = [BmobQuery queryWithClassName:className];\n    //按updatedAt进行降序排列\n    [query orderByDescending:@\nupdatedAt\n];\n    //返回最多20个结果\n    query.limit = 20;\n    //执行查询\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        //处理查询结果\n        for (BmobObject *obj in array) {\n            News *info    = [[News alloc] init];\n            if ([obj objectForKey:@\ntitle\n]) {\n                info.title    = [obj objectForKey:@\ntitle\n];\n            }\n            if ([obj objectForKey:@\ndescribe\n]) {\n                info.content  = [obj objectForKey:@\ndescribe\n];\n            }\n            if ([obj objectForKey:@\nphone\n]) {\n                info.phoneNum = [obj objectForKey:@\nphone\n];\n            }\n            info.time     = [_dateFormatter stringFromDate:obj.updatedAt];\n            [_infoMutableArray addObject:info];\n        }\n\n        [_tableView reloadData];\n    }];\n\n\n\n\n后记\n\n\n本案例只是演示如何用Bmob进行快速的数据添加和查询，在真实的应用环境下，你还可能还需要使用到用户系统、文件服务、更复杂的数据结构和服务，这些都可以使用Bmob就可以实现。如果想要获取更多的信息，请各位查看Bmob的\n开发文档\n或者联系技术客服。欢迎砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～\n\n\n案例下载\n\n\n失物招领案例下载\n\n\n推送案例教程\n\n\n推送案例需求描述\n\n\n用户反馈是移动开发中最常见的功能，可以用来收集我们的用户对软件的意见和建议。通常在开发用户反馈功能时，我们都会将用户反馈的信息保存到服务器中，定期登录后台管理系统查看，这样很难做到实时查看用户反馈信息。本文结合Bmob推送服务和数据存储服务开发用户反馈功能，实现用户提交反馈信息保存在Bmob云数据库的同时，也将用户的反馈信息推送到运营/研发人员的设备中。\n\n\n本案例将使用到Bmob的如下功能：\n\n\n1、  推送服务\n\n\n将用户的反馈信息实时推送到订阅了接收反馈信息的设备中，实现端到端的消息传递。\n\n\n2、  数据存储服务\n\n\n添加和查看反馈信息，使用到了添加、查询和按时间排序的功能。\n\n\n本案例最终实现的界面效果如下：\n\n\n \n\n\n发送反馈截图\n\n\n \n\n\n查看反馈意见截图\n\n\n推送案例数据结构设计\n\n\n在Bmob开发者后台创建一个应用（还不知道怎么创建应用和添加数据表的开发朋友请先移步快速入门指南查看相关教程），添加两个表，分别是Feedback（用户反馈信息表，存储用户提交的反馈信息）和Installation（设备安装表，存储需要接收推送信息的设备信息）。以下是对这两个表的数据结构的详细描述（省略对常用默认字段objectId、createAt、updateAt的描述）\n\n\n\n    \n\n        \nFeedback表\n\n    \n\n    \n\n        \n字段名\n类型\n描述\n\n    \n\n    \n\n        \nContact\nString\n用户的联系方式\n\n    \n\n    \n\n        \ndeviceType\nString\n系统字段，是一个必须的字段, 必须被设置为 \"ios\" 或者 \"android\", 而且自这个对象生成以后就不能变化\n\n    \n\n    \n\n        \ncontent\nString\n反馈内容\n\n    \n\n\n\n\n\n\n    \n\n        \nInstallation表\n\n    \n\n    \n\n        \n字段名\n类型\n描述\n\n    \n\n    \n\n        \ninstallationId\nString\n系统字段，是一个Bmob生成的字符串标志, 而且如果 deviceType 是 android 的话是一个必填字段, 如果是 ios 的话则可选. 它只要对象被生成了就不能发生改变, 而且对一个 app 来说是不可重复的\n\n    \n\n    \n\n        \ndeviceToken\nString\n系统字段，是一个 Apple 生成的字符串标志, 在 deviceType 为 ios 上的设备是必须的, 而且自对象生成开始就不能改动, 对于一个 app 来说也是不可重复的\n\n    \n\n    \n\n        \nbadge\nNumber\n系统字段，表示iOS 设备最新已知的应用badge\n\n    \n\n    \n\n        \ntimeZone\nString\n系统字段，表示安装的这个设备的系统时区\n\n    \n\n    \n\n        \nchannels\nArray\n系统字段，表示这个安装对象的订阅频道列表\n\n    \n\n    \n\n        \nappIdentifiter\nString\niOS应用的Bundle identifier\n\n    \n\n    \n\n        \nisDeveloper\nBoolean\n是否是开发者（是的话则用于接收推送信息）\n\n    \n\n\n\n\n\n推送案例安装和初始化\n\n\n还不知道怎么安装使用Bmob数据存储Sdk的开发朋友请先移步快速入门指南查看相关教程。\n\n\n推送服务的SDK初始化和Bmob数据存储SDK一样，只需要在main.m调用registerWithAppKey方法即可：\n\n\nint main(int argc, char * argv[])\n{\n\n    //可更换为您的应用的key\n    [Bmob registerWithAppKey:@\n3124f50157a5df138aba77a85e1d8909\n];\n\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n\n\n\n\n发送反馈功能的开发\n\n\n这里要实现的是当用户点击“发送”反馈按钮之后，先把用户的反馈信息上传到Bmob云数据库中，然后发送一条推送信息到Installation表中isDeveloper为true的设备中去。\n\n\n为实现将数据保存到云数据库的功能，你需要先创建BmobObject对象，该对象通过initWithClassName方法与云端数据库的Feedback表对应起来，然后通过setObject方法设置数据对象。实现代码如下：\n\n\nBmobObject *feedbackObj = [[BmobObject alloc] initWithClassName:@\nFeedback\n];\n\n//联系方式\n[feedbackObj setObject:contactTextfield.text forKey:@\ncontact\n];\n\n//反馈内容\n    [feedbackObj setObject:ncTextView.text forKey:@\ncontent\n];\n\n\n\n\n接着，你就可以直接调用BmobObject对象的saveInBackgroundWithResultBlock方法，将数据插入到云数据库中了。实现代码如下：\n\n\n//保存反馈信息到Bmob云数据库中\n[feedbackObj saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\nif (isSuccessful) {\n        NSLog(@”保存成功”);\n    }else{\nNSLog(@”保存失败”);\n}\n}];\n\n\n\n\n保存成功之后，你可以推送一条信息到BmobInstallation安装表中isDeveloper字段值为true的设备中。实现代码如下：\n\n\n/**\n * 推送反馈信息给isDeveloper的设备\n * @param message 反馈信息\n */\n\n-(void)sendPush:(NSString*) message {\n    //发送推送\n    BmobPush *push = [BmobPush push];\n    BmobQuery *query = [BmobInstallation query];\n    //条件为isDeveloper是true\n    [query whereKey:@\nisDeveloper\n equalTo:[NSNumber numberWithBool:YES] ];\n    [push setQuery:query];\n    //推送内容为反馈的内容\n    [push setMessage: message];\n    [push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@\npush error =====\n%@\n,[error description]);\n    }];\n}\n\n\n\n\n查看反馈功能的开发\n\n\n为了接收用户端推送过来的反馈信息，需要在AppDelegate类中注册通知功能（application类registerForRemoteNotificationTypes方法）、设置推送消息到达之后的处理方法（BmobPush类handlePush方法），当然了，还需要将接收推送信息的当前机器信息添加到云端数据库中的设备安装表中（BmobInstallation）。实现代码如下：\n\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n    //注册通知功能\n[application registerForRemoteNotificationTypes:UIRemoteNotificationTypeAlert|\nUIRemoteNotificationTypeBadge|\nUIRemoteNotificationTypeSound];\n    ……\n    return YES;\n}\n\n//接收推送信息的处理服务\n-(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo{\n    NSLog(@\nuserInfo %@\n,[userInfo description]);\n    [BmobPush handlePush:userInfo];\n}\n\n//往云端数据库中的设备表注册信息\n-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken{\n    BmobInstallation    *installation = [BmobInstallation currentInstallation];\n    [installation setDeviceTokenFromData:deviceToken];\n    //设置isDeveloper为true\n    [installation setObject:[NSNumber numberWithBool:YES] forKey:@\nisDeveloper\n];\n    [installation saveInBackground];\n}\n\n\n\n\n查看反馈列表的功能实现很简单，只需要调用BmobQuery的findObjectsInBackgroundWithBlock方法就可以了，实现代码如下：\n\n\n//创建BmobQuery查询对象，对应查询云端数据库中的Feedback表\nBmobQuery *query = [BmobQuery queryWithClassName:@\nFeedback\n];\n//按updatedAt降序排列\n[query orderByDescending:@\nupdatedAt\n];\n[query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        //处理查询结果\n        for (BmobObject *obj in array) {\n            NSMutableDictionary *dic = [NSMutableDictionary dictionary];\n            [dic setObject:[obj objectForKey:@\ncontent\n] forKey:@\ncontent\n];\n            [dic setObject:[obj objectForKey:@\ncontact\n] forKey:@\ncontact\n];\n            [dic setObject:obj.createdAt forKey:@\ntime\n];\n            [_feedbacksArray addObject:dic];\n            [_feedbackTableView reloadData];\n        }\n }];\n\n\n\n\n推送案例后记\n\n\n当然了，实际使用过程的反馈功能可能并没有那么简单，或许你需要实现能够直接跟用户对话的反馈功能，或许你想要实现智能化的机器回答，这些都可以使用Bmob移动云服务平台进行快速设计和开发的。欢迎各位砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～\n\n\n推送案例下载\n\n\n反馈案例下载\n\n\n其他案例\n\n\n快速入门相关源码:\nhttps://github.com/bmob/bmob-ios-demo\n\n\n数据关联章节Demo下载:\nhttps://github.com/bmob/bmob-ios-demo/tree/master/BmobSDK/BmobRelationDemo\n\n\n第三方登录Demo:\nhttps://github.com/bmob/bmob-ios-demo\n\n\n文件管理Demo:\nhttps://github.com/bmob/bmob-ios-demo/tree/master/BmobSDK/BmobFileDemo\n\n\n数据实时更新Demo:\nhttps://github.com/bmob/bmob-ios-demo/blob/master/BmobDataDemo_iOS.zip\n\n\nBmobIMSDK源代码：\nhttps://github.com/bmob/bmob-iOS-im-sdk\n\n\nSwift使用BmobSDK案例源码:\nhttps://github.com/bmob/bmob-app-demo-show/blob/master/download/BmobSwift.zip\n\n\n踢球吧源码\nhttps://github.com/bmob/BmobTiQiuBa\n\n\nmexiQQ开发者实现的iOS实践案例\nhttps://github.com/bmob/VReader-iOS\n\n\niOS云端逻辑案例:\nhttps://github.com/bmob/bmob-ios-demo/blob/master/CloudFunction.zip\n\n\niOS BmobSDK API使用案例:\nhttps://github.com/bmob/bmob-ios-demo/blob/master/BmobStorageDemo.zip", 
            "title": "示例/功能"
        }, 
        {
            "location": "/data/ios/example/#_1", 
            "text": "", 
            "title": "失物招领案例教程"
        }, 
        {
            "location": "/data/ios/example/#_2", 
            "text": "为演示Bmob提供的云数据库的功能，本文制作了一个失物招领的简单案例，实现物品的发布和呈现，展示如何使用Bmob快速开发一个有后端数据库的应用软件。使用场景如下：用户捡到物品，打开手机软件，填写物品的招领信息（标题、描述和联系方式）；用户丢失物品，打开手机软件，填写物品的丢失信息（标题、描述和联系方式）；任何人都可以查看到失物和招领的信息列表。  说明一点的是，因为是演示案例，所以信息的添加并没有进行用户身份验证。  本案例将使用到Bmob的如下功能：  1、  添加数据\n添加失物/招领信息到服务器中。  2、  查找数据  在列表中显示所有用户发布的失物/招领信息。  本案例最终实现的部分界面效果如下：     失物招领软件闪图     招领列表页     添加失物信息", 
            "title": "需求描述"
        }, 
        {
            "location": "/data/ios/example/#_3", 
            "text": "本案例的数据结构非常简单，只需要设计两个表，一个是失物表（Lost表），一个是招领表（Found表），对应的数据结构如下（省略对常用默认字段objectId、createAt、updateAt的描述，对于还不知道怎么创建应用和添加数据表的开发朋友请先移步 快速入门指南 查看相关教程）：  \n     \n         失物表（Lost） \n     \n     \n         字段名 类型 描述 \n     \n     \n         describe String 失物的描述信息 \n     \n     \n         phone String 联系的手机号码 \n     \n     \n         title String 失物的标题信息 \n        \n     \n         招领表（Found） \n     \n     \n         字段名 类型 描述 \n     \n     \n         describe String 招领的描述信息 \n     \n     \n         phone String 联系的手机号码 \n     \n     \n         title String 招领的标题信息", 
            "title": "数据结构设计"
        }, 
        {
            "location": "/data/ios/example/#sdk", 
            "text": "Bmob为每个应用都提供了一个唯一标识（对应为开发者后台应用中的“应用密钥- Application ID”），使用Bmob开发的应用都要首先使用这个Application ID”进行初始化。对应代码如下（详细代码实现参看main.m文件）：  int main(int argc, char * argv[])\n{\n\n    @autoreleasepool {\n        //registerWithAppKey需要使用Application ID进行初始化\n        [Bmob registerWithAppKey:@ e9bbe5f23a1aa1d60d525871e1d7db99 ];\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}", 
            "title": "初始化SDK"
        }, 
        {
            "location": "/data/ios/example/#_4", 
            "text": "用户填写了失物信息之后，只需要构造一个BmobObject实例，然后简单调用setObject方法就可以将信息添加到云数据库中，实现代码如下（详细代码实现参看AddViewController.m文件）：          //创建BmobObject对象，指定对应要操作的数据表名称\n        BmobObject *obj = [[BmobObject alloc] initWithClassName:className];\n        //设置字段值\n        [obj setObject:titleTextField.text forKey:@ title ];\n        [obj setObject:phoneTextField.text forKey:@ phone ];\n        [obj setObject:desTextField.text forKey:@ describe ];\n        //执行保存操作\n        [obj saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n\n            if (!error) {\n                //其他代码\n            }\n\n        }];", 
            "title": "添加失物及招领信息"
        }, 
        {
            "location": "/data/ios/example/#_5", 
            "text": "Bmob提供了复杂和简单的查询方法，可以对查询结果进行排序，可以对结果进行缓存。本案例只使用到Bmob提供的最简单的查询和排序功能，直接调用BmobQuery类的findObjects方法和orderByDescending方法来获取失物列表，实现代码如下（详细代码实现参看MainActivity类）：      //创建BmobQuery实例，指定对应要操作的数据表名称\n    BmobQuery *query = [BmobQuery queryWithClassName:className];\n    //按updatedAt进行降序排列\n    [query orderByDescending:@ updatedAt ];\n    //返回最多20个结果\n    query.limit = 20;\n    //执行查询\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        //处理查询结果\n        for (BmobObject *obj in array) {\n            News *info    = [[News alloc] init];\n            if ([obj objectForKey:@ title ]) {\n                info.title    = [obj objectForKey:@ title ];\n            }\n            if ([obj objectForKey:@ describe ]) {\n                info.content  = [obj objectForKey:@ describe ];\n            }\n            if ([obj objectForKey:@ phone ]) {\n                info.phoneNum = [obj objectForKey:@ phone ];\n            }\n            info.time     = [_dateFormatter stringFromDate:obj.updatedAt];\n            [_infoMutableArray addObject:info];\n        }\n\n        [_tableView reloadData];\n    }];", 
            "title": "获取失物及招领列表"
        }, 
        {
            "location": "/data/ios/example/#_6", 
            "text": "本案例只是演示如何用Bmob进行快速的数据添加和查询，在真实的应用环境下，你还可能还需要使用到用户系统、文件服务、更复杂的数据结构和服务，这些都可以使用Bmob就可以实现。如果想要获取更多的信息，请各位查看Bmob的 开发文档 或者联系技术客服。欢迎砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～", 
            "title": "后记"
        }, 
        {
            "location": "/data/ios/example/#_7", 
            "text": "失物招领案例下载", 
            "title": "案例下载"
        }, 
        {
            "location": "/data/ios/example/#_8", 
            "text": "", 
            "title": "推送案例教程"
        }, 
        {
            "location": "/data/ios/example/#_9", 
            "text": "用户反馈是移动开发中最常见的功能，可以用来收集我们的用户对软件的意见和建议。通常在开发用户反馈功能时，我们都会将用户反馈的信息保存到服务器中，定期登录后台管理系统查看，这样很难做到实时查看用户反馈信息。本文结合Bmob推送服务和数据存储服务开发用户反馈功能，实现用户提交反馈信息保存在Bmob云数据库的同时，也将用户的反馈信息推送到运营/研发人员的设备中。  本案例将使用到Bmob的如下功能：  1、  推送服务  将用户的反馈信息实时推送到订阅了接收反馈信息的设备中，实现端到端的消息传递。  2、  数据存储服务  添加和查看反馈信息，使用到了添加、查询和按时间排序的功能。  本案例最终实现的界面效果如下：     发送反馈截图     查看反馈意见截图", 
            "title": "推送案例需求描述"
        }, 
        {
            "location": "/data/ios/example/#_10", 
            "text": "在Bmob开发者后台创建一个应用（还不知道怎么创建应用和添加数据表的开发朋友请先移步快速入门指南查看相关教程），添加两个表，分别是Feedback（用户反馈信息表，存储用户提交的反馈信息）和Installation（设备安装表，存储需要接收推送信息的设备信息）。以下是对这两个表的数据结构的详细描述（省略对常用默认字段objectId、createAt、updateAt的描述）  \n     \n         Feedback表 \n     \n     \n         字段名 类型 描述 \n     \n     \n         Contact String 用户的联系方式 \n     \n     \n         deviceType String 系统字段，是一个必须的字段, 必须被设置为 \"ios\" 或者 \"android\", 而且自这个对象生成以后就不能变化 \n     \n     \n         content String 反馈内容 \n       \n     \n         Installation表 \n     \n     \n         字段名 类型 描述 \n     \n     \n         installationId String 系统字段，是一个Bmob生成的字符串标志, 而且如果 deviceType 是 android 的话是一个必填字段, 如果是 ios 的话则可选. 它只要对象被生成了就不能发生改变, 而且对一个 app 来说是不可重复的 \n     \n     \n         deviceToken String 系统字段，是一个 Apple 生成的字符串标志, 在 deviceType 为 ios 上的设备是必须的, 而且自对象生成开始就不能改动, 对于一个 app 来说也是不可重复的 \n     \n     \n         badge Number 系统字段，表示iOS 设备最新已知的应用badge \n     \n     \n         timeZone String 系统字段，表示安装的这个设备的系统时区 \n     \n     \n         channels Array 系统字段，表示这个安装对象的订阅频道列表 \n     \n     \n         appIdentifiter String iOS应用的Bundle identifier \n     \n     \n         isDeveloper Boolean 是否是开发者（是的话则用于接收推送信息）", 
            "title": "推送案例数据结构设计"
        }, 
        {
            "location": "/data/ios/example/#_11", 
            "text": "还不知道怎么安装使用Bmob数据存储Sdk的开发朋友请先移步快速入门指南查看相关教程。  推送服务的SDK初始化和Bmob数据存储SDK一样，只需要在main.m调用registerWithAppKey方法即可：  int main(int argc, char * argv[])\n{\n\n    //可更换为您的应用的key\n    [Bmob registerWithAppKey:@ 3124f50157a5df138aba77a85e1d8909 ];\n\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}", 
            "title": "推送案例安装和初始化"
        }, 
        {
            "location": "/data/ios/example/#_12", 
            "text": "这里要实现的是当用户点击“发送”反馈按钮之后，先把用户的反馈信息上传到Bmob云数据库中，然后发送一条推送信息到Installation表中isDeveloper为true的设备中去。  为实现将数据保存到云数据库的功能，你需要先创建BmobObject对象，该对象通过initWithClassName方法与云端数据库的Feedback表对应起来，然后通过setObject方法设置数据对象。实现代码如下：  BmobObject *feedbackObj = [[BmobObject alloc] initWithClassName:@ Feedback ];\n\n//联系方式\n[feedbackObj setObject:contactTextfield.text forKey:@ contact ];\n\n//反馈内容\n    [feedbackObj setObject:ncTextView.text forKey:@ content ];  接着，你就可以直接调用BmobObject对象的saveInBackgroundWithResultBlock方法，将数据插入到云数据库中了。实现代码如下：  //保存反馈信息到Bmob云数据库中\n[feedbackObj saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\nif (isSuccessful) {\n        NSLog(@”保存成功”);\n    }else{\nNSLog(@”保存失败”);\n}\n}];  保存成功之后，你可以推送一条信息到BmobInstallation安装表中isDeveloper字段值为true的设备中。实现代码如下：  /**\n * 推送反馈信息给isDeveloper的设备\n * @param message 反馈信息\n */\n\n-(void)sendPush:(NSString*) message {\n    //发送推送\n    BmobPush *push = [BmobPush push];\n    BmobQuery *query = [BmobInstallation query];\n    //条件为isDeveloper是true\n    [query whereKey:@ isDeveloper  equalTo:[NSNumber numberWithBool:YES] ];\n    [push setQuery:query];\n    //推送内容为反馈的内容\n    [push setMessage: message];\n    [push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@ push error ===== %@ ,[error description]);\n    }];\n}", 
            "title": "发送反馈功能的开发"
        }, 
        {
            "location": "/data/ios/example/#_13", 
            "text": "为了接收用户端推送过来的反馈信息，需要在AppDelegate类中注册通知功能（application类registerForRemoteNotificationTypes方法）、设置推送消息到达之后的处理方法（BmobPush类handlePush方法），当然了，还需要将接收推送信息的当前机器信息添加到云端数据库中的设备安装表中（BmobInstallation）。实现代码如下：  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n    //注册通知功能\n[application registerForRemoteNotificationTypes:UIRemoteNotificationTypeAlert|\nUIRemoteNotificationTypeBadge|\nUIRemoteNotificationTypeSound];\n    ……\n    return YES;\n}\n\n//接收推送信息的处理服务\n-(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo{\n    NSLog(@ userInfo %@ ,[userInfo description]);\n    [BmobPush handlePush:userInfo];\n}\n\n//往云端数据库中的设备表注册信息\n-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken{\n    BmobInstallation    *installation = [BmobInstallation currentInstallation];\n    [installation setDeviceTokenFromData:deviceToken];\n    //设置isDeveloper为true\n    [installation setObject:[NSNumber numberWithBool:YES] forKey:@ isDeveloper ];\n    [installation saveInBackground];\n}  查看反馈列表的功能实现很简单，只需要调用BmobQuery的findObjectsInBackgroundWithBlock方法就可以了，实现代码如下：  //创建BmobQuery查询对象，对应查询云端数据库中的Feedback表\nBmobQuery *query = [BmobQuery queryWithClassName:@ Feedback ];\n//按updatedAt降序排列\n[query orderByDescending:@ updatedAt ];\n[query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        //处理查询结果\n        for (BmobObject *obj in array) {\n            NSMutableDictionary *dic = [NSMutableDictionary dictionary];\n            [dic setObject:[obj objectForKey:@ content ] forKey:@ content ];\n            [dic setObject:[obj objectForKey:@ contact ] forKey:@ contact ];\n            [dic setObject:obj.createdAt forKey:@ time ];\n            [_feedbacksArray addObject:dic];\n            [_feedbackTableView reloadData];\n        }\n }];", 
            "title": "查看反馈功能的开发"
        }, 
        {
            "location": "/data/ios/example/#_14", 
            "text": "当然了，实际使用过程的反馈功能可能并没有那么简单，或许你需要实现能够直接跟用户对话的反馈功能，或许你想要实现智能化的机器回答，这些都可以使用Bmob移动云服务平台进行快速设计和开发的。欢迎各位砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～", 
            "title": "推送案例后记"
        }, 
        {
            "location": "/data/ios/example/#_15", 
            "text": "反馈案例下载", 
            "title": "推送案例下载"
        }, 
        {
            "location": "/data/ios/example/#_16", 
            "text": "快速入门相关源码: https://github.com/bmob/bmob-ios-demo  数据关联章节Demo下载: https://github.com/bmob/bmob-ios-demo/tree/master/BmobSDK/BmobRelationDemo  第三方登录Demo: https://github.com/bmob/bmob-ios-demo  文件管理Demo: https://github.com/bmob/bmob-ios-demo/tree/master/BmobSDK/BmobFileDemo  数据实时更新Demo: https://github.com/bmob/bmob-ios-demo/blob/master/BmobDataDemo_iOS.zip  BmobIMSDK源代码： https://github.com/bmob/bmob-iOS-im-sdk  Swift使用BmobSDK案例源码: https://github.com/bmob/bmob-app-demo-show/blob/master/download/BmobSwift.zip  踢球吧源码 https://github.com/bmob/BmobTiQiuBa  mexiQQ开发者实现的iOS实践案例 https://github.com/bmob/VReader-iOS  iOS云端逻辑案例: https://github.com/bmob/bmob-ios-demo/blob/master/CloudFunction.zip  iOS BmobSDK API使用案例: https://github.com/bmob/bmob-ios-demo/blob/master/BmobStorageDemo.zip", 
            "title": "其他案例"
        }, 
        {
            "location": "/data/ios/update_log/", 
            "text": "v2.1.5 (2017-2-17)\n\n\n1.BmobObject setObject: bug 修复\n\n\nv2.1.4 (2017-2-16)\n\n\n1.bug修复\n\n\nv2.1.3 (2017-2-10)\n\n\n1.修复支付异常回调\n2.分离微信支付模块文件\n\n\nv2.1.2 (2017-2-8)\n\n\n1.修改订单查询接口\n\n\nv2.1.1 (2017-2-6)\n\n\n1.添加支付订单信息回调接口\n2.修复user类achieve失败的bug\n\n\nv2.1.0 (2017-1-20)\n\n\n1.修复模块重复问题\n\n\nv2.0.8 (2017-1-19)\n\n\n1.添加微信支付功能\n\n\nv2.0.7 (2017-1-18)\n\n\n1.Bug修复\n\n\nv2.0.6 (2017-1-17)\n\n\n1.Bug修复\n\n\nv2.0.5 (2017-1-17)\n\n\n1.Bug修复\n2.取消xib，该用纯代码实现支付界面\n3.扩展iOS6-iOS7支持\n\n\nv2.0.4 (2017-1-14)\n\n\n1.Bug修复\n\n\nv2.0.3 (2017-1-14)\n\n\n1.Bug修复\n\n\nv2.0.2 (2017-1-13)\n\n\n1.添加支付宝支付\n\n\nv2.0.1 (2016-12-05)\n\n\n1.修复更新个人资料可能会crash的问题\n\n\nv2.0.0 (2016-11-25)\n\n\n1.全面支持https服务\n\n\nv1.7.3 (2016-11-9)\n\n\n1.添加动态更新功能\n2.适配新的短信服务\n\n\nv1.7.2 (2016-07-18)\n\n\n1.替换BmobProFile 内部下载的方法，减少SDK的体积\n2.修复BmobFile上传后可能name为空的问题\n3.修复文件上传内存泄漏的问题\n\n\nv1.7.1 (2016-06-08)\n\n\n1.修改BmobQuery 取消方法错误拼写\n2.修改BmobObject objectWithoutDatatWithClassName方法拼写错误\n3.BmobObject+subclass 增加+(instancetype)covertWithObject:(BmobObject *)obj; 方便在swift调用\n4.修复更新个人资料可能会报用户名已存在的问题\n5.修复有ACL导致的更新不成功的问题\n\n\nv1.7.0 (2016-04-22)\n\n\n1.恢复BmobProFile文件下载的功能\n2.恢复云端代码同步接口（请在子线程使用），新增+(id)callFunction:(NSString \n)function withParameters:(NSDictionary \n)parameters error:(NSError **)error;返回错误信息\n3.Bmob类新增设置文件上传的授权时间和分片大小\n4.BmobInstallation类去掉currentInstallation(命名让人误会)，用installation代替(单纯创建一个BmobInstallation对象).\n\n\nv1.6.9 (2016-04-14)\n\n\n1.文件服务更换为CDN上传,废除新旧文件上传服务\n2.新增文件批量删除接口\n3.去掉调用云端代码同步的方法\n4.BmobUser 设置用户名变为setUsername:(NSString *)username\n5.更换网络请求库为NSURLSession\n6.修复设置超时时间没有反馈的bug\n7.修复某些回调不在主线程的问题\n\n\nv1.6.8 (2016-03-31)\n\n\n1.修复上一个版本用户可能无法更新资料和实时监控的问题\n\n\nv1.6.7 (2016-03-18)\n\n\n1.修复注销登录后的bug\n2.修复请求完成后，偶然会崩溃的的bug\n\n\nv1.6.6 (2015-12-23)\n\n\n1.添加封装的复合查询方法\n2.原子计数器支持浮点数\n3.修复网络环境较差时出现崩溃bug\n\n\nv1.6.5 (2015-10-08)\n\n\n1.支持bitcode操作；\n2.添加从字典初始化BmobObject方法；\n3.添加单独修改JSON对象某个key-value对的功能。\n\n\nv1.6.4 (2015-08-27)\n\n\n1.修改注册后没返回objectId的问题\n\n\nv1.6.3 (2015-08-24)\n\n\n1.添加根据旧密码修改新密码接口；\n2.添加手机验证码注册时可同时添加新密码或者是其它user列的信息接口；\n3.修改上传多个图片时偶然冲突导致上传失败的bug。\n\n\nv1.6.2 (2015-08-18)\n\n\n1.修复缩略图无法返回的问题;\n2.修复上传图片时，文件路径有误时应用出错的问题。\n\n\nv1.6.1（2015-07-27）\n\n\n1.修复使用账号密码注册时无法上传手机号的bug；\n2.开放获取表结构的接口。\n\n\nv1.6.0（2015-07-14）\n\n\n1.文件上传兼容旧文件系统\n1）修改上传文件接口\n2）添加获取已经上传文件访问url接口\n3）删除已上传文件接口\n2.修复子类化bug\n3.添加数组查询接口\n4.修复文件上传下载接口如果传空block会报错的bug\n\n\nv1.5.9（2015-07-01）\n\n\n1.提供修改超时间接口\n2.修复子类化bug\n3.修复实时监听bug\n4.提供自定义短信内容发送功能\n\n\nv1.5.8（2015-06-12）\n\n\n1.添加短信功能\n2.添加BmobObject子类化功能\n3.修复缓存查询部分bug\n4.修复云端代码无法同步bug\n5.第三方登录添加微信登录\n\n\nv1.5.7（2015-05-14）\n\n\n1.添加BQL查询功能\n2.开放模糊查询功能\n\n\nv1.5.6（2015-05-04）\n\n\n1.修改文件操作头文件部分注释；\n2.修复模拟器下有时无法上传文件的问题。\n\n\nv1.5.5（2015-04-24）\n\n\n1.增加统计查询方法\n2.修复部分bug\n\n\nv1.5.4 (2015-04-07)\n\n\n1.增加批量上传方法\nBmobFile\n+(void)filesUploadBatchWithDataArray:(NSArray *)dataArray\n                       progressBlock:(BmobFileBatchProgressBlock)progress\n                         resultBlock:(BmobFileBatchResultBlock)block;\n\n\nBmobFilePro\n+(void)uploadFilesWithDatas:(NSArray *)dataArray\n                resultBlock:(BmobBatchFileUploadResultBlock)block\n                   progress:(BmobIndexAndProgressBlock)progress;\n2.修复其他问题\n\n\nv1.5.3 (2015-03-05)\n\n\n1.修复蜂窝网络下可能会出现的使用新版文件上传文件，上传不了的问题\n2.修复在某些情况下用户可能无法更新表内容的问题\n\n\nv1.5.2 (2015-02-07)\n\n\n1.兼容1.5.1跟1.5.1之前的版本，即可以监听到通知再调用请求方法，也可以直接调用请求方法\n\n\nv1.5.1 (2015-01-23)\n\n\n1.添加初始化完成后通知kBmobInitSuccessNotification，kBmobInitFailNotification\n2.修改更新用户后本地用户可能会为空的问题\n注意：\n因为1.5.0之后的版本新增了加密功能，所以在还没初始化完成的时候请求接口会出现问题。\n故开发者可以监听此通知，获取成功通知的时候再进行其他接口的请求。\n\n\nv1.5.0 (2015-01-17)\n\n\n1.增加数据加密，建议使用新版本\n2.BmobProFile添加开启验证后得到的url方法\n\n\nv1.4.13(2015-01-05)\n\n\n1.新增文件管理类BmobProFile，提供多种上传方法等\n\n\nv1.4.12(2014-12-25)\n\n\n1.修复无网络时获取服务器时间出现的问题\n\n\nv1.4.11(2014-12-17)\n\n\n1.修改安全认证方法，注册方式可换回原来的方法,建议使用新版本\n NSString *appKey = @\"xxxx\";\n[Bmob registerWithAppKey:appKey];\n2.修复云端代码同步方法与异步方法数据格式不一样的问题\n\n\nv1.4.10(2014-12-9)\n\n\n1.增加安全认证的功能，注册应用方式修改为\n\n\n    NSString *appKey = @\nxxxx\n;\n#if DEBUG\n    [Bmob registerWithAppKey:appKey];\n#else\n    [Bmob registerWithAppKeyReleaseMode:appKey];\n#endif\n\n\n\n\n2.文件分片上传功能新增进度的方法。进度的范围为（0.0f-1.0f）\n3.新增批量上传的方法\n4.BmobQuery新增-(void)whereKeySExists:(NSArray \n)keys;\n和-(void)whereKeysDoesNotExist:(NSArray \n)keys; 方法\n\n\nv1.4.9 (2014-10-20)\n\n\n1.修复openudid冲突的问题\n\n\nv1.4.8 (2014-10-11)\n\n\n1.修复用户更新函数在iOS6下可能出现的崩溃问题\n2.修复已知的查询函数可能进入不了block的问题\n\n\nv1.4.7 (2014-10-10)\n\n\n1.修复云端代码的问题\n\n\nv1.4.6 (2014-09-22)\n\n\n修复本地缓存用户，更新后本地基本数据类型不一致的问题\n\n\nv1.4.5(2014-09-17)\n\n\n修复一些问题及优化结构\n\n\nv1.4.4(2014-09-12)\n\n\n修复v1.4.3的一些问题\n\n\nv1.4.3(2014-09-04)\n\n\n1.批量添加批量更新，也能增加特殊类型\n\n\nv1.4.2 (2014-08-20)\n\n\n1.BmobUser 添加获取邮箱是否已验证的方法\n2.修复BmobUser有可能更新不成功的问题\n\n\nv1.4.1 (2014-08-05)\n\n\nBmobUser类增加：\n1.QQ，新浪微博账号注册登录Bmob的功能\n2.关联QQ账号，微博账号功能\n3.提供取消关联的功能\n\n\nv1.4.0 (2014-07-18)\n\n\n1、增加数据实时功能，提供多种监听表变化的方法。\n2、增加BmobEvent类别，监听事件后，开发者可在代理函数里进行操作。\n3、依赖库需要添加多libicucore.dylib\n\n\nv1.3.15(2014-07-17)\n\n\n1、BmobQuery的- (void)getObjectInBackgroundWithId:(NSString \n)objectId\n                              block:(BmobObjectResultBlock)block\n也支持-(void)includeKey:(NSString \n)key跟-(void)selectKeys:(NSArray*)keys了\n\n\nv1.3.14(2014-07-14)\n\n\n1、修复2G网络下查询可能会crash的问题\n\n\nv1.3.13(2014-6-18)\n\n\n1、修正一些bug\n2、修正缓存查询可能存在的问题\n\n\nv1.3.12(2014-6-11)\n\n\n1、BmobQuery新增自定义查询条件接口：-(void)queryWithAllConstraint:(NSDictionary*)conDictionary;\n2、BmobQuery新增取消接口\n\n\nv1.3.11(2014-05-28)\n\n\n1、修复更新可能不成功的问题\n\n\nv1.3.10(2014-05-27)\n\n\n1、BmobFile类添加分片上传的方法\n2、添加BmobACL权限和BmobRole角色管理类\n3、添加BmobImage图像处理类，提供多种方法处理图像\n\n\nv1.3.9(2014-05-21)\n\n\n1、修复user表有关联关系，用户登录后更新不成功的问题\n\n\nv1.3.8 (2014-05-16)\n\n\n1、修复云端代码同步没返回的bug\n2、增加文件上传进度和取消上传函数\n3、修复添加SDK出现多个警告的问题\n\n\nv1.3.7(2014-04-30)\n\n\n1、增加BmobInstallation类别，注册需要推送设备。\n2、增加BmobPush功能模块，可进行自定义推送。\n\n\nv1.3.6(2014-04-23)\n\n\n1、BmobUser增加邮箱验证接口，只有在web端应用设置里开启邮箱验证才有效\n2、增加BmobObjectBatch类，批量修改数据\n\n\nv1.3.5(2014-04-18)\n\n\n1、添加x86_64位、arm64架构\n2、添加指针类型，和relation类型\n3、添加BmobObject对象列为Number时，可进行原子增加或减少的功能\n4、添加BmobRelation类，为BmobObject之类关联关系\n5、BmobQuery新增查询约束条件\n- (void)whereKey:(NSString \n)key matchesQuery:(BmobQuery \n)query;\n- (void)whereKey:(NSString \n)key doesNotMatchQuery:(BmobQuery \n)query;\n- (void)whereObjectKey:(NSString \n)key relatedTo:(BmobObject\n)object;\n\n\nv1.3.4（2014-04-10）\n\n\n1、Bmob.h 引入头文件\n\n\n#import \nBmobObject.h\n\n#import \nBmobFile.h\n\n#import \nBmobGeoPoint.h\n\n#import \nBmobQuery.h\n\n#import \nBmobUser.h\n\n#import \nBmobCloud.h\n\n#import \nBmobConfig.h\n\n\n\n\n\nv1.3.3（2014-04-08）\n\n\n1、增加组合查询并操作跟或操作\n\n\nv1.3.2(2014-04-06)\n\n\n1、修复[BmobUser getCurrentObject]与 之前版本不兼容的问题\n\n\nv1.3.1(2014-04-04)\n\n\n1、修复BmobFile url的相关bug\n2、增加BmobQuery约束条件：\n//  设置查询后要返回的key\n-(void)selectKeys:(NSArray\n)keys;\n//指定的key的值是存在的\n- (void)whereKeyExists:(NSString \n)key;\n// 指定的key的值是不存在的\n- (void)whereKeyDoesNotExist:(NSString *)key;\n\n\nv1.3.0\n\n\n1、修复BmobUser无法重置密码的bug\n\n\nv1.2.91\n\n\n1、修正一些bug\n\n\nv1.2.9\n\n\n1、Bmob类增加获取服务器时间接口\n\n\nv1.2.8\n\n\n1、修复登陆失败后没返回错误信息\n\n\nv1.2.7(2014-03-05)\n\n\n1、修复上传文件失败的bug\n2、修复BmobObject 函数-(void)setObject:(id)obj forKey:(NSString*)aKey;obj为nil时，crash的问题\n3、修复某些字符无法保存的问题\n4、修复BmobFile 路径没有文件时crash的问题\n5、BmobFile增加saveInBackground方法\n\n\nv1.2.6(2014-03-03)\n\n\n1、修复添加NSDate类型失败的问题\n\n\n2、BmobObject类添加-(void)saveAllWithDictionary:(NSDictionary*)dic;方法，支持批量添加数据\n\n\nv1.2.5\n\n\n(2014-02-25)\n1.修复在非主线程block没回调的问题\n\n\nv1.2.4\n\n\n(2014-02-24)\n1、使用自带访问网络的类替代部分第三方库，有base64、jsonkit、asihttprequest，减少冲突\n\n\n2、调用BmobObject 的saveInBackground和saveInBackgroundWithResultBlock函数后，回填objectId，createdAt,updatedAt等\n\n\nv1.2.3（2014-02-14）\n\n\n1.修复BmobUser 更新属性后本地没更新的bug\n\n\n2.修改地理位置查询，排序结果从近到远，而不是根据updateAt降序排序\n\n\nv1.2.2（2014-01-12）\n\n\n1.优化初始化函数\n\n\nv1.2.1（2014-01-02）\n\n\n1.新增云端代码功能\n2.优化性能，减少冗余\n\n\nv1.2.0（2013-12-02）\n\n\n1.更改静态库为framework，减少体积\n2.调整调用函数，更稳定更便捷\n3.增加完善部分错误信息回调接口\n\n\nv1.1.7(2013-11-27)\n\n\n1.解决打包出现的bug\n2.优化相关回调函数\n\n\nv1.1.6(2013-11-26)\n\n\n1、增加稳定性，优化代码结构\n\n\n2、BmobQuery增加查询用户函数+(BmobQuery*)queryForUser;\n\n\n3、新增加密码重置功能\n\n\n4、新增用户登陆功能，登陆成功返回个人信息\n5、新增接口请求数据统计\n\n\nv1.1.5(2013-11-06)\n\n\n1、修复在循环中使用BmobQuery:- (void)getObjectInBackgroundWithId:(NSString *)objectId\n                              block:(BmobObjectResultBlock)block;\n遇到的问题\n\n\nv1.1.4(2013-10-29)\n\n\n1、新增Count查询功能\n\n\n2、新增地理位置查询功能\n\n\n3、修改BmobGeo类初始化方法与web端显示不一致的问题\n\n\nv1.1.3(2013-10-17)\n\n\n1.修复BmobObject取特殊类型属性错误的bug\n2.修复上传时会更新createdAt的问题\n\n\nv1.1.2(2013-10-11)\n\n\n1、修复BmobObject类updatedAt、createdAt类型问题\n\n\nv1.1.1(2013-10-09)\n\n\n1、对网络传输的优化\n\n\nv1.1.0(2013-09-22)\n\n\n1、BmobFile类添加了初始化方法：-(id)initWithClassName:(NSString \n)className withFileData:(NSData\n)data;可以直接上传二进制数据；\n2、修复了BmobQuery类中- (void)findObjectsInBackgroundWithBlock:(BmobObjectArrayResultBlock)block;得到的数组中的对象不能更新的bug；", 
            "title": "更新日志"
        }, 
        {
            "location": "/data/ios/update_log/#v215-2017-2-17", 
            "text": "1.BmobObject setObject: bug 修复", 
            "title": "v2.1.5 (2017-2-17)"
        }, 
        {
            "location": "/data/ios/update_log/#v214-2017-2-16", 
            "text": "1.bug修复", 
            "title": "v2.1.4 (2017-2-16)"
        }, 
        {
            "location": "/data/ios/update_log/#v213-2017-2-10", 
            "text": "1.修复支付异常回调\n2.分离微信支付模块文件", 
            "title": "v2.1.3 (2017-2-10)"
        }, 
        {
            "location": "/data/ios/update_log/#v212-2017-2-8", 
            "text": "1.修改订单查询接口", 
            "title": "v2.1.2 (2017-2-8)"
        }, 
        {
            "location": "/data/ios/update_log/#v211-2017-2-6", 
            "text": "1.添加支付订单信息回调接口\n2.修复user类achieve失败的bug", 
            "title": "v2.1.1 (2017-2-6)"
        }, 
        {
            "location": "/data/ios/update_log/#v210-2017-1-20", 
            "text": "1.修复模块重复问题", 
            "title": "v2.1.0 (2017-1-20)"
        }, 
        {
            "location": "/data/ios/update_log/#v208-2017-1-19", 
            "text": "1.添加微信支付功能", 
            "title": "v2.0.8 (2017-1-19)"
        }, 
        {
            "location": "/data/ios/update_log/#v207-2017-1-18", 
            "text": "1.Bug修复", 
            "title": "v2.0.7 (2017-1-18)"
        }, 
        {
            "location": "/data/ios/update_log/#v206-2017-1-17", 
            "text": "1.Bug修复", 
            "title": "v2.0.6 (2017-1-17)"
        }, 
        {
            "location": "/data/ios/update_log/#v205-2017-1-17", 
            "text": "1.Bug修复\n2.取消xib，该用纯代码实现支付界面\n3.扩展iOS6-iOS7支持", 
            "title": "v2.0.5 (2017-1-17)"
        }, 
        {
            "location": "/data/ios/update_log/#v204-2017-1-14", 
            "text": "1.Bug修复", 
            "title": "v2.0.4 (2017-1-14)"
        }, 
        {
            "location": "/data/ios/update_log/#v203-2017-1-14", 
            "text": "1.Bug修复", 
            "title": "v2.0.3 (2017-1-14)"
        }, 
        {
            "location": "/data/ios/update_log/#v202-2017-1-13", 
            "text": "1.添加支付宝支付", 
            "title": "v2.0.2 (2017-1-13)"
        }, 
        {
            "location": "/data/ios/update_log/#v201-2016-12-05", 
            "text": "1.修复更新个人资料可能会crash的问题", 
            "title": "v2.0.1 (2016-12-05)"
        }, 
        {
            "location": "/data/ios/update_log/#v200-2016-11-25", 
            "text": "1.全面支持https服务", 
            "title": "v2.0.0 (2016-11-25)"
        }, 
        {
            "location": "/data/ios/update_log/#v173-2016-11-9", 
            "text": "1.添加动态更新功能\n2.适配新的短信服务", 
            "title": "v1.7.3 (2016-11-9)"
        }, 
        {
            "location": "/data/ios/update_log/#v172-2016-07-18", 
            "text": "1.替换BmobProFile 内部下载的方法，减少SDK的体积\n2.修复BmobFile上传后可能name为空的问题\n3.修复文件上传内存泄漏的问题", 
            "title": "v1.7.2 (2016-07-18)"
        }, 
        {
            "location": "/data/ios/update_log/#v171-2016-06-08", 
            "text": "1.修改BmobQuery 取消方法错误拼写\n2.修改BmobObject objectWithoutDatatWithClassName方法拼写错误\n3.BmobObject+subclass 增加+(instancetype)covertWithObject:(BmobObject *)obj; 方便在swift调用\n4.修复更新个人资料可能会报用户名已存在的问题\n5.修复有ACL导致的更新不成功的问题", 
            "title": "v1.7.1 (2016-06-08)"
        }, 
        {
            "location": "/data/ios/update_log/#v170-2016-04-22", 
            "text": "1.恢复BmobProFile文件下载的功能\n2.恢复云端代码同步接口（请在子线程使用），新增+(id)callFunction:(NSString  )function withParameters:(NSDictionary  )parameters error:(NSError **)error;返回错误信息\n3.Bmob类新增设置文件上传的授权时间和分片大小\n4.BmobInstallation类去掉currentInstallation(命名让人误会)，用installation代替(单纯创建一个BmobInstallation对象).", 
            "title": "v1.7.0 (2016-04-22)"
        }, 
        {
            "location": "/data/ios/update_log/#v169-2016-04-14", 
            "text": "1.文件服务更换为CDN上传,废除新旧文件上传服务\n2.新增文件批量删除接口\n3.去掉调用云端代码同步的方法\n4.BmobUser 设置用户名变为setUsername:(NSString *)username\n5.更换网络请求库为NSURLSession\n6.修复设置超时时间没有反馈的bug\n7.修复某些回调不在主线程的问题", 
            "title": "v1.6.9 (2016-04-14)"
        }, 
        {
            "location": "/data/ios/update_log/#v168-2016-03-31", 
            "text": "1.修复上一个版本用户可能无法更新资料和实时监控的问题", 
            "title": "v1.6.8 (2016-03-31)"
        }, 
        {
            "location": "/data/ios/update_log/#v167-2016-03-18", 
            "text": "1.修复注销登录后的bug\n2.修复请求完成后，偶然会崩溃的的bug", 
            "title": "v1.6.7 (2016-03-18)"
        }, 
        {
            "location": "/data/ios/update_log/#v166-2015-12-23", 
            "text": "1.添加封装的复合查询方法\n2.原子计数器支持浮点数\n3.修复网络环境较差时出现崩溃bug", 
            "title": "v1.6.6 (2015-12-23)"
        }, 
        {
            "location": "/data/ios/update_log/#v165-2015-10-08", 
            "text": "1.支持bitcode操作；\n2.添加从字典初始化BmobObject方法；\n3.添加单独修改JSON对象某个key-value对的功能。", 
            "title": "v1.6.5 (2015-10-08)"
        }, 
        {
            "location": "/data/ios/update_log/#v164-2015-08-27", 
            "text": "1.修改注册后没返回objectId的问题", 
            "title": "v1.6.4 (2015-08-27)"
        }, 
        {
            "location": "/data/ios/update_log/#v163-2015-08-24", 
            "text": "1.添加根据旧密码修改新密码接口；\n2.添加手机验证码注册时可同时添加新密码或者是其它user列的信息接口；\n3.修改上传多个图片时偶然冲突导致上传失败的bug。", 
            "title": "v1.6.3 (2015-08-24)"
        }, 
        {
            "location": "/data/ios/update_log/#v162-2015-08-18", 
            "text": "1.修复缩略图无法返回的问题;\n2.修复上传图片时，文件路径有误时应用出错的问题。", 
            "title": "v1.6.2 (2015-08-18)"
        }, 
        {
            "location": "/data/ios/update_log/#v1612015-07-27", 
            "text": "1.修复使用账号密码注册时无法上传手机号的bug；\n2.开放获取表结构的接口。", 
            "title": "v1.6.1（2015-07-27）"
        }, 
        {
            "location": "/data/ios/update_log/#v1602015-07-14", 
            "text": "1.文件上传兼容旧文件系统\n1）修改上传文件接口\n2）添加获取已经上传文件访问url接口\n3）删除已上传文件接口\n2.修复子类化bug\n3.添加数组查询接口\n4.修复文件上传下载接口如果传空block会报错的bug", 
            "title": "v1.6.0（2015-07-14）"
        }, 
        {
            "location": "/data/ios/update_log/#v1592015-07-01", 
            "text": "1.提供修改超时间接口\n2.修复子类化bug\n3.修复实时监听bug\n4.提供自定义短信内容发送功能", 
            "title": "v1.5.9（2015-07-01）"
        }, 
        {
            "location": "/data/ios/update_log/#v1582015-06-12", 
            "text": "1.添加短信功能\n2.添加BmobObject子类化功能\n3.修复缓存查询部分bug\n4.修复云端代码无法同步bug\n5.第三方登录添加微信登录", 
            "title": "v1.5.8（2015-06-12）"
        }, 
        {
            "location": "/data/ios/update_log/#v1572015-05-14", 
            "text": "1.添加BQL查询功能\n2.开放模糊查询功能", 
            "title": "v1.5.7（2015-05-14）"
        }, 
        {
            "location": "/data/ios/update_log/#v1562015-05-04", 
            "text": "1.修改文件操作头文件部分注释；\n2.修复模拟器下有时无法上传文件的问题。", 
            "title": "v1.5.6（2015-05-04）"
        }, 
        {
            "location": "/data/ios/update_log/#v1552015-04-24", 
            "text": "1.增加统计查询方法\n2.修复部分bug", 
            "title": "v1.5.5（2015-04-24）"
        }, 
        {
            "location": "/data/ios/update_log/#v154-2015-04-07", 
            "text": "1.增加批量上传方法\nBmobFile\n+(void)filesUploadBatchWithDataArray:(NSArray *)dataArray\n                       progressBlock:(BmobFileBatchProgressBlock)progress\n                         resultBlock:(BmobFileBatchResultBlock)block;  BmobFilePro\n+(void)uploadFilesWithDatas:(NSArray *)dataArray\n                resultBlock:(BmobBatchFileUploadResultBlock)block\n                   progress:(BmobIndexAndProgressBlock)progress;\n2.修复其他问题", 
            "title": "v1.5.4 (2015-04-07)"
        }, 
        {
            "location": "/data/ios/update_log/#v153-2015-03-05", 
            "text": "1.修复蜂窝网络下可能会出现的使用新版文件上传文件，上传不了的问题\n2.修复在某些情况下用户可能无法更新表内容的问题", 
            "title": "v1.5.3 (2015-03-05)"
        }, 
        {
            "location": "/data/ios/update_log/#v152-2015-02-07", 
            "text": "1.兼容1.5.1跟1.5.1之前的版本，即可以监听到通知再调用请求方法，也可以直接调用请求方法", 
            "title": "v1.5.2 (2015-02-07)"
        }, 
        {
            "location": "/data/ios/update_log/#v151-2015-01-23", 
            "text": "1.添加初始化完成后通知kBmobInitSuccessNotification，kBmobInitFailNotification\n2.修改更新用户后本地用户可能会为空的问题\n注意：\n因为1.5.0之后的版本新增了加密功能，所以在还没初始化完成的时候请求接口会出现问题。\n故开发者可以监听此通知，获取成功通知的时候再进行其他接口的请求。", 
            "title": "v1.5.1 (2015-01-23)"
        }, 
        {
            "location": "/data/ios/update_log/#v150-2015-01-17", 
            "text": "1.增加数据加密，建议使用新版本\n2.BmobProFile添加开启验证后得到的url方法", 
            "title": "v1.5.0 (2015-01-17)"
        }, 
        {
            "location": "/data/ios/update_log/#v14132015-01-05", 
            "text": "1.新增文件管理类BmobProFile，提供多种上传方法等", 
            "title": "v1.4.13(2015-01-05)"
        }, 
        {
            "location": "/data/ios/update_log/#v14122014-12-25", 
            "text": "1.修复无网络时获取服务器时间出现的问题", 
            "title": "v1.4.12(2014-12-25)"
        }, 
        {
            "location": "/data/ios/update_log/#v14112014-12-17", 
            "text": "1.修改安全认证方法，注册方式可换回原来的方法,建议使用新版本\n NSString *appKey = @\"xxxx\";\n[Bmob registerWithAppKey:appKey];\n2.修复云端代码同步方法与异步方法数据格式不一样的问题", 
            "title": "v1.4.11(2014-12-17)"
        }, 
        {
            "location": "/data/ios/update_log/#v14102014-12-9", 
            "text": "1.增加安全认证的功能，注册应用方式修改为      NSString *appKey = @ xxxx ;\n#if DEBUG\n    [Bmob registerWithAppKey:appKey];\n#else\n    [Bmob registerWithAppKeyReleaseMode:appKey];\n#endif  2.文件分片上传功能新增进度的方法。进度的范围为（0.0f-1.0f）\n3.新增批量上传的方法\n4.BmobQuery新增-(void)whereKeySExists:(NSArray  )keys;\n和-(void)whereKeysDoesNotExist:(NSArray  )keys; 方法", 
            "title": "v1.4.10(2014-12-9)"
        }, 
        {
            "location": "/data/ios/update_log/#v149-2014-10-20", 
            "text": "1.修复openudid冲突的问题", 
            "title": "v1.4.9 (2014-10-20)"
        }, 
        {
            "location": "/data/ios/update_log/#v148-2014-10-11", 
            "text": "1.修复用户更新函数在iOS6下可能出现的崩溃问题\n2.修复已知的查询函数可能进入不了block的问题", 
            "title": "v1.4.8 (2014-10-11)"
        }, 
        {
            "location": "/data/ios/update_log/#v147-2014-10-10", 
            "text": "1.修复云端代码的问题", 
            "title": "v1.4.7 (2014-10-10)"
        }, 
        {
            "location": "/data/ios/update_log/#v146-2014-09-22", 
            "text": "修复本地缓存用户，更新后本地基本数据类型不一致的问题", 
            "title": "v1.4.6 (2014-09-22)"
        }, 
        {
            "location": "/data/ios/update_log/#v1452014-09-17", 
            "text": "修复一些问题及优化结构", 
            "title": "v1.4.5(2014-09-17)"
        }, 
        {
            "location": "/data/ios/update_log/#v1442014-09-12", 
            "text": "修复v1.4.3的一些问题", 
            "title": "v1.4.4(2014-09-12)"
        }, 
        {
            "location": "/data/ios/update_log/#v1432014-09-04", 
            "text": "1.批量添加批量更新，也能增加特殊类型", 
            "title": "v1.4.3(2014-09-04)"
        }, 
        {
            "location": "/data/ios/update_log/#v142-2014-08-20", 
            "text": "1.BmobUser 添加获取邮箱是否已验证的方法\n2.修复BmobUser有可能更新不成功的问题", 
            "title": "v1.4.2 (2014-08-20)"
        }, 
        {
            "location": "/data/ios/update_log/#v141-2014-08-05", 
            "text": "BmobUser类增加：\n1.QQ，新浪微博账号注册登录Bmob的功能\n2.关联QQ账号，微博账号功能\n3.提供取消关联的功能", 
            "title": "v1.4.1 (2014-08-05)"
        }, 
        {
            "location": "/data/ios/update_log/#v140-2014-07-18", 
            "text": "1、增加数据实时功能，提供多种监听表变化的方法。\n2、增加BmobEvent类别，监听事件后，开发者可在代理函数里进行操作。\n3、依赖库需要添加多libicucore.dylib", 
            "title": "v1.4.0 (2014-07-18)"
        }, 
        {
            "location": "/data/ios/update_log/#v13152014-07-17", 
            "text": "1、BmobQuery的- (void)getObjectInBackgroundWithId:(NSString  )objectId\n                              block:(BmobObjectResultBlock)block\n也支持-(void)includeKey:(NSString  )key跟-(void)selectKeys:(NSArray*)keys了", 
            "title": "v1.3.15(2014-07-17)"
        }, 
        {
            "location": "/data/ios/update_log/#v13142014-07-14", 
            "text": "1、修复2G网络下查询可能会crash的问题", 
            "title": "v1.3.14(2014-07-14)"
        }, 
        {
            "location": "/data/ios/update_log/#v13132014-6-18", 
            "text": "1、修正一些bug\n2、修正缓存查询可能存在的问题", 
            "title": "v1.3.13(2014-6-18)"
        }, 
        {
            "location": "/data/ios/update_log/#v13122014-6-11", 
            "text": "1、BmobQuery新增自定义查询条件接口：-(void)queryWithAllConstraint:(NSDictionary*)conDictionary;\n2、BmobQuery新增取消接口", 
            "title": "v1.3.12(2014-6-11)"
        }, 
        {
            "location": "/data/ios/update_log/#v13112014-05-28", 
            "text": "1、修复更新可能不成功的问题", 
            "title": "v1.3.11(2014-05-28)"
        }, 
        {
            "location": "/data/ios/update_log/#v13102014-05-27", 
            "text": "1、BmobFile类添加分片上传的方法\n2、添加BmobACL权限和BmobRole角色管理类\n3、添加BmobImage图像处理类，提供多种方法处理图像", 
            "title": "v1.3.10(2014-05-27)"
        }, 
        {
            "location": "/data/ios/update_log/#v1392014-05-21", 
            "text": "1、修复user表有关联关系，用户登录后更新不成功的问题", 
            "title": "v1.3.9(2014-05-21)"
        }, 
        {
            "location": "/data/ios/update_log/#v138-2014-05-16", 
            "text": "1、修复云端代码同步没返回的bug\n2、增加文件上传进度和取消上传函数\n3、修复添加SDK出现多个警告的问题", 
            "title": "v1.3.8 (2014-05-16)"
        }, 
        {
            "location": "/data/ios/update_log/#v1372014-04-30", 
            "text": "1、增加BmobInstallation类别，注册需要推送设备。\n2、增加BmobPush功能模块，可进行自定义推送。", 
            "title": "v1.3.7(2014-04-30)"
        }, 
        {
            "location": "/data/ios/update_log/#v1362014-04-23", 
            "text": "1、BmobUser增加邮箱验证接口，只有在web端应用设置里开启邮箱验证才有效\n2、增加BmobObjectBatch类，批量修改数据", 
            "title": "v1.3.6(2014-04-23)"
        }, 
        {
            "location": "/data/ios/update_log/#v1352014-04-18", 
            "text": "1、添加x86_64位、arm64架构\n2、添加指针类型，和relation类型\n3、添加BmobObject对象列为Number时，可进行原子增加或减少的功能\n4、添加BmobRelation类，为BmobObject之类关联关系\n5、BmobQuery新增查询约束条件\n- (void)whereKey:(NSString  )key matchesQuery:(BmobQuery  )query;\n- (void)whereKey:(NSString  )key doesNotMatchQuery:(BmobQuery  )query;\n- (void)whereObjectKey:(NSString  )key relatedTo:(BmobObject )object;", 
            "title": "v1.3.5(2014-04-18)"
        }, 
        {
            "location": "/data/ios/update_log/#v1342014-04-10", 
            "text": "1、Bmob.h 引入头文件  #import  BmobObject.h \n#import  BmobFile.h \n#import  BmobGeoPoint.h \n#import  BmobQuery.h \n#import  BmobUser.h \n#import  BmobCloud.h \n#import  BmobConfig.h", 
            "title": "v1.3.4（2014-04-10）"
        }, 
        {
            "location": "/data/ios/update_log/#v1332014-04-08", 
            "text": "1、增加组合查询并操作跟或操作", 
            "title": "v1.3.3（2014-04-08）"
        }, 
        {
            "location": "/data/ios/update_log/#v1322014-04-06", 
            "text": "1、修复[BmobUser getCurrentObject]与 之前版本不兼容的问题", 
            "title": "v1.3.2(2014-04-06)"
        }, 
        {
            "location": "/data/ios/update_log/#v1312014-04-04", 
            "text": "1、修复BmobFile url的相关bug\n2、增加BmobQuery约束条件：\n//  设置查询后要返回的key\n-(void)selectKeys:(NSArray )keys;\n//指定的key的值是存在的\n- (void)whereKeyExists:(NSString  )key;\n// 指定的key的值是不存在的\n- (void)whereKeyDoesNotExist:(NSString *)key;", 
            "title": "v1.3.1(2014-04-04)"
        }, 
        {
            "location": "/data/ios/update_log/#v130", 
            "text": "1、修复BmobUser无法重置密码的bug", 
            "title": "v1.3.0"
        }, 
        {
            "location": "/data/ios/update_log/#v1291", 
            "text": "1、修正一些bug", 
            "title": "v1.2.91"
        }, 
        {
            "location": "/data/ios/update_log/#v129", 
            "text": "1、Bmob类增加获取服务器时间接口", 
            "title": "v1.2.9"
        }, 
        {
            "location": "/data/ios/update_log/#v128", 
            "text": "1、修复登陆失败后没返回错误信息", 
            "title": "v1.2.8"
        }, 
        {
            "location": "/data/ios/update_log/#v1272014-03-05", 
            "text": "1、修复上传文件失败的bug\n2、修复BmobObject 函数-(void)setObject:(id)obj forKey:(NSString*)aKey;obj为nil时，crash的问题\n3、修复某些字符无法保存的问题\n4、修复BmobFile 路径没有文件时crash的问题\n5、BmobFile增加saveInBackground方法", 
            "title": "v1.2.7(2014-03-05)"
        }, 
        {
            "location": "/data/ios/update_log/#v1262014-03-03", 
            "text": "1、修复添加NSDate类型失败的问题  2、BmobObject类添加-(void)saveAllWithDictionary:(NSDictionary*)dic;方法，支持批量添加数据", 
            "title": "v1.2.6(2014-03-03)"
        }, 
        {
            "location": "/data/ios/update_log/#v125", 
            "text": "(2014-02-25)\n1.修复在非主线程block没回调的问题", 
            "title": "v1.2.5"
        }, 
        {
            "location": "/data/ios/update_log/#v124", 
            "text": "(2014-02-24)\n1、使用自带访问网络的类替代部分第三方库，有base64、jsonkit、asihttprequest，减少冲突  2、调用BmobObject 的saveInBackground和saveInBackgroundWithResultBlock函数后，回填objectId，createdAt,updatedAt等", 
            "title": "v1.2.4"
        }, 
        {
            "location": "/data/ios/update_log/#v1232014-02-14", 
            "text": "1.修复BmobUser 更新属性后本地没更新的bug  2.修改地理位置查询，排序结果从近到远，而不是根据updateAt降序排序", 
            "title": "v1.2.3（2014-02-14）"
        }, 
        {
            "location": "/data/ios/update_log/#v1222014-01-12", 
            "text": "1.优化初始化函数", 
            "title": "v1.2.2（2014-01-12）"
        }, 
        {
            "location": "/data/ios/update_log/#v1212014-01-02", 
            "text": "1.新增云端代码功能\n2.优化性能，减少冗余", 
            "title": "v1.2.1（2014-01-02）"
        }, 
        {
            "location": "/data/ios/update_log/#v1202013-12-02", 
            "text": "1.更改静态库为framework，减少体积\n2.调整调用函数，更稳定更便捷\n3.增加完善部分错误信息回调接口", 
            "title": "v1.2.0（2013-12-02）"
        }, 
        {
            "location": "/data/ios/update_log/#v1172013-11-27", 
            "text": "1.解决打包出现的bug\n2.优化相关回调函数", 
            "title": "v1.1.7(2013-11-27)"
        }, 
        {
            "location": "/data/ios/update_log/#v1162013-11-26", 
            "text": "1、增加稳定性，优化代码结构  2、BmobQuery增加查询用户函数+(BmobQuery*)queryForUser;  3、新增加密码重置功能  4、新增用户登陆功能，登陆成功返回个人信息\n5、新增接口请求数据统计", 
            "title": "v1.1.6(2013-11-26)"
        }, 
        {
            "location": "/data/ios/update_log/#v1152013-11-06", 
            "text": "1、修复在循环中使用BmobQuery:- (void)getObjectInBackgroundWithId:(NSString *)objectId\n                              block:(BmobObjectResultBlock)block;\n遇到的问题", 
            "title": "v1.1.5(2013-11-06)"
        }, 
        {
            "location": "/data/ios/update_log/#v1142013-10-29", 
            "text": "1、新增Count查询功能  2、新增地理位置查询功能  3、修改BmobGeo类初始化方法与web端显示不一致的问题", 
            "title": "v1.1.4(2013-10-29)"
        }, 
        {
            "location": "/data/ios/update_log/#v1132013-10-17", 
            "text": "1.修复BmobObject取特殊类型属性错误的bug\n2.修复上传时会更新createdAt的问题", 
            "title": "v1.1.3(2013-10-17)"
        }, 
        {
            "location": "/data/ios/update_log/#v1122013-10-11", 
            "text": "1、修复BmobObject类updatedAt、createdAt类型问题", 
            "title": "v1.1.2(2013-10-11)"
        }, 
        {
            "location": "/data/ios/update_log/#v1112013-10-09", 
            "text": "1、对网络传输的优化", 
            "title": "v1.1.1(2013-10-09)"
        }, 
        {
            "location": "/data/ios/update_log/#v1102013-09-22", 
            "text": "1、BmobFile类添加了初始化方法：-(id)initWithClassName:(NSString  )className withFileData:(NSData )data;可以直接上传二进制数据；\n2、修复了BmobQuery类中- (void)findObjectsInBackgroundWithBlock:(BmobObjectArrayResultBlock)block;得到的数组中的对象不能更新的bug；", 
            "title": "v1.1.0(2013-09-22)"
        }, 
        {
            "location": "/data/wechat_app/", 
            "text": "注册Bmob帐号\n\n\n在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。\n\n\n\n\n网站后台创建应用\n\n\n登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。\n\n\n\n\n配置小程序密钥和获取应用密钥\n\n\n选择你要开发的应用，进入该应用\n\n\n\n\n在跳转页面，进入设置/应用密钥，将你的AppID(小程序ID)和AppSecret(小程序密钥)填写到Bmob中\n\n\n\n\n\n\n在下图位置点击复制，即可得到Application ID和REST API Key\n\n\n\n\n获取Application ID和REST API Key后，下载SDK。\n\n\n配置安全域名\n\n\n在你的微信小程序后台配置你的服务器域名\n\n\n\n\n下载和安装BmobSDK\n\n\n一、把\"bmob-min.js\"和\"underscore.js\"放到相应的文件，例如放到utils中，在其他页面添加以下代码\n\n\nvar Bmob = require('../../utils/bmob.js');\n\n\n\n\n二、接着是在app.js中加入下面两行代码进行全局初始化\n\n\nvar Bmob = require('utils/bmob.js');\nBmob.initialize(\n你的Application ID\n, \n你的REST API Key\n);\n\n\n\n\n\n添加一行数据\n\n\n添加数据\n\n\n\n      var Diary = Bmob.Object.extend(\ndiary\n);\n      var diary = new Diary();\n      diary.set(\ntitle\n,\nhello\n);\n      diary.set(\ncontent\n,\nhello world\n);\n      //添加数据，第一个入口参数是null\n      diary.save(null, {\n        success: function(result) {\n          // 添加成功，返回成功之后的objectId（注意：返回的属性名字是id，不是objectId），你还可以在Bmob的Web管理后台看到对应的数据\n            console.log(\n日记创建成功, objectId:\n+result.id);\n        },\n        error: function(result, error) {\n          // 添加失败\n          console.log('创建日记失败');\n\n        }\n      });\n\n\n\n\n获取一行数据\n\n\n\n    var Diary = Bmob.Object.extend(\ndiary\n);\n    var query = new Bmob.Query(Diary);\n    query.get(\n4edc3f6ee9\n, {\n      success: function(result) {\n        // The object was retrieved successfully.\n        console.log(\n该日记标题为\n+result.get(\ntitle\n));\n      },\n      error: function(result, error) {\n        console.log(\n查询失败\n);\n      }\n    });\n\n\n\n\n修改一行数据\n\n\n\n    var Diary = Bmob.Object.extend(\ndiary\n);\n    var query = new Bmob.Query(Diary);\n    // 这个 id 是要修改条目的 id，你在生成这个存储并成功时可以获取到，请看前面的文档\n    query.get(\n4edc3f6ee9\n, {\n        success: function(result) {\n          // 回调中可以取得这个 diary 对象的一个实例，然后就可以修改它了\n          result.set('title',\n我是title\n);\n          result.set('content',\n我是content\n);\n          result.save();\n          // The object was retrieved successfully.\n        },\n        error: function(object, error) {\n\n        }\n    });\n\n\n\n\n删除一行数据\n\n\n\n    var Diary = Bmob.Object.extend(\ndiary\n);\n    var query = new Bmob.Query(Diary);\n    query.get(objectId, {\n      success: function(object) {\n        // The object was retrieved successfully.\n        object.destroy({\n          success: function(deleteObject) {\n            console.log('删除日记成功');\n          },\n          error: function(object, error) {\n            console.log('删除日记失败');\n          }\n        });\n      },\n      error: function(object, error) {\n        alert(\nquery object fail\n);\n      }\n    });\n\n\n\n\n源码下载\n\n\n快速入门相关源码下载", 
            "title": "快速入门"
        }, 
        {
            "location": "/data/wechat_app/#bmob", 
            "text": "在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。", 
            "title": "注册Bmob帐号"
        }, 
        {
            "location": "/data/wechat_app/#_1", 
            "text": "登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。", 
            "title": "网站后台创建应用"
        }, 
        {
            "location": "/data/wechat_app/#_2", 
            "text": "选择你要开发的应用，进入该应用   在跳转页面，进入设置/应用密钥，将你的AppID(小程序ID)和AppSecret(小程序密钥)填写到Bmob中    在下图位置点击复制，即可得到Application ID和REST API Key   获取Application ID和REST API Key后，下载SDK。", 
            "title": "配置小程序密钥和获取应用密钥"
        }, 
        {
            "location": "/data/wechat_app/#_3", 
            "text": "在你的微信小程序后台配置你的服务器域名", 
            "title": "配置安全域名"
        }, 
        {
            "location": "/data/wechat_app/#bmobsdk", 
            "text": "一、把\"bmob-min.js\"和\"underscore.js\"放到相应的文件，例如放到utils中，在其他页面添加以下代码  var Bmob = require('../../utils/bmob.js');  二、接着是在app.js中加入下面两行代码进行全局初始化  var Bmob = require('utils/bmob.js');\nBmob.initialize( 你的Application ID ,  你的REST API Key );", 
            "title": "下载和安装BmobSDK"
        }, 
        {
            "location": "/data/wechat_app/#_4", 
            "text": "添加数据  \n      var Diary = Bmob.Object.extend( diary );\n      var diary = new Diary();\n      diary.set( title , hello );\n      diary.set( content , hello world );\n      //添加数据，第一个入口参数是null\n      diary.save(null, {\n        success: function(result) {\n          // 添加成功，返回成功之后的objectId（注意：返回的属性名字是id，不是objectId），你还可以在Bmob的Web管理后台看到对应的数据\n            console.log( 日记创建成功, objectId: +result.id);\n        },\n        error: function(result, error) {\n          // 添加失败\n          console.log('创建日记失败');\n\n        }\n      });", 
            "title": "添加一行数据"
        }, 
        {
            "location": "/data/wechat_app/#_5", 
            "text": "var Diary = Bmob.Object.extend( diary );\n    var query = new Bmob.Query(Diary);\n    query.get( 4edc3f6ee9 , {\n      success: function(result) {\n        // The object was retrieved successfully.\n        console.log( 该日记标题为 +result.get( title ));\n      },\n      error: function(result, error) {\n        console.log( 查询失败 );\n      }\n    });", 
            "title": "获取一行数据"
        }, 
        {
            "location": "/data/wechat_app/#_6", 
            "text": "var Diary = Bmob.Object.extend( diary );\n    var query = new Bmob.Query(Diary);\n    // 这个 id 是要修改条目的 id，你在生成这个存储并成功时可以获取到，请看前面的文档\n    query.get( 4edc3f6ee9 , {\n        success: function(result) {\n          // 回调中可以取得这个 diary 对象的一个实例，然后就可以修改它了\n          result.set('title', 我是title );\n          result.set('content', 我是content );\n          result.save();\n          // The object was retrieved successfully.\n        },\n        error: function(object, error) {\n\n        }\n    });", 
            "title": "修改一行数据"
        }, 
        {
            "location": "/data/wechat_app/#_7", 
            "text": "var Diary = Bmob.Object.extend( diary );\n    var query = new Bmob.Query(Diary);\n    query.get(objectId, {\n      success: function(object) {\n        // The object was retrieved successfully.\n        object.destroy({\n          success: function(deleteObject) {\n            console.log('删除日记成功');\n          },\n          error: function(object, error) {\n            console.log('删除日记失败');\n          }\n        });\n      },\n      error: function(object, error) {\n        alert( query object fail );\n      }\n    });", 
            "title": "删除一行数据"
        }, 
        {
            "location": "/data/wechat_app/#_8", 
            "text": "快速入门相关源码下载", 
            "title": "源码下载"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/", 
            "text": "简介\n\n\nBmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。\n\n\n典型案例\n\n\nBmob示例包含常用接口（学习示例）：\nhttps://github.com/magic007/wechatAppDemo\n （采用实时数据同步SDK开发，里面几乎包含了小程序开发常见功能示例代码，右击可直接查看源码）\n扫描二维码查看\n\n\n\n\n\n\n\n心邮（官方线上项目）：\nhttps://github.com/bmob/Bmob-wechatapp-xinyou\n （采用实时数据同步SDK开发，右击可直接查看源码）\n\n\n\n\n\n\n1.生日工具                    -------工具类\n\n\n2.足迹地图\n\n\n3.接力喵视频                -------视频类\n\n\n4.像素涂鸦\n\n\n5.地道美食地图           -------LBS\n\n\n6.胖熊圈\n\n\n7.有货Hk\n\n\n8.厦漳泉生活通               -------本地生活\n\n\n9.极简笔记\n\n\n10.衣在线                  -------商城\n\n\n11.活动报名表                -------工具类\n\n\n12.味蕾点餐               -------点餐\n\n\n13.烟台微拼               -------本地生活\n\n\n14.顺德便利贴\n\n\n15.同城生活广告\n\n\n16.点点英语学堂\n\n\n17.朝露时刻               -------音频类\n\n\n18.青岛一起秀科学俱乐部\n\n\n19.纸塘                 -------17年6月最热门的小程序\n\n\n20.雷湖古琴艺术\n\n\n21.皋城文明随手拍   -----政府\n\n\n22.阅后即焚图片分享\n\n\n23.猎位共享停车\n\n\n24.听写宝\n\n\n25.嘿车出行\n\n\n26.喵星人宠物社区\n\n\n27.标签生成器\n\n\n28.视频看房\n\n\n29.海南黎家特产\n\n\n30.轩宇工具\n\n\n31.在旅途看世界\n\n\n32.寻遍美食地图\n\n\n33.Bmob示例\n\n\n34.鲁山拼车\n\n\n33.莲馨图书室          图书馆-扫描借书\n\n\n34.灵动云课堂\n\n\n35.9cam     视频类\n\n\n36.恋爱迹\n\n\n37.融信品质生活服务\n\n\n38.全民摄影秀\n\n\n39.农电微服务    国家电网公司\n\n\n40.壁纸印象\n\n\n41.跟妆师\n\n\n42.高能名片\n\n\n43.婚纱lite\n\n\n44.张阿姨打扫\n\n\n45.吃决策\n\n\n46.比心比价\n\n\n47.蜂鸟作业               教育\n\n\n48.美味面包lite\n\n\n51.幸福的5班\n\n\n52.大武汉公交               交通\n\n\n53.Buy优选                  淘客\n\n\n54.码赚\n\n\n55.附近的圈子\n\n\n56.吴忠意大利冰淇淋          实体店点餐\n\n\n57.摩西讲单词     教育\n\n\n58.贝莱福居\n\n\n59.花间集鲜花\n\n\n60.柏亚阅读书吧\n\n\n61.找我跑腿服务\n\n\n62.橙色工地圈\n\n\n63.大学城活动报名\n\n\n64.聚合助手\n\n\n65.圆桌绿色版\n\n\n66.我的王者名片\n\n\n67.趣猫\n\n\n68.管图智能选座          大学图书馆\n\n\n69.呼伦贝尔二手车平台\n\n\n70.我的王者名片\n\n\n71.万能服           答题应用\n\n\n官方交流QQ群：118541934 。欢迎提交给我们\n\n\n\n\n\n\n\n\n应用程序\n\n\n在Bmob平台注册后，每个账户可创建多个应用程序，创建的每个应用程序都有其独自的应用程序ID，此后所有的应用程序将凭其ID进行Bmob SDK的使用。即使只有一个应用程序，也可以以不同的版本进行测试和生产。\n\n\n对象\n\n\n数据对象\n\n\nBmob数据存储是建立在\nBmob.Object\n基础上的。如写日记的\nBmob.Object\n示例如下：\n\n\ntitle: \nI am title\n, content: \nI am content\n\n\n\n\n\n这里需要注意的是：anchor\n\n\n\n\n键必须是字母或者数字的字符串，值可以是字符串、数字、布尔值或者数组和字典。\n\n\n每一个\nBmob.Object\n都是一个特定子类的实例，子类名可以来区分各种数据，如我们可以把写日记的类称之为\ndiary\n。\n\n\n\n\n创建对象\n\n\n你可以使用\nBmob.Object.extend\n方法来创建新的\nBmob.Object\n子类，示例代码如下：\n\n\n\n    // 创建Bmob.Object子类\n    var Diary = Bmob.Object.extend(\ndiary\n);\n\n    // 创建该类的一个实例\n    var diary = new Diary();\n\n\n\n\n\n如果你想为\nBmob.Object\n的子类添加一些实例方法和类方法，示例代码如下：\n\n\n\n    // 为Bmob.Object的子类添加实例方法和类方法\n    var Diary = Bmob.Object.extend(\ndiary\n, {\n      //实例方法\n      gleaterThanOneHundred: function() {\n        return this.get(\ntitle\n);\n      }\n    }, {\n      //类方法\n      spawn: function(title) {\n        var diary = new Diary();\n        diary.set(\ntitle\n, title);\n        return diary;\n      }\n    });\n\n    var diary = Diary.spawn(\nhello world\n);\n    console.log(diary.gleaterThanOneHundred());\n\n\n\n\n小程序使用图文素材\n\n\n图文素材，类似微信的图文素材，经常被用在活动、广告、详细说明等情况。\n使用图文素材系统会生成一个\n_Article\n 的数据表。如需取出图文素材的数据，只需跟普通表一样操作即可。\n\n\n增加一篇图文\n\n\n\n   var Diary = Bmob.Object.extend(\n_Article\n);\n      var diary = new Diary();\n      diary.set(\ntitle\n,\nhello\n);\n      diary.set(\ncontent\n,\nhello world\n);\n      //添加数据，第一个入口参数是null\n      diary.save(null, {\n        success: function(result) {\n          // 添加成功，返回成功之后的objectId（注意：返回的属性名字是id，不是objectId），你还可以在Bmob的Web管理后台看到对应的数据\n            console.log(\n创建成功, objectId:\n+result.id);\n        },\n        error: function(result, error) {\n          // 添加失败\n          console.log('创建失败');\n\n        }\n      });\n\n\n\n\n\n静态文件\n\n\n为了满足应用各类需求，保存的内容会生成一个HTML文件，存在您的文件中，如应用支持显示HTML，可直接显示，或者url内容转发到朋友圈。\n\n\nps:最近小程序也推出了显示H5页面，如果需要使用，可开通FTP功能自己管理应用的文件空间。\n\n\n下载域名\n\n\n由于最近微信封了~~*.upaiyun.com~~   域名，如果你没做文件下载功能，只是显示图片，可以不填写。如果你需要做下载功能，在应用设置里面，可以开启独立域名， 开启后，填写到微信平台就好了，当然有时候你想用自己的域名，也是可以的，可以工单联系我们。\n\n\n客服消息\n\n\n对一些应用有嵌入微信客服消息，需要主动实时收到用户反馈，并希望手机可以回复消息的，可以基于云逻辑开发此功能，如果完全不想写代码实现也可以联系我们,出一定费用整套客服系统帮上线。\n\n\n简介地址：\nhttp://www.jianshu.com/p/540a8db78fbf\n\n\nWebSocket\n\n\n一个微信小程序同时只能有一个 WebSocket 连接，如果当前已存在一个 WebSocket 连接，会创建失败。WebSocket可以做一些实时数据功能，比如聊天室，你画我猜之类的游戏。具体文档参考~~JavaScript-\n实时数据平台~~  \n\n\n微信主人通知接口\n\n\n微信主动推送通知，业务场景：比如你有APP，有人下单了，或者有人留言了。你可以收到微信推送通知。\n\n\n支持2种调用方法\n1.小程序\n2.restful\n\n\n1.小程序\nBmob.sendMasterMessage\n调用主人通知接口\n\n\n\n成功后发送主人模板消息，这个只需把openid改正确即可接收到， Bmob后端云公众号回复openid\n          var temp = {\n            \ntouser\n: \noUxY3w_jURG89H5wCIvJDPjJ5s2o\n,\n            \ntemplate_id\n: \n-ERkPwp0ntimqH39bggQc_Pj55a18CYLpj-Ert8-c8Y\n,\n            \nurl\n: \nhttps://www.bmob.cn/\n,\n            \ndata\n: {\n              \nfirst\n: {\n                \nvalue\n: \n您好，Restful 失效，请登录控制台查看。\n,\n                \ncolor\n: \n#c00\n\n              },\n              \nkeyword1\n: {\n                \nvalue\n: \nRestful 失效\n\n              },\n              \nkeyword2\n: {\n                \nvalue\n: \n2017-07-03 16:13:01\n\n              },\n              \nkeyword3\n: {\n                \nvalue\n: \n高\n\n              },\n              \nremark\n: {\n                \nvalue\n: \n如果您十分钟内再次收到此信息，请及时处理。\n\n              }\n            }\n          }\n          console.log(temp);\n          Bmob.sendMasterMessage(temp).then(function (obj) {\n            console.log('发送成功');\n\n\n          }, function (err) {\n\n            common.showTip('失败' + err);\n          });\n\n\n\n\n\n2.restful调用方式\n\n\n\ncurl --request POST \\\n  --url http://api.bmob.cn/1/wechatApp/notifyMsg \\\n  --header 'content-type: application/json' \\\n  --header 'x-bmob-application-id: ' \\\n  --header 'x-bmob-rest-api-key: ' \\\n  --data '{\\n    \ntouser\n: \noUxY3w_jURG89H5wCIvJDPjJ5s2o\n,\\n    \ntemplate_id\n:\n-ERkPwp0ntimqH39bggQc_Pj55a18CYLpj-Ert8-c8Y\n,\\n    \nurl\n: \nhttp://www.bmob.cn/\n,\\n    \ndata\n: {\\n        \nfirst\n: {\\n            \nvalue\n: \n您好，Restful 失效，请登录控制台查看。\n,\\n            \ncolor\n: \n#c00\n\\n        },\\n        \nkeyword1\n: {\\n            \nvalue\n: \nRestful 失效\n\\n        },\\n        \nkeyword2\n: {\\n            \nvalue\n: \n2017-07-03 16:13:01\n\\n        },\\n        \nkeyword3\n: {\\n            \nvalue\n: \n高\n\\n        },\\n        \nremark\n: {\\n            \nvalue\n: \n如果您十分钟内再次收到此信息，请及时处理。\n\\n        }\\n    }\\n}'\n\n\n\n\nPS:\nopenid\n 关注Bmob后端云公众平台回复\nopenid\n\n\n开放3个模板：\n1.新订单通知（template_id：K9-6_Ayj4MLC2yvwY60-cq18tngJHAlqDfsOvv3D7a8\n）\n\n\n{{first.DATA}}\n\n提交时间：{{tradeDateTime.DATA}}\n订单类型：{{orderType.DATA}}\n客户信息：{{customerInfo.DATA}}\n{{orderItemName.DATA}}：{{orderItemData.DATA}}\n{{remark.DATA}}\n\n\n\n\n2.系统报警通知（template_id：-ERkPwp0ntimqH39bggQc_Pj55a18CYLpj-Ert8-c8Y\n）\n\n\n{{first.DATA}}\n系统名称：{{keyword1.DATA}}\n报警时间：{{keyword2.DATA}}\n报警级别：{{keyword3.DATA}}\n{{remark.DATA}}\n\n\n\n\n3.购买成功通知（template_id：Mbk3kYqRGkL98ch6Lie4XSXtOsxXj2SC0SRQXd89G1Y\n）\n\n\n您好，您已购买成功。\n\n商品信息：{{name.DATA}}\n{{remark.DATA}}\n\n\n\n\n4.审核结果通知（template_id：aNNNmi7WK4kohleWhCkDRKJiHOZnIpkrhXx5XPx4dx0\n）\n\n\n{{first.DATA}}\n账号名称：{{keyword1.DATA}}\n审核状态：{{keyword2.DATA}}\n审核时间：{{keyword3.DATA}}\n{{remark.DATA}}\n\n\n\n\nps：目前每个应用，每天有100条的免费额度，如需更多，可以工单联系我们\n\n\n生成小程序二维码\n\n\n生成推广二维码非常简单，比如你是传统企业，你可以为你店里每件衣服生成一个二维码，用户扫描直接可以付款定位到那件衣服，如果你是餐厅老板，客户在桌子上扫描二维码可以定位那张桌子。如果你是互联网企业，你可以发布二维码到朋友圈，可以定位到是谁推荐了这个用户，这个用户上级是谁，等等。Bmob封装了生成二维码函数，以下示例代码。\n\n\nBmob.generateCode 参数列表\n\n\n\n\n\n\n\n\n键\n\n\n值\n\n\n参数说明\n\n\n\n\n\n\n\n\n\n\npath\n\n\npages/index/index\n\n\n页面路径，支持参数\n\n\n\n\n\n\nwidth\n\n\n430\n\n\n二维码宽度\n\n\n\n\n\n\ninterface\n\n\na\\b\\c\n\n\n对应微信二维码abc方案\n\n\n\n\n\n\nscene\n\n\nBmob\n\n\n微信B方案才需要此值\n\n\n\n\n\n\ntype\n\n\n0/1\n\n\n默认0，返回二维码base64数据.如果为1则服务端返回为二维码网络路径\n\n\n\n\n\n\n\n\n更多微信官方小程序码介绍 \n微信官方小程序码介绍\n\n\n\n\nformSubmit: function (event) {\n        var path = event.detail.value.path; //路径\n        var width = event.detail.value.width; //宽度\n        var that = this;\n        Bmob.generateCode({ \npath\n: path, \nwidth\n: width }).then(function (obj) {\n            console.log(obj);\n            that.setData({\n                imageBytes: obj.imageBytes  //二维码示例\n            })\n\n        }, function (err) {\n\n            //失败\n        });\n    }\n\n\n\n\n\n小程序分享群Id\n\n\n有些时候，我们小程序需要把内容分享到微信群，统计每个微信群有多少用户来查看了此信息。可以使用此接口，下面是微信官方的2个说法\n\n\n 当用户成功地将小程序页面分享到微信群的时候，小程序的回调中可以获取分享目标的微信群 ID。\n\n\n 当用户从微信群进入小程序页面的时候，小程序启动时可以获取用户进入小程序的渠道群聊 ID。\n\n\n\nPage({\n  onLoad () {\n    wx.showShareMenu({\n      withShareTicket: true //要求小程序返回分享目标信息\n    })\n  },\n  // 其他的页面函数、生命周期函数等\n  onShareAppMessage() {\n    return {\n      title: '页面分享标题',\n      path: '/pages/path/to/target',\n      success(res){\n        console.log(res.shareTickets);\n                wx.getShareInfo({\n          shareTicket: res.shareTickets,\n          complete(res) {\n\n            //内部调用云函数\n            var currentUser = Bmob.User.current();\n            var data = { \nobjectId\n: currentUser.id, \nencryptedData\n: res.encryptedData, \niv\n: res.iv};\n            console.log(data);\n\n            // console.log(data);\n            Bmob.Cloud.run('getOpenGId', data).then(function (obj) {\n              // var res = JSON.parse(obj)\n              console.log(obj)\n            }, function (err) {\n              console.log(err)\n            });\n\n          }\n        })\n\n\n      }\n    }\n  }\n}\n\n\n\n\n\n 页面只要加上这2个函数，即可实现转发到群功能，这里主要讲下解密群ID。\n\n\n解密群ID主要是通过云逻辑来实现，这里添加一个\ngetOpenGId\n 逻辑。你也可以复制腾讯官方提供的nodejs里面的代码\n\n\n\nfunction onRequest(request, response, modules) {\n    var objectId = request.body.objectId;\n    var db = modules.oData;\n    var crypto = modules.crypto;\n    db.findOne({\n        \ntable\n: \n_User\n,\n        //表名\n        \nobjectId\n: objectId //记录的objectId\n    },\n    function(err, data) {\n        //回调函数\n        var data = JSON.parse(data);\n        var sessionkey = data.authData.weapp.session_key;   //微信最新版本改版，此id是由前端发送过来\n        var encryptedData = request.body.encryptedData;\n        var iv = request.body.iv\n        var groupid = groupIdParse(modules, sessionkey, encryptedData, iv) response.end(groupid);\n\n    });\n\n    function groupIdParse(modules, sessionKey, encryptedData, iv) {\n        var crypto = modules.oCrypto;\n        var sessionKey = new Buffer(sessionKey, 'base64'); //new Base64().decode(sessionKey);\n        encryptedData = new Buffer(encryptedData, 'base64'); //new Base64().decode(encryptedData);\n        iv = new Buffer(iv, 'base64'); //new Base64().decode(iv)\n        var result = '';\n        try {\n            // 解密\n            var decipher = crypto.createDecipheriv('aes-128-cbc', sessionKey, iv)\n            // 设置自动 padding 为 true，删除填充补位\n            decipher.setAutoPadding(true) var decoded = decipher.update(encryptedData, 'binary', 'utf8') decoded += decipher.final('utf8') result = decoded;\n            // decoded = JSON.parse(decoded)\n        } catch(err) {\n            throw new Error('Illegal Buffer123' + err)\n        }\n        //  if (decoded.watermark.appid !== this.appId) {\n        //     //  throw new Error('Illegal Buffer')\n        // }\n        return result;\n    }\n\n}\n\n\n\n\n解密返回数据：\n{\"openGId\":\"GLfcX0ber2CAPtXng-ac4g8zyNmk\",\"watermark\":{\"timestamp\":1496720764,\"appid\":\"wx77d6b7031c1e4763\"}}\n\n\n如果你的应用功能出现解密报错，你可以写死传过来的三个变量，示例：\n\n\nvar sessionKey=\nxTlW5jfSUP3Kx0vC5PJbmw==\n;\n    var encryptedData=\nSLvbzyuyck7384tlGjXwI5Meb2LydIhUGvwerwsvJhws1EJb7LnFPX1MfRcTyF8Bfj0ZRP8wu8XR+7hmTqgdQx11nOlJA0RawSoTJNYmy9kfYQsdqTq5EX0rRH8VozPURnTrjM9EGbfqaN6EetI/aQ==\n;\n    var iv=\n7/TqHciNjSi3cdFFxr97ww==\n;\n\n    var groupid=groupIdParse(modules,sessionKey,encryptedData,iv)\n    var jsongid=JSON.parse(groupid);\n    response.end(groupid);\n    return;\n\n\n\n\n小程序模板消息\n\n\n小程序模板消息首先是通过获取\naccess_token\n来发送。access_token有效期2小时。\n\n\n模板消息支持2种方式调用。\n- 1.Restful\n- 2.小程序\n\n\nRestful\n\n\ncurl -X POST \\\n  http://api.bmob.cn/1/wechatApp/SendWeAppMessage \\\n  -H 'cache-control: no-cache' \\\n  -H 'content-type: application/json' \\\n  -H 'x-bmob-application-id: XXX' \\\n  -H 'x-bmob-rest-api-key: XXX' \\\n  -d '{\n     \ntouser\n: \nosr4I0WBS4kZuD_5P-_-bxbSobTg\n,\n        \ntemplate_id\n: \nomTTRD3pAMiAGKmyKo15Ifc2U_wLr6oWRZOifnTngvQ\n,\n        \npage\n: \nindex\n,\n        \nform_id\n:\n3a8c5659469c9a582c8fd65054ea5307\n,\n        \ndata\n: {\n          \nkeyword1\n: {\n            \nvalue\n: \nSDK测试内容\n,\n            \ncolor\n: \n#173177\n\n          },\n      \nkeyword2\n: {\n          \nvalue\n: \n2015年01月05日 12:30\n\n      },\n      \nkeyword3\n: {\n          \nvalue\n: \nBmob科技\n\n      }\n    }\n    ,\nemphasis_keyword\n: \n\n}'\n\n\n\n\nRestful主要用在一些特殊情况，例如审核后给用户发送一个通知，定时发通知等这种要配合云逻辑或自己服务端来使用。\n\n\n小程序内部调用比较常用，使用门槛低\n\n\nvar currentUser = Bmob.User.current();\nvar temp = {\n    \ntouser\n: currentUser.get(\nopenid\n),\n    \ntemplate_id\n: \nB-2GcobfYnptevxY8G3SdA72YLYGZpOoJO_FEHlouWg\n,\n    \npage\n: \n,\n    \nform_id\n: formId,\n    \ndata\n: {\n        \nkeyword1\n: {\n            \nvalue\n: \nSDK测试内容\n,\n            \ncolor\n: \n#173177\n\n        },\n        \nkeyword2\n: {\n            \nvalue\n: \n199.00\n\n        },\n        \nkeyword3\n: {\n            \nvalue\n: \n123456789\n\n        },\n        \nkeyword4\n: {\n            \nvalue\n: \n2015年01月05日 12:30\n\n        },\n        \nkeyword5\n: {\n            \nvalue\n: \n恭喜您支付成功，如有疑问请反馈与我\n\n        }\n    },\n    \nemphasis_keyword\n: \nkeyword1.DATA\n\n}\nBmob.sendMessage(temp).then(function(obj) {\n    console.log('发送成功')\n},\nfunction(err) {\n    common.showTip('失败' + err)\n});\n\n\n\n\n\n\n小程序短信验证码\n\n\n方法调用与JavaScript一致，查看JavaScript 短信文档 \n请求短信验证码\n\n\n小程序支付\n\n\n小程序支付只需发起请求获取微信需要的字段，这里用Bmob.Pay.wechatPay获取\nnonceStr\n,\npackages\n,\norderId\n等相关信息。然后 wx.requestPayment弹窗支付页面，里面处理成功失败。 （Bmob的接口都是独立的，任何平台小程序都可以使用，自需要小程序微信开通都支持。目前小程序支付跟其他有APP区别Bmob平台不收取任何手续费，只要是Bmob平台付费会员都可使用。）\n\n\n\n//传参数金额，名称，描述,openid\n    Bmob.Pay.wechatPay(0.01, '名称1', '描述', openId).then(function (resp) {\n      console.log('resp');\n      console.log(resp);\n\n      that.setData({\n        loading: true,\n        dataInfo: resp\n      })\n\n      //服务端返回成功\n      var timeStamp = resp.timestamp,\n        nonceStr = resp.noncestr,\n        packages = resp.package,\n        orderId = resp.out_trade_no,//订单号，如需保存请建表保存。\n        sign = resp.sign;\n\n      //打印订单号\n      console.log(orderId);\n\n      //发起支付\n      wx.requestPayment({\n        'timeStamp': timeStamp,\n        'nonceStr': nonceStr,\n        'package': packages,\n        'signType': 'MD5',\n        'paySign': sign,\n        'success': function (res) {\n          //付款成功,这里可以写你的业务代码\n          console.log(res);\n        },\n        'fail': function (res) {\n          //付款失败\n          console.log('付款失败');\n          console.log(res);\n        }\n      })\n\n    }, function (err) {\n      console.log('服务端返回失败');\n      common.showTip(err.message, 'loading',{},6000);\n      console.log(err);\n    });\n\n\n\n\n\n\n\n添加数据\n\n\n添加数据非常简单，任何\nBmob.Object\n子类都有\nsave\n方法可以用于将当前对象的内容保存到服务端。示例代码如下：\n\n\n\n    //创建类和实例\n    var Diary = Bmob.Object.extend(\ndiary\n);\n    var diary = new Diary();\n    diary.set(\ntitle\n,\nhello\n);\n    diary.set(\ncontent\n,\nhello world\n);\n    //添加数据，第一个入口参数是null\n    diary.save(null, {\n        success: function(result) {\n          // 添加成功，返回成功之后的objectId（注意：返回的属性名字是id，不是objectId），你还可以在Bmob的Web管理后台看到对应的数据\n            console.log(\n日记创建成功, objectId:\n+result.id);\n        },\n        error: function(result, error) {\n          // 添加失败\n          console.log('创建日记失败');\n\n        }\n    });\n\n\n\n\n你也可以用如下的示例代码添加数据：\n\n\n\n    var Diary = Bmob.Object.extend(\ndiary\n);\n    var diary = new Diary();\n    // 添加数据，第一个入口参数是Json数据\n    diary.save({\n      title: \nhello\n,\n      content: \nhello world\n\n    }, {\n      success: function(result) {\n        // 添加成功\n      },\n      error: function(result, error) {\n        // 添加失败\n      }\n    });\n\n\n\n\n这里有几点需要注意的是:\n\n\n\n\n如果云端数据库中不存在\ndiary\n表，Bmob会自动地在你第一次使用它的时候创建。\n\n\n每个\nBmob.Object\n对象都有几个默认的字段是自动创建的：\nobjectId\n是一个对于每一个保存的对象为一个标志；\ncreatedAt\n和\nupdatedAt\n表示对象在Bmob中创建和最后一次更改的时间。这些字段的创建和内容是由服务器端自动完成的，在保存\nBmob.Object\n之前不会存在。\n\n\n添加成功后，可以通过\nresult.createdAt\n获取对象的创建时间，通过\nresult.updatedAt\n获取对象的更新时间；可以通过\nresult.id\n获取对象的objectId。\n\n\n\n\n查询数据\n\n\n数据的查询是每个应用都会频繁使用到的，Bmob提供了\nBmob.Object\n类，方便大家实现不同条件的查询。\n\n\n查询所有数据\n\n\n查询某个数据表中的所有数据是非常简单的，只需要使用\nBmob.Query\n的\nfind\n方法就可以了，示例代码如下：\n\n\nvar Diary = Bmob.Object.extend(\ndiary\n);\nvar query = new Bmob.Query(Diary);\n// 查询所有数据\nquery.find({\n  success: function(results) {\n    console.log(\n共查询到 \n + results.length + \n 条记录\n);\n    // 循环处理查询到的数据\n    for (var i = 0; i \n results.length; i++) {\n      var object = results[i];\n      console.log(object.id + ' - ' + object.get('title'));\n    }\n  },\n  error: function(error) {\n    console.log(\n查询失败: \n + error.code + \n \n + error.message);\n  }\n});\n\n\n\n\n如果你只想要一个结果，一个更加方便的方法是使用\nfirst\n，而不是\nfind\n方法，示例代码如下：\n\n\nvar Diary = Bmob.Object.extend(\ndiary\n);\nvar query = new Bmob.Query(Diary);\nquery.first({\n  success: function(object) {\n    // 查询成功\n  },\n  error: function(error) {\n    console.log(\n查询失败: \n + error.code + \n \n + error.message);\n  }\n});\n\n\n\n\n这里需要注意一点的是：\n\n默认情况下，系统实际上并不会返回所有的数据，而是默认返回10条数据记录，你可以通过setLimit方法设置返回的记录数量。更多细节可\n点击查看分页查询\n一节。\n\n\n获取对象的特殊属性\n\n\n注意，在对象中获取objectId，createdAt，updatedAt的方法分别如下：\nobj.id\nobj.createdAt\nobj.updatedAt\n\n\n查询单条数据\n\n\n当我们知道某条数据的\nobjectId\n时，就可以根据\nobjectId\n值直接获取单条数据对象，示例代码如下：\n\n\nvar Diary = Bmob.Object.extend(\ndiary\n);\n//创建查询对象，入口参数是对象类的实例\nvar query = new Bmob.Query(Diary);\n//查询单条数据，第一个参数是这条数据的objectId值\nquery.get(\n82c3e62d2c\n, {\n  success: function(result) {\n    // 查询成功，调用get方法获取对应属性的值\n    var title = result.get(\ntitle\n);\n    var content = result.get(\ncontent\n);\n  },\n  error: function(object, error) {\n    // 查询失败\n  }\n});\n\n\n\n\n条件查询\n\n\n如果要查询某个属性等于某个值，示例代码如下：\n\n\nquery.equalTo(\ntitle\n, \nbmob\n);\n\n\n\n\n如果要查询某个属性不等于某个值，示例代码如下：\n\n\nquery.notEqualTo(\ntitle\n, \nbmob sdk\n);\n\n\n\n\n如果要模糊查询某个值，示例代码如下（模糊查询目前只提供给付费套餐会员使用）：\n\n\nquery.equalTo(\ntitle\n, { \n$regex\n: \n + k + \n.*\n });\n\n\n\n\n查询大于某个日期的数据，示例代码如下\nquery.equalTo(\"dateTime\", {\"$gte\":{\"__type\":\"Date\",\"iso\":\"2011-08-21 18:02:52\"}});\n\n\n对查询的属性值进行大小比较的示例代码如下：\n\n\n// score \n 50\nquery.lessThan(列名称, 50);\n\n// score \n= 50\nquery.lessThanOrEqualTo(列名称, 50);\n\n// score \n 50\nquery.greaterThan(列名称, 50);\n\n// score \n= 50\nquery.greaterThanOrEqualTo(列名称, 50);\n\n\n\n\n两条查询语句一起写，就相当于\nAND\n查询，如下示例代码，查询同时满足\n\"playerName\"=\"bmob\" and \"score\"\n100\n的数据：\n\n\nquery.notEqualTo(\ntitle\n, \nbmob\n);\nquery.greaterThan(列名称, 100);\n\n\n\n\n一个完整的例子：\n\n\nvar Diary = Bmob.Object.extend(\ndiary\n);\nvar query = new Bmob.Query(Diary);\nquery.equalTo(\ntitle\n, \nhello\n);\n// 查询所有数据\nquery.find({\n    success: function(results) {\n        console.log(\n共查询到 \n + results.length + \n 条记录\n);\n        // 循环处理查询到的数据\n        for (var i = 0; i \n results.length; i++) {\n        var object = results[i];\n        console.log(object.id + ' - ' + object.get('title'));\n        }\n    },\n    error: function(error) {\n        console.log(\n查询失败: \n + error.code + \n \n + error.message);\n    }\n});\n\n\n\n\n分页查询\n\n\n有时，在数据比较多的情况下，你希望查询出的符合要求的所有数据能按照多少条为一页来显示，这时可以使用\nlimit\n方法来限制查询结果的数据条数来进行分页。默认情况下，Limit的值为10，最大有效设置值1000（设置的数值超过1000还是视为1000）。\n\n\n// 返回最多10条数据\nquery.limit(10);\n\n\n\n\n在数据较多的情况下，在\nlimit\n的基础上分页显示数据是比较合理的解决办法，\nskip\n方法可以做到跳过查询的前多少条数据来实现分页查询的功能。默认情况下\nskip\n的值为10。\n\n\nquery.skip(10); // skip the first 10 results\n\n\n\n\n结果排序\n\n\n我们可以对返回的结果进行排序（只支持\nnumber\n，\ndate\n，\nstring\n类型的排序），示例代码如下：\n\n\n// 对score字段升序排列\nquery.ascending(列名称);\n\n// 对score字段降序排列\nquery.descending(列名称);\n\n\n\n\n统计记录数量\n\n\n如果你只是想统计满足\nquery\n的结果集到底有多条记录，你可以使用\ncount\n方法。如为了获得diary表的记录数量，示例代码如下：\n\n\nvar Diary = Bmob.Object.extend(\ndiary\n);\nvar query = new Bmob.Query(Diary);\nquery.count({\n  success: function(count) {\n    // 查询成功，返回记录数量\n    console.log(\n共有 \n + count + \n 条记录\n);\n  },\n  error: function(error) {\n    // 查询失败\n  }\n});\n\n\n\n\n\n复杂查询\n\n\n如果你想查询某一字段值在某一集合中的记录的话，可以使用\ncontainedIn\n方法，如获取\n\"Bmob\"、\"hello\"、\"sure\"\n三条标题为这的记录信息，那么示例代码如下：\n\n\n// 第一个参数是字段名称，第二个参数是数组\nquery.containedIn(\ntitle\n, [\nBmob\n, \nhello\n, \nsure\n]);\n\n\n\n\n\n相反地，你可以使用\nnotContainedIn\n方法来查询在集合外的目标对象。\n\n\n如果想要查询含有某一特定属性的对象，可以使用\nexists\n。相对地，如果你想获取没有这一特定属性的对象，你可以使用\ndoesNotExist\n，示例代码如下：\n\n\n// 查询含有title属性的对象\nquery.exists(\ntitle\n);\n\n// 查询不含有title属性的对象\nquery.doesNotExist(\ntitle\n);\n\n\n\n\n你可以使用\nmatchesKeyInQuery\n方法来进行嵌套的子查询。举例说，如果你有一个类包含了用户心情， 而你在用户类中存储了用户的详细信息，你可以构造一个查询来查找被点赞次数超过5次的用户信息，示例代码如下：\n\n\nvar Diary = Bmob.Object.extend(\ndiary\n);\nvar DiaryQuery = new Bmob.Query(Diary);\nDiaryQuery.greaterThan(\nisLike\n,5);\nvar userQuery = new Bmob.Query(Bmob.User);\nuserQuery.matchesKeyInQuery(\nphone\n, \nnickname\n, DiaryQuery);\nuserQuery.find({\n  success: function(results) {\n    // results has the list of users with all user with record\n  }\n});\n\n\n\n\n相对地，可以使用\ndoesNotMatchKeyInQuery\n来获取属性不在子查询结果中的对象。比如为了获得用户的日记被点赞不超过5次的情况：\n\n\nvar Diary = Bmob.Object.extend(\ndiary\n);\nvar DiaryQuery = new Bmob.Query(Diary);\nDiaryQuery.greaterThan(\nisLike\n,5);\nvar userQuery = new Bmob.Query(Bmob.User);\nuserQuery.doesNotMatchKeyInQuery(\nphone\n, \nnickname\n, DiaryQuery);\nuserQuery.find({\n  success: function(results) {\n\n  }\n});\n\n\n\n\n查询指定列\n\n\n有时候你不想返回所有的字段信息，那么就可以用\nselect\n方法来限定返回的字段。示例代码如下：\n\n\nvar Diary = Bmob.Object.extend(\ndiary\n);\nvar query = new Bmob.Query(Diary);\n// 只返回score和playerName字段值\nquery.select(\ntitle\n);\nquery.find().then(function(results) {\n  // 返回成功\n});\n\n\n\n\n注意：系统默认的字段\nobjectId\n、\ncreatedAt\n、\nupdatedAt\n、\nACL\n也会返回。\n\n\n对字符串类型做查询\n\n\n如果想要查询以某一个特定字符串开头的记录，可以使用\nstartWith\n方法，示例代码如下：\n\n\n// 查询在title字段中以he开头的记录\nvar query = new Bmob.Query(Diary);\nquery.startsWith(\ntitle\n, \nhe\n);\n\n\n\n\n或查询\n\n\n你可以使用\nBmob.Query.or\n方法操作或查询，示例代码如下：\n\n\nvar query1 = new Bmob.Query(Diary);\nquery1.greaterThan(\nisLike\n, 150);\n\nvar query2 = new Bmob.Query(Diary);\nquery2.lessThan(\nisLike\n, 5);\n\nvar mainQuery = Bmob.Query.or(query1, query2);\nmainQuery.find({\n  success: function(results) {\n     // 返回 isLike \n 150 or isLike \n 5 的值\n  },\n  error: function(error) {\n    // 返回失败\n  }\n});\n\n\n\n\n注意：我们不会在组合查询的子查询中支持非过滤型的条件 (比如:limit,skip,ascending/descending,include)\n\n\n修改数据\n\n\n修改数据非常简单，首先需要获取到要更新的\nBmob.Object\n对象，修改值后保存数据就可以了，示例代码如下：\n\n\nvar Diary = Bmob.Object.extend(\ndiary\n);\nvar query = new Bmob.Query(Diary);\n\n// 这个 id 是要修改条目的 id，你在\n 这个存储并成功时可以获取到，请看前面的文档\nquery.get('3453453453fdsdf', {\n    success: function(result) {\n      // 回调中可以取得这个 GameScore 对象的一个实例，然后就可以修改它了\n      result.set('title', 'test!');\n      result.save();\n\n      // The object was retrieved successfully.\n    },\n    error: function(object, error) {\n\n    }\n});\n\n\n\n\n或者\n\n\nvar Diary = Bmob.Object.extend(\ndiary\n);\nvar Diary = new Diary();\nDiary.set(\ntitle\n, \n111\n);\nDiary.set(\ncontent\n, \n222\n);\n//添加数据\nDiary.save(null, {\n  success: function(result) {\n    // 修改数据\n    result.set(\ntitle\n, \n111\n);\n    result.set(\ncontent\n, \n222\n);\n    result.save();\n  }\n})\n\n\n\n\n如果想更新成功后获取更新后的对象属性，请设置\nfetchWhenSave\n：\n\n\n //假设result是已经存在的对象\n    result.fetchWhenSave(true);\n    result.set(\ntitle\n, \n111\n);\n    result.set(\ncontent\n, \n222\n);\n    result.save();\n\n\n\n\n删除数据\n\n\n删除数据可以使用\nBmob.Object\n的\ndestroy\n方法，示例代码如下：\n\n\nmyObject.destroy({\n  success: function(myObject) {\n    // 删除成功\n  },\n  error: function(myObject, error) {\n    // 删除失败\n  }\n});\n\n\n\n\n\n批量删除对象的示例代码如下：\n\n\n//单个请求每次最多删除50条。\n var query = new Bmob.Query('diary');\n query.equalTo(\ntitle\n, \n后端云\n);\n          query.find().then(function (todos) {\n            return Bmob.Object.destroyAll(todos);\n          }).then(function (todos) {\n            console.log(todos);\n            // 删除成功\n          }, function (error) {\n            // 异常处理\n          });\n\n\n\n\n如果你想将查询出来的对象都删除，或者删除符合查询条件的所有对象，可以调用\ndestroyAll\n方法，示例代码如下：\n\n\nquery.destroyAll({\n   success: function(){\n      //删除成功\n   },\n   error: function(err){\n      // 删除失败\n   }\n   });\n\n\n\n\n删除字段\n\n\n你可以使用\nunset\n方法在删除一个字段：\n\n\n// 删除playerName字段\nmyObject.unset(\ntitle\n);\nmyObject.save();\n\n\n\n\n常见数据类型的操作\n\n\nvar number = 42;\nvar string = \nthe number is \n + number;\nvar date = new Date();\nvar array = [string, number];\nvar object = { number: number, string: string };\n\nvar bigObject = new BigObject();\nbigObject.set(\nmyNumber\n, number);\nbigObject.set(\nmyString\n, string);\nbigObject.set(\nmyDate\n, date);\nbigObject.set(\nmyArray\n, array);\nbigObject.set(\nmyObject\n, object);\nbigObject.set(\nmyNull\n, null);\nbigObject.save();\n\n\n\n\n数组操作\n\n\n添加及更新数组\n\n\n为了帮你存储数组类数据，有三种操作你可以原子性地改动一个数组，这需要一个给定的 key：\n\n\n\n\nadd\n在一个数组的末尾加入一个给定的对象。\n\n\naddUnique\n只会把原本不存在的对象加入数组，所以加入的位置没有保证。\n\n\n\n\n比如, 我们想在数组\"DiaryType\"中加入日记类型：\n\n\nDiary.addUnique(\nDiaryType\n, \npublic\n);\nDiary.addUnique(\nDiaryType\n, \nsecret\n);\nDiary.save();\n\n\n\n\n数组查询\n\n\n对于value是数组的情况，你可以这样查询数组中的值有\n2\n的情况的对象：\n\n\n// Find objects where the array in DiaryType contains public.\nquery.equalTo(\nDiaryType\n,\npublic\n);\n\n\n\n\n你同样可以用下面的方式找到同时包含元素\n2、3、4\n的数组：\n\n\n// Find objects where the array in DiaryType contains all of the elements public,secret.\nquery.containsAll(\nDiaryType\n, [\npublic\n,\nsecret\n]);\n\n\n\n\n删除数组\n\n\nremove\n在一个数组中删除所有指定的所有实例：\n\n\nvar Diary = Bmob.Object.extend(\ndiary\n);\nvar query = new Bmob.Query(Diary);\nquery.get(\nbc5da708dc\n,{\n  success: function(result) {\n    result.remove(\nDiaryType\n,\npublic\n);\n    result.save();\n  },\n  error: function(error) {\n    console.log(\nError: \n + error.code + \n \n + error.message);\n  }\n});\n\n\n\n\n批量操作\n\n\n批量更新示例\n\n\n\n把Todo表title所有为Bmob的更新为Bmob后端云\nvar query = new bmob.Query('Todo');\nquery.equalTo(\ntitle\n, \nbmob\n);\nquery.find().then(function(todos) {\n    todos.forEach(function(todo) {\n        todo.set('title', \nBmob后端云\n);\n    });\n    return bmob.Object.saveAll(todos);\n}).then(function(todos) {\n    // 更新成功\n},\nfunction(error) {\n    // 异常处理\n});\n\n\n\n\n\n批量增删改\n\n\nvar objects = []; // 构建一个本地的 bmob.Object 对象数组\n// 批量创建（更新）\nbmob.Object.saveAll(objects).then(function(objects) {\n    // 成功\n},\nfunction(error) {\n    // 异常处理\n});\n// 批量删除\nbmob.Object.destroyAll(objects).then(function() {\n    // 成功\n},\nfunction(error) {\n    // 异常处理\n});\n// 批量获取\nbmob.Object.fetchAll(objects).then(function(objects) {\n    // 成功\n},\nfunction(error) {\n    // 异常处理\n});\n\n\n\n\n数据关联\n\n\n添加及修改关联关系\n\n\n一对一关系和一对多关系\n\n\n一对一关系和一对多关系都可以通过在一个\nBmob.Object\n内保存另一个对象来实现。比如，每一个 Comment都对应了一个Post，创建一个有一个Comment的Post，你可以这样写：\n\n\n\n// Declare the types.\nvar Post = Bmob.Object.extend(\nPost\n);\nvar Comment = Bmob.Object.extend(\nComment\n);\n\n// Create the post\nvar myPost = new Post();\nmyPost.set(\ntitle\n, \nI'm Hungry\n);\nmyPost.set(\ncontent\n, \nWhere should we go for lunch?\n);\n\n// Create the comment\nvar myComment = new Comment();\nmyComment.set(\ncontent\n, \nLet's do Sushirrito.\n);\n\n// Add the post as a value in the comment\nmyComment.set(\nparent\n, myPost);\n\n// This will save both myPost and myComment\nmyComment.save();\n\n\n\n\n\nBmob内部会自动处理，调用Comment的\nsave\n方法就可以同时保存两个新对象。\n\n\n如果是现有对象想要关联到新对象，你同样可以通过只用它们的\nobjectId\n来连接彼此。请注意，不能直接像上面的例子那样将现有对象设置进去，而是必须\nnew\n一个新对象并只设置\nid\n属性：\n\n\nvar post = Bmob.Object.createWithoutData(\nPost\n, \n320b0395f3\n);\nmyComment.set(\nparent\n, post);\n\n\n\n\n或者：\n\n\nvar post = new Post();\npost.id = '520c7e1ae4b0a3ac9ebe326a';\nmyComment.set(\nparent\n, post);\n\n\n\n\n如果希望查询结果中包含多个相关联的其他数据类型。你可以使用 include 方 法。例如有个comments，你可能想同时获取它们相关的 post 数据:\n\n\nvar query = new Bmob.Query(Comment);\n\nquery.include(\npost\n);\n\n\n\n\n\n可以这样获取include对象的属性:\n\n\nobj.get(\ninloudeObj\n).field\n\n\n\n\n查出用户发表的日志示例\n\n\n    var objectId,that=this;\n    var currentUser = Bmob.User.current();\n    objectId = currentUser.id;\n\n    var Diary = Bmob.Object.extend(\ndiary\n);\n    var query = new Bmob.Query(Diary);\n    var isme = new Bmob.User();\n    isme.id = objectId;     //当前用户的objectId\n    query.equalTo(\nown\n, isme);\n    query.descending('createdAt');  //排序\n    query.include(\nown\n);  //own 字段名称，类型 Pointer\n\n    // 查询所有数据\n    query.limit(that.data.limit);\n    query.find({\n      success: function (results) {\n        that.setData({\n          diaryList: results\n        })\n      },\n      error: function (error) {\n        console.log(\n查询失败: \n + error.code + \n \n + error.message);\n      }\n    });\n\n\n\n\nwxml文件调用\n\n\nview class=\nweui-media-box weui-media-box_text\n wx:for=\n{{diaryList}}\n wx:key=\ndiaryItem\n\n日志标题：\n{{item.title}}\n用户表的日志作者：\n{{item.own.nickName}}\n\n/view\n\n\n\n\n\n\n原子计数器\n\n\n许多应用都需要维持一些计数器数据，譬如用来跟踪心情被点赞数目等等。Bmob提供了便捷的方式来对任何数字字段进行原子性的增加或者减少：\n\n\nDiary.increment(\nisLike\n);\nDiary.save();\n\n\n\n\n你可以同样传入第二个参数到\nincrement\n方法来指定增加多少，\n1\n是默认值。\n\n\n文件上传\n\n\n文件上传\n\n\n文件上传，例如，我们从本地上传一张图片到服务器，名称为\"1.jpg\"，可用以下代码：\n\n\n在js中添加以下代码：\n\n\nwx.chooseImage({\n  count: 1, // 默认9\n  sizeType: [ 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\n  sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\n  success: function (res) {\n      var tempFilePaths = res.tempFilePaths;\n      if(tempFilePaths.length\n0){\n          var name=\n1.jpg\n;//上传的图片的别名，建议可以用日期命名\n          var file=new Bmob.File(name,tempFilePaths);\n          file.save().then(function(res){\n            console.log(res.url());\n          },function(error){\n            console.log(error);\n          })\n      }\n\n  }\n})\n\n#### PS： 特别注意的是 `tempFilePaths` 是微信返回的数组。\n\n\n\n\n\n图片批量上传\n\n\n图片批量上传，我们只需要for循环一下上面的就好，一下示例代码。\n\n\nupImg: function () {\n    var that = this;\n    wx.chooseImage({\n      count: 9, // 默认9\n      sizeType: ['compressed'], // 可以指定是原图还是压缩图，默认二者都有\n      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\n      success: function (res) {\n        wx.showNavigationBarLoading()\n        that.setData({\n          loading: false\n        })\n        var urlArr = new Array();\n        // var urlArr={};\n        var tempFilePaths = res.tempFilePaths;\n        console.log(tempFilePaths)\n        var imgLength = tempFilePaths.length;\n        if (imgLength \n 0) {\n          var newDate = new Date();\n          var newDateStr = newDate.toLocaleDateString();\n\n          var j = 0;\n          //如果想顺序变更，可以for (var i = imgLength; i \n 0; i--)\n          for (var i = 0; i \n imgLength; i++) {\n            var tempFilePath = [tempFilePaths[i]];\n            var extension = /\\.([^.]*)$/.exec(tempFilePath[0]);\n            if (extension) {\n              extension = extension[1].toLowerCase();\n            }\n            var name = newDateStr + \n.\n + extension;//上传的图片的别名\n\n            var file = new Bmob.File(name, tempFilePath);\n            file.save().then(function (res) {\n              wx.hideNavigationBarLoading()\n              var url = res.url();\n              console.log(\n第\n + i + \n张Url\n + url);\n\n              urlArr.push({ \nurl\n: url });\n              j++;\n              console.log(j, imgLength);\n              // if (imgLength == j) {\n              //   console.log(imgLength, urlArr);\n              //如果担心网络延时问题，可以去掉这几行注释，就是全部上传完成后显示。\n                showPic(urlArr, that)\n              // }\n\n            }, function (error) {\n              console.log(error)\n            });\n\n          }\n\n\n\n\n        }\n\n      }\n    })\n  }\n})\n\n\n\n//上传完成后显示图片\nfunction showPic(urlArr, t) {\n  t.setData({\n    loading: true,\n    urlArr: urlArr\n  })\n}\n\n\n\n\n\n文件删除\n\n\nvar path;\npath = \nhttp://bmob-cdn-9200.b0.upaiyun.com/2017/04/25/f24b9ef540f1aeb680ebe01ba8543d9f.png\n;\nvar s = new Bmob.Files.del(path).then(function(res) {\n    if (res.msg == \nok\n) {\n        console.log('删除成功');\n    }\n},\nfunction(error) {\n    console.log(error)\n});\n\n\n\n\n图片处理\n\n\n新版文件服务由第三方厂商又拍云提供，只需要在文件上传成功返回的url后面拼接特定参数即可实现缩放，缩略图，加水印等效果，\n如图\n，具体可参考\n这里\n 。\n\n\nPromise\n\n\n除了回调函数之外，每一个在Bmob JavaScript SDK中的异步方法都会返回一个 Promise. 使用 Promise，你的代码可以比原来的嵌套 callback 的方法看起来优雅得多.\n\n\nthen 方法\n\n\n每一个\nPromise\n都有一个叫\nthen\n的方法, 这个方法接受一对\ncallback\n。第一个\ncallback\n在\npromise\n被解决的时候调用，第二个会在\npromise\n被拒绝的时候调用。\n\n\nobj.save().then(function(obj) {\n  // the object was saved successfully.\n}, function(error) {\n  // the save failed.\n});\n\n\n\n\n将Promise 组织在一起\n\n\nPromise\n比较神奇，可以代替多层嵌套方式来解决发送异步请求代码的调用顺序问题。 如果一个\nPromise\n的回调会返回一个\nPromise\n，那么第二个\nthen\n里的\ncallback\n在第一个\nthen\n的\ncallback\n没有解决前是不会解决的。\n\n\nvar query = new Bmob.Query(\nStudent\n);\nquery.descending(\ngpa\n);\nquery.find().then(function(students) {\n  students[0].set(\nvaledictorian\n, true);\n  return students[0].save();\n\n}).then(function(valedictorian) {\n  return query.find();\n\n}).then(function(students) {\n  students[1].set(\nsalutatorian\n, true);\n  return students[1].save();\n\n}).then(function(salutatorian) {\n  // Everything is done!\n\n});\n\n\n\n\n错误处理\n\n\n如果任意一个在链中的\nPromise\n返回一个错误的话，所有的成功的\ncallback\n在接下来都会被跳过直到遇到一个处理错误的\ncallback\n。处理\nerror\n的\ncallback\n可以转换\nerror\n或者可以通过返回一个新的\nPromise\n的方式来处理它。你可以想象成拒绝的\npromise\n有点像异常，而\nerror callback\n则像是一个\ncatch\n来处理这个异常或者抛出异常。\n\n\nvar query = new Bmob.Query(\nStudent\n);\nquery.descending(\ngpa\n);\nquery.find().then(function(students) {\n  students[0].set(\nvaledictorian\n, true);\n  // Force this callback to fail.\n  return Bmob.Promise.error(\nThere was an error.\n);\n\n}).then(function(valedictorian) {\n  // Now this will be skipped.\n  return query.find();\n\n}).then(function(students) {\n  // This will also be skipped.\n  students[1].set(\nsalutatorian\n, true);\n  return students[1].save();\n}, function(error) {\n  // This error handler WILL be called. error will be \nThere was an error.\n.\n  // Let's handle the error by returning a new promise.\n  return Bmob.Promise.as(\nHello!\n);\n\n}).then(function(hello) {\n  // Everything is done!\n}, function(error) {\n  // This isn't called because the error was already handled.\n});\n\n\n\n\n通常来说，在正常情况的回调函数链的末尾，加一个错误处理的回调函数会是很方便的做法.\n\n\n创建 Promise\n\n\n在开始阶段，你可以只用系统（譬如\nfind\n和\nsave\n方法等）返回的\npromise\n。但在更高级的场景下，你可能需要创建自己的\npromise\n。在创建了\nPromise\n之后，你需要调用\nresolve\n或者\nreject\n来触发它的\ncallback\n。\n\n\nvar successful = new Bmob.Promise();\nsuccessful.resolve(\nThe good result.\n);\n\nvar failed = new Bmob.Promise();\nfailed.reject(\nAn error message.\n);\n\n\n\n\n如果你在创建\npromise\n的时候就知道它的结果，下面有两个很方便的方法可以使用：\n\n\nvar successful = Bmob.Promise.as(\nThe good result.\n);\nvar failed = Bmob.Promise.error(\nAn error message.\n);\n\n\n\n\n顺序的Promise\n\n\nvar query = new Bmob.Query(\nComments\n);\nquery.equalTo(\npost\n, 123);\n\nquery.find().then(function(results) {\n  // Create a trivial resolved promise as a base case.\n  var promise = Bmob.Promise.as();\n  _.each(results, function(result) {\n    // For each item, extend the promise with a function to delete it.\n    promise = promise.then(function() {\n      // Return a promise that will be resolved when the delete is finished.\n      return result.destroy();\n    });\n  });\n  return promise;\n\n}).then(function() {\n  // Every comment was deleted.\n});\n\n\n\n\n并行的Promise\n\n\n你也可以用\nPromise\n来并行的进行多个任务，这时需要使用\nwhen\n方法。你可以一次同时开始几个操作，使用\nBmob.Promise.when\n来创建一个新的\npromise\n，它会在所有输入的\nPromise\n被解决之后才被解决。即便一些输入的\npromise\n失败了，新的\nPromise\n也会被成功执行。你可以在 \ncallback\n的参数部分检查每一个\npromise\n的结果，并行地进行操作会比顺序进行更快，但是也会消耗更多的系统资源和带宽。\n\n\nvar query = new Bmob.Query(\nComments\n);\nquery.equalTo(\npost\n, 123);\n\nquery.find().then(function(results) {\n  // Collect one promise for each delete into an array.\n  var promises = [];\n  _.each(results, function(result) {\n    // Start this delete immediately and add its promise to the list.\n    promises.push(result.destroy());\n  });\n  // Return a new promise that is resolved when all of the deletes are finished.\n  return Bmob.Promise.when(promises);\n\n}).then(function() {\n  // Every comment was deleted.\n});\n\n\n\n\n创建异步方法\n\n\n有了上面这些工具以后, 就很容易创建你自己的异步方法来返回\npromise\n了。举例说，你可以创建一个有\npromise\n版本的\nsetTimeout\n。\n\n\nvar delay = function(millis) {\n  var promise = new Bmob.Promise();\n  setTimeout(function() {\n    promise.resolve();\n  }, millis);\n  return promise;\n};\n\ndelay(100).then(function() {\n  // This ran after 100ms!\n});\n\n\n\n\nCollection\n\n\n一个\nBmob.Collection\n就是一个\nBmob.Objects\n的有序集合，它和\nBackbone.Collection\n是兼容的，有相同的特性和功能，你可以通过用一个模型类或者一个特定的\nBmob.Query\n来创建一个新的子类。\n\n\n// A Collection containing all instances of TestObject.\nvar TestCollection = Bmob.Collection.extend({\n  model: TestObject\n});\nvar collection = new TestCollection();\n\n// A Collection of TestObjects whose temperature is \nhot\n.\nvar HotCollection = Bmob.Collection.extend({\n  model: TestObject,\n  query: (new Bmob.Query(TestObject)).equalTo(\ntemperature\n, \nhot\n)\n});\nvar collection = new HotCollection();\n\n// The Collection of TestObjects that match a complex query.\nvar query = new Bmob.Query(TestObject);\nquery.equalTo(\ntemperature\n, \nhot\n);\nquery.greaterThan(\ndegreesF\n, 100);\nvar collection = query.collection();\n\n\n\n\n获取Collection\n\n\n使用\nfetch\n方法来获取一个\ncollection\n里的所有元素:\n\n\nvar collection = new TestCollection();\ncollection.fetch({\n  success: function(collection) {\n    collection.each(function(object) {\n      console.warn(object);\n    });\n  },\n  error: function(collection, error) {\n    // The collection could not be retrieved.\n  }\n});\n\n\n\n\nCollection 排序\n\n\n你可以设定一个\ncomparator\n来对\ncollection\n中的元素进行排序:\n\n\nvar collection = new TestCollection();\ncollection.comparator = function(object) {\n  return object.get(\ntemperature\n);\n};\n\n\n\n\n修改一个 Collection\n\n\nCollection\n是可变的，你可以访问所有元素，增加或者删除元素：\n\n\nvar collection = new TestCollection();\n\ncollection.add([\n  {\nname\n: \nDuke\n},\n  {\nname\n: \nScarlett\n}\n]);\n\n// Get the \nDuke\n Bmob.Object by its sorted position.\nvar model = collection.at(0);\n\n// Or you can get it by Bmob objectId.\nvar modelAgain = collection.get(model.id);\n\n// Remove \nDuke\n from the collection.\ncollection.remove(model);\n\n// Completely replace all items in the collection.\ncollection.reset([\n  {\nname\n: \nHawk\n},\n  {\nname\n: \nJane\n}\n]);\n\n\n\n\n用户\n\n\n在许多应用中，都有一个用户账户的概念，用户账户让用户可以用安全的方式访问他们自己的信息。我们提供了一个特殊的用户类叫\nBmob.User\n来自动处理有关用户的账户管理的功能。\n\n\nBmob.User\n是\nBmob.Object\n的一个子类，而且有\nBmob.Object\n一样的功能，比如可变的模式、自动的持久化、键值对接口等。所有对\nBmob.Object\n有用的方法同样可以作用于\nBmob.User\n。\nBmob.User\n的不同之处在于\nBmob.User\n对于用户的账户有一些特定的功能。\n\n\n属性\n\n\nBmob.User\n有一些与\nBmob.Object\n不一样的字段:\n\nusername\n：用户的用户名（必须提供）\n\npassword\n：用户的密码（在注册的时候必须提供）\n\nemail\n：用户的 email（可选）\n\nuserData\n：每个微信用户的唯一标识，包括用户openId、expires_in、session_key（可选,自行创建，Object类型）\n我们会在下面的用例中详细介绍细节\n\n\n注册一（使用用户账号密码进行注册）\n\n\n通常你的app第一件要做的事情就是让用户进行注册，这里把用户密码设置为\nOpenid\n，下面的代码展示了怎样进行微信注册的过程（包括获取用户的唯一标识）：\n\n\n首先要在_User表新建一个用来存用户唯一标识的字段，例如：userData(Object类型)，然后在js中插入以下代码：\n\n\nwx.login({\n  success: function(res) {\n    if (res.code) {\n        Bmob.User.requestOpenId(res.code, {//获取userData(根据个人的需要，如果需要获取userData的需要在应用密钥中配置你的微信小程序AppId和AppSecret，且在你的项目中要填写你的appId)\n          success: function(userData) {\n              wx.getUserInfo({\n                  success: function(result) {\n                    var userInfo = result.userInfo\n                    var nickName = userInfo.nickName\n\n                    var user = new Bmob.User();//开始注册用户\n                    user.set(\nusername\n, nickName);\n                    user.set(\npassword\n, userData.openid);//因为密码必须提供，但是微信直接登录小程序是没有密码的，所以用openId作为唯一密码\n                    user.set(\nuserData\n, userData);\n                    user.signUp(null, {\n                        success: function(res) {\n                          console.log(\n注册成功!\n);\n                        },\n                        error: function(userData, error) {\n                          console.log(error)\n                        }\n                    });\n                  }\n              })\n          },\n          error: function(error) {\n              // Show the error message somewhere\n              console.log(\nError: \n + error.code + \n \n + error.message);\n          }\n      });\n\n    } else {\n      console.log('获取用户登录态失败！' + res.errMsg)\n    }\n  }\n});\n\n\n\n\n这个调用会异步地在在你的应用中创建一个新的用户。在它这样做之前，它同样会确认用户名和\nemail\n在应用内都是唯一的。同样，我们从不会将用户密码以明文向任何客户端发送。\n\n\n注意我们使用了\nsignUp\n方法而不是\nsave\n方法，新的\nBmob.User\n永远应该使用\nsignUp\n方法来新建。而随后的用户的信息更新可以调用\nsave\n来做。\n\n\n如果一个\nsignup\n没有成功的话，你应该读取返回的错误对象。最常见的问题是\nusername\n或者\nemail\n已经被其他用户所使用了。你应该清楚地反馈给你的用户，让他们再次用一个不同的用户名来注册。\n\n\n你也可以使用\nemail\n来作为用户名，只要求你的用户输入他们的\nemail\n但是同时自动填充好\nusername\n属性就可以了，\nBmob.User\n会跟原来一样工作，我们会在下面的重设密码环节再次说明这个细节。\n\n\n注册二（登录注册集合类，接口默认第一次注册，否则返回用户信息）\n\n\n首先要在_User表新建一个用来存用户唯一标识的字段，例如：userData(Object类型)，然后在js中插入以下代码：\n\n\n\nvar user = new Bmob.User();//实例化\n\nwx.login({\n\n        success: function (res) {\n          user.loginWithWeapp(res.code).then(function (user) {\n            var openid = user.get(\nauthData\n).weapp.openid;\n            console.log(user, 'user', user.id, res);\n            if (user.get(\nnickName\n)) {\n\n              // 第二次登录，打印用户之前保存的昵称\n              console.log(user.get(\nnickName\n), 'res.get(\nnickName\n)');\n\n              //更新openid\n              wx.setStorageSync('openid', openid)\n            } else {//注册成功的情况\n\n              var u = Bmob.Object.extend(\n_User\n);\n              var query = new Bmob.Query(u);\n              query.get(user.id, {\n                success: function (result) {\n                  wx.setStorageSync('own', result.get(\nuid\n));\n                },\n                error: function (result, error) {\n                  console.log(\n查询失败\n);\n                }\n              });\n\n\n              //保存用户其他信息，比如昵称头像之类的\n              wx.getUserInfo({\n                success: function (result) {\n\n                  var userInfo = result.userInfo;\n                  var nickName = userInfo.nickName;\n                  var avatarUrl = userInfo.avatarUrl;\n\n                  var u = Bmob.Object.extend(\n_User\n);\n                  var query = new Bmob.Query(u);\n                  // 这个 id 是要修改条目的 id，你在生成这个存储并成功时可以获取到，请看前面的文档\n                  query.get(user.id, {\n                    success: function (result) {\n                      // 自动绑定之前的账号\n\n                      result.set('nickName', nickName);\n                      result.set(\nuserPic\n, avatarUrl);\n                      result.set(\nopenid\n, openid);\n                      result.save();\n\n                    }\n                  });\n\n                }\n              });\n\n\n            }\n\n          }, function (err) {\n            console.log(err, 'errr');\n          });\n\n        }\n      });\n    }\n\n\n\n\n\n\n登录（自有账户密码登录，适合APP迁移过来的用户）\n\n\n如果你要求你的用户用你自己设计的注册页面注册后，当然应该让他们在以后用自己的账户登录进来，你可以使用\nlogIn\n方法来进行登陆：\n\n\nBmob.User.logIn(\nmyname\n, \nmypass\n, {\n  success: function(user) {\n    // Do stuff after successful login.\n  },\n  error: function(user, error) {\n    // The login failed. Check error to see why.\n  }\n});\n\n\n\n\n验证 Email\n\n\n在application设置中启用email验证可以让你的应用给最终用户一些更安全的使用体验，譬如部分功能只开放给验证过邮箱的用户使用等等。Email验证会在\nBmob.User\n上加入一个\nemailVerified\n字段。当一个\nBmob.User\n的\nemail\n被设定或者修改后,\nemailVerfied\n会被设定为\nfalse\n。Bmob 会向用户的\nemail\n来发送一个链接，点击这个链接会设置\nemailVerified\n为\ntrue\n：\n\n\n有三种\nemailVerified\n状态可以供参考：\n\n\n\n\ntrue\n：用户已经通过点击Bmob发过来的链接来确认邮箱地址. 当用户账户新创建的时候这个值永远不应该是true。\n\n\nfalse\n：在 \nBmob.User\n对象最后一次刷新的时候，用户还是没有确认他们的\nemail\n地址，如果\nemailVerified\n是false 的话，你应该考虑调用\nBmob.User\n的\nfetch\n方法。\n\n\nmissing\n：\nBmob.User\n被创建了，但是当时的\nemail\n验证功能还没有开启, 或者说\nBmob.User\n没有email地址。\n\n\n\n\n代码例子如下：console.log\n\n\n//reset password\n Bmob.User.requestEmailVerify(\nh6k65@126.com\n, {\n  success: function() {\n    // Password reset request was sent successfully\n  },\n  error: function(error) {\n    // Show the error message somewhere\n    console.log(\nError: \n + error.code + \n \n + error.message);\n  }\n});\n\n\n\n\n当前用户\n\n\n如果用户每次打开App的时候都要求登录无疑是令人感到厌烦的，你可以通过缓存当前的\nBmob.User\n对象来避免这个问题。\n\n\n无论你使用任何注册或者登录方法，用户都会在\nlocalStorage\n中储存，你可以把缓存作为一个\nsession\n对待，并且自动假设用户已经登录了。\n\n\nvar currentUser = Bmob.User.current();\nif (currentUser) {\n    // do stuff with the user\n} else {\n    // show the signup or login page\n}\n\n\n\n\n你可以通过\nlogout\n来清除掉当前的用户：\n\n\nBmob.User.logOut();\n\nvar currentUser = Bmob.User.current();  // this will now be null\n\n\n\n\n用户对象的安全\n\n\nBmob.User\n类默认就是受保护的，在\nBmob.User\n中保存的数据只能被那个用户所修改。默认地，数据仍然可以被任意客户端所读取。这样就是说，有些\nBmob.User\n对象被认证后是可以修改的，其他的仍然是只读的。\n\n\n特别的，你不能调用\nsave\n或者\ndelete\n方法除非\nBmob.User\n经过了认证，就比如调用过了\nlogIn\n或者\nsignUp\n方法，这样保证只有用户能改动他们自身的数据。\n\n\n下面的代码展示了上面说的安全策略：\n\n\nvar user = Bmob.User.logIn(\nmy_username\n, \nmy_password\n, {\n  success: function(user) {\n    user.set(\nusername\n, \nmy_new_username\n);  // attempt to change username\n    user.save(null, {\n      success: function(user) {\n        // This succeeds, since the user was authenticated on the device\n\n        // Get the user from a non-authenticated method\n        var query = new Bmob.Query(Bmob.User);\n        query.get(user.objectId, {\n          success: function(userAgain) {\n            userAgain.set(\nusername\n, \nanother_username\n);\n            userAgain.save(null, {\n              error: function(userAgain, error) {\n                // This will error, since the Bmob.User is not authenticated\n              }\n            });\n          }\n        });\n      }\n    });\n  }\n});\n\n\n\n\n从\nBmob.User.current()\n获取的\nBmob.User\n总是已经通过验证了的。\n\n\n如果你需要查看一个\nBmob.User\n是否已经认证过了，你可以调用\nauthenticated\n方法，你不需要查看一个认证方法中返回的\nBmob.User\n对象是否已经通过验证了。\n\n\n其他对象的安全\n\n\n和\nBmob.User\n相同的安全模型也使用于其他对象。对于任何对象来说，你可以指定哪些用户会被允许读取对象，哪些用户被允许修改对象。为了支持这种安全机制，每一个对象都有一个允许访问列表 (ACL)，是被\nBmob.ACL\n类所实现的。\n\n\n使用一个\nBmob.ACL\n最简单的方式是指定一个对象只能被一个单一的用户读或者写。为了创建这样的对象，首先必须有一个已经登录的\nBmob.User\n。然后，新的\nBmob.ACL(user)\n生成一个\nBmob.ACL\n来限定\nuser\n的访问。一个对象的ACL会在对象保存的时候被存储起来，就像其他的属性一样，这样，为了创建一个当前user私有的一个note：\n\n\nvar Note = Bmob.Object.extend(\nNote\n);\nvar privateNote = new Note();\nprivateNote.set(\ncontent\n, \nThis note is private!\n);\nprivateNote.setACL(new Bmob.ACL(Bmob.User.current()));\nprivateNote.save();\n\n\n\n\n这个note只能由当前的用户所访问，但是可以在用户登录的任何设备上访问，只要是相同的用户就可以了。这项功能对于你如果想让用户再任何其他的设备上保存和访问数据十分有用，比如说一个私人的todo list应用。\n\n\n权限也能在使用者的基础上授予，你可以通过\nsetReadAccess\n和\nsetWriteAccess\n方法独立的向\nBmob.ACL\n中添加权限。比如，假设你有一条消息想要发送给一个组里的多个用户，他们中的每一个都有读和写的权限：\n\n\nvar Message = Bmob.Object.extend(\nMessage\n);\nvar groupMessage = new Message();\nvar groupACL = new Bmob.ACL();\n\n// userList is an array with the users we are sending this message to.\nfor (var i = 0; i \n userList.length; i++) {\n  groupACL.setReadAccess(userList[i], true);\n  groupACL.setWriteAccess(userList[i], true);\n}\n\ngroupMessage.setACL(groupACL);\ngroupMessage.save();\n\n\n\n\n你同样可以对所有的用户授权，只要使用\nsetPublicReadAccess\n和\nsetPublicWriteAccess\n就可以了。这样允许了在一个消息板上发评论的模式，比如，我们要创建一个post只能被它的作者修改，但是可以被所有人读取：\n\n\nvar publicPost = new Post();\nvar postACL = new Bmob.ACL(Bmob.User.current());\npostACL.setPublicReadAccess(true);\npublicPost.setACL(postACL);\npublicPost.save();\n\n\n\n\n比如说删除一个对象，但是你没有写的权限这种操作是禁止的，这样会返回一个\nBmob.Error.OBJECT_NOT_FOUND\n的错误码，为了安全起见，这样防止了客户端区分出到底有哪些对象被创建了但是无法读取还是根本不存在。\n\n\n重设密码\n\n\n在现实中只要你引入了密码系统，总会有用户会忘掉他们的密码。在这种情形下，我们的库提供一个让他们安全地重设密码的功能。\n\n\n为了能让用户重设密码，应该要求用户提供他们的email地址，然后这样调用：\n\n\n Bmob.User.requestPasswordReset(\ntest@126.com\n, {\n  success: function() {\n    // Password reset request was sent successfully\n  },\n  error: function(error) {\n    // Show the error message somewhere\n    console.log(\nError: \n + error.code + \n \n + error.message);\n  }\n});\n\n\n\n\n这样会尝试匹配给定的email和用户的email或者username字段，然后会发送用户的密码重设邮件。由于我们是这样做的，所以你可以选择用户是否拿email作为他们的用户名，或者说用户把email作为用户的另一个信息保存。\n\n\n密码重设的流程如下:\n\n\n\n\n用户输入email来请求重设他们的密码。\n\n\nBmob向用户的email地址发送邮件，包含了一个重设密码的链接。\n\n\n用户点击这个重设密码的链接，会重定向到一个Bmob页面来允许他们重设密码。\n\n\n用户输入新的密码，他们的密码现在会更新为输入的新密码。\n\n\n\n\n查询\n\n\n为了查询用户，你可以简单的创建一个\nBmob.Query\n针对\nBmob.Users\n：\n\n\nvar query = new Bmob.Query(Bmob.User);\nquery.equalTo(gender, \nfemale\n);  // find all the women\nquery.find({\n  success: function(women) {\n    // Do stuff\n  }\n});\n\n\n\n\n关联\n\n\n关联一个\nBmob.User\n的对象可以很快就见效，比如说，假设你有一个blog程序，为了保存一个用户的新post还有读取他们所有的post。\n\n\nvar user = Bmob.User.current();\n\n// Make a new post\nvar Post = Bmob.Object.extend(\nPost\n);\nvar post = new Post();\npost.set(\ntitle\n, \nMy New Post\n);\npost.set(\nbody\n, \nThis is some great content.\n);\npost.set(\nuser\n, user);\npost.save(null, {\n  success: function(post) {\n    // Find all posts by the current user\n    var query = new Bmob.Query(Post);\n    query.equalTo(\nuser\n, user);\n    query.find({\n      success: function(usersPosts) {\n        // userPosts contains all of the posts by the current user.\n      }\n    });\n  }\n});\n\n\n\n\nACL和角色\n\n\n数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看\nBmob数据与安全页面\n，了解Bmob如何保护数据安全）。\n\n\n其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。\n\n\n大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：\n\n\n\n\n对于私有数据，读写权限可以只局限于数据的所有者。\n\n\n对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。\n\n\n对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。\n\n\n属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。\n\n\n一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。\n\n\n\n\nACL的格式\n\n\n在Bmob中，ACL是按JSON对象格式（key-value）来表示的。这个JSON对象的key是objectId（用户表某个用户对应的objectId）或者是*(表示公共的访问权限)，ACL 的值是\"读和写的权限\"，这个JSON对象的key总是权限名，而这些key的值总是true。\n\n\n如果您想让一个id为\"Kc3M222k\"的用户有读和写一条数据的权限，而且这个数据应该可以被全部人读取的话，这个ACL的表达方式如下：\n\n\n{\n  \nKc3M222k\n: {\n    \nread\n: true,\n    \nwrite\n: true\n  },\n  \n*\n: {\n    \nread\n: true\n  }\n}\n\n\n\n\n角色和相关操作\n\n\n在很多情况下，你需要定义一些用户具有某种相同的数据操作权限，而另外一群用户具有另外一种相同的数据操作权限，这时你就可以使用到Bmob的角色（对应Bmob在Web提供的Role表、SDK中的BmobRole类）功能，设置不同的用户组不同的操作权限。角色表有三个特殊字段：\n\n\nname\n : 必须字段，表示角色名称,而且只允许被设置一次（命名必须由字母, 空格, 减号或者下划线构成）。\n\n\nusers\n :一个指向一系列用户的关系, 这些用户会继承角色的权限。\n\n\nroles\n : 一个指向一系列子角色的关系, 这些子关系会继承父角色所有的权限。\n\n\n创建角色\n\n\nvar roleACL = new Bmob.ACL();\nroleACL.setPublicReadAccess(true);\nvar role = new Bmob.Role(\ntest\n, roleACL);\nrole.save();\n\n\n\n\n角色对象的安全性\n\n\nBmob.Role\n使用和其他Bmob对象一样的ACL权限策略, 除开它需要ACL被显式地设置以外。通常来说，只有用户有极大的权限（比如管理员）才应该被允许创建或者更改Role，所以你应该按这种标准来设定Role的ACL。请注意，如果你给了用户一个\nBmob.Role\n一个写权限，这个用户有可能会在这个权限中加入另一个user，或者甚至直接把角色删除掉。\n\n\n为了创建一个新的\nBmob.Role\n，你应该如下写：\n\n\n// By specifying no write privileges for the ACL, we can ensure the role cannot be altered.\nvar roleACL = new Bmob.ACL();\nroleACL.setPublicReadAccess(true);\nvar role = new Bmob.Role(\nAdministrator\n, roleACL);\nrole.save();\n\n\n\n\n你可以通过增加\"user\"和\"roles\"关系的成员来在\nBmob.Role\n中加入用户或者子角色：\n\n\nvar role = new Bmob.Role(roleName, roleACL);\nfor (var i = 0; i \n usersToAddToRole.length; i++) {\n  role.getUsers().add(usersToAddToRole[i]);\n}\nfor (var i = 0; i \n rolesToAddToRole.length; i++) {\n  role.getRoles().add(rolesToAddToRole[i]);\n}\nrole.save();\n\n\n\n\n请非常注意一点，注册角色的ACL的时候，它们只能被应该有权限修改它的人修改。\n\n\n其他对象的安全性\n\n\n现在你应该已经创建了在你的程序中要使用的一系列的角色，你可以用ACL来定义他们的用户可以拥有的权限，每一个\nBmob.Object\n都可以指定一个\nBmob.ACL\n，这样提供了哪些用户或者角色应该有权限来读或者写这个对象。\n\n\n将一个读或者写的权限授予一个角色是很直观的，你可以使用\nBmob.Role\n：\n\n\nvar moderators = /* Query for some Bmob.Role */;\nvar wallPost = new Bmob.Object(\nWallPost\n);\nvar postACL = new Bmob.ACL();\npostACL.setRoleWriteAccess(moderators, true);\nwallPost.setACL(postACL);\nwallPost.save();\n\n\n\n\n你可以不需要查找这个Role，直接把名字提供给ACL：\n\n\nvar wallPost = new Bmob.Object(\nWallPost\n);\nvar postACL = new Bmob.ACL();\npostACL.setRoleWriteAccess(\nModerators\n, true);\nwallPost.setACL(postACL);\nwallPost.save();\n\n\n\n\n角色继承\n\n\n就像上面所描述的一样，一个角色可能包含其他的角色，表示两个角色之间的父-子关系，这样做的结果就是任何被授予一个角色的权限都会被隐式地授予这个角 色的所有子角色。\n\n\n这样的关系很经常会在有用户管理内容的程序之中看到，比如论坛，有一个很少量的用户称为管理员，有最高的权限，比如程序设定、创建新的论坛、设定所有人能看到的内容等等。另一类有一部分类似于\"版主\" 的用户，这些人有责任保持用户创建的内容是合适的，任何一个\"版主\"有的权限\"管理员\"都应该有。为了启用这种关系，你应该使\"管理员\"成为\"版主\"的一个子角色。\n\n\nvar administrators = /* Your \nAdministrators\n role */;\nvar moderators = /* Your \nModerators\n role */;\nmoderators.getRoles().add(administrators);\nmoderators.save();\n\n\n\n\n地理位置\n\n\n创建地理位置对象\n\n\n地理位置对象的创建需要用到\nBmob.GeoPoint\n类，如创建一个地理位置在纬度40度，经度在-30度的点的示例代码如下：\n\n\nvar point = new Bmob.GeoPoint({latitude: 40.0, longitude: -30.0});\n\n\n\n\n查询地理位置对象\n\n\n现在你可以有一系列的对象可以做空间坐标查询了，如果能轻松地发现有哪些对象离一个点最近就好了。这样可以通过在\nBmob.Query\n中加入一个\nnear\n来做查询，为了获得离用户最近的10个地点列表，可以这样：\n\n\n// location对应Web后台的一个字段名称\nvar userGeoPoint = userObject.get(\nlocation\n);\n// 创建查询\nvar query = new Bmob.Query(PlaceObject);\n// location附近的位置\nquery.near(\nlocation\n, userGeoPoint);\n// 返回10个地点数据\nquery.limit(10);\n// 查询\nquery.find({\n  success: function(placesObjects) {\n  }\n});\n\n\n\n\n在这时\nplaceObjects\n会返回一个按离\nuserGeoPoint\n的距离排序的列表，注意如果一个\nascending()/descending()\n给了查询的话，会取代按距离排序这项特性。\n\n\n为了按距离限制返回的结果，你可以使用\nwithinMiles\n、\nwithinKilometers\n和\nwithinRadians\n。\n\n\n同样，查询在特定地域的Object是可以的。为了找到用矩形表示的一块地域中的对象，加入\nwithinGeoBox\n来在\nBmob.Query\n中加入约束。\n\n\nvar southwestOfSF = new Bmob.GeoPoint(37.708813, -122.526398);\nvar northeastOfSF = new Bmob.GeoPoint(37.822802, -122.373962);\n\nvar query = new Bmob.Query(PizzaPlaceObject);\nquery.withinGeoBox(\nlocation\n, southwestOfSF, northeastOfSF);\nquery.find({\n  success: function(pizzaPlacesInSF) {\n    ...\n  }\n});\n\n\n\n\n小程序使用云逻辑\n\n\n端逻辑调用使用Bmob.Cloud.run方法，如调用云函数中的\"test\"方法，并传递name参数到服务器中的示例代码如下：\n\n\nBmob.Cloud.run('test', {\nname\n:\ntom\n}, {\n  success: function(result) {\n    console.log(result);\n  },\n  error: function(error) {\n  }\n})\n\n\n\n\n如果不需要传递参数，示例代码如下：\n\n\nBmob.Cloud.run('test', {}, {\n  success: function(result) {\n    console.log(result);\n  },\n  error: function(error) {\n  }\n})", 
            "title": "开发文档"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_1", 
            "text": "Bmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。", 
            "title": "简介"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_2", 
            "text": "Bmob示例包含常用接口（学习示例）： https://github.com/magic007/wechatAppDemo  （采用实时数据同步SDK开发，里面几乎包含了小程序开发常见功能示例代码，右击可直接查看源码）\n扫描二维码查看    心邮（官方线上项目）： https://github.com/bmob/Bmob-wechatapp-xinyou  （采用实时数据同步SDK开发，右击可直接查看源码）    1.生日工具                    -------工具类  2.足迹地图  3.接力喵视频                -------视频类  4.像素涂鸦  5.地道美食地图           -------LBS  6.胖熊圈  7.有货Hk  8.厦漳泉生活通               -------本地生活  9.极简笔记  10.衣在线                  -------商城  11.活动报名表                -------工具类  12.味蕾点餐               -------点餐  13.烟台微拼               -------本地生活  14.顺德便利贴  15.同城生活广告  16.点点英语学堂  17.朝露时刻               -------音频类  18.青岛一起秀科学俱乐部  19.纸塘                 -------17年6月最热门的小程序  20.雷湖古琴艺术  21.皋城文明随手拍   -----政府  22.阅后即焚图片分享  23.猎位共享停车  24.听写宝  25.嘿车出行  26.喵星人宠物社区  27.标签生成器  28.视频看房  29.海南黎家特产  30.轩宇工具  31.在旅途看世界  32.寻遍美食地图  33.Bmob示例  34.鲁山拼车  33.莲馨图书室          图书馆-扫描借书  34.灵动云课堂  35.9cam     视频类  36.恋爱迹  37.融信品质生活服务  38.全民摄影秀  39.农电微服务    国家电网公司  40.壁纸印象  41.跟妆师  42.高能名片  43.婚纱lite  44.张阿姨打扫  45.吃决策  46.比心比价  47.蜂鸟作业               教育  48.美味面包lite  51.幸福的5班  52.大武汉公交               交通  53.Buy优选                  淘客  54.码赚  55.附近的圈子  56.吴忠意大利冰淇淋          实体店点餐  57.摩西讲单词     教育  58.贝莱福居  59.花间集鲜花  60.柏亚阅读书吧  61.找我跑腿服务  62.橙色工地圈  63.大学城活动报名  64.聚合助手  65.圆桌绿色版  66.我的王者名片  67.趣猫  68.管图智能选座          大学图书馆  69.呼伦贝尔二手车平台  70.我的王者名片  71.万能服           答题应用  官方交流QQ群：118541934 。欢迎提交给我们", 
            "title": "典型案例"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_3", 
            "text": "在Bmob平台注册后，每个账户可创建多个应用程序，创建的每个应用程序都有其独自的应用程序ID，此后所有的应用程序将凭其ID进行Bmob SDK的使用。即使只有一个应用程序，也可以以不同的版本进行测试和生产。", 
            "title": "应用程序"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_4", 
            "text": "", 
            "title": "对象"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_5", 
            "text": "Bmob数据存储是建立在 Bmob.Object 基础上的。如写日记的 Bmob.Object 示例如下：  title:  I am title , content:  I am content   这里需要注意的是：anchor   键必须是字母或者数字的字符串，值可以是字符串、数字、布尔值或者数组和字典。  每一个 Bmob.Object 都是一个特定子类的实例，子类名可以来区分各种数据，如我们可以把写日记的类称之为 diary 。", 
            "title": "数据对象"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_6", 
            "text": "你可以使用 Bmob.Object.extend 方法来创建新的 Bmob.Object 子类，示例代码如下：  \n    // 创建Bmob.Object子类\n    var Diary = Bmob.Object.extend( diary );\n\n    // 创建该类的一个实例\n    var diary = new Diary();  如果你想为 Bmob.Object 的子类添加一些实例方法和类方法，示例代码如下：  \n    // 为Bmob.Object的子类添加实例方法和类方法\n    var Diary = Bmob.Object.extend( diary , {\n      //实例方法\n      gleaterThanOneHundred: function() {\n        return this.get( title );\n      }\n    }, {\n      //类方法\n      spawn: function(title) {\n        var diary = new Diary();\n        diary.set( title , title);\n        return diary;\n      }\n    });\n\n    var diary = Diary.spawn( hello world );\n    console.log(diary.gleaterThanOneHundred());", 
            "title": "创建对象"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_7", 
            "text": "图文素材，类似微信的图文素材，经常被用在活动、广告、详细说明等情况。\n使用图文素材系统会生成一个 _Article  的数据表。如需取出图文素材的数据，只需跟普通表一样操作即可。", 
            "title": "小程序使用图文素材"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_8", 
            "text": "var Diary = Bmob.Object.extend( _Article );\n      var diary = new Diary();\n      diary.set( title , hello );\n      diary.set( content , hello world );\n      //添加数据，第一个入口参数是null\n      diary.save(null, {\n        success: function(result) {\n          // 添加成功，返回成功之后的objectId（注意：返回的属性名字是id，不是objectId），你还可以在Bmob的Web管理后台看到对应的数据\n            console.log( 创建成功, objectId: +result.id);\n        },\n        error: function(result, error) {\n          // 添加失败\n          console.log('创建失败');\n\n        }\n      });", 
            "title": "增加一篇图文"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_9", 
            "text": "为了满足应用各类需求，保存的内容会生成一个HTML文件，存在您的文件中，如应用支持显示HTML，可直接显示，或者url内容转发到朋友圈。  ps:最近小程序也推出了显示H5页面，如果需要使用，可开通FTP功能自己管理应用的文件空间。", 
            "title": "静态文件"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_10", 
            "text": "由于最近微信封了~~*.upaiyun.com~~   域名，如果你没做文件下载功能，只是显示图片，可以不填写。如果你需要做下载功能，在应用设置里面，可以开启独立域名， 开启后，填写到微信平台就好了，当然有时候你想用自己的域名，也是可以的，可以工单联系我们。", 
            "title": "下载域名"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_11", 
            "text": "对一些应用有嵌入微信客服消息，需要主动实时收到用户反馈，并希望手机可以回复消息的，可以基于云逻辑开发此功能，如果完全不想写代码实现也可以联系我们,出一定费用整套客服系统帮上线。  简介地址： http://www.jianshu.com/p/540a8db78fbf", 
            "title": "客服消息"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#websocket", 
            "text": "一个微信小程序同时只能有一个 WebSocket 连接，如果当前已存在一个 WebSocket 连接，会创建失败。WebSocket可以做一些实时数据功能，比如聊天室，你画我猜之类的游戏。具体文档参考~~JavaScript- 实时数据平台~~", 
            "title": "WebSocket"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_12", 
            "text": "微信主动推送通知，业务场景：比如你有APP，有人下单了，或者有人留言了。你可以收到微信推送通知。  支持2种调用方法\n1.小程序\n2.restful  1.小程序 Bmob.sendMasterMessage 调用主人通知接口  \n成功后发送主人模板消息，这个只需把openid改正确即可接收到， Bmob后端云公众号回复openid\n          var temp = {\n             touser :  oUxY3w_jURG89H5wCIvJDPjJ5s2o ,\n             template_id :  -ERkPwp0ntimqH39bggQc_Pj55a18CYLpj-Ert8-c8Y ,\n             url :  https://www.bmob.cn/ ,\n             data : {\n               first : {\n                 value :  您好，Restful 失效，请登录控制台查看。 ,\n                 color :  #c00 \n              },\n               keyword1 : {\n                 value :  Restful 失效 \n              },\n               keyword2 : {\n                 value :  2017-07-03 16:13:01 \n              },\n               keyword3 : {\n                 value :  高 \n              },\n               remark : {\n                 value :  如果您十分钟内再次收到此信息，请及时处理。 \n              }\n            }\n          }\n          console.log(temp);\n          Bmob.sendMasterMessage(temp).then(function (obj) {\n            console.log('发送成功');\n\n\n          }, function (err) {\n\n            common.showTip('失败' + err);\n          });  2.restful调用方式  \ncurl --request POST \\\n  --url http://api.bmob.cn/1/wechatApp/notifyMsg \\\n  --header 'content-type: application/json' \\\n  --header 'x-bmob-application-id: ' \\\n  --header 'x-bmob-rest-api-key: ' \\\n  --data '{\\n     touser :  oUxY3w_jURG89H5wCIvJDPjJ5s2o ,\\n     template_id : -ERkPwp0ntimqH39bggQc_Pj55a18CYLpj-Ert8-c8Y ,\\n     url :  http://www.bmob.cn/ ,\\n     data : {\\n         first : {\\n             value :  您好，Restful 失效，请登录控制台查看。 ,\\n             color :  #c00 \\n        },\\n         keyword1 : {\\n             value :  Restful 失效 \\n        },\\n         keyword2 : {\\n             value :  2017-07-03 16:13:01 \\n        },\\n         keyword3 : {\\n             value :  高 \\n        },\\n         remark : {\\n             value :  如果您十分钟内再次收到此信息，请及时处理。 \\n        }\\n    }\\n}'  PS: openid  关注Bmob后端云公众平台回复 openid  开放3个模板：\n1.新订单通知（template_id：K9-6_Ayj4MLC2yvwY60-cq18tngJHAlqDfsOvv3D7a8\n）  {{first.DATA}}\n\n提交时间：{{tradeDateTime.DATA}}\n订单类型：{{orderType.DATA}}\n客户信息：{{customerInfo.DATA}}\n{{orderItemName.DATA}}：{{orderItemData.DATA}}\n{{remark.DATA}}  2.系统报警通知（template_id：-ERkPwp0ntimqH39bggQc_Pj55a18CYLpj-Ert8-c8Y\n）  {{first.DATA}}\n系统名称：{{keyword1.DATA}}\n报警时间：{{keyword2.DATA}}\n报警级别：{{keyword3.DATA}}\n{{remark.DATA}}  3.购买成功通知（template_id：Mbk3kYqRGkL98ch6Lie4XSXtOsxXj2SC0SRQXd89G1Y\n）  您好，您已购买成功。\n\n商品信息：{{name.DATA}}\n{{remark.DATA}}  4.审核结果通知（template_id：aNNNmi7WK4kohleWhCkDRKJiHOZnIpkrhXx5XPx4dx0\n）  {{first.DATA}}\n账号名称：{{keyword1.DATA}}\n审核状态：{{keyword2.DATA}}\n审核时间：{{keyword3.DATA}}\n{{remark.DATA}}  ps：目前每个应用，每天有100条的免费额度，如需更多，可以工单联系我们", 
            "title": "微信主人通知接口"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_13", 
            "text": "生成推广二维码非常简单，比如你是传统企业，你可以为你店里每件衣服生成一个二维码，用户扫描直接可以付款定位到那件衣服，如果你是餐厅老板，客户在桌子上扫描二维码可以定位那张桌子。如果你是互联网企业，你可以发布二维码到朋友圈，可以定位到是谁推荐了这个用户，这个用户上级是谁，等等。Bmob封装了生成二维码函数，以下示例代码。  Bmob.generateCode 参数列表     键  值  参数说明      path  pages/index/index  页面路径，支持参数    width  430  二维码宽度    interface  a\\b\\c  对应微信二维码abc方案    scene  Bmob  微信B方案才需要此值    type  0/1  默认0，返回二维码base64数据.如果为1则服务端返回为二维码网络路径     更多微信官方小程序码介绍  微信官方小程序码介绍  \n\nformSubmit: function (event) {\n        var path = event.detail.value.path; //路径\n        var width = event.detail.value.width; //宽度\n        var that = this;\n        Bmob.generateCode({  path : path,  width : width }).then(function (obj) {\n            console.log(obj);\n            that.setData({\n                imageBytes: obj.imageBytes  //二维码示例\n            })\n\n        }, function (err) {\n\n            //失败\n        });\n    }", 
            "title": "生成小程序二维码"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#id", 
            "text": "有些时候，我们小程序需要把内容分享到微信群，统计每个微信群有多少用户来查看了此信息。可以使用此接口，下面是微信官方的2个说法   当用户成功地将小程序页面分享到微信群的时候，小程序的回调中可以获取分享目标的微信群 ID。   当用户从微信群进入小程序页面的时候，小程序启动时可以获取用户进入小程序的渠道群聊 ID。  \nPage({\n  onLoad () {\n    wx.showShareMenu({\n      withShareTicket: true //要求小程序返回分享目标信息\n    })\n  },\n  // 其他的页面函数、生命周期函数等\n  onShareAppMessage() {\n    return {\n      title: '页面分享标题',\n      path: '/pages/path/to/target',\n      success(res){\n        console.log(res.shareTickets);\n                wx.getShareInfo({\n          shareTicket: res.shareTickets,\n          complete(res) {\n\n            //内部调用云函数\n            var currentUser = Bmob.User.current();\n            var data = {  objectId : currentUser.id,  encryptedData : res.encryptedData,  iv : res.iv};\n            console.log(data);\n\n            // console.log(data);\n            Bmob.Cloud.run('getOpenGId', data).then(function (obj) {\n              // var res = JSON.parse(obj)\n              console.log(obj)\n            }, function (err) {\n              console.log(err)\n            });\n\n          }\n        })\n\n\n      }\n    }\n  }\n}   页面只要加上这2个函数，即可实现转发到群功能，这里主要讲下解密群ID。  解密群ID主要是通过云逻辑来实现，这里添加一个 getOpenGId  逻辑。你也可以复制腾讯官方提供的nodejs里面的代码  \nfunction onRequest(request, response, modules) {\n    var objectId = request.body.objectId;\n    var db = modules.oData;\n    var crypto = modules.crypto;\n    db.findOne({\n         table :  _User ,\n        //表名\n         objectId : objectId //记录的objectId\n    },\n    function(err, data) {\n        //回调函数\n        var data = JSON.parse(data);\n        var sessionkey = data.authData.weapp.session_key;   //微信最新版本改版，此id是由前端发送过来\n        var encryptedData = request.body.encryptedData;\n        var iv = request.body.iv\n        var groupid = groupIdParse(modules, sessionkey, encryptedData, iv) response.end(groupid);\n\n    });\n\n    function groupIdParse(modules, sessionKey, encryptedData, iv) {\n        var crypto = modules.oCrypto;\n        var sessionKey = new Buffer(sessionKey, 'base64'); //new Base64().decode(sessionKey);\n        encryptedData = new Buffer(encryptedData, 'base64'); //new Base64().decode(encryptedData);\n        iv = new Buffer(iv, 'base64'); //new Base64().decode(iv)\n        var result = '';\n        try {\n            // 解密\n            var decipher = crypto.createDecipheriv('aes-128-cbc', sessionKey, iv)\n            // 设置自动 padding 为 true，删除填充补位\n            decipher.setAutoPadding(true) var decoded = decipher.update(encryptedData, 'binary', 'utf8') decoded += decipher.final('utf8') result = decoded;\n            // decoded = JSON.parse(decoded)\n        } catch(err) {\n            throw new Error('Illegal Buffer123' + err)\n        }\n        //  if (decoded.watermark.appid !== this.appId) {\n        //     //  throw new Error('Illegal Buffer')\n        // }\n        return result;\n    }\n\n}  解密返回数据： {\"openGId\":\"GLfcX0ber2CAPtXng-ac4g8zyNmk\",\"watermark\":{\"timestamp\":1496720764,\"appid\":\"wx77d6b7031c1e4763\"}}  如果你的应用功能出现解密报错，你可以写死传过来的三个变量，示例：  var sessionKey= xTlW5jfSUP3Kx0vC5PJbmw== ;\n    var encryptedData= SLvbzyuyck7384tlGjXwI5Meb2LydIhUGvwerwsvJhws1EJb7LnFPX1MfRcTyF8Bfj0ZRP8wu8XR+7hmTqgdQx11nOlJA0RawSoTJNYmy9kfYQsdqTq5EX0rRH8VozPURnTrjM9EGbfqaN6EetI/aQ== ;\n    var iv= 7/TqHciNjSi3cdFFxr97ww== ;\n\n    var groupid=groupIdParse(modules,sessionKey,encryptedData,iv)\n    var jsongid=JSON.parse(groupid);\n    response.end(groupid);\n    return;", 
            "title": "小程序分享群Id"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_14", 
            "text": "小程序模板消息首先是通过获取 access_token 来发送。access_token有效期2小时。  模板消息支持2种方式调用。\n- 1.Restful\n- 2.小程序  Restful  curl -X POST \\\n  http://api.bmob.cn/1/wechatApp/SendWeAppMessage \\\n  -H 'cache-control: no-cache' \\\n  -H 'content-type: application/json' \\\n  -H 'x-bmob-application-id: XXX' \\\n  -H 'x-bmob-rest-api-key: XXX' \\\n  -d '{\n      touser :  osr4I0WBS4kZuD_5P-_-bxbSobTg ,\n         template_id :  omTTRD3pAMiAGKmyKo15Ifc2U_wLr6oWRZOifnTngvQ ,\n         page :  index ,\n         form_id : 3a8c5659469c9a582c8fd65054ea5307 ,\n         data : {\n           keyword1 : {\n             value :  SDK测试内容 ,\n             color :  #173177 \n          },\n       keyword2 : {\n           value :  2015年01月05日 12:30 \n      },\n       keyword3 : {\n           value :  Bmob科技 \n      }\n    }\n    , emphasis_keyword :  \n}'  Restful主要用在一些特殊情况，例如审核后给用户发送一个通知，定时发通知等这种要配合云逻辑或自己服务端来使用。  小程序内部调用比较常用，使用门槛低  var currentUser = Bmob.User.current();\nvar temp = {\n     touser : currentUser.get( openid ),\n     template_id :  B-2GcobfYnptevxY8G3SdA72YLYGZpOoJO_FEHlouWg ,\n     page :  ,\n     form_id : formId,\n     data : {\n         keyword1 : {\n             value :  SDK测试内容 ,\n             color :  #173177 \n        },\n         keyword2 : {\n             value :  199.00 \n        },\n         keyword3 : {\n             value :  123456789 \n        },\n         keyword4 : {\n             value :  2015年01月05日 12:30 \n        },\n         keyword5 : {\n             value :  恭喜您支付成功，如有疑问请反馈与我 \n        }\n    },\n     emphasis_keyword :  keyword1.DATA \n}\nBmob.sendMessage(temp).then(function(obj) {\n    console.log('发送成功')\n},\nfunction(err) {\n    common.showTip('失败' + err)\n});", 
            "title": "小程序模板消息"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_15", 
            "text": "方法调用与JavaScript一致，查看JavaScript 短信文档  请求短信验证码", 
            "title": "小程序短信验证码"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_16", 
            "text": "小程序支付只需发起请求获取微信需要的字段，这里用Bmob.Pay.wechatPay获取 nonceStr , packages , orderId 等相关信息。然后 wx.requestPayment弹窗支付页面，里面处理成功失败。 （Bmob的接口都是独立的，任何平台小程序都可以使用，自需要小程序微信开通都支持。目前小程序支付跟其他有APP区别Bmob平台不收取任何手续费，只要是Bmob平台付费会员都可使用。）  \n//传参数金额，名称，描述,openid\n    Bmob.Pay.wechatPay(0.01, '名称1', '描述', openId).then(function (resp) {\n      console.log('resp');\n      console.log(resp);\n\n      that.setData({\n        loading: true,\n        dataInfo: resp\n      })\n\n      //服务端返回成功\n      var timeStamp = resp.timestamp,\n        nonceStr = resp.noncestr,\n        packages = resp.package,\n        orderId = resp.out_trade_no,//订单号，如需保存请建表保存。\n        sign = resp.sign;\n\n      //打印订单号\n      console.log(orderId);\n\n      //发起支付\n      wx.requestPayment({\n        'timeStamp': timeStamp,\n        'nonceStr': nonceStr,\n        'package': packages,\n        'signType': 'MD5',\n        'paySign': sign,\n        'success': function (res) {\n          //付款成功,这里可以写你的业务代码\n          console.log(res);\n        },\n        'fail': function (res) {\n          //付款失败\n          console.log('付款失败');\n          console.log(res);\n        }\n      })\n\n    }, function (err) {\n      console.log('服务端返回失败');\n      common.showTip(err.message, 'loading',{},6000);\n      console.log(err);\n    });", 
            "title": "小程序支付"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_17", 
            "text": "添加数据非常简单，任何 Bmob.Object 子类都有 save 方法可以用于将当前对象的内容保存到服务端。示例代码如下：  \n    //创建类和实例\n    var Diary = Bmob.Object.extend( diary );\n    var diary = new Diary();\n    diary.set( title , hello );\n    diary.set( content , hello world );\n    //添加数据，第一个入口参数是null\n    diary.save(null, {\n        success: function(result) {\n          // 添加成功，返回成功之后的objectId（注意：返回的属性名字是id，不是objectId），你还可以在Bmob的Web管理后台看到对应的数据\n            console.log( 日记创建成功, objectId: +result.id);\n        },\n        error: function(result, error) {\n          // 添加失败\n          console.log('创建日记失败');\n\n        }\n    });  你也可以用如下的示例代码添加数据：  \n    var Diary = Bmob.Object.extend( diary );\n    var diary = new Diary();\n    // 添加数据，第一个入口参数是Json数据\n    diary.save({\n      title:  hello ,\n      content:  hello world \n    }, {\n      success: function(result) {\n        // 添加成功\n      },\n      error: function(result, error) {\n        // 添加失败\n      }\n    });  这里有几点需要注意的是:   如果云端数据库中不存在 diary 表，Bmob会自动地在你第一次使用它的时候创建。  每个 Bmob.Object 对象都有几个默认的字段是自动创建的： objectId 是一个对于每一个保存的对象为一个标志； createdAt 和 updatedAt 表示对象在Bmob中创建和最后一次更改的时间。这些字段的创建和内容是由服务器端自动完成的，在保存 Bmob.Object 之前不会存在。  添加成功后，可以通过 result.createdAt 获取对象的创建时间，通过 result.updatedAt 获取对象的更新时间；可以通过 result.id 获取对象的objectId。", 
            "title": "添加数据"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_18", 
            "text": "数据的查询是每个应用都会频繁使用到的，Bmob提供了 Bmob.Object 类，方便大家实现不同条件的查询。", 
            "title": "查询数据"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_19", 
            "text": "查询某个数据表中的所有数据是非常简单的，只需要使用 Bmob.Query 的 find 方法就可以了，示例代码如下：  var Diary = Bmob.Object.extend( diary );\nvar query = new Bmob.Query(Diary);\n// 查询所有数据\nquery.find({\n  success: function(results) {\n    console.log( 共查询到   + results.length +   条记录 );\n    // 循环处理查询到的数据\n    for (var i = 0; i   results.length; i++) {\n      var object = results[i];\n      console.log(object.id + ' - ' + object.get('title'));\n    }\n  },\n  error: function(error) {\n    console.log( 查询失败:   + error.code +     + error.message);\n  }\n});  如果你只想要一个结果，一个更加方便的方法是使用 first ，而不是 find 方法，示例代码如下：  var Diary = Bmob.Object.extend( diary );\nvar query = new Bmob.Query(Diary);\nquery.first({\n  success: function(object) {\n    // 查询成功\n  },\n  error: function(error) {\n    console.log( 查询失败:   + error.code +     + error.message);\n  }\n});  这里需要注意一点的是： \n默认情况下，系统实际上并不会返回所有的数据，而是默认返回10条数据记录，你可以通过setLimit方法设置返回的记录数量。更多细节可 点击查看分页查询 一节。", 
            "title": "查询所有数据"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_20", 
            "text": "注意，在对象中获取objectId，createdAt，updatedAt的方法分别如下：\nobj.id\nobj.createdAt\nobj.updatedAt", 
            "title": "获取对象的特殊属性"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_21", 
            "text": "当我们知道某条数据的 objectId 时，就可以根据 objectId 值直接获取单条数据对象，示例代码如下：  var Diary = Bmob.Object.extend( diary );\n//创建查询对象，入口参数是对象类的实例\nvar query = new Bmob.Query(Diary);\n//查询单条数据，第一个参数是这条数据的objectId值\nquery.get( 82c3e62d2c , {\n  success: function(result) {\n    // 查询成功，调用get方法获取对应属性的值\n    var title = result.get( title );\n    var content = result.get( content );\n  },\n  error: function(object, error) {\n    // 查询失败\n  }\n});", 
            "title": "查询单条数据"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_22", 
            "text": "如果要查询某个属性等于某个值，示例代码如下：  query.equalTo( title ,  bmob );  如果要查询某个属性不等于某个值，示例代码如下：  query.notEqualTo( title ,  bmob sdk );  如果要模糊查询某个值，示例代码如下（模糊查询目前只提供给付费套餐会员使用）：  query.equalTo( title , {  $regex :   + k +  .*  });  查询大于某个日期的数据，示例代码如下\nquery.equalTo(\"dateTime\", {\"$gte\":{\"__type\":\"Date\",\"iso\":\"2011-08-21 18:02:52\"}});  对查询的属性值进行大小比较的示例代码如下：  // score   50\nquery.lessThan(列名称, 50);\n\n// score  = 50\nquery.lessThanOrEqualTo(列名称, 50);\n\n// score   50\nquery.greaterThan(列名称, 50);\n\n// score  = 50\nquery.greaterThanOrEqualTo(列名称, 50);  两条查询语句一起写，就相当于 AND 查询，如下示例代码，查询同时满足 \"playerName\"=\"bmob\" and \"score\" 100 的数据：  query.notEqualTo( title ,  bmob );\nquery.greaterThan(列名称, 100);  一个完整的例子：  var Diary = Bmob.Object.extend( diary );\nvar query = new Bmob.Query(Diary);\nquery.equalTo( title ,  hello );\n// 查询所有数据\nquery.find({\n    success: function(results) {\n        console.log( 共查询到   + results.length +   条记录 );\n        // 循环处理查询到的数据\n        for (var i = 0; i   results.length; i++) {\n        var object = results[i];\n        console.log(object.id + ' - ' + object.get('title'));\n        }\n    },\n    error: function(error) {\n        console.log( 查询失败:   + error.code +     + error.message);\n    }\n});", 
            "title": "条件查询"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_23", 
            "text": "有时，在数据比较多的情况下，你希望查询出的符合要求的所有数据能按照多少条为一页来显示，这时可以使用 limit 方法来限制查询结果的数据条数来进行分页。默认情况下，Limit的值为10，最大有效设置值1000（设置的数值超过1000还是视为1000）。  // 返回最多10条数据\nquery.limit(10);  在数据较多的情况下，在 limit 的基础上分页显示数据是比较合理的解决办法， skip 方法可以做到跳过查询的前多少条数据来实现分页查询的功能。默认情况下 skip 的值为10。  query.skip(10); // skip the first 10 results", 
            "title": "分页查询"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_24", 
            "text": "我们可以对返回的结果进行排序（只支持 number ， date ， string 类型的排序），示例代码如下：  // 对score字段升序排列\nquery.ascending(列名称);\n\n// 对score字段降序排列\nquery.descending(列名称);", 
            "title": "结果排序"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_25", 
            "text": "如果你只是想统计满足 query 的结果集到底有多条记录，你可以使用 count 方法。如为了获得diary表的记录数量，示例代码如下：  var Diary = Bmob.Object.extend( diary );\nvar query = new Bmob.Query(Diary);\nquery.count({\n  success: function(count) {\n    // 查询成功，返回记录数量\n    console.log( 共有   + count +   条记录 );\n  },\n  error: function(error) {\n    // 查询失败\n  }\n});", 
            "title": "统计记录数量"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_26", 
            "text": "如果你想查询某一字段值在某一集合中的记录的话，可以使用 containedIn 方法，如获取 \"Bmob\"、\"hello\"、\"sure\" 三条标题为这的记录信息，那么示例代码如下：  // 第一个参数是字段名称，第二个参数是数组\nquery.containedIn( title , [ Bmob ,  hello ,  sure ]);  相反地，你可以使用 notContainedIn 方法来查询在集合外的目标对象。  如果想要查询含有某一特定属性的对象，可以使用 exists 。相对地，如果你想获取没有这一特定属性的对象，你可以使用 doesNotExist ，示例代码如下：  // 查询含有title属性的对象\nquery.exists( title );\n\n// 查询不含有title属性的对象\nquery.doesNotExist( title );  你可以使用 matchesKeyInQuery 方法来进行嵌套的子查询。举例说，如果你有一个类包含了用户心情， 而你在用户类中存储了用户的详细信息，你可以构造一个查询来查找被点赞次数超过5次的用户信息，示例代码如下：  var Diary = Bmob.Object.extend( diary );\nvar DiaryQuery = new Bmob.Query(Diary);\nDiaryQuery.greaterThan( isLike ,5);\nvar userQuery = new Bmob.Query(Bmob.User);\nuserQuery.matchesKeyInQuery( phone ,  nickname , DiaryQuery);\nuserQuery.find({\n  success: function(results) {\n    // results has the list of users with all user with record\n  }\n});  相对地，可以使用 doesNotMatchKeyInQuery 来获取属性不在子查询结果中的对象。比如为了获得用户的日记被点赞不超过5次的情况：  var Diary = Bmob.Object.extend( diary );\nvar DiaryQuery = new Bmob.Query(Diary);\nDiaryQuery.greaterThan( isLike ,5);\nvar userQuery = new Bmob.Query(Bmob.User);\nuserQuery.doesNotMatchKeyInQuery( phone ,  nickname , DiaryQuery);\nuserQuery.find({\n  success: function(results) {\n\n  }\n});", 
            "title": "复杂查询"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_27", 
            "text": "有时候你不想返回所有的字段信息，那么就可以用 select 方法来限定返回的字段。示例代码如下：  var Diary = Bmob.Object.extend( diary );\nvar query = new Bmob.Query(Diary);\n// 只返回score和playerName字段值\nquery.select( title );\nquery.find().then(function(results) {\n  // 返回成功\n});  注意：系统默认的字段 objectId 、 createdAt 、 updatedAt 、 ACL 也会返回。", 
            "title": "查询指定列"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_28", 
            "text": "如果想要查询以某一个特定字符串开头的记录，可以使用 startWith 方法，示例代码如下：  // 查询在title字段中以he开头的记录\nvar query = new Bmob.Query(Diary);\nquery.startsWith( title ,  he );", 
            "title": "对字符串类型做查询"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_29", 
            "text": "你可以使用 Bmob.Query.or 方法操作或查询，示例代码如下：  var query1 = new Bmob.Query(Diary);\nquery1.greaterThan( isLike , 150);\n\nvar query2 = new Bmob.Query(Diary);\nquery2.lessThan( isLike , 5);\n\nvar mainQuery = Bmob.Query.or(query1, query2);\nmainQuery.find({\n  success: function(results) {\n     // 返回 isLike   150 or isLike   5 的值\n  },\n  error: function(error) {\n    // 返回失败\n  }\n});  注意：我们不会在组合查询的子查询中支持非过滤型的条件 (比如:limit,skip,ascending/descending,include)", 
            "title": "或查询"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_30", 
            "text": "修改数据非常简单，首先需要获取到要更新的 Bmob.Object 对象，修改值后保存数据就可以了，示例代码如下：  var Diary = Bmob.Object.extend( diary );\nvar query = new Bmob.Query(Diary);\n\n// 这个 id 是要修改条目的 id，你在\n 这个存储并成功时可以获取到，请看前面的文档\nquery.get('3453453453fdsdf', {\n    success: function(result) {\n      // 回调中可以取得这个 GameScore 对象的一个实例，然后就可以修改它了\n      result.set('title', 'test!');\n      result.save();\n\n      // The object was retrieved successfully.\n    },\n    error: function(object, error) {\n\n    }\n});  或者  var Diary = Bmob.Object.extend( diary );\nvar Diary = new Diary();\nDiary.set( title ,  111 );\nDiary.set( content ,  222 );\n//添加数据\nDiary.save(null, {\n  success: function(result) {\n    // 修改数据\n    result.set( title ,  111 );\n    result.set( content ,  222 );\n    result.save();\n  }\n})  如果想更新成功后获取更新后的对象属性，请设置 fetchWhenSave ：   //假设result是已经存在的对象\n    result.fetchWhenSave(true);\n    result.set( title ,  111 );\n    result.set( content ,  222 );\n    result.save();", 
            "title": "修改数据"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_31", 
            "text": "删除数据可以使用 Bmob.Object 的 destroy 方法，示例代码如下：  myObject.destroy({\n  success: function(myObject) {\n    // 删除成功\n  },\n  error: function(myObject, error) {\n    // 删除失败\n  }\n});  批量删除对象的示例代码如下：  //单个请求每次最多删除50条。\n var query = new Bmob.Query('diary');\n query.equalTo( title ,  后端云 );\n          query.find().then(function (todos) {\n            return Bmob.Object.destroyAll(todos);\n          }).then(function (todos) {\n            console.log(todos);\n            // 删除成功\n          }, function (error) {\n            // 异常处理\n          });  如果你想将查询出来的对象都删除，或者删除符合查询条件的所有对象，可以调用 destroyAll 方法，示例代码如下：  query.destroyAll({\n   success: function(){\n      //删除成功\n   },\n   error: function(err){\n      // 删除失败\n   }\n   });", 
            "title": "删除数据"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_32", 
            "text": "你可以使用 unset 方法在删除一个字段：  // 删除playerName字段\nmyObject.unset( title );\nmyObject.save();", 
            "title": "删除字段"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_33", 
            "text": "var number = 42;\nvar string =  the number is   + number;\nvar date = new Date();\nvar array = [string, number];\nvar object = { number: number, string: string };\n\nvar bigObject = new BigObject();\nbigObject.set( myNumber , number);\nbigObject.set( myString , string);\nbigObject.set( myDate , date);\nbigObject.set( myArray , array);\nbigObject.set( myObject , object);\nbigObject.set( myNull , null);\nbigObject.save();", 
            "title": "常见数据类型的操作"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_34", 
            "text": "", 
            "title": "数组操作"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_35", 
            "text": "为了帮你存储数组类数据，有三种操作你可以原子性地改动一个数组，这需要一个给定的 key：   add 在一个数组的末尾加入一个给定的对象。  addUnique 只会把原本不存在的对象加入数组，所以加入的位置没有保证。   比如, 我们想在数组\"DiaryType\"中加入日记类型：  Diary.addUnique( DiaryType ,  public );\nDiary.addUnique( DiaryType ,  secret );\nDiary.save();", 
            "title": "添加及更新数组"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_36", 
            "text": "对于value是数组的情况，你可以这样查询数组中的值有 2 的情况的对象：  // Find objects where the array in DiaryType contains public.\nquery.equalTo( DiaryType , public );  你同样可以用下面的方式找到同时包含元素 2、3、4 的数组：  // Find objects where the array in DiaryType contains all of the elements public,secret.\nquery.containsAll( DiaryType , [ public , secret ]);", 
            "title": "数组查询"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_37", 
            "text": "remove 在一个数组中删除所有指定的所有实例：  var Diary = Bmob.Object.extend( diary );\nvar query = new Bmob.Query(Diary);\nquery.get( bc5da708dc ,{\n  success: function(result) {\n    result.remove( DiaryType , public );\n    result.save();\n  },\n  error: function(error) {\n    console.log( Error:   + error.code +     + error.message);\n  }\n});", 
            "title": "删除数组"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_38", 
            "text": "", 
            "title": "批量操作"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_39", 
            "text": "把Todo表title所有为Bmob的更新为Bmob后端云\nvar query = new bmob.Query('Todo');\nquery.equalTo( title ,  bmob );\nquery.find().then(function(todos) {\n    todos.forEach(function(todo) {\n        todo.set('title',  Bmob后端云 );\n    });\n    return bmob.Object.saveAll(todos);\n}).then(function(todos) {\n    // 更新成功\n},\nfunction(error) {\n    // 异常处理\n});", 
            "title": "批量更新示例"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_40", 
            "text": "var objects = []; // 构建一个本地的 bmob.Object 对象数组\n// 批量创建（更新）\nbmob.Object.saveAll(objects).then(function(objects) {\n    // 成功\n},\nfunction(error) {\n    // 异常处理\n});\n// 批量删除\nbmob.Object.destroyAll(objects).then(function() {\n    // 成功\n},\nfunction(error) {\n    // 异常处理\n});\n// 批量获取\nbmob.Object.fetchAll(objects).then(function(objects) {\n    // 成功\n},\nfunction(error) {\n    // 异常处理\n});", 
            "title": "批量增删改"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_41", 
            "text": "", 
            "title": "数据关联"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_42", 
            "text": "", 
            "title": "添加及修改关联关系"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_43", 
            "text": "一对一关系和一对多关系都可以通过在一个 Bmob.Object 内保存另一个对象来实现。比如，每一个 Comment都对应了一个Post，创建一个有一个Comment的Post，你可以这样写：  \n// Declare the types.\nvar Post = Bmob.Object.extend( Post );\nvar Comment = Bmob.Object.extend( Comment );\n\n// Create the post\nvar myPost = new Post();\nmyPost.set( title ,  I'm Hungry );\nmyPost.set( content ,  Where should we go for lunch? );\n\n// Create the comment\nvar myComment = new Comment();\nmyComment.set( content ,  Let's do Sushirrito. );\n\n// Add the post as a value in the comment\nmyComment.set( parent , myPost);\n\n// This will save both myPost and myComment\nmyComment.save();  Bmob内部会自动处理，调用Comment的 save 方法就可以同时保存两个新对象。  如果是现有对象想要关联到新对象，你同样可以通过只用它们的 objectId 来连接彼此。请注意，不能直接像上面的例子那样将现有对象设置进去，而是必须 new 一个新对象并只设置 id 属性：  var post = Bmob.Object.createWithoutData( Post ,  320b0395f3 );\nmyComment.set( parent , post);  或者：  var post = new Post();\npost.id = '520c7e1ae4b0a3ac9ebe326a';\nmyComment.set( parent , post);  如果希望查询结果中包含多个相关联的其他数据类型。你可以使用 include 方 法。例如有个comments，你可能想同时获取它们相关的 post 数据:  var query = new Bmob.Query(Comment);\n\nquery.include( post );  可以这样获取include对象的属性:  obj.get( inloudeObj ).field  查出用户发表的日志示例      var objectId,that=this;\n    var currentUser = Bmob.User.current();\n    objectId = currentUser.id;\n\n    var Diary = Bmob.Object.extend( diary );\n    var query = new Bmob.Query(Diary);\n    var isme = new Bmob.User();\n    isme.id = objectId;     //当前用户的objectId\n    query.equalTo( own , isme);\n    query.descending('createdAt');  //排序\n    query.include( own );  //own 字段名称，类型 Pointer\n\n    // 查询所有数据\n    query.limit(that.data.limit);\n    query.find({\n      success: function (results) {\n        that.setData({\n          diaryList: results\n        })\n      },\n      error: function (error) {\n        console.log( 查询失败:   + error.code +     + error.message);\n      }\n    });  wxml文件调用  view class= weui-media-box weui-media-box_text  wx:for= {{diaryList}}  wx:key= diaryItem \n日志标题：\n{{item.title}}\n用户表的日志作者：\n{{item.own.nickName}} /view", 
            "title": "一对一关系和一对多关系"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_44", 
            "text": "许多应用都需要维持一些计数器数据，譬如用来跟踪心情被点赞数目等等。Bmob提供了便捷的方式来对任何数字字段进行原子性的增加或者减少：  Diary.increment( isLike );\nDiary.save();  你可以同样传入第二个参数到 increment 方法来指定增加多少， 1 是默认值。", 
            "title": "原子计数器"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_45", 
            "text": "", 
            "title": "文件上传"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_46", 
            "text": "文件上传，例如，我们从本地上传一张图片到服务器，名称为\"1.jpg\"，可用以下代码：  在js中添加以下代码：  wx.chooseImage({\n  count: 1, // 默认9\n  sizeType: [ 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\n  sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\n  success: function (res) {\n      var tempFilePaths = res.tempFilePaths;\n      if(tempFilePaths.length 0){\n          var name= 1.jpg ;//上传的图片的别名，建议可以用日期命名\n          var file=new Bmob.File(name,tempFilePaths);\n          file.save().then(function(res){\n            console.log(res.url());\n          },function(error){\n            console.log(error);\n          })\n      }\n\n  }\n})\n\n#### PS： 特别注意的是 `tempFilePaths` 是微信返回的数组。", 
            "title": "文件上传"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_47", 
            "text": "图片批量上传，我们只需要for循环一下上面的就好，一下示例代码。  upImg: function () {\n    var that = this;\n    wx.chooseImage({\n      count: 9, // 默认9\n      sizeType: ['compressed'], // 可以指定是原图还是压缩图，默认二者都有\n      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\n      success: function (res) {\n        wx.showNavigationBarLoading()\n        that.setData({\n          loading: false\n        })\n        var urlArr = new Array();\n        // var urlArr={};\n        var tempFilePaths = res.tempFilePaths;\n        console.log(tempFilePaths)\n        var imgLength = tempFilePaths.length;\n        if (imgLength   0) {\n          var newDate = new Date();\n          var newDateStr = newDate.toLocaleDateString();\n\n          var j = 0;\n          //如果想顺序变更，可以for (var i = imgLength; i   0; i--)\n          for (var i = 0; i   imgLength; i++) {\n            var tempFilePath = [tempFilePaths[i]];\n            var extension = /\\.([^.]*)$/.exec(tempFilePath[0]);\n            if (extension) {\n              extension = extension[1].toLowerCase();\n            }\n            var name = newDateStr +  .  + extension;//上传的图片的别名\n\n            var file = new Bmob.File(name, tempFilePath);\n            file.save().then(function (res) {\n              wx.hideNavigationBarLoading()\n              var url = res.url();\n              console.log( 第  + i +  张Url  + url);\n\n              urlArr.push({  url : url });\n              j++;\n              console.log(j, imgLength);\n              // if (imgLength == j) {\n              //   console.log(imgLength, urlArr);\n              //如果担心网络延时问题，可以去掉这几行注释，就是全部上传完成后显示。\n                showPic(urlArr, that)\n              // }\n\n            }, function (error) {\n              console.log(error)\n            });\n\n          }\n\n\n\n\n        }\n\n      }\n    })\n  }\n})\n\n\n\n//上传完成后显示图片\nfunction showPic(urlArr, t) {\n  t.setData({\n    loading: true,\n    urlArr: urlArr\n  })\n}", 
            "title": "图片批量上传"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_48", 
            "text": "var path;\npath =  http://bmob-cdn-9200.b0.upaiyun.com/2017/04/25/f24b9ef540f1aeb680ebe01ba8543d9f.png ;\nvar s = new Bmob.Files.del(path).then(function(res) {\n    if (res.msg ==  ok ) {\n        console.log('删除成功');\n    }\n},\nfunction(error) {\n    console.log(error)\n});", 
            "title": "文件删除"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_49", 
            "text": "新版文件服务由第三方厂商又拍云提供，只需要在文件上传成功返回的url后面拼接特定参数即可实现缩放，缩略图，加水印等效果， 如图 ，具体可参考 这里  。", 
            "title": "图片处理"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#promise", 
            "text": "除了回调函数之外，每一个在Bmob JavaScript SDK中的异步方法都会返回一个 Promise. 使用 Promise，你的代码可以比原来的嵌套 callback 的方法看起来优雅得多.", 
            "title": "Promise"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#then", 
            "text": "每一个 Promise 都有一个叫 then 的方法, 这个方法接受一对 callback 。第一个 callback 在 promise 被解决的时候调用，第二个会在 promise 被拒绝的时候调用。  obj.save().then(function(obj) {\n  // the object was saved successfully.\n}, function(error) {\n  // the save failed.\n});", 
            "title": "then 方法"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#promise_1", 
            "text": "Promise 比较神奇，可以代替多层嵌套方式来解决发送异步请求代码的调用顺序问题。 如果一个 Promise 的回调会返回一个 Promise ，那么第二个 then 里的 callback 在第一个 then 的 callback 没有解决前是不会解决的。  var query = new Bmob.Query( Student );\nquery.descending( gpa );\nquery.find().then(function(students) {\n  students[0].set( valedictorian , true);\n  return students[0].save();\n\n}).then(function(valedictorian) {\n  return query.find();\n\n}).then(function(students) {\n  students[1].set( salutatorian , true);\n  return students[1].save();\n\n}).then(function(salutatorian) {\n  // Everything is done!\n\n});", 
            "title": "将Promise 组织在一起"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_50", 
            "text": "如果任意一个在链中的 Promise 返回一个错误的话，所有的成功的 callback 在接下来都会被跳过直到遇到一个处理错误的 callback 。处理 error 的 callback 可以转换 error 或者可以通过返回一个新的 Promise 的方式来处理它。你可以想象成拒绝的 promise 有点像异常，而 error callback 则像是一个 catch 来处理这个异常或者抛出异常。  var query = new Bmob.Query( Student );\nquery.descending( gpa );\nquery.find().then(function(students) {\n  students[0].set( valedictorian , true);\n  // Force this callback to fail.\n  return Bmob.Promise.error( There was an error. );\n\n}).then(function(valedictorian) {\n  // Now this will be skipped.\n  return query.find();\n\n}).then(function(students) {\n  // This will also be skipped.\n  students[1].set( salutatorian , true);\n  return students[1].save();\n}, function(error) {\n  // This error handler WILL be called. error will be  There was an error. .\n  // Let's handle the error by returning a new promise.\n  return Bmob.Promise.as( Hello! );\n\n}).then(function(hello) {\n  // Everything is done!\n}, function(error) {\n  // This isn't called because the error was already handled.\n});  通常来说，在正常情况的回调函数链的末尾，加一个错误处理的回调函数会是很方便的做法.", 
            "title": "错误处理"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#promise_2", 
            "text": "在开始阶段，你可以只用系统（譬如 find 和 save 方法等）返回的 promise 。但在更高级的场景下，你可能需要创建自己的 promise 。在创建了 Promise 之后，你需要调用 resolve 或者 reject 来触发它的 callback 。  var successful = new Bmob.Promise();\nsuccessful.resolve( The good result. );\n\nvar failed = new Bmob.Promise();\nfailed.reject( An error message. );  如果你在创建 promise 的时候就知道它的结果，下面有两个很方便的方法可以使用：  var successful = Bmob.Promise.as( The good result. );\nvar failed = Bmob.Promise.error( An error message. );", 
            "title": "创建 Promise"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#promise_3", 
            "text": "var query = new Bmob.Query( Comments );\nquery.equalTo( post , 123);\n\nquery.find().then(function(results) {\n  // Create a trivial resolved promise as a base case.\n  var promise = Bmob.Promise.as();\n  _.each(results, function(result) {\n    // For each item, extend the promise with a function to delete it.\n    promise = promise.then(function() {\n      // Return a promise that will be resolved when the delete is finished.\n      return result.destroy();\n    });\n  });\n  return promise;\n\n}).then(function() {\n  // Every comment was deleted.\n});", 
            "title": "顺序的Promise"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#promise_4", 
            "text": "你也可以用 Promise 来并行的进行多个任务，这时需要使用 when 方法。你可以一次同时开始几个操作，使用 Bmob.Promise.when 来创建一个新的 promise ，它会在所有输入的 Promise 被解决之后才被解决。即便一些输入的 promise 失败了，新的 Promise 也会被成功执行。你可以在  callback 的参数部分检查每一个 promise 的结果，并行地进行操作会比顺序进行更快，但是也会消耗更多的系统资源和带宽。  var query = new Bmob.Query( Comments );\nquery.equalTo( post , 123);\n\nquery.find().then(function(results) {\n  // Collect one promise for each delete into an array.\n  var promises = [];\n  _.each(results, function(result) {\n    // Start this delete immediately and add its promise to the list.\n    promises.push(result.destroy());\n  });\n  // Return a new promise that is resolved when all of the deletes are finished.\n  return Bmob.Promise.when(promises);\n\n}).then(function() {\n  // Every comment was deleted.\n});", 
            "title": "并行的Promise"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_51", 
            "text": "有了上面这些工具以后, 就很容易创建你自己的异步方法来返回 promise 了。举例说，你可以创建一个有 promise 版本的 setTimeout 。  var delay = function(millis) {\n  var promise = new Bmob.Promise();\n  setTimeout(function() {\n    promise.resolve();\n  }, millis);\n  return promise;\n};\n\ndelay(100).then(function() {\n  // This ran after 100ms!\n});", 
            "title": "创建异步方法"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#collection", 
            "text": "一个 Bmob.Collection 就是一个 Bmob.Objects 的有序集合，它和 Backbone.Collection 是兼容的，有相同的特性和功能，你可以通过用一个模型类或者一个特定的 Bmob.Query 来创建一个新的子类。  // A Collection containing all instances of TestObject.\nvar TestCollection = Bmob.Collection.extend({\n  model: TestObject\n});\nvar collection = new TestCollection();\n\n// A Collection of TestObjects whose temperature is  hot .\nvar HotCollection = Bmob.Collection.extend({\n  model: TestObject,\n  query: (new Bmob.Query(TestObject)).equalTo( temperature ,  hot )\n});\nvar collection = new HotCollection();\n\n// The Collection of TestObjects that match a complex query.\nvar query = new Bmob.Query(TestObject);\nquery.equalTo( temperature ,  hot );\nquery.greaterThan( degreesF , 100);\nvar collection = query.collection();", 
            "title": "Collection"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#collection_1", 
            "text": "使用 fetch 方法来获取一个 collection 里的所有元素:  var collection = new TestCollection();\ncollection.fetch({\n  success: function(collection) {\n    collection.each(function(object) {\n      console.warn(object);\n    });\n  },\n  error: function(collection, error) {\n    // The collection could not be retrieved.\n  }\n});", 
            "title": "获取Collection"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#collection_2", 
            "text": "你可以设定一个 comparator 来对 collection 中的元素进行排序:  var collection = new TestCollection();\ncollection.comparator = function(object) {\n  return object.get( temperature );\n};", 
            "title": "Collection 排序"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#collection_3", 
            "text": "Collection 是可变的，你可以访问所有元素，增加或者删除元素：  var collection = new TestCollection();\n\ncollection.add([\n  { name :  Duke },\n  { name :  Scarlett }\n]);\n\n// Get the  Duke  Bmob.Object by its sorted position.\nvar model = collection.at(0);\n\n// Or you can get it by Bmob objectId.\nvar modelAgain = collection.get(model.id);\n\n// Remove  Duke  from the collection.\ncollection.remove(model);\n\n// Completely replace all items in the collection.\ncollection.reset([\n  { name :  Hawk },\n  { name :  Jane }\n]);", 
            "title": "修改一个 Collection"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_52", 
            "text": "在许多应用中，都有一个用户账户的概念，用户账户让用户可以用安全的方式访问他们自己的信息。我们提供了一个特殊的用户类叫 Bmob.User 来自动处理有关用户的账户管理的功能。  Bmob.User 是 Bmob.Object 的一个子类，而且有 Bmob.Object 一样的功能，比如可变的模式、自动的持久化、键值对接口等。所有对 Bmob.Object 有用的方法同样可以作用于 Bmob.User 。 Bmob.User 的不同之处在于 Bmob.User 对于用户的账户有一些特定的功能。", 
            "title": "用户"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_53", 
            "text": "Bmob.User 有一些与 Bmob.Object 不一样的字段: username ：用户的用户名（必须提供） password ：用户的密码（在注册的时候必须提供） email ：用户的 email（可选） userData ：每个微信用户的唯一标识，包括用户openId、expires_in、session_key（可选,自行创建，Object类型）\n我们会在下面的用例中详细介绍细节", 
            "title": "属性"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_54", 
            "text": "通常你的app第一件要做的事情就是让用户进行注册，这里把用户密码设置为 Openid ，下面的代码展示了怎样进行微信注册的过程（包括获取用户的唯一标识）：  首先要在_User表新建一个用来存用户唯一标识的字段，例如：userData(Object类型)，然后在js中插入以下代码：  wx.login({\n  success: function(res) {\n    if (res.code) {\n        Bmob.User.requestOpenId(res.code, {//获取userData(根据个人的需要，如果需要获取userData的需要在应用密钥中配置你的微信小程序AppId和AppSecret，且在你的项目中要填写你的appId)\n          success: function(userData) {\n              wx.getUserInfo({\n                  success: function(result) {\n                    var userInfo = result.userInfo\n                    var nickName = userInfo.nickName\n\n                    var user = new Bmob.User();//开始注册用户\n                    user.set( username , nickName);\n                    user.set( password , userData.openid);//因为密码必须提供，但是微信直接登录小程序是没有密码的，所以用openId作为唯一密码\n                    user.set( userData , userData);\n                    user.signUp(null, {\n                        success: function(res) {\n                          console.log( 注册成功! );\n                        },\n                        error: function(userData, error) {\n                          console.log(error)\n                        }\n                    });\n                  }\n              })\n          },\n          error: function(error) {\n              // Show the error message somewhere\n              console.log( Error:   + error.code +     + error.message);\n          }\n      });\n\n    } else {\n      console.log('获取用户登录态失败！' + res.errMsg)\n    }\n  }\n});  这个调用会异步地在在你的应用中创建一个新的用户。在它这样做之前，它同样会确认用户名和 email 在应用内都是唯一的。同样，我们从不会将用户密码以明文向任何客户端发送。  注意我们使用了 signUp 方法而不是 save 方法，新的 Bmob.User 永远应该使用 signUp 方法来新建。而随后的用户的信息更新可以调用 save 来做。  如果一个 signup 没有成功的话，你应该读取返回的错误对象。最常见的问题是 username 或者 email 已经被其他用户所使用了。你应该清楚地反馈给你的用户，让他们再次用一个不同的用户名来注册。  你也可以使用 email 来作为用户名，只要求你的用户输入他们的 email 但是同时自动填充好 username 属性就可以了， Bmob.User 会跟原来一样工作，我们会在下面的重设密码环节再次说明这个细节。", 
            "title": "注册一（使用用户账号密码进行注册）"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_55", 
            "text": "首先要在_User表新建一个用来存用户唯一标识的字段，例如：userData(Object类型)，然后在js中插入以下代码：  \nvar user = new Bmob.User();//实例化\n\nwx.login({\n\n        success: function (res) {\n          user.loginWithWeapp(res.code).then(function (user) {\n            var openid = user.get( authData ).weapp.openid;\n            console.log(user, 'user', user.id, res);\n            if (user.get( nickName )) {\n\n              // 第二次登录，打印用户之前保存的昵称\n              console.log(user.get( nickName ), 'res.get( nickName )');\n\n              //更新openid\n              wx.setStorageSync('openid', openid)\n            } else {//注册成功的情况\n\n              var u = Bmob.Object.extend( _User );\n              var query = new Bmob.Query(u);\n              query.get(user.id, {\n                success: function (result) {\n                  wx.setStorageSync('own', result.get( uid ));\n                },\n                error: function (result, error) {\n                  console.log( 查询失败 );\n                }\n              });\n\n\n              //保存用户其他信息，比如昵称头像之类的\n              wx.getUserInfo({\n                success: function (result) {\n\n                  var userInfo = result.userInfo;\n                  var nickName = userInfo.nickName;\n                  var avatarUrl = userInfo.avatarUrl;\n\n                  var u = Bmob.Object.extend( _User );\n                  var query = new Bmob.Query(u);\n                  // 这个 id 是要修改条目的 id，你在生成这个存储并成功时可以获取到，请看前面的文档\n                  query.get(user.id, {\n                    success: function (result) {\n                      // 自动绑定之前的账号\n\n                      result.set('nickName', nickName);\n                      result.set( userPic , avatarUrl);\n                      result.set( openid , openid);\n                      result.save();\n\n                    }\n                  });\n\n                }\n              });\n\n\n            }\n\n          }, function (err) {\n            console.log(err, 'errr');\n          });\n\n        }\n      });\n    }", 
            "title": "注册二（登录注册集合类，接口默认第一次注册，否则返回用户信息）"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#app", 
            "text": "如果你要求你的用户用你自己设计的注册页面注册后，当然应该让他们在以后用自己的账户登录进来，你可以使用 logIn 方法来进行登陆：  Bmob.User.logIn( myname ,  mypass , {\n  success: function(user) {\n    // Do stuff after successful login.\n  },\n  error: function(user, error) {\n    // The login failed. Check error to see why.\n  }\n});", 
            "title": "登录（自有账户密码登录，适合APP迁移过来的用户）"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#email", 
            "text": "在application设置中启用email验证可以让你的应用给最终用户一些更安全的使用体验，譬如部分功能只开放给验证过邮箱的用户使用等等。Email验证会在 Bmob.User 上加入一个 emailVerified 字段。当一个 Bmob.User 的 email 被设定或者修改后, emailVerfied 会被设定为 false 。Bmob 会向用户的 email 来发送一个链接，点击这个链接会设置 emailVerified 为 true ：  有三种 emailVerified 状态可以供参考：   true ：用户已经通过点击Bmob发过来的链接来确认邮箱地址. 当用户账户新创建的时候这个值永远不应该是true。  false ：在  Bmob.User 对象最后一次刷新的时候，用户还是没有确认他们的 email 地址，如果 emailVerified 是false 的话，你应该考虑调用 Bmob.User 的 fetch 方法。  missing ： Bmob.User 被创建了，但是当时的 email 验证功能还没有开启, 或者说 Bmob.User 没有email地址。   代码例子如下：console.log  //reset password\n Bmob.User.requestEmailVerify( h6k65@126.com , {\n  success: function() {\n    // Password reset request was sent successfully\n  },\n  error: function(error) {\n    // Show the error message somewhere\n    console.log( Error:   + error.code +     + error.message);\n  }\n});", 
            "title": "验证 Email"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_56", 
            "text": "如果用户每次打开App的时候都要求登录无疑是令人感到厌烦的，你可以通过缓存当前的 Bmob.User 对象来避免这个问题。  无论你使用任何注册或者登录方法，用户都会在 localStorage 中储存，你可以把缓存作为一个 session 对待，并且自动假设用户已经登录了。  var currentUser = Bmob.User.current();\nif (currentUser) {\n    // do stuff with the user\n} else {\n    // show the signup or login page\n}  你可以通过 logout 来清除掉当前的用户：  Bmob.User.logOut();\n\nvar currentUser = Bmob.User.current();  // this will now be null", 
            "title": "当前用户"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_57", 
            "text": "Bmob.User 类默认就是受保护的，在 Bmob.User 中保存的数据只能被那个用户所修改。默认地，数据仍然可以被任意客户端所读取。这样就是说，有些 Bmob.User 对象被认证后是可以修改的，其他的仍然是只读的。  特别的，你不能调用 save 或者 delete 方法除非 Bmob.User 经过了认证，就比如调用过了 logIn 或者 signUp 方法，这样保证只有用户能改动他们自身的数据。  下面的代码展示了上面说的安全策略：  var user = Bmob.User.logIn( my_username ,  my_password , {\n  success: function(user) {\n    user.set( username ,  my_new_username );  // attempt to change username\n    user.save(null, {\n      success: function(user) {\n        // This succeeds, since the user was authenticated on the device\n\n        // Get the user from a non-authenticated method\n        var query = new Bmob.Query(Bmob.User);\n        query.get(user.objectId, {\n          success: function(userAgain) {\n            userAgain.set( username ,  another_username );\n            userAgain.save(null, {\n              error: function(userAgain, error) {\n                // This will error, since the Bmob.User is not authenticated\n              }\n            });\n          }\n        });\n      }\n    });\n  }\n});  从 Bmob.User.current() 获取的 Bmob.User 总是已经通过验证了的。  如果你需要查看一个 Bmob.User 是否已经认证过了，你可以调用 authenticated 方法，你不需要查看一个认证方法中返回的 Bmob.User 对象是否已经通过验证了。", 
            "title": "用户对象的安全"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_58", 
            "text": "和 Bmob.User 相同的安全模型也使用于其他对象。对于任何对象来说，你可以指定哪些用户会被允许读取对象，哪些用户被允许修改对象。为了支持这种安全机制，每一个对象都有一个允许访问列表 (ACL)，是被 Bmob.ACL 类所实现的。  使用一个 Bmob.ACL 最简单的方式是指定一个对象只能被一个单一的用户读或者写。为了创建这样的对象，首先必须有一个已经登录的 Bmob.User 。然后，新的 Bmob.ACL(user) 生成一个 Bmob.ACL 来限定 user 的访问。一个对象的ACL会在对象保存的时候被存储起来，就像其他的属性一样，这样，为了创建一个当前user私有的一个note：  var Note = Bmob.Object.extend( Note );\nvar privateNote = new Note();\nprivateNote.set( content ,  This note is private! );\nprivateNote.setACL(new Bmob.ACL(Bmob.User.current()));\nprivateNote.save();  这个note只能由当前的用户所访问，但是可以在用户登录的任何设备上访问，只要是相同的用户就可以了。这项功能对于你如果想让用户再任何其他的设备上保存和访问数据十分有用，比如说一个私人的todo list应用。  权限也能在使用者的基础上授予，你可以通过 setReadAccess 和 setWriteAccess 方法独立的向 Bmob.ACL 中添加权限。比如，假设你有一条消息想要发送给一个组里的多个用户，他们中的每一个都有读和写的权限：  var Message = Bmob.Object.extend( Message );\nvar groupMessage = new Message();\nvar groupACL = new Bmob.ACL();\n\n// userList is an array with the users we are sending this message to.\nfor (var i = 0; i   userList.length; i++) {\n  groupACL.setReadAccess(userList[i], true);\n  groupACL.setWriteAccess(userList[i], true);\n}\n\ngroupMessage.setACL(groupACL);\ngroupMessage.save();  你同样可以对所有的用户授权，只要使用 setPublicReadAccess 和 setPublicWriteAccess 就可以了。这样允许了在一个消息板上发评论的模式，比如，我们要创建一个post只能被它的作者修改，但是可以被所有人读取：  var publicPost = new Post();\nvar postACL = new Bmob.ACL(Bmob.User.current());\npostACL.setPublicReadAccess(true);\npublicPost.setACL(postACL);\npublicPost.save();  比如说删除一个对象，但是你没有写的权限这种操作是禁止的，这样会返回一个 Bmob.Error.OBJECT_NOT_FOUND 的错误码，为了安全起见，这样防止了客户端区分出到底有哪些对象被创建了但是无法读取还是根本不存在。", 
            "title": "其他对象的安全"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_59", 
            "text": "在现实中只要你引入了密码系统，总会有用户会忘掉他们的密码。在这种情形下，我们的库提供一个让他们安全地重设密码的功能。  为了能让用户重设密码，应该要求用户提供他们的email地址，然后这样调用：   Bmob.User.requestPasswordReset( test@126.com , {\n  success: function() {\n    // Password reset request was sent successfully\n  },\n  error: function(error) {\n    // Show the error message somewhere\n    console.log( Error:   + error.code +     + error.message);\n  }\n});  这样会尝试匹配给定的email和用户的email或者username字段，然后会发送用户的密码重设邮件。由于我们是这样做的，所以你可以选择用户是否拿email作为他们的用户名，或者说用户把email作为用户的另一个信息保存。  密码重设的流程如下:   用户输入email来请求重设他们的密码。  Bmob向用户的email地址发送邮件，包含了一个重设密码的链接。  用户点击这个重设密码的链接，会重定向到一个Bmob页面来允许他们重设密码。  用户输入新的密码，他们的密码现在会更新为输入的新密码。", 
            "title": "重设密码"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_60", 
            "text": "为了查询用户，你可以简单的创建一个 Bmob.Query 针对 Bmob.Users ：  var query = new Bmob.Query(Bmob.User);\nquery.equalTo(gender,  female );  // find all the women\nquery.find({\n  success: function(women) {\n    // Do stuff\n  }\n});", 
            "title": "查询"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_61", 
            "text": "关联一个 Bmob.User 的对象可以很快就见效，比如说，假设你有一个blog程序，为了保存一个用户的新post还有读取他们所有的post。  var user = Bmob.User.current();\n\n// Make a new post\nvar Post = Bmob.Object.extend( Post );\nvar post = new Post();\npost.set( title ,  My New Post );\npost.set( body ,  This is some great content. );\npost.set( user , user);\npost.save(null, {\n  success: function(post) {\n    // Find all posts by the current user\n    var query = new Bmob.Query(Post);\n    query.equalTo( user , user);\n    query.find({\n      success: function(usersPosts) {\n        // userPosts contains all of the posts by the current user.\n      }\n    });\n  }\n});", 
            "title": "关联"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#acl", 
            "text": "数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看 Bmob数据与安全页面 ，了解Bmob如何保护数据安全）。  其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。  大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：   对于私有数据，读写权限可以只局限于数据的所有者。  对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。  对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。  属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。  一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。", 
            "title": "ACL和角色"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#acl_1", 
            "text": "在Bmob中，ACL是按JSON对象格式（key-value）来表示的。这个JSON对象的key是objectId（用户表某个用户对应的objectId）或者是*(表示公共的访问权限)，ACL 的值是\"读和写的权限\"，这个JSON对象的key总是权限名，而这些key的值总是true。  如果您想让一个id为\"Kc3M222k\"的用户有读和写一条数据的权限，而且这个数据应该可以被全部人读取的话，这个ACL的表达方式如下：  {\n   Kc3M222k : {\n     read : true,\n     write : true\n  },\n   * : {\n     read : true\n  }\n}", 
            "title": "ACL的格式"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_62", 
            "text": "在很多情况下，你需要定义一些用户具有某种相同的数据操作权限，而另外一群用户具有另外一种相同的数据操作权限，这时你就可以使用到Bmob的角色（对应Bmob在Web提供的Role表、SDK中的BmobRole类）功能，设置不同的用户组不同的操作权限。角色表有三个特殊字段：  name  : 必须字段，表示角色名称,而且只允许被设置一次（命名必须由字母, 空格, 减号或者下划线构成）。  users  :一个指向一系列用户的关系, 这些用户会继承角色的权限。  roles  : 一个指向一系列子角色的关系, 这些子关系会继承父角色所有的权限。", 
            "title": "角色和相关操作"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_63", 
            "text": "var roleACL = new Bmob.ACL();\nroleACL.setPublicReadAccess(true);\nvar role = new Bmob.Role( test , roleACL);\nrole.save();", 
            "title": "创建角色"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_64", 
            "text": "Bmob.Role 使用和其他Bmob对象一样的ACL权限策略, 除开它需要ACL被显式地设置以外。通常来说，只有用户有极大的权限（比如管理员）才应该被允许创建或者更改Role，所以你应该按这种标准来设定Role的ACL。请注意，如果你给了用户一个 Bmob.Role 一个写权限，这个用户有可能会在这个权限中加入另一个user，或者甚至直接把角色删除掉。  为了创建一个新的 Bmob.Role ，你应该如下写：  // By specifying no write privileges for the ACL, we can ensure the role cannot be altered.\nvar roleACL = new Bmob.ACL();\nroleACL.setPublicReadAccess(true);\nvar role = new Bmob.Role( Administrator , roleACL);\nrole.save();  你可以通过增加\"user\"和\"roles\"关系的成员来在 Bmob.Role 中加入用户或者子角色：  var role = new Bmob.Role(roleName, roleACL);\nfor (var i = 0; i   usersToAddToRole.length; i++) {\n  role.getUsers().add(usersToAddToRole[i]);\n}\nfor (var i = 0; i   rolesToAddToRole.length; i++) {\n  role.getRoles().add(rolesToAddToRole[i]);\n}\nrole.save();  请非常注意一点，注册角色的ACL的时候，它们只能被应该有权限修改它的人修改。", 
            "title": "角色对象的安全性"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_65", 
            "text": "现在你应该已经创建了在你的程序中要使用的一系列的角色，你可以用ACL来定义他们的用户可以拥有的权限，每一个 Bmob.Object 都可以指定一个 Bmob.ACL ，这样提供了哪些用户或者角色应该有权限来读或者写这个对象。  将一个读或者写的权限授予一个角色是很直观的，你可以使用 Bmob.Role ：  var moderators = /* Query for some Bmob.Role */;\nvar wallPost = new Bmob.Object( WallPost );\nvar postACL = new Bmob.ACL();\npostACL.setRoleWriteAccess(moderators, true);\nwallPost.setACL(postACL);\nwallPost.save();  你可以不需要查找这个Role，直接把名字提供给ACL：  var wallPost = new Bmob.Object( WallPost );\nvar postACL = new Bmob.ACL();\npostACL.setRoleWriteAccess( Moderators , true);\nwallPost.setACL(postACL);\nwallPost.save();", 
            "title": "其他对象的安全性"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_66", 
            "text": "就像上面所描述的一样，一个角色可能包含其他的角色，表示两个角色之间的父-子关系，这样做的结果就是任何被授予一个角色的权限都会被隐式地授予这个角 色的所有子角色。  这样的关系很经常会在有用户管理内容的程序之中看到，比如论坛，有一个很少量的用户称为管理员，有最高的权限，比如程序设定、创建新的论坛、设定所有人能看到的内容等等。另一类有一部分类似于\"版主\" 的用户，这些人有责任保持用户创建的内容是合适的，任何一个\"版主\"有的权限\"管理员\"都应该有。为了启用这种关系，你应该使\"管理员\"成为\"版主\"的一个子角色。  var administrators = /* Your  Administrators  role */;\nvar moderators = /* Your  Moderators  role */;\nmoderators.getRoles().add(administrators);\nmoderators.save();", 
            "title": "角色继承"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_67", 
            "text": "", 
            "title": "地理位置"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_68", 
            "text": "地理位置对象的创建需要用到 Bmob.GeoPoint 类，如创建一个地理位置在纬度40度，经度在-30度的点的示例代码如下：  var point = new Bmob.GeoPoint({latitude: 40.0, longitude: -30.0});", 
            "title": "创建地理位置对象"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_69", 
            "text": "现在你可以有一系列的对象可以做空间坐标查询了，如果能轻松地发现有哪些对象离一个点最近就好了。这样可以通过在 Bmob.Query 中加入一个 near 来做查询，为了获得离用户最近的10个地点列表，可以这样：  // location对应Web后台的一个字段名称\nvar userGeoPoint = userObject.get( location );\n// 创建查询\nvar query = new Bmob.Query(PlaceObject);\n// location附近的位置\nquery.near( location , userGeoPoint);\n// 返回10个地点数据\nquery.limit(10);\n// 查询\nquery.find({\n  success: function(placesObjects) {\n  }\n});  在这时 placeObjects 会返回一个按离 userGeoPoint 的距离排序的列表，注意如果一个 ascending()/descending() 给了查询的话，会取代按距离排序这项特性。  为了按距离限制返回的结果，你可以使用 withinMiles 、 withinKilometers 和 withinRadians 。  同样，查询在特定地域的Object是可以的。为了找到用矩形表示的一块地域中的对象，加入 withinGeoBox 来在 Bmob.Query 中加入约束。  var southwestOfSF = new Bmob.GeoPoint(37.708813, -122.526398);\nvar northeastOfSF = new Bmob.GeoPoint(37.822802, -122.373962);\n\nvar query = new Bmob.Query(PizzaPlaceObject);\nquery.withinGeoBox( location , southwestOfSF, northeastOfSF);\nquery.find({\n  success: function(pizzaPlacesInSF) {\n    ...\n  }\n});", 
            "title": "查询地理位置对象"
        }, 
        {
            "location": "/data/wechat_app/develop_doc/#_70", 
            "text": "端逻辑调用使用Bmob.Cloud.run方法，如调用云函数中的\"test\"方法，并传递name参数到服务器中的示例代码如下：  Bmob.Cloud.run('test', { name : tom }, {\n  success: function(result) {\n    console.log(result);\n  },\n  error: function(error) {\n  }\n})  如果不需要传递参数，示例代码如下：  Bmob.Cloud.run('test', {}, {\n  success: function(result) {\n    console.log(result);\n  },\n  error: function(error) {\n  }\n})", 
            "title": "小程序使用云逻辑"
        }, 
        {
            "location": "/data/wechat_app/example/", 
            "text": "示例和功能\n\n\nwechatApp快速入门相关源码:\nhttp://www.bmob.cn/sdk/bmob-wechatApp-v0.3.zip", 
            "title": "示例/功能"
        }, 
        {
            "location": "/data/wechat_app/example/#_1", 
            "text": "wechatApp快速入门相关源码: http://www.bmob.cn/sdk/bmob-wechatApp-v0.3.zip", 
            "title": "示例和功能"
        }, 
        {
            "location": "/data/cocos2d_x/", 
            "text": "简介\n\n\nCocos2d-x SDK是Bmob提供给Cocos2d-x开发者的工具，旨在帮助游戏开发者能够快速灵活使用我们提供的云服务。\n\n注：使用sdk，环境必须支持Ｃ++11标准，同时还必须使用cocos2dx-3.x版本．\n\n\nSDK配置\n\n\n使用 Cocos2dx 的 SDK ,需要将 SDK 源码以及对应的库文件复制到项目中或设置编源码路径．\n\n\n源码结构\n\n\n---bmobsdk　　　　　　　　　//ＳＤＫ　根目录\n    --- bmobobject       　　　//sdk基础对象目录\n        ---  bmobSDKinit.h             //sdk初始化对象\n        ---  bmobcloud.h    　　　　　　//云端代码操作对象\n        ---  bmoboject.h    　　　　　　//sdk基础对象\n        ---  bmobquery.h    　　　　　　//sdk查询对象\n        ---  bmobqueryinterface.h    //sdk查询对象接口\n        ---  bmobuser.h              //用户对象\n\n    --- decrypt　　　　//安全相关目录\n        ---  include 　　　　　//sdk安全头文件目录\n\n    --- delegate　　　　　　　//delegate目录\n        ---  bmobdelegate.h        //sdk　回调接口定义\n    --- demo\n    --- jsoncpp　　　　　　　//json库\n    --- libs　　　　　　　　　//sdk需要的库\n        ---  android       　　　　//android平台下sdk需要的库文件目录\n        ---  linux         　　　　//linux平台下sdk需要的库文件目录\n        ---  windows       　　　　//windows平台下sdk需要的库文件目录\n    --- util　　　　　　　　　//sdk使用的一些工具\n        ---  bmobhttputil.h       //sdk关于http请求的url和tag定义\n        ---  bmobjsonutil.h       //sdk对json的操作，主要是转换\n        ---  bmobblog.h           // sdk日志输出工具（仅实现了控制台输出）\n        ---  bmobsdkutil.h        //sdk工具类，主要是进行数据的转换以及获取时间\n        ---  bmobstrutil.h        //字符串操作类（目前没有实现） \n\n   ---  bmobsdk.cpp\n   ---  bmobsdk.h　              //sdk的使用必须包含的头文件\n\n\n\n\n如图： \n\n\n\n\nlinux平台下源码编译\n\n\nlinux下编译方法多种，这里根据Cocos2d-x 3.x提供的方法使用cmake进行编译．同时需要将libbmobsafe.so拷到项目中，编译项目进行链接．\n\n\n\n\n将sdk源码（包含了开发的源码以及对应的库）拷贝到项目对应的目录下；\n\n\n\n\n\n\n\n\n在CMakeLists.txt中设置编译源码；如图：\n\n\n\n\n\n\n\n\n添加．so文件路径到CMakeLists.txt文件中 \n\n\n\n\n\n\n\n\n将对应的库在CMakeLists.txt进行连接；如图： \n\n\n\n\n\n\nＳＤＫ使用：\n\n\n\n\n在需要使用的文件中加入上图中的代码．\n编译成功运行输出结果如： \n\n\n\n\nandroid平台下源码编译\n\n\n将sdk源码拖到项目中．编写Android.mk. 在使用SDK时，需要添加两个库：［libbmobsafe.a libstlport_static.a］，在Android.mk中通过LOCAL_LDLIBS变量链接这两个库，如将库放在$(LOCAL_PATH)/../obj/目录下，链接方式就是：\n\n\nLOCAL_LDLIBS += $(LOCAL_PATH)/../obj/libbmobsafe.a \\\n                $(LOCAL_PATH)/../obj/libstlport_static.a\n\n\n\n\n在Application.mk中添加APP_STL,设置为stlport_static\n库在sdk源码libs目录下 编译源码中连接库的mk片段：\n\n\nApplication.mk\n\n\nAPP_ABI := armeabi armeabi-v7a\nAPP_STL := stlport_static\nAPP_CPPFLAGS += -fexceptions\n\n\n\n\nAndroid.mk\n\n\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := crypttest\nLOCAL_CPPFLAGS := -fPIC -Wall -Wextra -DAPP_CFG_ANDROID -DLINUX -finline-functions -O3 -fno-strict-aliasing -fvisibility=hidden -static-libstdc++  -frtti -fexceptions\nLOCAL_C_INCLUDES := $(LOCAL_PATH)/../include\n\nLOCAL_LDLIBS += $(LOCAL_PATH)/../obj/libbmobsafe.a \\\n                $(LOCAL_PATH)/../obj/libstlport_static.a\n\nLOCAL_SRC_FILES :=     \\    #源码文件\n                     ...\n\n...\n\n\n\n\n按照上面的编译完成以后，就可以在android中使用sdk了．\n\n注：使用ＳＤＫ，必须包含上面的库，否则会提示无法找到XXX符号．\n\n\nwindows平台下源码编译\n\n\nwindows平台以visual studio2015为环境配置。\n1. 将需要的库文件（bmobsafelib.dll）添加到项目依赖库的目录中。 如cocos2dx-3.x提供的源码中，将需要的库复制到\\cocos2d-x-3.9\\build\\Debug.win32\\cpp-empty-test目录下。\n\n\n\n\n\n\n在程序开始的地方使用#pragma comment( lib,\"bmobsafelib.lib\")将库链接到项目中。 \n\n\n\n\n\n\n\n\n将源码添加到项目中,即可完成sdk的导入。 在项目中使用SDK的文件中包含文件bmobsdk\\bmobsdk.h，如：#include \"bmobsdk\\bmobsdk.h\"，同时导入命名空间bmobsdk，如：using namespace bmobsdk;完成上的工作就可以使用sdk服务。 \n\n\n\n\n\n\n导入cocos2dx-3.x的cpp-empty-test项目后的结构： \n\n\n\n\n至此SDK 配置完成。\n\n注：如上面的添加以后，可能还会出现如图：\n\n\n\n\n这样的错误，解决方法是添加现有项，如：\n\n\n\n\n\n\n这样就完成windows SDK的配置。\n\n\nSDK初始化\n\n\n使用 BmobSDK 之前,需要先初始化 SDK 环境,初始化使用BmobSDKInit的initialize方法，方法原型是：\n\n\n/**\n  * 使用appID和appKey初始化环境\n  * @param app_id string\n  * @return\n  */\n  void initialize(string app_id,BmobInitDelegate* delegate);\n\n\n\n\n参数说明：\n\n\n     app_id             应用Application ID\n     delegate            初始化回调接口\n\n\n\n\n调用:\n\n\n/**\n  * test object\n  */\n  BmobSDKInit::getInstance()-\ninitialize(\nappID\n,this);\n\n\n\n\n\n回调接口：\n\n\n    class BmobInitDelegate{ public: /**\n    * 初始化SDK成功回调\n    * @param data const void* 返回的数据\n    * @return void\n    */\n    virtual void onInitSuccess(const void* data) = 0;\n    /**\n    * 初始化SDK失败回调\n    * @param code const int 失败的代码\n    * @param msg const void* 失败的返回数据\n    * @return void\n    */\n    virtual void onInitFail(const int code,const void* data) = 0;\n    };\n\n\n\n\n注：BmobSDKInit是一个单例对象，代表了整个SDK环境． \n\n\n\n有上面的输出说明初始化成功。\n\n\n应用程序\n\n\n在 Bmob 平台注册后,每个账户可创建多个应用程序,创建的每个应用程序有各自的Application ID ,应用程序将凭 Application ID 使用 BmobSDK 。\n\n\n应用安全\n\n\n请大家在使用 Bmob 开发应用程序之前,仔细阅读“数据与安全”的文档:\nhttp://docs.bmob.cn/datasafety/index.html?menukey=otherdoc\nkey=datasafety\n\n\n数据类型\n\n\n目前为止,我们支持的数据类型CCString 、 CCInteger 、 CCBool 、 CCArray 、 CCDictionary 、 map 、string 以及 BmobObject 对象类型。\n\n\n对象\n\n\n一个数据对象( BmobObject 类和子类,其中 BmobObject 继承 Cocos2dx 中的CCObject 类)对应于 Bmob 后台的一个数据表。\n\n\n数据对象\n\n\nSDK存储数据建立在 BmobObject 基础上,任何要保存的数据对象必须继承BmobObject 类。 BmobObject 类本身包含 objectId 、 createdAt 、 updatedAt 、 ACL四个默认的属性, objectId 是数据的唯一标识,类似于表的主键, createdAt 是数据创建时间, updatedAt 是数据最后修改时间, ACL 是数据操作权限。\n如游戏中使用 GameScore 表来记录玩家信息,其中表的字段有: score (分数)、playerName (玩家名字)、 info (玩家头像)属性,这个数据对象定义如:\n\n\n//必须要继承自 BmobObject 类\nclass\nGameScore :public BmobObject {\npublic:\n    GameScore (stringtableName);\n    ~ GameScore ();\nprivate:\n    CC_SYNTHESIZE(std::string, m_playerName, PlayerName);\n    CC_SYNTHESIZE(int,m_score,Score);\n    CC_SYNTHESIZE(std::string,m_info,Info);\n};\n\n\n\n\n注:对于开发发者来说,不需要对 objectId 、 createdAt 、 updatedAt 、 ACL 四个属性进行定义,已经在 BmobObject 类中默认定义了。\n\n\n类名和表名的关系\n\n\n\n\nSDK 官方推荐类名和表名完全一致的映射使用方式,.如上面的 \nGameScore\n 类,在使用 SDK 的接口保存数据的时候,传递对应的类名,在后台创建的表名就和传递名一样。\n\n\n如果不想创建和类名一样的表名,传递其他的名字即可。\n\n\n\n\n添加数据\n\n\n添加数据使用 BmobObject 类提供的 save 方法,并传递监听接口指针.将对象的内容保存到数据库。 方法原型:\n\n\nvirtual void save( BmobSaveDelegate * delegate);\n\n\n\n\n如,将玩家为Habrrier 的信息保存到 GameScore 数据表中,SDK使用如下:\n\n\n    GameScore *game = new GameScore (\nGameScore\n);\n    game-\nautorelease();\n    game-\nsetName(\nHabrrier\n);\n    game-\nsetScore(670);\n    game-\nsetInfo(\nMy name is Habrrier\n);\n    game-\nclear();\n    game-\nenParamsToHttp(\nplayerName\n,CCString::createWithFormat(\n%s\n,game-\ngame-\ngetName().c_str()));\n    game-\nenParamsToHttp(\nscore\n,CCInteger::create(game-\ngetScore()));\n    game-\nenParamsToHttp(\ninfo\n,CCString::createWithFormat(\n%s\n,game-\ngetInfo().c_str()));\n    game-\nsave(this);\n\n\n\n\n上面调用 enParamsToHttp 方法是将上面的属性转换成 key-value 放入 http 请求中,只有调用该方法,才能使用 save 保存数据到后台。同时 this 代表的类中实现 BmobSaveDelegate 接口,监听保存数据的返回状态,回调方法是:\n\n\n      void onSaveSucess(const void* data){\n      // 数据添加成功\n      }\n      void onSaveError(int code,const void* data){\n      // 数据添加失败\n      }\n\n\n\n\n如果对返回状态不关心可以传递 NULL 作为 save 的参数。实现 BmobSaveDelegate 接口如下:\n\n\n      class HelloWorld :public BmobSaveDelegate {\n      ...\n      public:\n          virtual void onSaveSucess(const void* data){//To DO}\n          virtual void onSaveError(int code,const void* data){//To Do}\n      ....\n      };\n\n\n\n\n运行以上代码,如果添加成功,你可以在 Bmob 提供的后台的数据浏览中看到类似这样的结果:\n\n\n{\ndata\n:{\ncreatedAt\n:\n2016-03-10 14:43:16\n,\nobjectId\n:\n992be5638a\n},\nresult\n:{\ncode\n:200,\nmessage\n:\nok\n}} \n\n\n\n\n这是登录后台，就可以看到： \n\n\n\n这里需要注意的是:\n\n1. 如果服务器端不存在 GameScore 表,系统将自动建表该表,并插入数据。\n2. 如果服务器端已经存在 GameScore 表,那就会将该条数据保存到对应的表中。\n3. 每个 BmobObject 对象都有几个默认的键 ( 数据列 ) 是不需要开发者指定的,objectId 是每个保存成功数据的唯一标识符。createdAt 和 updatedAt 代表每个对象 ( 每条数据 ) 在服务器上创建和最后修改的时间。这些键 ( 数据列 ) 的创建和数据内容是由服务器端自主生成。\n4. 因此,使用 save 方法时 , 不需要调用 setObjectId 方 法,否则会出现提示:“ It is a reserved field: objectId(105)”-- 表明objectId 为系统保留字段,不允许修改 。\n\n\n修改数据\n\n\n修改数据主要是调用 SDK 重的 update 方法,将对象的 objectId 和实现的监听接口传递给该方法,以指明要更新的数据。方法原型:\n\n\nvirtual void update(string objectId,BmobUpdateDelegate* delegate);\n\n\n\n\n参数：\n\n\nobjectId 　　　更新对象id\ndelegate 更新回调接口\n\n\n\n\n例如:将 GameScore 表中 objectId 为 2e0f067922 的游戏分数修改为 1000.\n\n\nGameScore *game = new GameScore (\nGameScore\n);\ngame-\nautorelease();\ngame-\nsetScore(1000);\ngame-\nclear();\ngame-\nenParamsToHttp(\nscore\n,CCInteger::create(game-\ngetScore()));\ngame-\nupdate(\n2e0f067922\n,this);\n\n\n\n\n其中 this 必须实现 BmobUpdateDelegate 接口,以监听更新状态。\n\n\nvoid onUpdateSucess(void* data){\n// 数据更新成功\n}\nvoid onUpdateError(int code,void* data){\n// 数据更新失败\n}\n\n\n\n\n同样的和保存数据一样,使用 set 方法来更新数据也需要调用 enParamsToHttp 将数据放入 http 中。SDK 提供了另一种方法来更新数据,通过调用 Bmobobject 类中的setValue ( key , value )方法,只需要传入 key 和要更新的值,如:\n\n\n    GameScore *game = new\n    game-\nautorelease();\n    GameScore (\nabcdef\n);\n    game-\nclear();\n    game-\nsetValue(\nscore\n,CCFloat::create(1000));\n    game-\nupdate(\n2e0f067922\n,this);\n\n\n\n\n返回结果：\n\n\n{\ndata\n:{\nupdatedAt\n:\n2016-03-10 14:49:05\n},\nresult\n:{\ncode\n:200,\nmessage\n:\nok\n}} \n\n\n\n\n更新数据时,如果对更新状态需要监听,需实现 BmobUpdateDelegate 接口,并传递给update 方法。接口 BmobUpdateDelegate 实现如下:\n\n\nclass HelloWorld :public BmobUpdateDelegate {\n...\npublic:\n    virtual void onUpdateSucess(const void* data){//To Do}\n    virtual void onUpdateError(int code const void* data){//To Do}\n..\n};\n\n\n\n\n删除数据\n\n\n从服务器删除对象使用 BmobObject 对象的 del 方法，并传递监听接口参数,方法原型:\n\n\nvirtual void del( BmobDeleteDelegate * delegate);\n\n\n\n\n例如:将 GameScore 表中 objectId 为 0875c8a278 的数据删除。\n\n\n    GameScore *\n    game = new GameScore (\nabcdef\n);\n    game-\nautorelease();\n    game-\nsetObjectId(\n0875c8a278\n);\n    game-\ndel(this);\n\n\n\n\n返回结果:\n\n\n{\ndata\n:{\nmsg\n:\nok\n},\nresult\n:{\ncode\n:200,\nmessage\n:\nok\n}}\n\n\n\n\n在这里 this 类必须实现 BmobDeleteDelegate 接口,以便监听状态,如果传递 NULL ,说明删除状态不监听。其监听回调方法是:\n\n\nvoid onDeleteSucess(void* data){\n// 删除数据成功\n}\nvoid onDeleteErrpr(int code,void* data){\n// 删除数据失败\n}\n接口 BmobDeletedelegate 实现如下:\nclass  HelloWorld :public BmobDeleteDelegate {..\npublic:\n    virtual void onDeleteSucess(const void* data){//To Do}\n    virtual void onDeleteError(int code,const void* data){//To Do}\n..\n};\n\n\n\n\n删除数据除了使用上面调用 setObjectId 来设置 objectId 更新以外,还可以调用 del 的一个重载方法:\n\n\nvirtual void del(string objectId,BmobDeleteDelegate* delegate);\n\n\n\n\n来更新,直接通过传递 objectId 实现更新。如:\n\n\nGameScore * game = new GameScore (\nGameScore\n);\ngame-\nautorelease();\ngame-\ndel(\n0875c8a278\n,this);\n\n\n\n\n返回结果：\n\n\n{\ndata\n:{\nmsg\n:\nok\n},\nresult\n:{\ncode\n:200,\nmessage\n:\nok\n}}\n\n\n\n\n注意:删除数据只能通过 objectId 来删除,目前不提供查询条件方式的删除方法。\n\n\n查询数据\n\n\n数据的查询可能是每个应用都会频繁使用, BmobSDK 中提供了 BmobQuery 类,提供了多种方法实现不同条件的查询。\n\n注: 在做新的查询之前一定要调用 BmobQuery 的 clear 方法,否则结果不可预知。\n\n\n查询所有数据\n\n\n查询某个数据表中的所有数据使用 BmobQuery 提供的 findObjects 方法,参数是监听接口。方法原型:\n\n\nvirtual void findObjects(BmobFindDelegate* delegate);\n\n\n\n\n例如:查询 GameScore 表中的所有数据:\n\n\nBmobQuery *query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease();\nquery-\nfindObjects(this);\n\n\n\n\n注:如果需要监听查找状态以及查询结果,必须实现 BmobFindDelegate 接口,上面的 this 必须实现该接口。接口中的回调方法方法:\n\n\nvirtual void onFindSucess(const void* data) {\n// 查询数据成功回调, data 是查询返回的数据\n}\nvirtual void onFindError(int code,const void* data) {\n// 查询数据失败回调, data 是失败信息\n}\n\n\n\n\n接口实现\n\n\nclass HelloWorld:public BmobFindDelegate{\n...\npublic:\n    virtual void onFindSucess(const void* data){//To Do}\n    virtual void onFindError(int code,const void* data){//To Do}\n.....\n};\n\n\n\n\n同样的也可以使用 findObjects 的一个变体,通过直接指定表明查询,方法原型是: \nvirtual void findObjects(string tableName,BmobFindDelegate* delegate) = 0;\n 如果对查询结果和状态不关系的,可以传递 NULL 参数。 同时也可以通过设置 where 条件来查询满足条件的所有数据。 如可以使用 BmobQuery 中的 findObjects 方法查询 GameScore 表中 playerName 爲 xiaoming 的所有数据:\n\n\nBmobQuery *query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease();\nstring name = \nxiaoming\n;\nquery-\nclear();\nquery-\naddWhereEqualTo(\nplayerName\n,CCString::createWithFormat(\n%s\n,name.c_str()));\nquery-\nfindObjects(this);\n\n\n\n\n返回结果：\n\n\n{\ndata\n:{\nage\n:23,\ncreatedAt\n:\n2016-03-10 14:43:16\n,\ninfo\n:\n playerInfo\n,\nobjectId\n:\n992be5638a\n,\nplayerAddress\n:\nGuangzhou\n,\nplayerName\n:\nshockerjue\n,\nscore1\n:9000,\nupdatedAt\n:\n2016-03-10 14:54:45\n},\nresult\n:{\ncode\n:200,\nmessage\n:\nok\n}}\n\n\n\n\n注:在不需要 where 查询或者是查询全部数据之前,先调用 clear 清除之前设置过的where 条件,或者是当重新设置 where 条件,那之前必须先调用 clear 函数以清除之前的where 条件。\n\n\n查询单条数据\n\n\n同样的可以根据 objectId 直接获取单条数据对象,查询调用 BmobQuery 提供的getObject 方法并传递 objectId 以及回调接口查询。方法原型:\n\n\nvirtual void getObject(string objectId,BmobGetDelegate* delegate);\n\n\n\n\n例如:在 GameScore 表中查询 objectId 为 c660c4166d 的人员信息。\n\n\nBmobQuery *query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease();\nquery-\ngetObject(\nc660c4166d\n,this);\n\n\n\n\n返回结果：\n\n\n{\ndata\n:{\nage\n:23,\ncreatedAt\n:\n2016-03-10 14:43:16\n,\ninfo\n:\n playerInfo\n,\nobjectId\n:\n992be5638a\n, \nplayerAddress\n:\nexample\n,\nplayerName\n:\nexample\n,\nscore1\n:9000,\nupdatedAt\n:\n2016-03-10 14:54:45\n},\nresult\n:{\ncode\n:200,\nmessage\n:\nok\n}}\n\n\n\n\n注:如果需要监听查询的状态以及查询结果,必须实现 BmobGetDelegate 接口,上面的 this 实现了该接口。接口中的回调方法:\n\n\nvirtual void onGetSucess(const void* data) {\n// 查询单条数据成功, data 存储了查询的结果\n}\nvirtual void onGetError(int code,const void* data) {\n// 查询单条数据失败, code 返回状态码, data 存储失败信息\n}\n\n\n\n\n接口 BmobGetDelegate 的实现如下:\n\n\nclass HelloWorld :public BmobGetDelegate {\n...\npublic:\n    virtual void onGetSucess(const void* data){//To Do}\n    virtual void onGetError(int code,const void* data){//To Do }\n.....\n};\n\n\n\n\n限制查询\n\n\n查询数据可以使用 BmobQuery 提供的 setLimit 和 setSkip 方法来做一些限制。限制结果查询返回数量,使用 setLimit 方法;限制结果跳转的页数,使用 setSkip 方法。方法原型是:\n\n\nvirtual void setLimit(int limit);\nvirtual void setSkip(int skip);\n\n\n\n\n如限制跳转到结果的第 10 页,并且仅查询 20 条数据的使用方法是:\n\n\nBmobQuery *query = new query-\nautorelease();\nBmobQuery (\nGameScore\n);\nquery-\nsetLimit(20);\nquery-\nsetSkip(10);\nquery-\nfindObjects(this);\n\n\n\n\n需要监听查询状态和结果,需要实现 BmobFindDelegate 接口,上面的 this 实现了该接口。\n\n注:如果 setSkip 设置的值超过了结果的页数,那返回将没有结果数据。\n\n\n条件查询\n\n\n查询过程中,基于不同条件查询,可以使用 BmobQuery 提供的条件查询。\n\n\n比较查询\n\n\n要查询特定键的值,可以使用 BmobQuery 提供的 addWhereEqualTo 方法指定条件。如要过滤掉特定键的值可以使用 addWhereNotEqualTo 方法指定条件,之后调用findObjects 方法触发查询。方法原型是:\n\n\nvirtual void addWhereEqualTo(string seg,CCObject *object);\nvirtual void addWhereNotEqualTo(string seg,CCObject *object);\n\n\n\n\n比如需要查询 name 等于“ Barbie” 的数据时可以这样写:\n\n\nquery-\naddWhereEqualTo(\nname\n, \nBarbie\n);\nquery-\nfindObjects(this);\n\n\n\n\n同样可以在查询操作中添加多个约束条件,来查询符合的数据。 如查询 GameScore 表中 playerName 不等于 Bridder ,且 score 等于 10989 的数据:\n\n\nBmobQuery *query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease();\nstring name = \nBridder\n;\nquery-\nclear();\nquery-\naddWhereEqualTo(\nscore\n,CCFloat::create(10989));\nquery-\naddWhereNotEqualTo(\nplayerName\n,CCString::createWithFormat(\n%s\n,\nname.c_str()));\nquery-\nfindObjects(this);\n\n\n\n\n以下还包含了各种不同条件的比较查询:\n\n\n小于条件\n\n\nvirtual void addWhereLessThan(string seg,CCObject* object) ;\n// 添加玩家分数小于 2345 的条件 //\nquery-\naddWhereLessThan(\nscore\n,CCInteger::create(2345));\n\n\n\n\n小于等于条件\n\n\nvirtual void addWhereLessThanOrEqualTo(string seg,CCObject* object);\n// 添加玩家分数小于等于 2345 的条件 //\nquery-\naddWhereLessThanOrEqualTo(\nscore\n,CCInteger::create(2345));\n\n\n\n\n大于条件\n\n\nvirtual void addWhereGreaterThan(string seg,CCObject* object);\n// 添加玩家分数大于 2334 的条件 //\nquery-\naddWhereGreaterThan(\nscore\n,CCInteger::create(2334));\n\n\n\n\n大于等于\n\n\nvirtual void addWhereGreaterThanOrEqualTo(string seg,CCObject*object) ;\n// 添加玩家分数大于等于 2345 的条件\nquery-\naddWhereGreaterThanOrEqualTo(\nscore\n,CCInteger::create(2345));\n\n\n\n\n注:不能添加具有矛盾的查询条件,否则将得不到想要的结果!\n\n\n子查询\n\n\n如果需要查询匹配几个不同值的数据,可以使用 BmobQuery 提供的addWhereContainedIn 方法,方法原型:\n\n\nvirtual void addWhereContainedIn(string seg,CCObject* array) ;\n\n\n\n\n如:要查询 GameScore 表中 playerName 为“ Barbie”,“Joe”,“Julia” 三个人的成绩:\n\n\n        string[] names = {\nBarbie\n, \nJoe\n, \nJulia\n};\n        CCArray* array = CCArray::create();\n        array-\naddObject(CCString::createWithFormat(\n%s\n,name[0].c_str()));\n        array-\naddObject(CCString::createWithFormat(\n%s\n,name[1].c_str()));\n        array-\naddObject(CCString::createWithFormat(\n%s\n,name[2].c_str()));\n        query-\naddWhereContainedIn(\nplayerName\n, array);\n\n\n\n\n相反,如果想查询排除“ Barbie”,“Joe”,“Julia” 这三个人的其他同学的信息,你可以使用 addWhereNotContainedIn 方法来实现。方法原型是:\n\n\nvirtual void addWhereNotContainedIn(string seg,CCObject* array) ;\n\nquery-\naddWhereNotContainedIn(\nplayerName\n, array);\n\n\n\n\n之后调用 findObjects 方法查询 :\n\n\nquery-\nfindObjects(this);\n\n\n\n\n排序\n\n\n对应数据的排序,如数字或字符串,可以使用升序或降序的方式来控制查询数据的结果顺序,需要进行排序查询,可以使用 BmobQuery 提供的 order 方法,其方法原型:\n\n\nvirtual void order(string key);\n\n\n\n\n如对 GameScore 重的 score 段进行升序或降序查询:\n\n\nquery-\norder(\nscore\n);// 升序 //\nquery-\norder(\n-score\n);// 降序 //\nquery-\norder(\n-score,PlayerName\n);// 对多个字段进行排序查询 //\n\n\n\n\n说明:多个字段排序时,先按第一个字段进行排序,再按第二个字段进行排序,依次进行。\n\n\n数组查询\n\n\n对于字段类型为数组的情况,需要查找字段中的数组值包含有 xxx 的对象,可以使用 addWhereContainsAll 方法,方法原型是:\n\n\n  virtual void addWhereContainsAll(string seg,CCArray* array) ;\n\n\n\n\n如查询有 Read 、 Write 、 Coffee 的人:\n\n\n  CCArray* array1 = CCArray::create();\n  string name1[] = {\nRead\n,\nWrite\n,\nCoffee\n};\n  array-\naddObject(CCString::createWithFormat(\n%s\n,name1[0].c_str()));\n  array-\naddObject(CCString::createWithFormat(\n%s\n,name1[1].c_str()));\n  array-\naddObject(CCString::createWithFormat(\n%s\n,name1[2].c_str()));\n  query-\naddWhereContainsAll(\nhobby\n, array);\n  query-\nfindObjects(this);\n\n\n\n\n列值是否存在\n\n\n如果想查询某个列是否存在,可以使用 addWhereExists 方法,方法原型是:\n\n\nvirtual void addWhereExists(string column);\n// 查询 username 有值的数据\nquery-\naddWhereExists(\nusername\n);\n\n\n\n\n如果想查询某个列值不存在,则可以用 addWhereDoesNotExists 方法,方法原型是:\n\n\nvirtual void addWhereDoesNotExists(string column);\n    // 查询 username 字段没有值的数据\nbr\n\n    query-\naddWhereDoesNotExists(\nusername\n);\n    query-\nfindObjects(this);\n\n\n\n\n查询指定的列\n\n\n可以限定查询返回的字段,通过 BmobQuery 的 addQueryKey 方法添加 where 条件。方法原型是:\n\n\nvirtual void addQueryKeys(string column) ;\n\n\n\n\n通过传入 keys 参数,值为用一个逗号分隔的字段名称列表,为了获取对象只包含 score 和playerName 字段 ( 还有特殊的内置字段比如 objectId,createdAt 和 updatedAt) ,请求如下:\n\n\nquery-\naddQueryKeys(”score,playerName“);\n\n\n\n\n之后调用 findObjects 或者是 getObject 来查询。\n\n\n查询个数\n\n\n统计满足查询条件的对象数量,且不需要获取所有匹配对象的具体数据信息,可直接使用count 替代 findObjects 。 例如,查询 playerName 为 Barrier 玩家玩的游戏场数:\n\n\nBmobQuery *query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease();\nstring name = \nBarrier\n;\nquery-\naddWhereEqualTo(\nplayerName\n,CCString::createWithFormat(\n%s\n,\nname.c_str()));\nquery-\ncount(this)\n\n\n\n\n如果需要获得返回的数据加数量,可以使用 BmobQuery 的 count 重载方法, count(BmobCountDelegate* delegate,bool sign)并传递一个 bool 值, false 是 不返回数据(和直接调用 count 一样的结果), true 返回数据。如:\n\n\nBmobQuery *query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease();\nstring name = \nlingo\n;\nquery-\naddWhereEqualTo(\nplayerName\n,CCString::createWithFormat(\n%s\n,\nname.c_str()));\nquery-\ncount(this,true);\n\n\n\n\n要获得查询的结果,需要实现 BmobCountDelegate 接口,并实现其中的回调方法:\n\n\nvirtual void onCountSucess(const void* data){\n// 返回查询数据\n// 数据格式: {\ncount\n:3,\nresults\n:[]}\n}\nvirtual void onCountError(int code,const void* data){\n// 返回失败信息与数据\n}\n\n\n\n\nBQL查询\n\n\nBQL查询 SDK提供类 SQL 语法的 BQL 查询语言来查询数据，其基本语法和sql类似，如：\n\n\nbql\n:\nselect * from GameScore where name=? and score\n? limit ?,?\n,\n\nvalues\n:[\ntest\n, 90 ,10, 100],\n\n\n\n\n其中的values是用来填充bql中的值，也就是问号的地方．Cocos2dx　SDK中的BQL查询使用BmobQuery类中的BSQLFindObjects方法，原型是：\n\n\n/**\n  * 执行sdk定义的sql查询\n  * @param bql 查询语句\n  * @param values sql语句对应的值\n  * @param delegate 回调接口\n  * @return\n  */\nvoid BmobQuery::BSQLFindObjects(string bql,CCObject* values,BmobBQLDelegate* delegate)\n\n\n\n\n查询表MyGameData中的所有数据，values传递空值：\n\n\n  BmobQuery* query = new BmobQuery(\nMyGameData\n);\n  query-\nautorelease();\n  query-\nBSQLFindObjects(\nselect * from MyGameData\n,nullptr,this);\n\n\n\n\n返回数据：\n\n\n{\n    \ndata\n:{\n            \nc\n:\nMyGameData\n,\n             \nresults\n:[]\n       },\n       \nresult\n:{\n               \ncode\n:200,\n               \nmessage\n:\nok\n\n               }\n}\n\n\n\n\n查询表结构\n\n\nＳＤＫ提供查询数据表的结构．查询使用SDK的BmobQuery对象中的findTableStruct方法，原型是：\n\n\n/**\n  * 查询表的结构\n  * @param tableName 表名\n  * @param delegate 查询回调接口\n  */\n  virtual void findTableStruct(string tableName,BmobFindDelegate* delegate) = 0;\n\n\n\n\n如果tableName为空，则获取的是所有的数据表结构．\n如查询表Gamescore的结构：\n\n\nBmobQuery* query = new BmobQuery(\nMyGameData\n);\nquery-\nautorelease();\nquery-\nfindTableStruct(\n,this);\n\n\n\n\n返回：\n\n\n{\ndata\n:{\nclassName\n:\nGameScore\n,\nfields\n:{\nACL\n:{\ntype\n:\nObject\n},\ncreatedAt\n:{\ntype\n:\nDate\n},\ninfo\n:{\ntype\n:\nString\n},\nobjectId\n:{\ntype\n:\nString\n},\nplayerName\n:{\ntype\n:\nString\n},\nscore\n:{\ntype\n:\nNumber\n},\nupdatedAt\n:{\ntype\n:\nDate\n}}},\nresult\n:{\ncode\n:200,\nmessage\n:\nok\n}}\n\n\n\n\n查询所有表结构：\n\n\nBmobQuery* query = new BmobQuery(\nMyGameData\n);\nquery-\nautorelease();\nquery-\nfindTableStruct(\n,this);\n\n\n\n\n返回：\n\n\n{\ndata\n:{\nresults\n:[]},\nresult\n:{\ncode\n:200,\nmessage\n:\nok\n}}\n\n\n\n\n数组\n\n\n对于数组类型数据, BmobSDK 提供了 3 种操作来原子性地修改一个数组字段:\nadd 在一个数组字段的后面添加一些指定的对象 ( 包装在一个数组内 )\nsetValue 在一个数组字段里面修改其中的值\nremoveAll 从一个数组字段的值内移除指定的数组中的所有对象\n\n\n添加数组数据\n\n\n可以使用 BmobObject 中的 add 方法实现数组的添加,函数原型:\n\n\n/**\n只添加一个数据\n*\n*/\nvirtual void add(string column,CCObject* object);\n/**\n* 同时添加多个数据\n*/\nvirtual void add(string column,CCArray* array);\n\n\n\n\n之后调用 BmobObject 提供的 save 方法来添加到服务,如在 GameScore 表中添加一个数 组名为 list 的数组,其中只有一个数据:\n\n\nGameScore *game = new GameScore (\nGameScore\n);\ngame-\nautorelease();\ngame-\nadd(“list”,CCInteger::create(234));\ngame-\nsave(this);\n\n\n\n\n如果要一次添加含多个数据的数组到表中,同样的调用 add 方法,只是需要传递包含多个 元素的数组:\n\n\nGameScore *game = new GameScore (\nGameScore\n);\ngame-\nautorelease();\nCCArray* array = CCArray::create();\narray-\naddObject(CCInteger::create(120));\narray-\naddObject(CCInteger::create(234));\ngame-\nadd(“list”,array);\ngame-\nsave(this);\n\n\n\n\n更新数组\n\n\n更新数组使用 BmobObject 提供的 setValue 方法来设置需要更新的数组元素,其方法原型是:\n\n\nvoid setValue(string key,cocos2d::CCArray* array);\n\n\n\n\n更新需要传递一个数组作为参数,如需要更新 GameScore 表中 objectId为” 5ec74b2297“list 数组的数据:\n\n\nGameScore *game = new GameScore (\nGameScore\n);\ngame-\nautorelease();\nCCArray* array = CCArray::create();\narray-\naddObject(CCInteger::create(123));\narray-\naddObject(CCInteger::create(234));\ngame-\nsetValue(\nlist\n,array);\ngame-\nupdate(“5ec74b2297”,this);\n\n\n\n\n查询数组\n\n\n对于字段类型为数组的情况,可以查找字段中的数组值包含有 xxx 的对象,查询使用BmobQuery 提供的 addWhereContainsAll 方法来查询,方法原型是:\n\n\nvoid BmobQuery::addWhereContainsAll(string seg,CCArray* array);\n\n\n\n\n如查询 GameScore 表中含有 hobby 数组字段且包含阅读、唱歌的数据:\n\n\nBmobQuery *query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease();\nCCArray* array = CCArray::create();\nstring name1[] = {\n 阅读 \n,\n 唱歌 \n};\narray-\naddObject(CCString::createWithFormat(\n%s\n,name1[0].c_str()));\narray-\naddObject(CCString::createWithFormat(\n%s\n,name1[1].c_str())) ;\nquery-\naddWhereContainsAll(\nname\n,array);\nquery-\nfindObjects(this);\n\n\n\n\n删除数组数据\n\n\n删除数组使用 BmobObject 提供的 removeAll 来设置要删除的数组字段,其函数原型是:\n\n\nvirtual void removeAll(string name,CCArray* array);\n\n\n\n\n如:删除 GameScore 数据表中 objectId 为“ 5ec74b2297” 的 含有 list 数组,且其中含有 123 和 234 的值:\n\n\nGameScore* game = new GameScore (\nGameScore\n);\ngame-\nautorelease();\ngame-\nsetObjectId(“”);\nCCArray* array = CCArray::create();\narray-\naddObject(CCInteger::create(123));\narray-\naddObject(CCInteger::create(234));\ngame-\nremoveAll(\nlist\n,array);\ngame-\nupdate(this);\n\n\n\n\n统计相关查询\n\n\nBmob 的统计查询,提供以下关键字或其组合的查询操作: Key Operation groupby 分组操作 groupcount 返回每个分组的总记录 sum 计算总和 average 计算平均值 max 计算最大值 min 计算最小值 having 分组中的过滤条件\n为避免和用户创建的列名称冲突, Bmob 约定以上统计关键字( sum, max, min) 的查询结果值都用 '_( 关键字 )+ 首字母大写的列名 ' 的格式,如计算玩家得分列名称为 score 总和的操作,则返回的结果集会有一个列名为 _sumScore 。 average 返回的列为 '_avg+ 首字 母大写的列名 ' ,有 groupcount 的情形下则返回 _count 。\n以上关键字除了 groupcount 是传 Boolean 值 true 或 false , having 传的是和 where类似的 json 字符串,但 having 只应该用于过滤分组查询得到的结果集,即 having 只应该包含结果集中的列名如 {\"_sumScore\":{\"$gt\":100}} ,其他关键字必须是字符串而必须是表中包含的列名,多个列名 用 , 分隔。\n以上关键字可以自由组合并可以与前面查询语句中的 where, order, limit, skip 等组合使用。\n比 如, GameScore 表是游戏玩家的信息和得分表,有 playerName( 玩家名称 ) 、score( 玩家得分 ) 等你自己创建的列,还有 Bmob 的默认 列 objectId, createdAt,updatedAt, 那么我们现在举例如何使用以上的查询关键字来作这个表的统计。\n\n\n计算总和\n\n\n计算数据的总和,使用 BmobQuery 提供的 findStatistics 方法,方法原型:\n\n\nvirtual void findStatistics(BmobStaticsDelegate* delegate);\n\n\n\n\n调用以前先调用 sum 方法将要计算的字段设置好。 如计算 GameScore 表所有玩家的得分总和, sum 后面只能拼接 Number 类型的列名,即要 计算哪个列的值的总和,只对 Number 类型有效,多个 Number 列用 , 分隔,则查询如下:\n\n\nBmobQuery *query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease();\nquery-\nsum(\nscore\n);\nquery-\nfindStatistics(this);\n\n\n\n\n计算多个列:\n\n\nBmobQuery* query = new BmobQuery(\nGameScore\n);\nquery-\nautorelease();\nquery-\nsum(\nscore,index\n);\nquery-\nfindStatistics(this);\n\n\n\n\n要监听统计结果,需要实现 BmobStaticsDelegate 接口,必须实现其中的方法 :\n\n\nvirtual void onStaticsSucess(const void* data){\n// 计算成功返回回调\n}\nvirtual void onStaticsError(int code,const void* data){\n// 计算失败回调\n}\n\n\n\n\n分组计算总和\n\n\n分组计算总和使用 findStatistics 方法,在使用以前先调用 groupby 方法将要分组的字 段设置好。 如以 GameScore 创建时间按天统计所有玩家的得分,并按时间降序 , groupby 后面只能 拼接列名,如果该列是时间类型,则按天分组,其他类型,则按确定值分组 :\n\n\nBmobQuery *query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease();\nquery-\nsum(\nscore\n);\nquery-\ngroupby(\ncreatedAt\n);\nquery-\nfindStatistics(this);\n\n\n\n\n多个分组并计算多个列的总和\n\n\n如以创建时间按天和按玩家名称分组统计所有玩家的得分 1 ,得分 2 的总和,并按得分 1 的 总和降序 , groupby 后面只能拼接列名,如果该列是时间类型,则按天分组,其他类型,则按确定值分组 :\n\n\nBmobQuery *query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease();\nquery-\nsum(\nscore1,score2\n);\nquery-\ngroupby(\ncreatedAt,playerName\n);\nquery-\norder(\n-score1\n);\nquery-\nfindStatistics(this);\n\n\n\n\n分组计算总和并只返回满足条件的部分值\n\n\n可以使用 BmobQuery 提供的 where 系列条件实现条件过滤查询,同时要调用 hanving 函 数传递 true 参数。如过滤 GameScore 中玩家总分小于 1000 的:\n\n\nBmobQuery *query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease();\nstring name = \nlingo\n;\nquery-\nsum(\nscore\n);\nquery-\ngroupby(\nplayerName\n);\nquery-\norder(\n-createdAt\n);\nquery-\nhaving(true);\nquery-\naddWhereLessThan(\n_sumScore\n,CCInteger::create(1000));\nquery-\nfindStatistics(this);\n\n\n\n\n分组计算总和并返回每个分组的记录数\n\n\n要查询分组的数量,调用 BmobQuery 的 setHasGroupCount 方法设置需要计数,方法原 型是:\n\n\nvirtual void setHasGroupCount(bool groupCount) ;\n\n\n\n\n比如以创建时间按天统计所有玩家的得分和每一天有多少条玩家的得分记录,并按时间降序 :\n\n\nBmobQuery *query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease();\nquery-\nsum(\nscore\n);\nquery-\ngroupby(\ncreateedAt\n);\nquery-\norder(\n-createdAt\n);\nquery-\nsetHasGroupCount(true);\nquery-\nfindStatistics(this);\n\n\n\n\n获取不重复的列值\n\n\n获取不重复的列时,调用 BmobQuery 提供的 groupby 方法设置列名。如获取玩家分数不重复:\n\n\nBmobQuery * query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease();\nquery-\ngroupby(\nscore\n);\n\n\n\n\n其他关键字\n\n\naverage( 计算平均值 ) , max( 计算最大值 ) , min( 计算最小值 ) 和 sum 查询语句是类似的。只需要调用对应的方法设置字段即可。\n查询 GameScore 表中 score 最小:\n\n\nBmobQuery * query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease() ;\nquery-\nmin(\nscore\n);\nquery-\nfindStatistics(this);\n\n\n\n\n查询 GameScore 表中 score 最大:\n\n\nBmobQuery * query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease();\nquery-\nmax(\nscore\n);\nquery-\nfindStatistics(this);\n\n\n\n\n查询 GameScore 表中 score 的平均值:\n\n\nBmobQuery * query = new BmobQuery (\nGameScore\n);\nquery-\nautorelease();\nquery-\naverage(\nscore\n);\nquery-\nfindStatistics(this);\n\n\n\n\n用户管理\n\n\n用户是一个应用程序的核心。对于个人开发者来说,自己的应用程序积累到越多的用户,就会给自己带来越强的创作动力。因此 Bmob 提供了一个专门的用户类——BmobUser 来自动处理用户账户管理所需的功能。 有了这个类,就可以在应用程序中添加用户账户功能。BmobUser 是 BmobObject 的一个子类,它继承了 BmobObject 所有的方法,具有 BmobObject 相同的功能。不同的是, BmobUser 增加了一些特定的关于用户账户管理相关 的功能。\n\n\n属性\n\n\nBmobUser 除了从 BmobObject 继承的属性外,还有几个特定的属性:\nusername: 用户的用户名 \n(必需)\n 。\npassword: 用户的密码 \n(必需)\n 。\nemail: 用户的电子邮件地址 \n(可选)\n 。\nemailVerified:邮箱认证状态 \n(可选)\n 。\nmobilePhoneNumber:手机号码 \n(可选)\n 。\nmobilePhoneNumberVerified:手机号码的认证状态 \n(可选)\n 。\n\n\n扩展用户类\n\n\n很多时候,你的用户表还会有很多其他字段,如性别、年龄、头像等。那么,你需要对BmobUser 类进行扩展,添加一些新的属性。示例代码如下所示:\n\n\nclass MyUser:public BmobUser {\npublic:\n    MyUser();\n    virtual MyUser();\nprivate:\n    CC_SYNTHESIZE(string,m_sex,SEX);\n    CC_SYNTHESIZE(int,m_age,Age);\n    CC_SYNTHESIZE(string,m_nick,Nick);\n};\n\n\n\n\n更多代码实现大家可以下载 SDK,在里面的 BmobExample 中查找 MyUser 类,参考它的用法。\n\n\n创建用户对象\n\n\n创建用户对象如下:\n\n\nBmobUser* user = BmobUser::createUser();\nuser-\nautorelease();\n\n\n\n\n注册\n\n\n应用程序可能会要求用户注册。下面的代码是一个典型的注册过程:\n\n\nBmobUser* bu = new BmobUser();\nbu→autorelease();\nbu-\nsetUsername(\nsendi\n);\nbu-\nsetPassword(\n123456\n);\nbu-\nsetEmail(\nsendi@163.com\n);\n//注意:不能用 save 方法进行注册\nbu-\nenParamsToHttp(“username”,CCString::createWithFormat(“%s”,bu-\ngetUserName().c_str()));\nbu-\nenParamsToHttp(“password”,CCString::createWithFormat(“%s”,bu→getPasswoed().c_str()));\nbu-\nenParamsToHttp(“email”,CCString::createWithFormat(“%s”,bu→getEmail().c_str()));\nbu-\nsignUp(this);\n\n\n\n\n注:注册时必须实现 BmobSaveDelegate 接口,以监听注册结果以及状态,接口中的方法:\n\n\nvirtual void onSaveSucess(const void* data) {\n// 注册成功的回调函数\n}\nvirtual void onSaveError(int code,const void* data) {\n// 注册失败的回调函数\n}\n\n\n\n\n在注册过程中,服务器会对注册用户信息进行检查,以确保注册的用户名和电子邮件地址是独一无二的。此外,对于用户的密码,你可以在应用程序中进行相应的加密处理后提交。\n如果注册不成功,可以查看返回的错误对象。最有可能的情况是,用户名或电子邮件已经被另一个用户注册。这种情况你可以提示用户,要求他们尝试使用不同的用户名进行注册。\n你也可以要求用户使用 Email 做为用户名注册,这样做的好处是,你在提交信息的时候可以将输入的“用户名“默认设置为用户的 Email 地址,以后在用户忘记密码的情况下可以使用Bmob 提供重置密码功能。\n\n注: 有些时候你可能需要在用户注册时发送一封验证邮件,以确认用户邮箱的真实性。这时,你只需要登录自己的应用管理后台,在应用设置-\n邮件设置(下图)中把“邮箱验证”功能打开,Bmob 云后端就会在注册时自动发动一封验证给用户。\n\nusername 字段是大小写敏感的字段,如果你希望应用的用户名不区分大小写,请在 注册和登录时进行大小写的统一转换。\n\n注:相同的邮箱不能注册不同的账号;同一个账号也不能使用两个邮箱注册。\n\n\n登陆\n\n\n当用户注册成功后,需要让以后能够用注册的用户名登录到他们的账户使用应用。可以使用BmobUser 类的 login 方法进行登陆。方法原型:\n\n\nvirtual void login(BmobSaveDelegate* delegate);\n\n\n\n\ndelegate 是登陆监听接口,如果需要获取登陆的状态,就必须实现该接口。如用户名为 Kiarrier 的登陆:\n\n\nBmobUser * bu = new BmobUser ();\nbu-\nautorelease();bu-\nsetUserName(\nKiarrier\n);\nbu-\nsetPassword(\n********\n);\nbu-\nlogin(this);\n\n\n\n\n也可使用如下方式完成 用户名+密码 的登录,使用 BmobUser 提供的 loginByAccount 方法登陆,参数为用户名和密码加监听接口,方法原型:\n\n\nvoid loginByAccount(string mebileNumber,string pwd, BmobLoginDelegate *delegate); 如:\nBmobUser * bu = new BmobUser ();\nbu-\nautorelease();\nbu-\nloginByAccount(\n15920955603\n,\n2222222222222\n,this);\n\n\n\n\n监听接口 BmobLoginDelegate 的回调方法:\n\n\nvirtual void onLoginDone(int code,const void* data){\n      // 返回登陆状态\n}\n\n\n\n\n获取当前用户\n\n\n如果用户在每次打开应用程序时都要登录,这将会直接影响到应用的用户体验。为了避免这种情况,可以使用缓存的 CurrentUser 对象。\n每当应用的用户注册成功或是第一次登录成功,都会在本地磁盘中有一个缓存的用户对象,这样,可以通过获取这个缓存的用户对象来进行登录:\n\n\nBmobUser* bmobUser = BmobUser::getCurrentUser();\nif(bmobUser != NULL){\n// 允许用户使用应用\n}else{\n//缓存用户对象为空时, 可打开用户注册界面...\n}\n\n\n\n\n在扩展了用户类的情况下获取当前登录用户,可以使用如下的示例代码( MyUser 类可参看 上面): \n\n\nMyUser userInfo = BmobUser::getCurrentUser();\n\n\n\n\n退出登录\n\n\n退出登录非常简单,可以使用如下的代码:\n\n\nBmobUser::logOut(); //清除缓存用户对象\nBmobUser* currentUser = BmobUser::getCurrentUser(); // 现在的 currentUser 是 NULL 了\n\n\n\n\n更新当前用户信息\n\n\n用户可能需要修改信息,应用具备修改个人资料的功能,修改个人资料使用 BmobUser 提供的 update 方法更新信息,Bmob 提供的用户更新方式有两种:\n第一种: 新建一个用户对象,并调用 update(string objectId,BmobSaveDeleaget* delegate)方法 来更新(推荐使用) ,示例:\n\n\nBmobUser* newUser = new BmobUser();\nnewUser→autorelease();\nnewUser-\nsetEmail(\nxxx@163.com\n);\nBmobUser bmobUser* = BmobUser::getCurrentUser();\nnewUser-\nupdate(bmobUser-\ngetObjectId(),this);\n\n\n\n\n第二种:获取本地的用户对象,并调用 update( BmobUpdateDelegate * delegate)方法来更新( 不推荐使用 ),示例:\n\n\nBmobUser* bmobUser = BmobUser::getCurrentUser();\nif(bmobUser != NULL){\n    // 修改用户的邮箱为 xxx@163.com\n    bmobUser-\nsetEmail(\nxxx@163.com\n);\n    bmobUser-\nupdate(this);\n}\n\n\n\n\n上面的两种更新方法都如果需要监听修改状态,都需要传递一个监听对象指镇给update 方法,该对象必须实现 BmobUpdateDelegate 接口,其中必须实现两个回调方法:\n\n\nvirtual void onUpdateSucess(const void* data){\n// 用户信息更新成功的回调\n}\nvirtual void onUpdateError(int code,const void* data) {\n// 用户信息更新失败的回调\n}\n\n\n\n\n\n\n开发者在进行用户更新操作的时候,推荐使用 第一种 方式来进行用户的更新操作,因为此方法只会更新你提交的用户信息(比如只会向服务器提交当前用户的 email 值),而不会将本地存储的用户信息也提交到后台更新。\n\n\n在更新用户信息时,如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话,Bmob 云后端同样会自动发一封邮件验证信息给用户。\n\n\n\n\n查询用户\n\n\n查询用户和查询普通对象一样,使用 BmobQuery 中的 findObjects 方法并传递一个实现的监听接口参数查询,方法原型: virtual void findObjects( BmobFindDelegate * delegate) = 0;如下:\n\n\nBmobQuery * query = new BmobQuery (BmobSDKInit::USER_TABLE);\nquery→autorelease();\nstring name = \nlingo\n;\nquery-\naddWhereEqualTo(\nusername\n,CCString::createWithFormat(\n%s\n,name.c_str()));\nquery-\nfindObjects(this);\n\n\n\n\n注:要查询用户信息,在创建 BmobQuery 对象时,必须传递 BmobSDKInit::USER_TABLE作为参数。浏览器中查看用户表User 表是一个特殊的表,专门存储 BmobUser 对象。\n\n\n密码重置\n\n\n有了密码系统,肯定会有用户 忘记密码 的情况。对于这种情况,我们提供了以下两种方法, 让用户安全地重置密码。\n\n\n邮箱重置密码\n\n\n使用邮箱重置密码,使用 BmobUser 提供的 resetPasswordByEamil 方法并传递邮箱地址和监听接口指针,开发者只需要求用户输入注册时的电子邮件地址即可:\n\n\nBmobUser * bu = new BmobUser ();\nbu-\nautorelease();\nbu-\nresetPasswordByEmail(\nxxxx@bmob.com\n,this);\n\n\n\n\n需要监听重置的状态,开发者必须实现 BmobResetPasswordDelegate 接口,上面传递给resetPasswordByEmail 的第二个参数就是实现该接口的指针,接口中的回调方法:\n\n\nvirtual void onResetSucess(const void* data){\n// 传送重置密码的邮件成功\n}\nvirtual void onResetError(int code,const void* data){\n// 重置错误\n}\n\n\n\n\n邮箱重置密码的流程如下:\n1. 用户输入他们的电子邮件,请求重置自己的密码。\n2. Bmob 向他们的邮箱发送一封包含特殊的密码重置链接的电子邮件。\n3. 用户根据向导点击重置密码连接,打开一个特殊的 Bmob 页面,根据提示他们可以输入一个新的密码。\n4. 用户的密码已被重置为新输入的密码。\n\n\n手机号码重置密码\n\n\nBmob 引入了短信验证系统,如果用户已经验证过手机号码或者使用过手机号码注册或登录过,可以通过手机号码来重置用户密码,以下是官方建议使用的重置流程:\n1、请求手机重置密码必须先获取短信验证码,获取短信验证码使用 BmobUser 提供的requestSMSCode 方法,传入电话号码和模板名以及请求监听接口,方法原型是:\n\n\nvoid requestSMSCode(string meblieNumber,string template_name,BmobRequestSMSCodeDelegate* delegate);\n\n\n\n\n注:如果在后台设置模板名,在申请验证码时需要传入 template_name。\n\n\nBmobUser * bu = new BmobUser ();\nbu-\nautorelease();\nbu-\nrequestSMSCode(\n159........\n,\n,this);\n\n\n\n\n监听请求状态,需要实现 BmobRequestSMSCodeDelegate 接口,上面的 this 实现了该接口, 接口中的回调函数:\n\n\nvirtual void onRequestDone(int code,const void* data){\n// 返回请求状态\n}\n\n\n\n\n2、用户收到重置密码的验证码之后,就可以调用 resetPasswordBySMSCode 方法来实现密 码重置,其中传递重置的密码和短信验证码以及监听接口,方法原型是: \n\n\nvoid resetPasswordBySMSCode(string pw,string code,BmobResetPasswordByCodeDelegate* delegate);\n\n\n\n\n如:\n\n\nBmobUser * bu = new BmobUser ();\nbu→autorelease();\nbu-\nresetPasswordBySMSCode(psw,msm_code,this);\n\n\n\n\n需要监听重置状态,需要实现 BmobResetPasswordByCodeDelegate 接口,回调函数:\n\n\nvirtual void onResetDone(int code,const void* data) {\n// 返回重置状态\n}\n\n\n\n\n重置成功以后,用户就可以使用新密码登陆了。 注:\n1. 请开发者按照官方推荐的操作流程来完成重置密码操作。也就是说,开发者在进行重置密码操作时,无需调用 verifySmsCode 接口去验证该验证码的有效性。\n2. 验证码只能使用一次,一旦该验证码被使用就会失效,那么再拿失效的验证码去调用重置密码接口,一定会报 207-验证码错误 。因为重置密码接口已经包含验证码的有效性验证。\n\n\n密码修改\n\n\nSDK 为开发者提供了直接修改当前用户登录密码的方法,只需要传入旧密码和新密码,然后调用 BmobUser 提供的方法 updateCurrentUserPassword 即可,方法原型:\n\n\nvoid updateCurrentUserPassword(string old_pwd,string new_pwd,BmobUpdateDelegate* delegate);\n\n\n\n\n以下是示例:\n\n\nBmobUser* bu = new BmobUser();\nbu→autorelease();\nbu-\nupdateCurrentUserPassword(“ 旧密码 ” , ” 新密码 ” ,this);\n\n\n\n\n需要监听该方法的修改状态,需要实现 BmobUpdateDelegate 监听接口。修改成功的返回是 JSON 数据,如: \n\n\n{\n\nmsg\n:\nok\n\n}\n\n\n\n\n注:此方法修改密码时,同样需要使用用户的 ID 以及为了安全 X-Bmob-Session-Token,所以需要用户登陆才能修改密码。\n\n\n邮箱验证\n\n\n设置邮件验证是一个可选的应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验,邮件验证功能会在用户(User)对象中加入 emailVerified 字段, 当一个用户的邮件被新添加或者修改过的话,emailVerified 会被默认设为 false,如果应用设置中开启了邮箱 认证功能,Bmob 会对用户填写的邮箱发送一个链接, 这个链接可以把 emailVerified 设置为 true.emailVerified 字段有 3 种状态可以考虑:\n\n\n\n\n\n\ntrue : 用户可以点击邮件中的链接通过 Bmob 来验证地址,一个用户永远不会在新创建这个值的时候显示 emailVerified 为 true。\n\n\n\n\n\n\nfalse : 用户(User)对象最后一次被刷新的时候, 用户并没有确认过他的邮箱地址, 如果你看到 emailVerified 为 false 的话,你可以考虑刷新用户(User)对象。\n\n\n\n\n\n\nmissing : 用户(User)对象已经被创建,但应用设置并没有开启邮件验证功能; 或者用户(User)对象没有 email 邮箱。\n\n\n\n\n\n\n请求验证 Email\n\n\n发送给用户的邮箱验证邮件会在一周内失效,可以通过调用 requestEmailVerify 来强制重新发送,方法原型:\n```cppvoid requestEmailVerify(string email,BmobEmailVerifyDelegate* delegate);\n\n\n如:\n```cpp\nBmobUser * bu = new BmobUser ();\nbu→autorelease();\nbu-\nrequestEmailVerify(\n914143799@qq.com\n,this);\n\n\n\n\n监听验证状态必须实现 BmobEmailVerifyDelegate 接口,接口中回调函数:\n\n\nvirtual void onEmailVerifySucess(const void* data) {\n// \n 请求验证邮件成功,请到 \n + email + \n 邮箱中进行激活。 \n//\n}\nvirtual void onEmailVerifyError(int code,const void* data){\n// 请求验证邮件失败\n}\n\n\n\n\n手机号码验证\n\n\n请求发送短信验证码Bmob 自 V3.3.9 版本开始引入了短信验证系统,可通过 requestSMSCode 方式请求发送短信验证码:\n\n\nBmobUser * bu = new BmobUser ();bu→autorelease();\nbu-\nrequestSMSCode(\n159........\n,\n,this);\n\n\n\n\n监听请求状态,需要实现 BmobRequestSMSCodeDelegate 接口,上面的 this 实现了该接口,接口中的回调函数:\n\n\nvirtual void onRequestDone(int code,const void* data){\n// 返回请求状态\n}\n\n\n\n\n短信默认模板:\n\n\n您的验证码是%smscode%,有效期为%ttl%分钟。您正在使用%appname%的验证码。【比目科技】 注:\n1. 模板名称 :模板名称需要开发者在应用的管理后台进行短信模板的添加工作,具体: 短信服务 -\n 短信模板 ,之后点击创建即可\n2. 只有审核通过之后的自定义短信模板才可以被使用,如果自定义的短信模板其状态显示审核中 或者 审核失败 ,再调用该方法则会以 默认模板 来发送验证码。\n3. 开发者提交短信验证码模板时需注意以下几点:\n1)、模板中不能有【】和 [] ,否则审核不通过;\n2)、如果你提交的短信模板无法发送,则有可能包含一些敏感监控词,具体可去Github 下载 短信关键字监控参考文档 来查看提交内容是否合法。\n3)、一天一个应用给同一手机号发送的短信不能超过 10 条,否则会报 10010 错误,其他错误码可查看 短信功能相关错误码 。\n\n\n邮箱登录\n\n\n新增 邮箱+密码 登录方式,可以通过 loginByAccount 方法来操作,使用方法查看账号名加密码 登陆: \n\n\nvirtual void loginByAccount(account, password, this);\n\n\n\n\n手机号码登录\n\n\n在手机号码被验证后,用户可以使用该手机号码进行登录操作,使用方法查看账号名加密码 登陆。 手机号码登录包括两种方式: 手机号码+密码 、 手机号码+短信验证码 。\n\n\n手机号码+密码\n\n\nBmobUser.loginByAccount( \n11 位手机号码\n, \n用户密码\n, this);\n\n\n\n\n手机号码+短信验证码\n\n\n先请求登录的短信验证码:\n\n\nBmobUser* bu = new BmobUser();\nbu-\nrequestSMSCode( \n11 位手机号码\n,\n模板名称\n,this);\n\n\n\n\n注:请求验证码查看\n\n最后调用 loginBySMSCode 方法进行手机号码登录:\n\n\nBmobUser * bu = new BmobUser ();\nbu-\nautorelease();\nbu-\nloginBySMSCode(\n15920955603\n,\n160469\n,this);\n\n\n\n\n手机号码一键注册或登录\n\n\nBmob 同样支持手机号码一键注册或登录,以下是一键登录的流程:\n1、请求登录操作的短信验证码:\n\n\nBmobSMS.requestSMSCode(context, \n11 位手机号码\n,\n模板名称\n, this);\n\n\n\n\n2、用户收到短信验证码之后,就可以调用 signOrLoginByMobilePhone 方法来实现一键登录,方法原型是:\n\n\nvoid signOrLoginByMobilePhone(string mebileNumber,string code,BmobLoginDelegate* delegate);\n\n\n\n\n如:\n\n\nBmobUser.signOrLoginByMobilePhone(this, \n11 位手机号码\n, \n验证码\n, this);\n\n\n\n\n可以查看验证码获取和手机+验证码登陆。\n\n\n绑定手机号码\n\n\n如果已有用户系统,需要为用户绑定手机号,那么官方推荐的绑定流程如下:\n\n\n第一步、先发送短信验证码并验证验证码的有效性,即调用 requestSMSCode 发送短信验证码,调用 verifySmsCode 来验证有效性。\n\n\n第二步、在验证成功之后更新当前用户的 MobilePhoneNumber 和MobilePhoneNumberVerified 两个字段,具体绑定示例如下:\n\n\n/**\n* bind mobile\n*/\nBmobUser * bu = new BmobUser ();\nbu-\nsetMobilePhoneNumber(\n15920955603\n);\nbu-\nsetMobilePhoneNumberVerified(true);bu→clear();\nbu-\nenParamsToHttp(\nmobilePhoneNumber\n,CCString::createWithFormat(\n%s\n,bu-\n\ngetMobilePhoneNumber().c_str()));\nbu-\nenParamsToHttp(\nmobilePhoneNumberVerified\n,CCBool::create(bu-\n\nCCBool::create(bu-\ngetMobilePhoneNumberVerified()));\nBmobUser * cur = BmobUser ::getCurrentUser();\nbu-\nupdate(cur-\ngetObjectId(),this);\n\n\n\n\n可以查看更新用户部分。\n\n\n云端代码\n\n\nbmobsdk 提供了操作云端代码的功能,包含执行云端代码、删除云端代码、创建云端代码等操作。云端代码,主要是将程序部分逻辑或数据处理定向到云服务器执行.\n操作云端代码,使用Bmob　SDK中的BmobCloud类中的execCloudCode方法：\n\n\nvoid execCloudCode(string cloudName,\n                                    std::map\nstring, CCObject*\n param,\n                                    BmobCloudDelegate 　*delegate,\n                                    BmobHttpUtil::CloudHttpType　type = BmobHttpUtil::CloudHttpType::HttpExec);\n\n\n\n\n参数：\n- cloudName 云端代码方法名\n- param 云端代码参数\n- delegate 云端代码执行回调接口\n- type 方法执行的操作类型，默认是执行云端代码\n\n\n执行云端代码\n\n\n执行云端代码主要是执行在云服务器中编写的执行代码,调用BmobCloud的execCloudCode方法执行.其中需要传递的参数是:云端代码的方法名/对应的参数(采用键值的方式)/回调接口/云端代码的操作类型\n\n\n如有云端代码如下:\n\n\nfunction onRequest(request, response, modules) {\n    response.send(\nwhat is result?\n)\n}\n\n\n\n\nSDK 执行上面的代码如:\n\n\n    BmobCloud* bcloud = new BmobCloud();\n    bcloud-\nautorelease();\n    std::map\nstring, CCObject*\n param;//云端代码的参数\n    bcloud-\nexecCloudCode(\nonRequest\n,param,this,BmobHttpUtil::CloudHttpType::HttpExec);\n\n\n\n\n执行结果：\n\n\n[BmobCloud[ onExecCloud ]] 116-3-18 17:46:40:    {\ndata\n:{\nresults\n:\nwhat is result?\n},\nresult\n:{\ncode\n:200,\nmessage\n:\nok\n}}\n\n\n\n\n注:执行云端代码必须传递参数,如果本身云端代码没有参数,同样需要传递一个空的map参数．", 
            "title": "开发文档"
        }, 
        {
            "location": "/data/cocos2d_x/#_1", 
            "text": "Cocos2d-x SDK是Bmob提供给Cocos2d-x开发者的工具，旨在帮助游戏开发者能够快速灵活使用我们提供的云服务。 注：使用sdk，环境必须支持Ｃ++11标准，同时还必须使用cocos2dx-3.x版本．", 
            "title": "简介"
        }, 
        {
            "location": "/data/cocos2d_x/#sdk", 
            "text": "使用 Cocos2dx 的 SDK ,需要将 SDK 源码以及对应的库文件复制到项目中或设置编源码路径．", 
            "title": "SDK配置"
        }, 
        {
            "location": "/data/cocos2d_x/#_2", 
            "text": "---bmobsdk　　　　　　　　　//ＳＤＫ　根目录\n    --- bmobobject       　　　//sdk基础对象目录\n        ---  bmobSDKinit.h             //sdk初始化对象\n        ---  bmobcloud.h    　　　　　　//云端代码操作对象\n        ---  bmoboject.h    　　　　　　//sdk基础对象\n        ---  bmobquery.h    　　　　　　//sdk查询对象\n        ---  bmobqueryinterface.h    //sdk查询对象接口\n        ---  bmobuser.h              //用户对象\n\n    --- decrypt　　　　//安全相关目录\n        ---  include 　　　　　//sdk安全头文件目录\n\n    --- delegate　　　　　　　//delegate目录\n        ---  bmobdelegate.h        //sdk　回调接口定义\n    --- demo\n    --- jsoncpp　　　　　　　//json库\n    --- libs　　　　　　　　　//sdk需要的库\n        ---  android       　　　　//android平台下sdk需要的库文件目录\n        ---  linux         　　　　//linux平台下sdk需要的库文件目录\n        ---  windows       　　　　//windows平台下sdk需要的库文件目录\n    --- util　　　　　　　　　//sdk使用的一些工具\n        ---  bmobhttputil.h       //sdk关于http请求的url和tag定义\n        ---  bmobjsonutil.h       //sdk对json的操作，主要是转换\n        ---  bmobblog.h           // sdk日志输出工具（仅实现了控制台输出）\n        ---  bmobsdkutil.h        //sdk工具类，主要是进行数据的转换以及获取时间\n        ---  bmobstrutil.h        //字符串操作类（目前没有实现） \n\n   ---  bmobsdk.cpp\n   ---  bmobsdk.h　              //sdk的使用必须包含的头文件  如图：", 
            "title": "源码结构"
        }, 
        {
            "location": "/data/cocos2d_x/#linux", 
            "text": "linux下编译方法多种，这里根据Cocos2d-x 3.x提供的方法使用cmake进行编译．同时需要将libbmobsafe.so拷到项目中，编译项目进行链接．   将sdk源码（包含了开发的源码以及对应的库）拷贝到项目对应的目录下；     在CMakeLists.txt中设置编译源码；如图：     添加．so文件路径到CMakeLists.txt文件中      将对应的库在CMakeLists.txt进行连接；如图：     ＳＤＫ使用：   在需要使用的文件中加入上图中的代码．\n编译成功运行输出结果如：", 
            "title": "linux平台下源码编译"
        }, 
        {
            "location": "/data/cocos2d_x/#android", 
            "text": "将sdk源码拖到项目中．编写Android.mk. 在使用SDK时，需要添加两个库：［libbmobsafe.a libstlport_static.a］，在Android.mk中通过LOCAL_LDLIBS变量链接这两个库，如将库放在$(LOCAL_PATH)/../obj/目录下，链接方式就是：  LOCAL_LDLIBS += $(LOCAL_PATH)/../obj/libbmobsafe.a \\\n                $(LOCAL_PATH)/../obj/libstlport_static.a  在Application.mk中添加APP_STL,设置为stlport_static\n库在sdk源码libs目录下 编译源码中连接库的mk片段：  Application.mk  APP_ABI := armeabi armeabi-v7a\nAPP_STL := stlport_static\nAPP_CPPFLAGS += -fexceptions  Android.mk  LOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := crypttest\nLOCAL_CPPFLAGS := -fPIC -Wall -Wextra -DAPP_CFG_ANDROID -DLINUX -finline-functions -O3 -fno-strict-aliasing -fvisibility=hidden -static-libstdc++  -frtti -fexceptions\nLOCAL_C_INCLUDES := $(LOCAL_PATH)/../include\n\nLOCAL_LDLIBS += $(LOCAL_PATH)/../obj/libbmobsafe.a \\\n                $(LOCAL_PATH)/../obj/libstlport_static.a\n\nLOCAL_SRC_FILES :=     \\    #源码文件\n                     ...\n\n...  按照上面的编译完成以后，就可以在android中使用sdk了． 注：使用ＳＤＫ，必须包含上面的库，否则会提示无法找到XXX符号．", 
            "title": "android平台下源码编译"
        }, 
        {
            "location": "/data/cocos2d_x/#windows", 
            "text": "windows平台以visual studio2015为环境配置。\n1. 将需要的库文件（bmobsafelib.dll）添加到项目依赖库的目录中。 如cocos2dx-3.x提供的源码中，将需要的库复制到\\cocos2d-x-3.9\\build\\Debug.win32\\cpp-empty-test目录下。    在程序开始的地方使用#pragma comment( lib,\"bmobsafelib.lib\")将库链接到项目中。      将源码添加到项目中,即可完成sdk的导入。 在项目中使用SDK的文件中包含文件bmobsdk\\bmobsdk.h，如：#include \"bmobsdk\\bmobsdk.h\"，同时导入命名空间bmobsdk，如：using namespace bmobsdk;完成上的工作就可以使用sdk服务。     导入cocos2dx-3.x的cpp-empty-test项目后的结构：    至此SDK 配置完成。 注：如上面的添加以后，可能还会出现如图：   这样的错误，解决方法是添加现有项，如：    这样就完成windows SDK的配置。", 
            "title": "windows平台下源码编译"
        }, 
        {
            "location": "/data/cocos2d_x/#sdk_1", 
            "text": "使用 BmobSDK 之前,需要先初始化 SDK 环境,初始化使用BmobSDKInit的initialize方法，方法原型是：  /**\n  * 使用appID和appKey初始化环境\n  * @param app_id string\n  * @return\n  */\n  void initialize(string app_id,BmobInitDelegate* delegate);  参数说明：       app_id             应用Application ID\n     delegate            初始化回调接口  调用:  /**\n  * test object\n  */\n  BmobSDKInit::getInstance()- initialize( appID ,this);  \n回调接口：      class BmobInitDelegate{ public: /**\n    * 初始化SDK成功回调\n    * @param data const void* 返回的数据\n    * @return void\n    */\n    virtual void onInitSuccess(const void* data) = 0;\n    /**\n    * 初始化SDK失败回调\n    * @param code const int 失败的代码\n    * @param msg const void* 失败的返回数据\n    * @return void\n    */\n    virtual void onInitFail(const int code,const void* data) = 0;\n    };  注：BmobSDKInit是一个单例对象，代表了整个SDK环境．   \n有上面的输出说明初始化成功。", 
            "title": "SDK初始化"
        }, 
        {
            "location": "/data/cocos2d_x/#_3", 
            "text": "在 Bmob 平台注册后,每个账户可创建多个应用程序,创建的每个应用程序有各自的Application ID ,应用程序将凭 Application ID 使用 BmobSDK 。", 
            "title": "应用程序"
        }, 
        {
            "location": "/data/cocos2d_x/#_4", 
            "text": "请大家在使用 Bmob 开发应用程序之前,仔细阅读“数据与安全”的文档: http://docs.bmob.cn/datasafety/index.html?menukey=otherdoc key=datasafety", 
            "title": "应用安全"
        }, 
        {
            "location": "/data/cocos2d_x/#_5", 
            "text": "目前为止,我们支持的数据类型CCString 、 CCInteger 、 CCBool 、 CCArray 、 CCDictionary 、 map 、string 以及 BmobObject 对象类型。", 
            "title": "数据类型"
        }, 
        {
            "location": "/data/cocos2d_x/#_6", 
            "text": "一个数据对象( BmobObject 类和子类,其中 BmobObject 继承 Cocos2dx 中的CCObject 类)对应于 Bmob 后台的一个数据表。", 
            "title": "对象"
        }, 
        {
            "location": "/data/cocos2d_x/#_7", 
            "text": "SDK存储数据建立在 BmobObject 基础上,任何要保存的数据对象必须继承BmobObject 类。 BmobObject 类本身包含 objectId 、 createdAt 、 updatedAt 、 ACL四个默认的属性, objectId 是数据的唯一标识,类似于表的主键, createdAt 是数据创建时间, updatedAt 是数据最后修改时间, ACL 是数据操作权限。\n如游戏中使用 GameScore 表来记录玩家信息,其中表的字段有: score (分数)、playerName (玩家名字)、 info (玩家头像)属性,这个数据对象定义如:  //必须要继承自 BmobObject 类\nclass\nGameScore :public BmobObject {\npublic:\n    GameScore (stringtableName);\n    ~ GameScore ();\nprivate:\n    CC_SYNTHESIZE(std::string, m_playerName, PlayerName);\n    CC_SYNTHESIZE(int,m_score,Score);\n    CC_SYNTHESIZE(std::string,m_info,Info);\n};  注:对于开发发者来说,不需要对 objectId 、 createdAt 、 updatedAt 、 ACL 四个属性进行定义,已经在 BmobObject 类中默认定义了。", 
            "title": "数据对象"
        }, 
        {
            "location": "/data/cocos2d_x/#_8", 
            "text": "SDK 官方推荐类名和表名完全一致的映射使用方式,.如上面的  GameScore  类,在使用 SDK 的接口保存数据的时候,传递对应的类名,在后台创建的表名就和传递名一样。  如果不想创建和类名一样的表名,传递其他的名字即可。", 
            "title": "类名和表名的关系"
        }, 
        {
            "location": "/data/cocos2d_x/#_9", 
            "text": "添加数据使用 BmobObject 类提供的 save 方法,并传递监听接口指针.将对象的内容保存到数据库。 方法原型:  virtual void save( BmobSaveDelegate * delegate);  如,将玩家为Habrrier 的信息保存到 GameScore 数据表中,SDK使用如下:      GameScore *game = new GameScore ( GameScore );\n    game- autorelease();\n    game- setName( Habrrier );\n    game- setScore(670);\n    game- setInfo( My name is Habrrier );\n    game- clear();\n    game- enParamsToHttp( playerName ,CCString::createWithFormat( %s ,game- game- getName().c_str()));\n    game- enParamsToHttp( score ,CCInteger::create(game- getScore()));\n    game- enParamsToHttp( info ,CCString::createWithFormat( %s ,game- getInfo().c_str()));\n    game- save(this);  上面调用 enParamsToHttp 方法是将上面的属性转换成 key-value 放入 http 请求中,只有调用该方法,才能使用 save 保存数据到后台。同时 this 代表的类中实现 BmobSaveDelegate 接口,监听保存数据的返回状态,回调方法是:        void onSaveSucess(const void* data){\n      // 数据添加成功\n      }\n      void onSaveError(int code,const void* data){\n      // 数据添加失败\n      }  如果对返回状态不关心可以传递 NULL 作为 save 的参数。实现 BmobSaveDelegate 接口如下:        class HelloWorld :public BmobSaveDelegate {\n      ...\n      public:\n          virtual void onSaveSucess(const void* data){//To DO}\n          virtual void onSaveError(int code,const void* data){//To Do}\n      ....\n      };  运行以上代码,如果添加成功,你可以在 Bmob 提供的后台的数据浏览中看到类似这样的结果:  { data :{ createdAt : 2016-03-10 14:43:16 , objectId : 992be5638a }, result :{ code :200, message : ok }}   这是登录后台，就可以看到：   这里需要注意的是: \n1. 如果服务器端不存在 GameScore 表,系统将自动建表该表,并插入数据。\n2. 如果服务器端已经存在 GameScore 表,那就会将该条数据保存到对应的表中。\n3. 每个 BmobObject 对象都有几个默认的键 ( 数据列 ) 是不需要开发者指定的,objectId 是每个保存成功数据的唯一标识符。createdAt 和 updatedAt 代表每个对象 ( 每条数据 ) 在服务器上创建和最后修改的时间。这些键 ( 数据列 ) 的创建和数据内容是由服务器端自主生成。\n4. 因此,使用 save 方法时 , 不需要调用 setObjectId 方 法,否则会出现提示:“ It is a reserved field: objectId(105)”-- 表明objectId 为系统保留字段,不允许修改 。", 
            "title": "添加数据"
        }, 
        {
            "location": "/data/cocos2d_x/#_10", 
            "text": "修改数据主要是调用 SDK 重的 update 方法,将对象的 objectId 和实现的监听接口传递给该方法,以指明要更新的数据。方法原型:  virtual void update(string objectId,BmobUpdateDelegate* delegate);  参数：  objectId 　　　更新对象id\ndelegate 更新回调接口  例如:将 GameScore 表中 objectId 为 2e0f067922 的游戏分数修改为 1000.  GameScore *game = new GameScore ( GameScore );\ngame- autorelease();\ngame- setScore(1000);\ngame- clear();\ngame- enParamsToHttp( score ,CCInteger::create(game- getScore()));\ngame- update( 2e0f067922 ,this);  其中 this 必须实现 BmobUpdateDelegate 接口,以监听更新状态。  void onUpdateSucess(void* data){\n// 数据更新成功\n}\nvoid onUpdateError(int code,void* data){\n// 数据更新失败\n}  同样的和保存数据一样,使用 set 方法来更新数据也需要调用 enParamsToHttp 将数据放入 http 中。SDK 提供了另一种方法来更新数据,通过调用 Bmobobject 类中的setValue ( key , value )方法,只需要传入 key 和要更新的值,如:      GameScore *game = new\n    game- autorelease();\n    GameScore ( abcdef );\n    game- clear();\n    game- setValue( score ,CCFloat::create(1000));\n    game- update( 2e0f067922 ,this);  返回结果：  { data :{ updatedAt : 2016-03-10 14:49:05 }, result :{ code :200, message : ok }}   更新数据时,如果对更新状态需要监听,需实现 BmobUpdateDelegate 接口,并传递给update 方法。接口 BmobUpdateDelegate 实现如下:  class HelloWorld :public BmobUpdateDelegate {\n...\npublic:\n    virtual void onUpdateSucess(const void* data){//To Do}\n    virtual void onUpdateError(int code const void* data){//To Do}\n..\n};", 
            "title": "修改数据"
        }, 
        {
            "location": "/data/cocos2d_x/#_11", 
            "text": "从服务器删除对象使用 BmobObject 对象的 del 方法，并传递监听接口参数,方法原型:  virtual void del( BmobDeleteDelegate * delegate);  例如:将 GameScore 表中 objectId 为 0875c8a278 的数据删除。      GameScore *\n    game = new GameScore ( abcdef );\n    game- autorelease();\n    game- setObjectId( 0875c8a278 );\n    game- del(this);  返回结果:  { data :{ msg : ok }, result :{ code :200, message : ok }}  在这里 this 类必须实现 BmobDeleteDelegate 接口,以便监听状态,如果传递 NULL ,说明删除状态不监听。其监听回调方法是:  void onDeleteSucess(void* data){\n// 删除数据成功\n}\nvoid onDeleteErrpr(int code,void* data){\n// 删除数据失败\n}\n接口 BmobDeletedelegate 实现如下:\nclass  HelloWorld :public BmobDeleteDelegate {..\npublic:\n    virtual void onDeleteSucess(const void* data){//To Do}\n    virtual void onDeleteError(int code,const void* data){//To Do}\n..\n};  删除数据除了使用上面调用 setObjectId 来设置 objectId 更新以外,还可以调用 del 的一个重载方法:  virtual void del(string objectId,BmobDeleteDelegate* delegate);  来更新,直接通过传递 objectId 实现更新。如:  GameScore * game = new GameScore ( GameScore );\ngame- autorelease();\ngame- del( 0875c8a278 ,this);  返回结果：  { data :{ msg : ok }, result :{ code :200, message : ok }}  注意:删除数据只能通过 objectId 来删除,目前不提供查询条件方式的删除方法。", 
            "title": "删除数据"
        }, 
        {
            "location": "/data/cocos2d_x/#_12", 
            "text": "数据的查询可能是每个应用都会频繁使用, BmobSDK 中提供了 BmobQuery 类,提供了多种方法实现不同条件的查询。 注: 在做新的查询之前一定要调用 BmobQuery 的 clear 方法,否则结果不可预知。", 
            "title": "查询数据"
        }, 
        {
            "location": "/data/cocos2d_x/#_13", 
            "text": "查询某个数据表中的所有数据使用 BmobQuery 提供的 findObjects 方法,参数是监听接口。方法原型:  virtual void findObjects(BmobFindDelegate* delegate);  例如:查询 GameScore 表中的所有数据:  BmobQuery *query = new BmobQuery ( GameScore );\nquery- autorelease();\nquery- findObjects(this);  注:如果需要监听查找状态以及查询结果,必须实现 BmobFindDelegate 接口,上面的 this 必须实现该接口。接口中的回调方法方法:  virtual void onFindSucess(const void* data) {\n// 查询数据成功回调, data 是查询返回的数据\n}\nvirtual void onFindError(int code,const void* data) {\n// 查询数据失败回调, data 是失败信息\n}  接口实现  class HelloWorld:public BmobFindDelegate{\n...\npublic:\n    virtual void onFindSucess(const void* data){//To Do}\n    virtual void onFindError(int code,const void* data){//To Do}\n.....\n};  同样的也可以使用 findObjects 的一个变体,通过直接指定表明查询,方法原型是:  virtual void findObjects(string tableName,BmobFindDelegate* delegate) = 0;  如果对查询结果和状态不关系的,可以传递 NULL 参数。 同时也可以通过设置 where 条件来查询满足条件的所有数据。 如可以使用 BmobQuery 中的 findObjects 方法查询 GameScore 表中 playerName 爲 xiaoming 的所有数据:  BmobQuery *query = new BmobQuery ( GameScore );\nquery- autorelease();\nstring name =  xiaoming ;\nquery- clear();\nquery- addWhereEqualTo( playerName ,CCString::createWithFormat( %s ,name.c_str()));\nquery- findObjects(this);  返回结果：  { data :{ age :23, createdAt : 2016-03-10 14:43:16 , info :  playerInfo , objectId : 992be5638a , playerAddress : Guangzhou , playerName : shockerjue , score1 :9000, updatedAt : 2016-03-10 14:54:45 }, result :{ code :200, message : ok }}  注:在不需要 where 查询或者是查询全部数据之前,先调用 clear 清除之前设置过的where 条件,或者是当重新设置 where 条件,那之前必须先调用 clear 函数以清除之前的where 条件。", 
            "title": "查询所有数据"
        }, 
        {
            "location": "/data/cocos2d_x/#_14", 
            "text": "同样的可以根据 objectId 直接获取单条数据对象,查询调用 BmobQuery 提供的getObject 方法并传递 objectId 以及回调接口查询。方法原型:  virtual void getObject(string objectId,BmobGetDelegate* delegate);  例如:在 GameScore 表中查询 objectId 为 c660c4166d 的人员信息。  BmobQuery *query = new BmobQuery ( GameScore );\nquery- autorelease();\nquery- getObject( c660c4166d ,this);  返回结果：  { data :{ age :23, createdAt : 2016-03-10 14:43:16 , info :  playerInfo , objectId : 992be5638a ,  playerAddress : example , playerName : example , score1 :9000, updatedAt : 2016-03-10 14:54:45 }, result :{ code :200, message : ok }}  注:如果需要监听查询的状态以及查询结果,必须实现 BmobGetDelegate 接口,上面的 this 实现了该接口。接口中的回调方法:  virtual void onGetSucess(const void* data) {\n// 查询单条数据成功, data 存储了查询的结果\n}\nvirtual void onGetError(int code,const void* data) {\n// 查询单条数据失败, code 返回状态码, data 存储失败信息\n}  接口 BmobGetDelegate 的实现如下:  class HelloWorld :public BmobGetDelegate {\n...\npublic:\n    virtual void onGetSucess(const void* data){//To Do}\n    virtual void onGetError(int code,const void* data){//To Do }\n.....\n};", 
            "title": "查询单条数据"
        }, 
        {
            "location": "/data/cocos2d_x/#_15", 
            "text": "查询数据可以使用 BmobQuery 提供的 setLimit 和 setSkip 方法来做一些限制。限制结果查询返回数量,使用 setLimit 方法;限制结果跳转的页数,使用 setSkip 方法。方法原型是:  virtual void setLimit(int limit);\nvirtual void setSkip(int skip);  如限制跳转到结果的第 10 页,并且仅查询 20 条数据的使用方法是:  BmobQuery *query = new query- autorelease();\nBmobQuery ( GameScore );\nquery- setLimit(20);\nquery- setSkip(10);\nquery- findObjects(this);  需要监听查询状态和结果,需要实现 BmobFindDelegate 接口,上面的 this 实现了该接口。 注:如果 setSkip 设置的值超过了结果的页数,那返回将没有结果数据。", 
            "title": "限制查询"
        }, 
        {
            "location": "/data/cocos2d_x/#_16", 
            "text": "查询过程中,基于不同条件查询,可以使用 BmobQuery 提供的条件查询。", 
            "title": "条件查询"
        }, 
        {
            "location": "/data/cocos2d_x/#_17", 
            "text": "要查询特定键的值,可以使用 BmobQuery 提供的 addWhereEqualTo 方法指定条件。如要过滤掉特定键的值可以使用 addWhereNotEqualTo 方法指定条件,之后调用findObjects 方法触发查询。方法原型是:  virtual void addWhereEqualTo(string seg,CCObject *object);\nvirtual void addWhereNotEqualTo(string seg,CCObject *object);  比如需要查询 name 等于“ Barbie” 的数据时可以这样写:  query- addWhereEqualTo( name ,  Barbie );\nquery- findObjects(this);  同样可以在查询操作中添加多个约束条件,来查询符合的数据。 如查询 GameScore 表中 playerName 不等于 Bridder ,且 score 等于 10989 的数据:  BmobQuery *query = new BmobQuery ( GameScore );\nquery- autorelease();\nstring name =  Bridder ;\nquery- clear();\nquery- addWhereEqualTo( score ,CCFloat::create(10989));\nquery- addWhereNotEqualTo( playerName ,CCString::createWithFormat( %s ,\nname.c_str()));\nquery- findObjects(this);  以下还包含了各种不同条件的比较查询:", 
            "title": "比较查询"
        }, 
        {
            "location": "/data/cocos2d_x/#_18", 
            "text": "virtual void addWhereLessThan(string seg,CCObject* object) ;\n// 添加玩家分数小于 2345 的条件 //\nquery- addWhereLessThan( score ,CCInteger::create(2345));", 
            "title": "小于条件"
        }, 
        {
            "location": "/data/cocos2d_x/#_19", 
            "text": "virtual void addWhereLessThanOrEqualTo(string seg,CCObject* object);\n// 添加玩家分数小于等于 2345 的条件 //\nquery- addWhereLessThanOrEqualTo( score ,CCInteger::create(2345));", 
            "title": "小于等于条件"
        }, 
        {
            "location": "/data/cocos2d_x/#_20", 
            "text": "virtual void addWhereGreaterThan(string seg,CCObject* object);\n// 添加玩家分数大于 2334 的条件 //\nquery- addWhereGreaterThan( score ,CCInteger::create(2334));", 
            "title": "大于条件"
        }, 
        {
            "location": "/data/cocos2d_x/#_21", 
            "text": "virtual void addWhereGreaterThanOrEqualTo(string seg,CCObject*object) ;\n// 添加玩家分数大于等于 2345 的条件\nquery- addWhereGreaterThanOrEqualTo( score ,CCInteger::create(2345));  注:不能添加具有矛盾的查询条件,否则将得不到想要的结果!", 
            "title": "大于等于"
        }, 
        {
            "location": "/data/cocos2d_x/#_22", 
            "text": "如果需要查询匹配几个不同值的数据,可以使用 BmobQuery 提供的addWhereContainedIn 方法,方法原型:  virtual void addWhereContainedIn(string seg,CCObject* array) ;  如:要查询 GameScore 表中 playerName 为“ Barbie”,“Joe”,“Julia” 三个人的成绩:          string[] names = { Barbie ,  Joe ,  Julia };\n        CCArray* array = CCArray::create();\n        array- addObject(CCString::createWithFormat( %s ,name[0].c_str()));\n        array- addObject(CCString::createWithFormat( %s ,name[1].c_str()));\n        array- addObject(CCString::createWithFormat( %s ,name[2].c_str()));\n        query- addWhereContainedIn( playerName , array);  相反,如果想查询排除“ Barbie”,“Joe”,“Julia” 这三个人的其他同学的信息,你可以使用 addWhereNotContainedIn 方法来实现。方法原型是:  virtual void addWhereNotContainedIn(string seg,CCObject* array) ;\n\nquery- addWhereNotContainedIn( playerName , array);  之后调用 findObjects 方法查询 :  query- findObjects(this);", 
            "title": "子查询"
        }, 
        {
            "location": "/data/cocos2d_x/#_23", 
            "text": "对应数据的排序,如数字或字符串,可以使用升序或降序的方式来控制查询数据的结果顺序,需要进行排序查询,可以使用 BmobQuery 提供的 order 方法,其方法原型:  virtual void order(string key);  如对 GameScore 重的 score 段进行升序或降序查询:  query- order( score );// 升序 //\nquery- order( -score );// 降序 //\nquery- order( -score,PlayerName );// 对多个字段进行排序查询 //  说明:多个字段排序时,先按第一个字段进行排序,再按第二个字段进行排序,依次进行。", 
            "title": "排序"
        }, 
        {
            "location": "/data/cocos2d_x/#_24", 
            "text": "对于字段类型为数组的情况,需要查找字段中的数组值包含有 xxx 的对象,可以使用 addWhereContainsAll 方法,方法原型是:    virtual void addWhereContainsAll(string seg,CCArray* array) ;  如查询有 Read 、 Write 、 Coffee 的人:    CCArray* array1 = CCArray::create();\n  string name1[] = { Read , Write , Coffee };\n  array- addObject(CCString::createWithFormat( %s ,name1[0].c_str()));\n  array- addObject(CCString::createWithFormat( %s ,name1[1].c_str()));\n  array- addObject(CCString::createWithFormat( %s ,name1[2].c_str()));\n  query- addWhereContainsAll( hobby , array);\n  query- findObjects(this);", 
            "title": "数组查询"
        }, 
        {
            "location": "/data/cocos2d_x/#_25", 
            "text": "如果想查询某个列是否存在,可以使用 addWhereExists 方法,方法原型是:  virtual void addWhereExists(string column);\n// 查询 username 有值的数据\nquery- addWhereExists( username );  如果想查询某个列值不存在,则可以用 addWhereDoesNotExists 方法,方法原型是:  virtual void addWhereDoesNotExists(string column);\n    // 查询 username 字段没有值的数据 br \n    query- addWhereDoesNotExists( username );\n    query- findObjects(this);", 
            "title": "列值是否存在"
        }, 
        {
            "location": "/data/cocos2d_x/#_26", 
            "text": "可以限定查询返回的字段,通过 BmobQuery 的 addQueryKey 方法添加 where 条件。方法原型是:  virtual void addQueryKeys(string column) ;  通过传入 keys 参数,值为用一个逗号分隔的字段名称列表,为了获取对象只包含 score 和playerName 字段 ( 还有特殊的内置字段比如 objectId,createdAt 和 updatedAt) ,请求如下:  query- addQueryKeys(”score,playerName“);  之后调用 findObjects 或者是 getObject 来查询。", 
            "title": "查询指定的列"
        }, 
        {
            "location": "/data/cocos2d_x/#_27", 
            "text": "统计满足查询条件的对象数量,且不需要获取所有匹配对象的具体数据信息,可直接使用count 替代 findObjects 。 例如,查询 playerName 为 Barrier 玩家玩的游戏场数:  BmobQuery *query = new BmobQuery ( GameScore );\nquery- autorelease();\nstring name =  Barrier ;\nquery- addWhereEqualTo( playerName ,CCString::createWithFormat( %s ,\nname.c_str()));\nquery- count(this)  如果需要获得返回的数据加数量,可以使用 BmobQuery 的 count 重载方法, count(BmobCountDelegate* delegate,bool sign)并传递一个 bool 值, false 是 不返回数据(和直接调用 count 一样的结果), true 返回数据。如:  BmobQuery *query = new BmobQuery ( GameScore );\nquery- autorelease();\nstring name =  lingo ;\nquery- addWhereEqualTo( playerName ,CCString::createWithFormat( %s ,\nname.c_str()));\nquery- count(this,true);  要获得查询的结果,需要实现 BmobCountDelegate 接口,并实现其中的回调方法:  virtual void onCountSucess(const void* data){\n// 返回查询数据\n// 数据格式: { count :3, results :[]}\n}\nvirtual void onCountError(int code,const void* data){\n// 返回失败信息与数据\n}", 
            "title": "查询个数"
        }, 
        {
            "location": "/data/cocos2d_x/#bql", 
            "text": "BQL查询 SDK提供类 SQL 语法的 BQL 查询语言来查询数据，其基本语法和sql类似，如：  bql : select * from GameScore where name=? and score ? limit ?,? , values :[ test , 90 ,10, 100],  其中的values是用来填充bql中的值，也就是问号的地方．Cocos2dx　SDK中的BQL查询使用BmobQuery类中的BSQLFindObjects方法，原型是：  /**\n  * 执行sdk定义的sql查询\n  * @param bql 查询语句\n  * @param values sql语句对应的值\n  * @param delegate 回调接口\n  * @return\n  */\nvoid BmobQuery::BSQLFindObjects(string bql,CCObject* values,BmobBQLDelegate* delegate)  查询表MyGameData中的所有数据，values传递空值：    BmobQuery* query = new BmobQuery( MyGameData );\n  query- autorelease();\n  query- BSQLFindObjects( select * from MyGameData ,nullptr,this);  返回数据：  {\n     data :{\n             c : MyGameData ,\n              results :[]\n       },\n        result :{\n                code :200,\n                message : ok \n               }\n}", 
            "title": "BQL查询"
        }, 
        {
            "location": "/data/cocos2d_x/#_28", 
            "text": "ＳＤＫ提供查询数据表的结构．查询使用SDK的BmobQuery对象中的findTableStruct方法，原型是：  /**\n  * 查询表的结构\n  * @param tableName 表名\n  * @param delegate 查询回调接口\n  */\n  virtual void findTableStruct(string tableName,BmobFindDelegate* delegate) = 0;  如果tableName为空，则获取的是所有的数据表结构．\n如查询表Gamescore的结构：  BmobQuery* query = new BmobQuery( MyGameData );\nquery- autorelease();\nquery- findTableStruct( ,this);  返回：  { data :{ className : GameScore , fields :{ ACL :{ type : Object }, createdAt :{ type : Date }, info :{ type : String }, objectId :{ type : String }, playerName :{ type : String }, score :{ type : Number }, updatedAt :{ type : Date }}}, result :{ code :200, message : ok }}  查询所有表结构：  BmobQuery* query = new BmobQuery( MyGameData );\nquery- autorelease();\nquery- findTableStruct( ,this);  返回：  { data :{ results :[]}, result :{ code :200, message : ok }}", 
            "title": "查询表结构"
        }, 
        {
            "location": "/data/cocos2d_x/#_29", 
            "text": "对于数组类型数据, BmobSDK 提供了 3 种操作来原子性地修改一个数组字段:\nadd 在一个数组字段的后面添加一些指定的对象 ( 包装在一个数组内 )\nsetValue 在一个数组字段里面修改其中的值\nremoveAll 从一个数组字段的值内移除指定的数组中的所有对象", 
            "title": "数组"
        }, 
        {
            "location": "/data/cocos2d_x/#_30", 
            "text": "可以使用 BmobObject 中的 add 方法实现数组的添加,函数原型:  /**\n只添加一个数据\n*\n*/\nvirtual void add(string column,CCObject* object);\n/**\n* 同时添加多个数据\n*/\nvirtual void add(string column,CCArray* array);  之后调用 BmobObject 提供的 save 方法来添加到服务,如在 GameScore 表中添加一个数 组名为 list 的数组,其中只有一个数据:  GameScore *game = new GameScore ( GameScore );\ngame- autorelease();\ngame- add(“list”,CCInteger::create(234));\ngame- save(this);  如果要一次添加含多个数据的数组到表中,同样的调用 add 方法,只是需要传递包含多个 元素的数组:  GameScore *game = new GameScore ( GameScore );\ngame- autorelease();\nCCArray* array = CCArray::create();\narray- addObject(CCInteger::create(120));\narray- addObject(CCInteger::create(234));\ngame- add(“list”,array);\ngame- save(this);", 
            "title": "添加数组数据"
        }, 
        {
            "location": "/data/cocos2d_x/#_31", 
            "text": "更新数组使用 BmobObject 提供的 setValue 方法来设置需要更新的数组元素,其方法原型是:  void setValue(string key,cocos2d::CCArray* array);  更新需要传递一个数组作为参数,如需要更新 GameScore 表中 objectId为” 5ec74b2297“list 数组的数据:  GameScore *game = new GameScore ( GameScore );\ngame- autorelease();\nCCArray* array = CCArray::create();\narray- addObject(CCInteger::create(123));\narray- addObject(CCInteger::create(234));\ngame- setValue( list ,array);\ngame- update(“5ec74b2297”,this);", 
            "title": "更新数组"
        }, 
        {
            "location": "/data/cocos2d_x/#_32", 
            "text": "对于字段类型为数组的情况,可以查找字段中的数组值包含有 xxx 的对象,查询使用BmobQuery 提供的 addWhereContainsAll 方法来查询,方法原型是:  void BmobQuery::addWhereContainsAll(string seg,CCArray* array);  如查询 GameScore 表中含有 hobby 数组字段且包含阅读、唱歌的数据:  BmobQuery *query = new BmobQuery ( GameScore );\nquery- autorelease();\nCCArray* array = CCArray::create();\nstring name1[] = {  阅读  ,  唱歌  };\narray- addObject(CCString::createWithFormat( %s ,name1[0].c_str()));\narray- addObject(CCString::createWithFormat( %s ,name1[1].c_str())) ;\nquery- addWhereContainsAll( name ,array);\nquery- findObjects(this);", 
            "title": "查询数组"
        }, 
        {
            "location": "/data/cocos2d_x/#_33", 
            "text": "删除数组使用 BmobObject 提供的 removeAll 来设置要删除的数组字段,其函数原型是:  virtual void removeAll(string name,CCArray* array);  如:删除 GameScore 数据表中 objectId 为“ 5ec74b2297” 的 含有 list 数组,且其中含有 123 和 234 的值:  GameScore* game = new GameScore ( GameScore );\ngame- autorelease();\ngame- setObjectId(“”);\nCCArray* array = CCArray::create();\narray- addObject(CCInteger::create(123));\narray- addObject(CCInteger::create(234));\ngame- removeAll( list ,array);\ngame- update(this);", 
            "title": "删除数组数据"
        }, 
        {
            "location": "/data/cocos2d_x/#_34", 
            "text": "Bmob 的统计查询,提供以下关键字或其组合的查询操作: Key Operation groupby 分组操作 groupcount 返回每个分组的总记录 sum 计算总和 average 计算平均值 max 计算最大值 min 计算最小值 having 分组中的过滤条件\n为避免和用户创建的列名称冲突, Bmob 约定以上统计关键字( sum, max, min) 的查询结果值都用 '_( 关键字 )+ 首字母大写的列名 ' 的格式,如计算玩家得分列名称为 score 总和的操作,则返回的结果集会有一个列名为 _sumScore 。 average 返回的列为 '_avg+ 首字 母大写的列名 ' ,有 groupcount 的情形下则返回 _count 。\n以上关键字除了 groupcount 是传 Boolean 值 true 或 false , having 传的是和 where类似的 json 字符串,但 having 只应该用于过滤分组查询得到的结果集,即 having 只应该包含结果集中的列名如 {\"_sumScore\":{\"$gt\":100}} ,其他关键字必须是字符串而必须是表中包含的列名,多个列名 用 , 分隔。\n以上关键字可以自由组合并可以与前面查询语句中的 where, order, limit, skip 等组合使用。\n比 如, GameScore 表是游戏玩家的信息和得分表,有 playerName( 玩家名称 ) 、score( 玩家得分 ) 等你自己创建的列,还有 Bmob 的默认 列 objectId, createdAt,updatedAt, 那么我们现在举例如何使用以上的查询关键字来作这个表的统计。", 
            "title": "统计相关查询"
        }, 
        {
            "location": "/data/cocos2d_x/#_35", 
            "text": "计算数据的总和,使用 BmobQuery 提供的 findStatistics 方法,方法原型:  virtual void findStatistics(BmobStaticsDelegate* delegate);  调用以前先调用 sum 方法将要计算的字段设置好。 如计算 GameScore 表所有玩家的得分总和, sum 后面只能拼接 Number 类型的列名,即要 计算哪个列的值的总和,只对 Number 类型有效,多个 Number 列用 , 分隔,则查询如下:  BmobQuery *query = new BmobQuery ( GameScore );\nquery- autorelease();\nquery- sum( score );\nquery- findStatistics(this);  计算多个列:  BmobQuery* query = new BmobQuery( GameScore );\nquery- autorelease();\nquery- sum( score,index );\nquery- findStatistics(this);  要监听统计结果,需要实现 BmobStaticsDelegate 接口,必须实现其中的方法 :  virtual void onStaticsSucess(const void* data){\n// 计算成功返回回调\n}\nvirtual void onStaticsError(int code,const void* data){\n// 计算失败回调\n}", 
            "title": "计算总和"
        }, 
        {
            "location": "/data/cocos2d_x/#_36", 
            "text": "分组计算总和使用 findStatistics 方法,在使用以前先调用 groupby 方法将要分组的字 段设置好。 如以 GameScore 创建时间按天统计所有玩家的得分,并按时间降序 , groupby 后面只能 拼接列名,如果该列是时间类型,则按天分组,其他类型,则按确定值分组 :  BmobQuery *query = new BmobQuery ( GameScore );\nquery- autorelease();\nquery- sum( score );\nquery- groupby( createdAt );\nquery- findStatistics(this);", 
            "title": "分组计算总和"
        }, 
        {
            "location": "/data/cocos2d_x/#_37", 
            "text": "如以创建时间按天和按玩家名称分组统计所有玩家的得分 1 ,得分 2 的总和,并按得分 1 的 总和降序 , groupby 后面只能拼接列名,如果该列是时间类型,则按天分组,其他类型,则按确定值分组 :  BmobQuery *query = new BmobQuery ( GameScore );\nquery- autorelease();\nquery- sum( score1,score2 );\nquery- groupby( createdAt,playerName );\nquery- order( -score1 );\nquery- findStatistics(this);", 
            "title": "多个分组并计算多个列的总和"
        }, 
        {
            "location": "/data/cocos2d_x/#_38", 
            "text": "可以使用 BmobQuery 提供的 where 系列条件实现条件过滤查询,同时要调用 hanving 函 数传递 true 参数。如过滤 GameScore 中玩家总分小于 1000 的:  BmobQuery *query = new BmobQuery ( GameScore );\nquery- autorelease();\nstring name =  lingo ;\nquery- sum( score );\nquery- groupby( playerName );\nquery- order( -createdAt );\nquery- having(true);\nquery- addWhereLessThan( _sumScore ,CCInteger::create(1000));\nquery- findStatistics(this);", 
            "title": "分组计算总和并只返回满足条件的部分值"
        }, 
        {
            "location": "/data/cocos2d_x/#_39", 
            "text": "要查询分组的数量,调用 BmobQuery 的 setHasGroupCount 方法设置需要计数,方法原 型是:  virtual void setHasGroupCount(bool groupCount) ;  比如以创建时间按天统计所有玩家的得分和每一天有多少条玩家的得分记录,并按时间降序 :  BmobQuery *query = new BmobQuery ( GameScore );\nquery- autorelease();\nquery- sum( score );\nquery- groupby( createedAt );\nquery- order( -createdAt );\nquery- setHasGroupCount(true);\nquery- findStatistics(this);", 
            "title": "分组计算总和并返回每个分组的记录数"
        }, 
        {
            "location": "/data/cocos2d_x/#_40", 
            "text": "获取不重复的列时,调用 BmobQuery 提供的 groupby 方法设置列名。如获取玩家分数不重复:  BmobQuery * query = new BmobQuery ( GameScore );\nquery- autorelease();\nquery- groupby( score );", 
            "title": "获取不重复的列值"
        }, 
        {
            "location": "/data/cocos2d_x/#_41", 
            "text": "average( 计算平均值 ) , max( 计算最大值 ) , min( 计算最小值 ) 和 sum 查询语句是类似的。只需要调用对应的方法设置字段即可。\n查询 GameScore 表中 score 最小:  BmobQuery * query = new BmobQuery ( GameScore );\nquery- autorelease() ;\nquery- min( score );\nquery- findStatistics(this);  查询 GameScore 表中 score 最大:  BmobQuery * query = new BmobQuery ( GameScore );\nquery- autorelease();\nquery- max( score );\nquery- findStatistics(this);  查询 GameScore 表中 score 的平均值:  BmobQuery * query = new BmobQuery ( GameScore );\nquery- autorelease();\nquery- average( score );\nquery- findStatistics(this);", 
            "title": "其他关键字"
        }, 
        {
            "location": "/data/cocos2d_x/#_42", 
            "text": "用户是一个应用程序的核心。对于个人开发者来说,自己的应用程序积累到越多的用户,就会给自己带来越强的创作动力。因此 Bmob 提供了一个专门的用户类——BmobUser 来自动处理用户账户管理所需的功能。 有了这个类,就可以在应用程序中添加用户账户功能。BmobUser 是 BmobObject 的一个子类,它继承了 BmobObject 所有的方法,具有 BmobObject 相同的功能。不同的是, BmobUser 增加了一些特定的关于用户账户管理相关 的功能。", 
            "title": "用户管理"
        }, 
        {
            "location": "/data/cocos2d_x/#_43", 
            "text": "BmobUser 除了从 BmobObject 继承的属性外,还有几个特定的属性:\nusername: 用户的用户名  (必需)  。\npassword: 用户的密码  (必需)  。\nemail: 用户的电子邮件地址  (可选)  。\nemailVerified:邮箱认证状态  (可选)  。\nmobilePhoneNumber:手机号码  (可选)  。\nmobilePhoneNumberVerified:手机号码的认证状态  (可选)  。", 
            "title": "属性"
        }, 
        {
            "location": "/data/cocos2d_x/#_44", 
            "text": "很多时候,你的用户表还会有很多其他字段,如性别、年龄、头像等。那么,你需要对BmobUser 类进行扩展,添加一些新的属性。示例代码如下所示:  class MyUser:public BmobUser {\npublic:\n    MyUser();\n    virtual MyUser();\nprivate:\n    CC_SYNTHESIZE(string,m_sex,SEX);\n    CC_SYNTHESIZE(int,m_age,Age);\n    CC_SYNTHESIZE(string,m_nick,Nick);\n};  更多代码实现大家可以下载 SDK,在里面的 BmobExample 中查找 MyUser 类,参考它的用法。", 
            "title": "扩展用户类"
        }, 
        {
            "location": "/data/cocos2d_x/#_45", 
            "text": "创建用户对象如下:  BmobUser* user = BmobUser::createUser();\nuser- autorelease();", 
            "title": "创建用户对象"
        }, 
        {
            "location": "/data/cocos2d_x/#_46", 
            "text": "应用程序可能会要求用户注册。下面的代码是一个典型的注册过程:  BmobUser* bu = new BmobUser();\nbu→autorelease();\nbu- setUsername( sendi );\nbu- setPassword( 123456 );\nbu- setEmail( sendi@163.com );\n//注意:不能用 save 方法进行注册\nbu- enParamsToHttp(“username”,CCString::createWithFormat(“%s”,bu- getUserName().c_str()));\nbu- enParamsToHttp(“password”,CCString::createWithFormat(“%s”,bu→getPasswoed().c_str()));\nbu- enParamsToHttp(“email”,CCString::createWithFormat(“%s”,bu→getEmail().c_str()));\nbu- signUp(this);  注:注册时必须实现 BmobSaveDelegate 接口,以监听注册结果以及状态,接口中的方法:  virtual void onSaveSucess(const void* data) {\n// 注册成功的回调函数\n}\nvirtual void onSaveError(int code,const void* data) {\n// 注册失败的回调函数\n}  在注册过程中,服务器会对注册用户信息进行检查,以确保注册的用户名和电子邮件地址是独一无二的。此外,对于用户的密码,你可以在应用程序中进行相应的加密处理后提交。\n如果注册不成功,可以查看返回的错误对象。最有可能的情况是,用户名或电子邮件已经被另一个用户注册。这种情况你可以提示用户,要求他们尝试使用不同的用户名进行注册。\n你也可以要求用户使用 Email 做为用户名注册,这样做的好处是,你在提交信息的时候可以将输入的“用户名“默认设置为用户的 Email 地址,以后在用户忘记密码的情况下可以使用Bmob 提供重置密码功能。 注: 有些时候你可能需要在用户注册时发送一封验证邮件,以确认用户邮箱的真实性。这时,你只需要登录自己的应用管理后台,在应用设置- 邮件设置(下图)中把“邮箱验证”功能打开,Bmob 云后端就会在注册时自动发动一封验证给用户。 \nusername 字段是大小写敏感的字段,如果你希望应用的用户名不区分大小写,请在 注册和登录时进行大小写的统一转换。 注:相同的邮箱不能注册不同的账号;同一个账号也不能使用两个邮箱注册。", 
            "title": "注册"
        }, 
        {
            "location": "/data/cocos2d_x/#_47", 
            "text": "当用户注册成功后,需要让以后能够用注册的用户名登录到他们的账户使用应用。可以使用BmobUser 类的 login 方法进行登陆。方法原型:  virtual void login(BmobSaveDelegate* delegate);  delegate 是登陆监听接口,如果需要获取登陆的状态,就必须实现该接口。如用户名为 Kiarrier 的登陆:  BmobUser * bu = new BmobUser ();\nbu- autorelease();bu- setUserName( Kiarrier );\nbu- setPassword( ******** );\nbu- login(this);  也可使用如下方式完成 用户名+密码 的登录,使用 BmobUser 提供的 loginByAccount 方法登陆,参数为用户名和密码加监听接口,方法原型:  void loginByAccount(string mebileNumber,string pwd, BmobLoginDelegate *delegate); 如:\nBmobUser * bu = new BmobUser ();\nbu- autorelease();\nbu- loginByAccount( 15920955603 , 2222222222222 ,this);  监听接口 BmobLoginDelegate 的回调方法:  virtual void onLoginDone(int code,const void* data){\n      // 返回登陆状态\n}", 
            "title": "登陆"
        }, 
        {
            "location": "/data/cocos2d_x/#_48", 
            "text": "如果用户在每次打开应用程序时都要登录,这将会直接影响到应用的用户体验。为了避免这种情况,可以使用缓存的 CurrentUser 对象。\n每当应用的用户注册成功或是第一次登录成功,都会在本地磁盘中有一个缓存的用户对象,这样,可以通过获取这个缓存的用户对象来进行登录:  BmobUser* bmobUser = BmobUser::getCurrentUser();\nif(bmobUser != NULL){\n// 允许用户使用应用\n}else{\n//缓存用户对象为空时, 可打开用户注册界面...\n}  在扩展了用户类的情况下获取当前登录用户,可以使用如下的示例代码( MyUser 类可参看 上面):   MyUser userInfo = BmobUser::getCurrentUser();", 
            "title": "获取当前用户"
        }, 
        {
            "location": "/data/cocos2d_x/#_49", 
            "text": "退出登录非常简单,可以使用如下的代码:  BmobUser::logOut(); //清除缓存用户对象\nBmobUser* currentUser = BmobUser::getCurrentUser(); // 现在的 currentUser 是 NULL 了", 
            "title": "退出登录"
        }, 
        {
            "location": "/data/cocos2d_x/#_50", 
            "text": "用户可能需要修改信息,应用具备修改个人资料的功能,修改个人资料使用 BmobUser 提供的 update 方法更新信息,Bmob 提供的用户更新方式有两种:\n第一种: 新建一个用户对象,并调用 update(string objectId,BmobSaveDeleaget* delegate)方法 来更新(推荐使用) ,示例:  BmobUser* newUser = new BmobUser();\nnewUser→autorelease();\nnewUser- setEmail( xxx@163.com );\nBmobUser bmobUser* = BmobUser::getCurrentUser();\nnewUser- update(bmobUser- getObjectId(),this);  第二种:获取本地的用户对象,并调用 update( BmobUpdateDelegate * delegate)方法来更新( 不推荐使用 ),示例:  BmobUser* bmobUser = BmobUser::getCurrentUser();\nif(bmobUser != NULL){\n    // 修改用户的邮箱为 xxx@163.com\n    bmobUser- setEmail( xxx@163.com );\n    bmobUser- update(this);\n}  上面的两种更新方法都如果需要监听修改状态,都需要传递一个监听对象指镇给update 方法,该对象必须实现 BmobUpdateDelegate 接口,其中必须实现两个回调方法:  virtual void onUpdateSucess(const void* data){\n// 用户信息更新成功的回调\n}\nvirtual void onUpdateError(int code,const void* data) {\n// 用户信息更新失败的回调\n}   开发者在进行用户更新操作的时候,推荐使用 第一种 方式来进行用户的更新操作,因为此方法只会更新你提交的用户信息(比如只会向服务器提交当前用户的 email 值),而不会将本地存储的用户信息也提交到后台更新。  在更新用户信息时,如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话,Bmob 云后端同样会自动发一封邮件验证信息给用户。", 
            "title": "更新当前用户信息"
        }, 
        {
            "location": "/data/cocos2d_x/#_51", 
            "text": "查询用户和查询普通对象一样,使用 BmobQuery 中的 findObjects 方法并传递一个实现的监听接口参数查询,方法原型: virtual void findObjects( BmobFindDelegate * delegate) = 0;如下:  BmobQuery * query = new BmobQuery (BmobSDKInit::USER_TABLE);\nquery→autorelease();\nstring name =  lingo ;\nquery- addWhereEqualTo( username ,CCString::createWithFormat( %s ,name.c_str()));\nquery- findObjects(this);  注:要查询用户信息,在创建 BmobQuery 对象时,必须传递 BmobSDKInit::USER_TABLE作为参数。浏览器中查看用户表User 表是一个特殊的表,专门存储 BmobUser 对象。", 
            "title": "查询用户"
        }, 
        {
            "location": "/data/cocos2d_x/#_52", 
            "text": "有了密码系统,肯定会有用户 忘记密码 的情况。对于这种情况,我们提供了以下两种方法, 让用户安全地重置密码。", 
            "title": "密码重置"
        }, 
        {
            "location": "/data/cocos2d_x/#_53", 
            "text": "使用邮箱重置密码,使用 BmobUser 提供的 resetPasswordByEamil 方法并传递邮箱地址和监听接口指针,开发者只需要求用户输入注册时的电子邮件地址即可:  BmobUser * bu = new BmobUser ();\nbu- autorelease();\nbu- resetPasswordByEmail( xxxx@bmob.com ,this);  需要监听重置的状态,开发者必须实现 BmobResetPasswordDelegate 接口,上面传递给resetPasswordByEmail 的第二个参数就是实现该接口的指针,接口中的回调方法:  virtual void onResetSucess(const void* data){\n// 传送重置密码的邮件成功\n}\nvirtual void onResetError(int code,const void* data){\n// 重置错误\n}  邮箱重置密码的流程如下:\n1. 用户输入他们的电子邮件,请求重置自己的密码。\n2. Bmob 向他们的邮箱发送一封包含特殊的密码重置链接的电子邮件。\n3. 用户根据向导点击重置密码连接,打开一个特殊的 Bmob 页面,根据提示他们可以输入一个新的密码。\n4. 用户的密码已被重置为新输入的密码。", 
            "title": "邮箱重置密码"
        }, 
        {
            "location": "/data/cocos2d_x/#_54", 
            "text": "Bmob 引入了短信验证系统,如果用户已经验证过手机号码或者使用过手机号码注册或登录过,可以通过手机号码来重置用户密码,以下是官方建议使用的重置流程:\n1、请求手机重置密码必须先获取短信验证码,获取短信验证码使用 BmobUser 提供的requestSMSCode 方法,传入电话号码和模板名以及请求监听接口,方法原型是:  void requestSMSCode(string meblieNumber,string template_name,BmobRequestSMSCodeDelegate* delegate);  注:如果在后台设置模板名,在申请验证码时需要传入 template_name。  BmobUser * bu = new BmobUser ();\nbu- autorelease();\nbu- requestSMSCode( 159........ , ,this);  监听请求状态,需要实现 BmobRequestSMSCodeDelegate 接口,上面的 this 实现了该接口, 接口中的回调函数:  virtual void onRequestDone(int code,const void* data){\n// 返回请求状态\n}  2、用户收到重置密码的验证码之后,就可以调用 resetPasswordBySMSCode 方法来实现密 码重置,其中传递重置的密码和短信验证码以及监听接口,方法原型是:   void resetPasswordBySMSCode(string pw,string code,BmobResetPasswordByCodeDelegate* delegate);  如:  BmobUser * bu = new BmobUser ();\nbu→autorelease();\nbu- resetPasswordBySMSCode(psw,msm_code,this);  需要监听重置状态,需要实现 BmobResetPasswordByCodeDelegate 接口,回调函数:  virtual void onResetDone(int code,const void* data) {\n// 返回重置状态\n}  重置成功以后,用户就可以使用新密码登陆了。 注:\n1. 请开发者按照官方推荐的操作流程来完成重置密码操作。也就是说,开发者在进行重置密码操作时,无需调用 verifySmsCode 接口去验证该验证码的有效性。\n2. 验证码只能使用一次,一旦该验证码被使用就会失效,那么再拿失效的验证码去调用重置密码接口,一定会报 207-验证码错误 。因为重置密码接口已经包含验证码的有效性验证。", 
            "title": "手机号码重置密码"
        }, 
        {
            "location": "/data/cocos2d_x/#_55", 
            "text": "SDK 为开发者提供了直接修改当前用户登录密码的方法,只需要传入旧密码和新密码,然后调用 BmobUser 提供的方法 updateCurrentUserPassword 即可,方法原型:  void updateCurrentUserPassword(string old_pwd,string new_pwd,BmobUpdateDelegate* delegate);  以下是示例:  BmobUser* bu = new BmobUser();\nbu→autorelease();\nbu- updateCurrentUserPassword(“ 旧密码 ” , ” 新密码 ” ,this);  需要监听该方法的修改状态,需要实现 BmobUpdateDelegate 监听接口。修改成功的返回是 JSON 数据,如:   { msg : ok \n}  注:此方法修改密码时,同样需要使用用户的 ID 以及为了安全 X-Bmob-Session-Token,所以需要用户登陆才能修改密码。", 
            "title": "密码修改"
        }, 
        {
            "location": "/data/cocos2d_x/#_56", 
            "text": "设置邮件验证是一个可选的应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验,邮件验证功能会在用户(User)对象中加入 emailVerified 字段, 当一个用户的邮件被新添加或者修改过的话,emailVerified 会被默认设为 false,如果应用设置中开启了邮箱 认证功能,Bmob 会对用户填写的邮箱发送一个链接, 这个链接可以把 emailVerified 设置为 true.emailVerified 字段有 3 种状态可以考虑:    true : 用户可以点击邮件中的链接通过 Bmob 来验证地址,一个用户永远不会在新创建这个值的时候显示 emailVerified 为 true。    false : 用户(User)对象最后一次被刷新的时候, 用户并没有确认过他的邮箱地址, 如果你看到 emailVerified 为 false 的话,你可以考虑刷新用户(User)对象。    missing : 用户(User)对象已经被创建,但应用设置并没有开启邮件验证功能; 或者用户(User)对象没有 email 邮箱。", 
            "title": "邮箱验证"
        }, 
        {
            "location": "/data/cocos2d_x/#email", 
            "text": "发送给用户的邮箱验证邮件会在一周内失效,可以通过调用 requestEmailVerify 来强制重新发送,方法原型:\n```cppvoid requestEmailVerify(string email,BmobEmailVerifyDelegate* delegate);  如:\n```cpp\nBmobUser * bu = new BmobUser ();\nbu→autorelease();\nbu- requestEmailVerify( 914143799@qq.com ,this);  监听验证状态必须实现 BmobEmailVerifyDelegate 接口,接口中回调函数:  virtual void onEmailVerifySucess(const void* data) {\n//   请求验证邮件成功,请到   + email +   邮箱中进行激活。  //\n}\nvirtual void onEmailVerifyError(int code,const void* data){\n// 请求验证邮件失败\n}", 
            "title": "请求验证 Email"
        }, 
        {
            "location": "/data/cocos2d_x/#_57", 
            "text": "请求发送短信验证码Bmob 自 V3.3.9 版本开始引入了短信验证系统,可通过 requestSMSCode 方式请求发送短信验证码:  BmobUser * bu = new BmobUser ();bu→autorelease();\nbu- requestSMSCode( 159........ , ,this);  监听请求状态,需要实现 BmobRequestSMSCodeDelegate 接口,上面的 this 实现了该接口,接口中的回调函数:  virtual void onRequestDone(int code,const void* data){\n// 返回请求状态\n}  短信默认模板:  您的验证码是%smscode%,有效期为%ttl%分钟。您正在使用%appname%的验证码。【比目科技】 注:\n1. 模板名称 :模板名称需要开发者在应用的管理后台进行短信模板的添加工作,具体: 短信服务 -  短信模板 ,之后点击创建即可\n2. 只有审核通过之后的自定义短信模板才可以被使用,如果自定义的短信模板其状态显示审核中 或者 审核失败 ,再调用该方法则会以 默认模板 来发送验证码。\n3. 开发者提交短信验证码模板时需注意以下几点:\n1)、模板中不能有【】和 [] ,否则审核不通过;\n2)、如果你提交的短信模板无法发送,则有可能包含一些敏感监控词,具体可去Github 下载 短信关键字监控参考文档 来查看提交内容是否合法。\n3)、一天一个应用给同一手机号发送的短信不能超过 10 条,否则会报 10010 错误,其他错误码可查看 短信功能相关错误码 。", 
            "title": "手机号码验证"
        }, 
        {
            "location": "/data/cocos2d_x/#_58", 
            "text": "新增 邮箱+密码 登录方式,可以通过 loginByAccount 方法来操作,使用方法查看账号名加密码 登陆:   virtual void loginByAccount(account, password, this);", 
            "title": "邮箱登录"
        }, 
        {
            "location": "/data/cocos2d_x/#_59", 
            "text": "在手机号码被验证后,用户可以使用该手机号码进行登录操作,使用方法查看账号名加密码 登陆。 手机号码登录包括两种方式: 手机号码+密码 、 手机号码+短信验证码 。", 
            "title": "手机号码登录"
        }, 
        {
            "location": "/data/cocos2d_x/#_60", 
            "text": "BmobUser.loginByAccount(  11 位手机号码 ,  用户密码 , this);", 
            "title": "手机号码+密码"
        }, 
        {
            "location": "/data/cocos2d_x/#_61", 
            "text": "先请求登录的短信验证码:  BmobUser* bu = new BmobUser();\nbu- requestSMSCode(  11 位手机号码 , 模板名称 ,this);  注:请求验证码查看 \n最后调用 loginBySMSCode 方法进行手机号码登录:  BmobUser * bu = new BmobUser ();\nbu- autorelease();\nbu- loginBySMSCode( 15920955603 , 160469 ,this);", 
            "title": "手机号码+短信验证码"
        }, 
        {
            "location": "/data/cocos2d_x/#_62", 
            "text": "Bmob 同样支持手机号码一键注册或登录,以下是一键登录的流程:\n1、请求登录操作的短信验证码:  BmobSMS.requestSMSCode(context,  11 位手机号码 , 模板名称 , this);  2、用户收到短信验证码之后,就可以调用 signOrLoginByMobilePhone 方法来实现一键登录,方法原型是:  void signOrLoginByMobilePhone(string mebileNumber,string code,BmobLoginDelegate* delegate);  如:  BmobUser.signOrLoginByMobilePhone(this,  11 位手机号码 ,  验证码 , this);  可以查看验证码获取和手机+验证码登陆。", 
            "title": "手机号码一键注册或登录"
        }, 
        {
            "location": "/data/cocos2d_x/#_63", 
            "text": "如果已有用户系统,需要为用户绑定手机号,那么官方推荐的绑定流程如下:  第一步、先发送短信验证码并验证验证码的有效性,即调用 requestSMSCode 发送短信验证码,调用 verifySmsCode 来验证有效性。  第二步、在验证成功之后更新当前用户的 MobilePhoneNumber 和MobilePhoneNumberVerified 两个字段,具体绑定示例如下:  /**\n* bind mobile\n*/\nBmobUser * bu = new BmobUser ();\nbu- setMobilePhoneNumber( 15920955603 );\nbu- setMobilePhoneNumberVerified(true);bu→clear();\nbu- enParamsToHttp( mobilePhoneNumber ,CCString::createWithFormat( %s ,bu- getMobilePhoneNumber().c_str()));\nbu- enParamsToHttp( mobilePhoneNumberVerified ,CCBool::create(bu- \nCCBool::create(bu- getMobilePhoneNumberVerified()));\nBmobUser * cur = BmobUser ::getCurrentUser();\nbu- update(cur- getObjectId(),this);  可以查看更新用户部分。", 
            "title": "绑定手机号码"
        }, 
        {
            "location": "/data/cocos2d_x/#_64", 
            "text": "bmobsdk 提供了操作云端代码的功能,包含执行云端代码、删除云端代码、创建云端代码等操作。云端代码,主要是将程序部分逻辑或数据处理定向到云服务器执行.\n操作云端代码,使用Bmob　SDK中的BmobCloud类中的execCloudCode方法：  void execCloudCode(string cloudName,\n                                    std::map string, CCObject*  param,\n                                    BmobCloudDelegate 　*delegate,\n                                    BmobHttpUtil::CloudHttpType　type = BmobHttpUtil::CloudHttpType::HttpExec);  参数：\n- cloudName 云端代码方法名\n- param 云端代码参数\n- delegate 云端代码执行回调接口\n- type 方法执行的操作类型，默认是执行云端代码", 
            "title": "云端代码"
        }, 
        {
            "location": "/data/cocos2d_x/#_65", 
            "text": "执行云端代码主要是执行在云服务器中编写的执行代码,调用BmobCloud的execCloudCode方法执行.其中需要传递的参数是:云端代码的方法名/对应的参数(采用键值的方式)/回调接口/云端代码的操作类型  如有云端代码如下:  function onRequest(request, response, modules) {\n    response.send( what is result? )\n}  SDK 执行上面的代码如:      BmobCloud* bcloud = new BmobCloud();\n    bcloud- autorelease();\n    std::map string, CCObject*  param;//云端代码的参数\n    bcloud- execCloudCode( onRequest ,param,this,BmobHttpUtil::CloudHttpType::HttpExec);  执行结果：  [BmobCloud[ onExecCloud ]] 116-3-18 17:46:40:    { data :{ results : what is result? }, result :{ code :200, message : ok }}  注:执行云端代码必须传递参数,如果本身云端代码没有参数,同样需要传递一个空的map参数．", 
            "title": "执行云端代码"
        }, 
        {
            "location": "/data/csharp/", 
            "text": "注册Bmob帐号\n\n\n在网址栏输入 www.bmob.cn 或者在百度输入“Bmob后端云”进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。\n\n\n网站后台创建应用\n\n\n登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。\n\n\n\n\n获取应用密钥\n\n\n选择你要开发的应用，点击该应用下方对应的“应用密钥”\n\n\n\n\n在跳转页面，获取\nApplication ID\n和\nREST API key\n，此IDs将会在初始化SDK中使用到。\n\n\n\n\n下载安装SDK\n\n\nBmob C# SDK下载地址：\nhttps://github.com/bmob/BmobSharp/releases\n\n\n\n\nWindows\n\n\n\n\n下载后解压，将Windows文件夹下的\nBmob-Windows.dll\n文件引用到你的项目工程中，如下图所示。\n\n\n\n\ndemo：\nbmob-desktop-demo\n\n\n\n\nUnity\n\n\n\n\n下载后解压，将Unity文件夹下的\nBmob-Unity.dll\n文件放置到你的项目工程的 \nAssets/libs/\n 目录下。\n\n\ndemo：\nbmob-unity-demo\n\n开发环境(调试)搭建：请查询\nBmobSharp的README文档\n。\n\n\n新建模型类\n\n\n要想对Bmob云端的数据进行操作，需要创建和数据表对应的模型类。在Bmob中，模型类需要继承自\nBmobTable\n，类的实现如下。\n\n\n//Game表对应的模型类\nclass GameObject : BmobTable\n{\n\n    private String fTable;\n    //以下对应云端字段名称\n    public BmobInt score { get; set; }\n    public String playerName { get; set; }\n    public BmobBoolean cheatMode { get; set; }\n\n    //构造函数\n    public GameObject() { }\n\n    //构造函数\n    public GameObject(String tableName)\n    {\n        this.fTable = tableName;\n    }\n\n    public override string table\n    {\n        get\n        {\n            if (fTable != null)\n            {\n                return fTable;\n            }\n            return base.table;\n        }\n    }\n\n    //读字段信息\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.score = input.getInt(\nscore\n);\n        this.cheatMode = input.getBoolean(\ncheatMode\n);\n        this.playerName = input.getString(\nplayerName\n);\n    }\n\n    //写字段信息\n    public override void write(BmobOutput output, bool all)\n    {\n        base.write(output, all);\n\n        output.Put(\nscore\n, this.score);\n        output.Put(\ncheatMode\n, this.cheatMode);\n        output.Put(\nplayerName\n, this.playerName);\n    }\n}\n\n\n\n\n初始化AppKey\n\n\n\n\nWindows\n\n\n\n\n在正式对Bmob后端云进行操作之前，需要先初始化AppKey/RestKey信息，也就是初始化之前获取的\nApplication ID/RestKey\n信息，实现代码如下。\n\n\n        //创建Bmob实例\n        private BmobWindows bmob;\n\n        public BmobBaseForm()\n            : base()\n        {\n            bmob = new BmobWindows();\n\n            //初始化，这个ApplicationId/RestKey需要更改为你自己的ApplicationId/RestKey（ http://www.bmob.cn 上注册登录之后，创建应用可获取到ApplicationId/RestKey）\n            Bmob.initialize(\n4414150cb439afdf684d37dc184e0f9f\n, \ne1deb317442129c125b228ddf78e5f22\n);\n\n            //注册调试工具\n            BmobDebug.Register(msg =\n { Debug.WriteLine(msg); });\n        }\n\n        public BmobWindows Bmob\n        {\n            get { return bmob; }\n        }\n\n\n\n\n\n\nUnity\n\n\n\n\n选中摄像机，把BmobUnity对象拖拽到摄像机上，然后再Properties选项卡中设置 \nApplicationId\n 和 \nRestKey\n 。\n\n\n\n\n在脚本中启动方法中获取BmobUntiy：\n\n\n        private static BmobUnity Bmob;\n\n        // Use this for initialization\n        void Start ()\n        {\n                BmobDebug.Register (print);\n                BmobDebug.level = BmobDebug.Level.TRACE;\n                Bmob = gameObject.GetComponent\nBmobUnity\n ();\n        }\n\n\n\n\n添加一行数据\n\n\n初始化AppKey之后，我们就可以对Bmob云数据库进行操作了。下面以添加一行数据为例进行说明，实现代码如下:\n\n\n//对应要操作的数据表\npublic const String TABLE_NAME = \nGame\n;\n//接下来要操作的数据的数据\nprivate GameObject gameObject = new GameObject(TABLE_NAME);\n\nprivate void createData_Click(object sender, EventArgs e)\n{\n    //设置值    \n    System.Random rnd = new System.Random();\n    gameObject.score = rnd.Next(-50, 170);\n    gameObject.playerName = \n123\n;\n    gameObject.cheatMode = false;\n\n    //保存数据\n    var future = Bmob.CreateTaskAsync(gameObject);\n    //异步显示返回的数据\n    FinishedCallback(future.Result, resultText);\n}\n\n\n\n\n更多例子\n\n\n大家可详细查看\n示例源码\n和 \nSDK项目源码\n，了解更多的Bmob C# SDK for Windows的操作。", 
            "title": "快速入门"
        }, 
        {
            "location": "/data/csharp/#bmob", 
            "text": "在网址栏输入 www.bmob.cn 或者在百度输入“Bmob后端云”进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。", 
            "title": "注册Bmob帐号"
        }, 
        {
            "location": "/data/csharp/#_1", 
            "text": "登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。", 
            "title": "网站后台创建应用"
        }, 
        {
            "location": "/data/csharp/#_2", 
            "text": "选择你要开发的应用，点击该应用下方对应的“应用密钥”   在跳转页面，获取 Application ID 和 REST API key ，此IDs将会在初始化SDK中使用到。", 
            "title": "获取应用密钥"
        }, 
        {
            "location": "/data/csharp/#sdk", 
            "text": "Bmob C# SDK下载地址： https://github.com/bmob/BmobSharp/releases   Windows   下载后解压，将Windows文件夹下的 Bmob-Windows.dll 文件引用到你的项目工程中，如下图所示。   demo： bmob-desktop-demo   Unity   下载后解压，将Unity文件夹下的 Bmob-Unity.dll 文件放置到你的项目工程的  Assets/libs/  目录下。  demo： bmob-unity-demo \n开发环境(调试)搭建：请查询 BmobSharp的README文档 。", 
            "title": "下载安装SDK"
        }, 
        {
            "location": "/data/csharp/#_3", 
            "text": "要想对Bmob云端的数据进行操作，需要创建和数据表对应的模型类。在Bmob中，模型类需要继承自 BmobTable ，类的实现如下。  //Game表对应的模型类\nclass GameObject : BmobTable\n{\n\n    private String fTable;\n    //以下对应云端字段名称\n    public BmobInt score { get; set; }\n    public String playerName { get; set; }\n    public BmobBoolean cheatMode { get; set; }\n\n    //构造函数\n    public GameObject() { }\n\n    //构造函数\n    public GameObject(String tableName)\n    {\n        this.fTable = tableName;\n    }\n\n    public override string table\n    {\n        get\n        {\n            if (fTable != null)\n            {\n                return fTable;\n            }\n            return base.table;\n        }\n    }\n\n    //读字段信息\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.score = input.getInt( score );\n        this.cheatMode = input.getBoolean( cheatMode );\n        this.playerName = input.getString( playerName );\n    }\n\n    //写字段信息\n    public override void write(BmobOutput output, bool all)\n    {\n        base.write(output, all);\n\n        output.Put( score , this.score);\n        output.Put( cheatMode , this.cheatMode);\n        output.Put( playerName , this.playerName);\n    }\n}", 
            "title": "新建模型类"
        }, 
        {
            "location": "/data/csharp/#appkey", 
            "text": "Windows   在正式对Bmob后端云进行操作之前，需要先初始化AppKey/RestKey信息，也就是初始化之前获取的 Application ID/RestKey 信息，实现代码如下。          //创建Bmob实例\n        private BmobWindows bmob;\n\n        public BmobBaseForm()\n            : base()\n        {\n            bmob = new BmobWindows();\n\n            //初始化，这个ApplicationId/RestKey需要更改为你自己的ApplicationId/RestKey（ http://www.bmob.cn 上注册登录之后，创建应用可获取到ApplicationId/RestKey）\n            Bmob.initialize( 4414150cb439afdf684d37dc184e0f9f ,  e1deb317442129c125b228ddf78e5f22 );\n\n            //注册调试工具\n            BmobDebug.Register(msg =  { Debug.WriteLine(msg); });\n        }\n\n        public BmobWindows Bmob\n        {\n            get { return bmob; }\n        }   Unity   选中摄像机，把BmobUnity对象拖拽到摄像机上，然后再Properties选项卡中设置  ApplicationId  和  RestKey  。   在脚本中启动方法中获取BmobUntiy：          private static BmobUnity Bmob;\n\n        // Use this for initialization\n        void Start ()\n        {\n                BmobDebug.Register (print);\n                BmobDebug.level = BmobDebug.Level.TRACE;\n                Bmob = gameObject.GetComponent BmobUnity  ();\n        }", 
            "title": "初始化AppKey"
        }, 
        {
            "location": "/data/csharp/#_4", 
            "text": "初始化AppKey之后，我们就可以对Bmob云数据库进行操作了。下面以添加一行数据为例进行说明，实现代码如下:  //对应要操作的数据表\npublic const String TABLE_NAME =  Game ;\n//接下来要操作的数据的数据\nprivate GameObject gameObject = new GameObject(TABLE_NAME);\n\nprivate void createData_Click(object sender, EventArgs e)\n{\n    //设置值    \n    System.Random rnd = new System.Random();\n    gameObject.score = rnd.Next(-50, 170);\n    gameObject.playerName =  123 ;\n    gameObject.cheatMode = false;\n\n    //保存数据\n    var future = Bmob.CreateTaskAsync(gameObject);\n    //异步显示返回的数据\n    FinishedCallback(future.Result, resultText);\n}", 
            "title": "添加一行数据"
        }, 
        {
            "location": "/data/csharp/#_5", 
            "text": "大家可详细查看 示例源码 和  SDK项目源码 ，了解更多的Bmob C# SDK for Windows的操作。", 
            "title": "更多例子"
        }, 
        {
            "location": "/data/csharp/develop_doc/", 
            "text": "简介\n\n\nBmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。\n\n\n应用程序\n\n\n在Bmob平台注册后，每个账户可创建多个应用程序，创建的每个应用程序都有其独自的应用程序ID，此后所有的应用程序将凭其ID进行Bmob SDK的使用。即使只有一个应用程序，也可以以不同的版本进行测试和生产。\n\n\nBmob客户端初始化\n\n\nUnity\n\n\n要使用Bmob提供的服务，首先需要把BmobUnity附加到你应用程序的Camara，然后获取BmobUnity脚本组件，才能进行下一步的操作。(把图中的Application Id换成你应用的appkey)\n\n\n\n\npublic class HelloBmob : MonoBehaviour\n{\n    //BmobUnity脚本组件实例\n    private BmobUnity bmobUnity;\n\n    // 初始化\n    void Start()\n    {\n        //获取BmobUnity脚本组件\n        bmobUnity = gameObject.GetComponent\nBmobUnity\n();\n    }\n\n\n\n\nDeskstop\n\n\nBmobWindows Bmob = new BmobWindows();\nBmob.initialize(\n4414150cb439afdf684d37dc184e0f9f\n, \ne1deb317442129c125b228ddf78e5f22\n); // 替换成你的appkey/RestKey\nBmobDebug.Register(msg =\n { Debug.WriteLine(msg); }); // 用于调试输出请求参数\n\n\n\n\nWindowsphone\n\n\nBmobWindowsPhone Bmob = new BmobWindowsPhone();\nBmob.initialize(\n4414150cb439afdf684d37dc184e0f9f\n, \ne1deb317442129c125b228ddf78e5f22\n); // 替换成你的appkey/RestKey\nBmobDebug.Register(msg =\n { Debug.WriteLine(msg); }); // 用于调试输出请求参数\n\n\n\n\nBmob接口方法\n\n\nSDK组件目前提供了如下的方法供大家使用：\n\n\n// 初始化组件（可供动态切换appKey、restKey）\npublic void initialize(string appKey, string restKey);\n\n//////////////////////////////////////////////\n//\n// 数据处理\n//\n//////////////////////////////////////////////\n\npublic void Create(string tablename, IBmobWritable data, BmobCallback\ncn.bmob.response.CreateCallbackData\n callback);\npublic void Create\nT\n(T data, BmobCallback\ncn.bmob.response.CreateCallbackData\n callback) where T : BmobTable;\npublic void Delete(string tablename, string objectId, BmobCallback\ncn.bmob.response.DeleteCallbackData\n callback);\npublic void Delete\nT\n(T data, BmobCallback\ncn.bmob.response.DeleteCallbackData\n callback) where T : BmobTable;\npublic void Update(string tablename, string objectId, IBmobWritable data, BmobCallback\ncn.bmob.response.UpdateCallbackData\n callback);\npublic void Update\nT\n(T data, BmobCallback\ncn.bmob.response.UpdateCallbackData\n callback) where T : BmobTable;\npublic void Find\nT\n(string tablename, BmobQuery query, BmobCallback\ncn.bmob.response.QueryCallbackData\nT\n callback);\npublic void Get\nT\n(string tablename, string objectId, BmobCallback\nT\n callback);\npublic void Get\nT\n(T data, BmobCallback\nT\n callback) where T : BmobTable;\n\n//////////////////////////////////////////////\n//\n// 用户处理\n//\n//////////////////////////////////////////////\n\n// 用户注册\npublic void Signup(BmobUser user, BmobCallback\nBmobUser\n callback);\npublic void Signup\nT\n(T user, BmobCallback\nT\n callback) where T : BmobUser;\npublic void DeleteUser(string objectId, string sessionToken, BmobCallback\ncn.bmob.response.DeleteCallbackData\n callback);\npublic void DeleteUser\nT\n(T data, BmobCallback\ncn.bmob.response.DeleteCallbackData\n callback) where T : BmobUser;\npublic void UpdateUser(string objectId, BmobUser data, string sessionToken, BmobCallback\ncn.bmob.response.UpdateCallbackData\n callback);\npublic void UpdateUser\nT\n(T data, BmobCallback\ncn.bmob.response.UpdateCallbackData\n callback) where T : BmobUser;\n\n// 发送邮箱验证\npublic void EmailVerify(string email, BmobCallback\ncn.bmob.response.EmptyCallbackData\n callback);\n\n// 重置密码\npublic void Reset(string email, BmobCallback\ncn.bmob.response.EmptyCallbackData\n callback);\n\npublic void Login(string username, string pwd, BmobCallback\nBmobUser\n callback);\npublic void Login\nT\n(string username, string pwd, BmobCallback\nT\n callback) where T : BmobUser;\n\n//////////////////////////////////////////////\n//\n// 其他功能\n//\n//////////////////////////////////////////////\n\n// 调用云端代码\npublic void Endpoint\nT\n(string eMethod, BmobCallback\nT\n callback);\npublic void Endpoint\nT\n(string eMethod, IDictionary\nstring, object\n parameters, BmobCallback\nT\n callback);\n\npublic void FileDelete(BmobFile file, BmobCallback\ncn.bmob.response.EmptyCallbackData\n callback);\npublic void FileDelete(string group, string url, BmobCallback\ncn.bmob.response.EmptyCallbackData\n callback);\npublic void FileUpload(BmobLocalFile file, BmobCallback\ncn.bmob.response.UploadCallbackData\n callback);\npublic void FileUpload(string localPath, BmobCallback\ncn.bmob.response.UploadCallbackData\n callback);\n\npublic void Endpoint\nT\n(string eMethod, BmobCallback\nT\n callback);\npublic void Endpoint\nT\n(string eMethod, IDictionary\nstring, object\n parameters, BmobCallback\nT\n callback);\n\npublic void FileDelete(BmobFile file, BmobCallback\ncn.bmob.response.EmptyCallbackData\n callback);\npublic void FileDelete(string group, string url, BmobCallback\ncn.bmob.response.EmptyCallbackData\n callback);\npublic void FileUpload(BmobLocalFile file, BmobCallback\ncn.bmob.response.UploadCallbackData\n callback);\npublic void FileUpload(string localPath, BmobCallback\ncn.bmob.response.UploadCallbackData\n callback);\n\n// 获取服务器时间戳\npublic void Timestamp(BmobCallback\ncn.bmob.response.TimeStampCallbackData\n callback);\n\npublic void Batch(BmobBatch requests, BmobCallback\nList\nDictionary\nstring, object\n callback);\n\npublic void Push(PushParamter param, BmobCallback\ncn.bmob.response.EmptyCallbackData\n callback);\npublic void Thumbnail(ThumbnailParameter param, BmobCallback\ncn.bmob.response.ThumbnailCallbackData\n callback);\n\n\n\n\n针对C# 4.0+，SDK为每个接口对应添加了Task功能：\n\n\npublic Task\nCreateCallbackData\n CreateTaskAsync(string tablename, IBmobWritable data);\npublic Task\nCreateCallbackData\n CreateTaskAsync\nT\n(T data) where T : BmobTable;\npublic Task\nUpdateCallbackData\n UpdateTaskAsync(string tablename, string objectId, IBmobWritable data);\npublic Task\nUpdateCallbackData\n UpdateTaskAsync\nT\n(T data) where T : BmobTable;\npublic Task\nDeleteCallbackData\n DeleteTaskAsync(string tablename, string objectId);\npublic Task\nDeleteCallbackData\n DeleteTaskAsync\nT\n(T data) where T : BmobTable;\npublic Task\nT\n GetTaskAsync\nT\n(string tablename, string objectId);\npublic Task\nT\n GetTaskAsync\nT\n(T data) where T : BmobTable;\npublic Task\nQueryCallbackData\nT\n FindTaskAsync\nT\n(string tablename, BmobQuery query);\n\npublic Task\nBmobUser\n SignupTaskAsync(BmobUser user);\npublic Task\nT\n SignupTaskAsync\nT\n(T user) where T : BmobUser;\npublic Task\nUpdateCallbackData\n UpdateUserTaskAsync(string objectId, BmobUser data, string sessionToken);\npublic Task\nUpdateCallbackData\n UpdateUserTaskAsync\nT\n(T data) where T : BmobUser;\npublic Task\nDeleteCallbackData\n DeleteUserTaskAsync(string objectId, string sessionToken);\npublic Task\nDeleteCallbackData\n DeleteUserTaskAsync\nT\n(T data) where T : BmobUser;\npublic Task\nEmptyCallbackData\n EmailVerifyTaskAsync(string email);\npublic Task\nEmptyCallbackData\n PhoneVerifyTaskAsync(string phone);\n\npublic Task\nEmptyCallbackData\n ResetTaskAsync(string email);\npublic Task\nEmptyCallbackData\n ResetTaskAsync(string phone, string smsCode, string newPassword);\n\npublic Task\nBmobUser\n LoginTaskAsync(string username, string pwd);\npublic Task\nT\n LoginTaskAsync\nT\n(string username, string pwd) where T : BmobUser;\n\npublic Task\nEmptyCallbackData\n PushTaskAsync(PushParamter param);\npublic Task\nTimeStampCallbackData\n TimestampTaskAsync();\n\npublic Task\nT\n EndpointTaskAsync\nT\n(string eMethod);\npublic Task\nT\n EndpointTaskAsync\nT\n(string eMethod, IDictionary\nstring, object\n parameters);\n\npublic Task\nUploadCallbackData\n FileUploadTaskAsync(BmobLocalFile file);\npublic Task\nUploadCallbackData\n FileUploadTaskAsync(string localPath);\npublic Task\nEmptyCallbackData\n FileDeleteTaskAsync(BmobFile file);\npublic Task\nEmptyCallbackData\n FileDeleteTaskAsync(string group, string url);\n\npublic Task\nList\nDictionary\nstring, object\n BatchTaskAsync(BmobBatch requests);\npublic Task\nThumbnailCallbackData\n ThumbnailTaskAsync(ThumbnailParameter param);\n\n\n\n\n关于接口方法的使用见详细开发文档。上面列表与实际可能有一点出错，可以查看最新版的源代码\nhttps://github.com/bmob/BmobSharp\n\n\n数据类型\n\n\n目前为止，我们支持的数据类型有String、int、Boolean、Array对象类型。同时Bmob也支持BmobDate、BmobGeoPoint、BmobFile数据类型。\n\n\n对象\n\n\n一个对象对应了数据表中的一条数据。C# SDK如果需要对数据进行操作，必须创建一个数据对象模型。\n\n\n数据对象模型\n\n\nBmob的数据操作是建立在表基础上的，SDK封装了BmobTable来处理，所以任何要操作的数据对象推荐继承自BmobTable类。BmobTable对象包含objectId、createdAt、updatedAt、ACL四个默认的属性，objectId为对象的唯一标识，可以理解为数据表中的主键，createdAt为数据的创建时间，updatedAt为数据的最后修改时间，ACL为数据的操作权限。例如，游戏中可能会用到的分数对象GameScore,它可能包含score、playerName、cheatMode等属性，那么，对应的数据对象模型的示例代码如下：\n\n\npublic class GameScore : BmobTable \n{\n    /// \nsummary\n\n    /// 玩家名称\n    /// \n/summary\n\n    public string playerName { get; set; }\n\n    /// \nsummary\n\n    /// 游戏分数\n    /// \n/summary\n\n    public BmobInt score { get; set; }\n\n    /// \nsummary\n\n    /// 是否作弊\n    /// \n/summary\n\n    public BmobBoolean cheatMode { get; set; }\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n        //读取属性值\n        this.playerName = input.getString(\nplayerName\n);\n        this.score = input.getInt(\nscore\n);\n        this.cheatMode = input.getBoolean(\ncheatMode\n);\n    }\n\n    public override void write(BmobOutput output, bool all)\n    {\n        base.write(output, all);\n        //写到发送端\n        output.Put(\nplayerName\n, this.playerName);\n        output.Put(\nscore\n, this.score);\n        output.Put(\ncheatMode\n, this.cheatMode);\n    }\n}\n\n\n\n\n特殊对象\n\n\n为了提供更好的服务，BmobSDK中提供了BmobUser和BmobRole两个特殊的BmobTable对象来完成不同的功能，在这里我们统一称为特殊对象。\n\n\n\n\nBmobUser对象主要是针对应用中的用户功能而提供的，它对应着web端的User表，使用BmobUser对象可以很方便的在应用中实现用户的注册、登录、邮箱验证等功能，具体的使用方法可查看文档的用户部分。\n\n\nBmobRole对象主要用于角色管理中，它对应Web端的Role表。使用BmobRole对象可以方便的为不同的用户提供不同的角色控制权限。\n\n\n\n\n添加数据\n\n\n添加数据非常简单，任何BmobTable对象都具有Create方法可以用于将当前对象的内容保存到服务端。 例如，你现在要保存一条游戏分数的记录，可以这样做：\n\n\nvar data = new GameScore();\ndata.score = 25;\ndata.playerName = \nbmob\n;\ndata.cheatMode = false;\n\nbmobUnity.Create(TABLENAME, data, (resp, exception) =\n\n{\n    if(exception != null){\n        print(\n保存失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n保存成功, @\n + resp.createdAt);\n});\n\n\n\n\n运行完以上代码后，数据即可保存到服务器端。为了确认数据是否真的已经保存成功，你可以在Bmob服务器端你应用程序的数据浏览项目中进行查看。你应该看到类似这样的结果：\n\n\nobjectId: \n0c6db13c\n, score: 25, playerName: \nbmob\n, cheatMode: false,createdAt:\n2013-09-27 10:32:54\n, updatedAt:\n2013-09-27 10:32:54\n\n\n\n\n\n这里需要注意几点：\n\n\n\n\n在运行以上代码时，如果服务器端你创建的应用程序中已经存在GameScore数据表和相应的score、playerName、cheatMode字段，那么你此时添加的数据和数据类型也应该和服务器端的表结构一致，否则将保存数据失败。\n\n\n如果服务器端不存在GameScore数据表，那么Bmob将根据你第一次(也就是运行的以上代码)保存的GameSocre对象在服务器为你创建此数据表并插入相应数据。\n\n\n每个BmobTable对象都有几个默认的键(数据列)是不需要开发者指定的，objectId是每个保存成功数据的唯一标识符。createdAt和updatedAt代表每个对象(每条数据)在服务器上创建和最后修改的时间。ACL是数据的操作权限，这个在没有指定的情况下为空。这些键(数据列)的创建和数据内容是由服务器端自主来完成的。\n\n\n\n\n查询数据\n\n\n数据的查询可能是每个应用都会频繁使用到的，BmobUnity SDK提供了BmobQuery类，它提供了多样的方法来实现不同条件的查询，同时它的使用也是非常的简单和方便的。\n\n\n查询所有数据\n\n\n查询某个数据表中的所有数据是非常简单的查询操作，如查询玩家名字为“bmob”的所有数据的示例代码如下：\n\n\n//创建一个BmobQuery查询对象\nBmobQuery query = new BmobQuery();\n//查询playerName的值为bmob的记录\nquery.WhereEqualTo(\nplayerName\n, \nbmob\n);\nbmobUnity.Find\nGameScore\n(TABLENAME, query, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List\nGameScore\n list = resp.results;\n    foreach (var game in list)\n    {\n        print(\n获取的对象为： \n + game.ToString());\n    }\n});\n\n\n\n\n这里需要注意一点的是： 默认情况下，系统实际上并不会返回所有的数据，而是默认返回10条数据记录，你可以通过setLimit方法设置返回的记录数量。更多细节可点击查看分页查询一节。\n\n\n查询单条数据\n\n\n当我们知道某条数据的objectId时，就可以根据objectId直接获取单条数据对象。例如：查询objectId为68ee8131ca的人员信息。\n\n\nbmobUnity.Get\nGameScore\n(TABLENAME, \n68ee8131ca\n, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    GameScore game = resp;\n    print(\n获取的对象为： \n + game.ToString());\n});\n\n\n\n\n条件查询\n\n\n上面我们已经看到了一个最简单的“字段值等于某个值”的简单条件的使用方法，BmobUnity为大家提供了更多的支持条件查询的方法。\n\n\n如果需要查询playerName不等于“Barbie”的数据时可以使用WhereNotEqualTo的查询语法，示例代码如下：\n\n\nquery.WhereNotEqualTo(\nplayerName\n, \nBarbie\n);\n\n\n\n\n你可以在你的查询操作中添加多个约束条件，来查询符合要求的数据：\n\n\nquery.WhereNotEqualTo(\nplayerName\n, \nBarbie\n);     //名字不等于Barbie\nquery.WhereGreaterThan(\nscore\n, 60);      //分数大于60岁\n\n\n\n\n你还可以使用一些比较查询，示例代码如下：\n\n\n//分数 \n 50\nquery.WhereLessThan(\nscore\n, 50);\n//分数 \n= 50\nquery.WhereLessThanOrEqualTo(\nscore\n, 50);\n//分数 \n 50\nquery.WhereGreaterThan(\nscore\n, 50);\n//分数 \n= 50\nquery.WhereGreaterThanOrEqualTo(\nscore\n, 50);\n\n\n\n\n如果你想查询匹配几个不同值的数据，如：要查询“Barbie”,“Joe”,“Julia”三个人的成绩时，可以使用WhereContainedIn方法（查询“字段的值在指定集合中”的记录列表）来实现，示例代码如下：\n\n\nquery.WhereContainedIn(\nplayerName\n, {\nBarbie\n, \nJoe\n, \nJulia\n});\n//或者使用下面的语句\nquery.WhereContainedIn(\nplayerName\n, \nBarbie\n, \nJoe\n, \nJulia\n);\n\n\n\n\n分页查询\n\n\n在数据比较多的情况下，你往往需要显示加载一部分数据就可以了，这样可以节省用户的流量和提升数据加载速度，提高用户体验。这时候，我们使用Limit方法就可以限制查询结果的数据条数。默认情况下Limit的值为10，示例代码如下：\n\n\nBmobQuery query = new BmobQuery();\n//设置最多返回20条记录\nquery.Limit(\n20\n);\n\n\n\n\n在Limit的基础上进行分页显示数据的一个比较合理的解决办法是：使用SKip方法，跳过前多少条数据。默认情况下Skip的值为10，示例代码如下：\n\n\nBmobQuery query = new BmobQuery();\n//忽略前20条数据\nquery.Skip(20);\n\n\n\n\n结果排序\n\n\n如果你想对游戏分数进行升序排序，示例代码可如下：\n\n\nBmobQuery query = new BmobQuery();\nquery.OrderBy(\nscore\n);\n\n\n\n\n如果你想对游戏分数进行降序排序，示例代码可如下：\n\n\nBmobQuery query = new BmobQuery();\nquery.OrderByDescending(\nscore\n);\n\n\n\n\n如果你想对两个或者以上的字段进行升序排序，如对score和cheatMode进行升序排序，示例代码如下：\n\n\nBmobQuery query = new BmobQuery();\nquery.OrderBy(\nscore\n).ThenBy(\ncheatMode\n);\n\n\n\n\n如果你想对两个或者以上的字段进行降序排序，如对score和cheatMode进行降序排序，示例代码如下：\n\n\nBmobQuery query = new BmobQuery();\nquery.OrderByDescending(\nscore\n).ThenByDescending(\ncheatMode\n);\n\n\n\n\n这些排序的方法还可以混合使用，具体详细用法不再详述。\n\n\n统计对象数量\n\n\n如果你想查询一个特定玩家玩的游戏场数，那么，示例代码可如下：\n\n\nBmobQuery query = new BmobQuery();\nquery.WhereEqualTo(\nplayerName\n, \nbmob\n);\nquery.Count ();\nbmobUnity.Find\nGameScore\n(TABLENAME, query, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    List\nGameScore\n list = resp.results;\n    BmobInt count = resp.count;\n    print(\n满足条件的对象个数为： \n + count.Get());\n    foreach (var game in list)\n    {\n        print(\n获取的对象为： \n + game.ToString());\n    }\n});\n\n\n\n\n或\n查询\n\n\n上面提到的查询语句都是and作为连接词的条件查询，但很多时候你还需要使用到“或（Or）”查询，如，你想查找GameScore表中 score 大于 90 或者 cheatMode 等于 true 的记录，示例代码如下：\n\n\nBmobQuery q1 = new BmobQuery();\nq1.WhereGreaterThan(\nscore\n, 90);\n\nBmobQuery q2 = new BmobQuery();\nq2.WhereEqualTo(\ncheatMode\n, true);\n\n//Or查询\nq1 = q1.Or(q2);\n\n\n\n\nOr查询是可变参数方法，你可以在里面放更多的查询对象，当然了，在Or查询方法里面的参数连接词为and。\n\n\n查询指定列\n\n\n有的时候，一张表的数据列比较多，而我们只想查询返回某些列的数据时，我们可以使用BmobQuery对象提供的Select方法来实现。如从GameScore表中查找playerName的值的示例代码如下：\n\n\nBmobQuery query = new BmobQuery();\nquery.Select(\nplayerName\n);\nbmobUnity.Find\nGameScore\n(TABLENAME, query, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    List\nGameScore\n list = resp.results;\n    foreach (var game in list)\n    {\n    }\n});\n\n\n\n\n指定多列时多次调用即可，如：\n\n\nBmobQuery query = new BmobQuery();\nquery.Select(\nplayerName\n, \nscore\n);\n\n\n\n\n删除与修改数据\n\n\n修改数据\n\n\n更新一个对象也是非常简单。例如：将GameScore表中objectId为0c6db13c的游戏分数修改为77.\n\n\nGameScore game = new GameScore();\ngame.score = 77;\nbmobUnity.Update(TABLENAME, \n68ee8131ca\n, game, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n修改失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n修改成功, @\n + resp.updatedAt);\n });\n\n\n\n\n删除数据\n\n\n从服务器删除对象。例如：将GameScore表中objectId为68ee8131ca的数据删除。\n\n\nbmobUnity.Delete(\nGameScore\n, \n68ee8131ca\n, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n删除失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n删除成功, @\n + resp.msg);\n});\n\n\n\n\n数据关联\n\n\n关联数据的对象模型\n\n\n数据可以和其他数据进行关联（使用BmobPointer关联类型），就像是传统数据库中的主外键关系一样，如：一条微博由一个用户发布，可以有多个用户评论，每条评论信息对应一个用户。这时候，微博表对应的对象模型就应该如下：\n\n\npublic class Weibo : BmobTable\n{\n    // 发布的微博\n    public string message { get; set; }\n    // 微博的作者\n    public BmobPointer\nBmobUser\n user { get; set; }\n    // 微博的图片地址\n    public string pic;\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.message = input.getString(\nmessage\n);\n        this.user = input.Get\nBmobPointer\nBmobUser\n(\nuser\n);\n        this.pic = input.getString(\npic\n);\n    }\n\n    public override void write(BmobOutput output, Boolean all)\n    {\n        base.write(output, all);\n\n        output.Put(\nmessage\n, this.message);\n        output.Put(\nuser\n, this.user);\n        output.Put(\npic\n, this.pic);\n    }\n}\n\n\n\n\n评论表对应的对象模型就应该如下：\n\n\npublic class Comment : BmobTable\n{\n    // 用户的评论\n    public string comment { get; set; }\n    // 发布评论的用户\n    public BmobPointer\nBmobUser\n user { get; set; }\n    // 评论的微博\n    public BmobPointer\nWeibo\n weibo { get; set; }\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.comment = input.getString(\ncomment\n);\n        this.user = input.Get\nBmobPointer\nBmobUser\n(\nuser\n);\n        this.weibo = input.Get\nBmobPointer\nWeibo\n(\nweibo\n);\n    }\n\n    public override void write(BmobOutput output, Boolean all)\n    {\n        base.write(output, all);\n\n        output.Put(\ncomment\n, this.comment);\n        output.Put(\nuser\n, this.user);\n        output.Put(\nweibo\n, this.weibo);\n    }\n}\n\n\n\n\n添加关联关系\n\n\n保存带有关联关系的评论表的数据的方法和保存其他数据模型的方法一样，还是使用BmobUnity对象的Create方法，示例代码如下：\n\n\n//获取当前登录用户信息\nGameUser user = BmobUser.CurrentUser();\nvar comment = new Comment();\n// 设定评论内容\ncomment.comment = \n发布的评论信息\n;\n// 设定评论人\ncomment.user = new BmobPointer\nBmobUser\n(user);\n// 设定评论对应的微博\nWeibo weibo = new Weibo();\nweibo.objectId = \nZGwboItm\n;\ncomment.weibo = new BmobPointer\nWeibo\n(weibo);;    \n\nbmobUnity.Create(TABLENAME, comment, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n添加失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n添加成功, @\n + resp.createAt);\n});\n\n\n\n\n修改关联对象\n\n\n关联对象的修改和普通BmobTable对象的修改一样，只需设置要更新的属性值，然后调用Update方法即可。下面假设将objectId为ef8e6agg28的评论记录的作者修改为其他人(这里是直接把当前用户的objectId设置为ZGwboItm)。\n\n\nGameUser user = BmobUser.CurrentUser();\nuser.objectId = \nZGwboItm\n;\nComment comment = new Comment();\n// SDK中有添加隐式转换，会把GameUser对象转换成BmobPointer\nGameUser\n\ncomment.user = user;\nbmobUnity.Update(TABLENAME, \nef8e6agg28\n, comment, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n修改失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n修改成功, @\n + resp.updatedAt);\n});\n\n\n\n\n查询关联对象\n\n\n如果你想要查询当前用户发表的所有评论信息，可以跟其他查询一样使用WhereEqualTo，示例代码如下：\n\n\nBmobQuery query = new BmobQuery();\n//按发布时间降序排列\nquery.OrderByDescending(\nupdatedAt\n);\n//获取当前用户信息\nGameUser user = BmobUser.CurrentUser();\n//查询当前用户的所有评论\nquery.WhereEqualTo(\nuser\n, new BmobPointer\nBmobUser\n(user));    \n// or use\n// query.WhereMatchesQuery(\nuser\n, user);\nbmobUnity.Find\nComment\n(TABLENAME, query, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List\nComment\n commentList = resp.results;\n    foreach (var comment in commentList)\n    {\n        print(\n获取的对象为： \n + comment.ToString());\n    }\n});\n\n\n\n\n如果你想要查询带有图片的微博的评论列表，即在Comment表中对Weibo表进行内部的查询，可以使用WhereMatchesQuery\n方法(DOC:查询的对象中的某个列符合另一个指针值)进行内部查询：\n\n\nWeibo wb = new Weibo();\n// Weibo对象赋值（条件赋值）\n\nBmobQuery query = new BmobQuery();\nquery.WhereMatchesQuery\nWeibo\n(\npic\n, new BmobPointer\nWeibo\n(wb)); \nbmobUnity.Find\nComment\n(TABLENAME, query, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List\nComment\n commentList = resp.results;\n    foreach (var comment in commentList)\n    {\n        print(\n获取的对象为： \n + comment.ToString());\n    }\n});\n\n\n\n\n反之，不想匹配某个子查询，你可以使用WhereDoesNotMatchQuery方法。 比如为了查询不带图片的微博的评论列表，就可以将上面的示例代码中的WhereMatchesQuery方法替换为WhereDoesNotMatchQuery方法。\n\n\n如果你想获取最新的10条评论，同时包含这些评论对应的微博，实现代码可以为如下：\n\n\nBmobQuery query = new BmobQuery();\n// 限制10条\nquery.Limit(10); \n//按创建时间排序\nquery.Order(\ncreatedAt\n); \n//同时将对应的微博信息也查询出来\nquery.Include(\nweibo\n);\n//执行查询\nbmobUnity.Find\nComment\n(TABLENAME, query, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List\nComment\n commentList = resp.results;\n    foreach (var comment in commentList)\n    {\n        print(\n获取的对象为： \n + comment.ToString());\n    }\n});\n\n\n\n\n你可以使用\n.\n号（英语句号）操作符来并列获得 Include 中的内嵌的对象。比如，你同时想 Include 一个 Comment 的 weibo 和weibo的 user（微博发布者）对象，你可以这样做：\n\n\nquery.Include(\nweibo.user\n);\n\n\n\n\n用户\n\n\n用户是一个应用程序的核心。对于个人开发者来说，自己的应用程序积累到越多的用户，就会给自己带来越强的创作动力。因此Bmob提供了一个专门的用户类——BmobUser来自动处理用户账户管理所需的功能。\n\n\n有了这个类，你就可以在你的应用程序中添加用户账户功能。\n\n\nBmobUser是BmobTable的一个子类，它继承了BmobTable所有的方法，具有BmobTable相同的功能。不同的是，BmobUser增加了一些特定的关于用户账户管理相关的功能。\n\n\n属性\n\n\nBmobUser除了从BmobTable继承的属性外，还有几个特定的属性： \n\n\n\n\nusername: 用户的用户名（必需）。 \n\n\npassword: 用户的密码（必需）。 \n\n\nemail: 用户的电子邮件地址（可选）。\n\n\n\n\n创建用户对象\n\n\n创建用户对象如下：\n\n\nBmobUser user = new BmobUser();\n\n\n\n\n如果你需要扩展用户资料信息，如给用户表添加生命值life和攻击指数attack，那么需要创建一个新的用户类，继承自BmobUser。示例代码如下：\n\n\npublic class GameUser : BmobUser\n{\n    public BmobInt life { get; set; }\n    public BmobInt attack { get; set; }\n\n    public override void write(BmobOutput output, bool all)\n    {\n        base.write(output, all);\n\n        output.Put(\nlife\n, this.life);\n        output.Put(\nattack\n, this.attack);\n    }\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.life = input.getInt(\nlife\n);\n        this.attack = input.getInt(\nattack\n);\n    }\n}\n\n\n\n\n注册用户\n\n\n你的应用程序可能会要求用户注册。下面的代码是一个典型的注册过程：\n\n\nBmobUser user = new BmobUser();\nuser.username = \nbmob\n;\nuser.password = \n123456\n;\n//邮箱用于找回密码\nuser.email = \npartnet@bmob.cn\n;\n//如使用了GameUser表的话，以下注册语句需要更改为：bmobUnity.Signup\nMyBmobUser\n(user,(resp, exception) =\n\nbmobUnity.Signup(user,(resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n注册失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n    print(\n注册成功\n);\n});\n\n\n\n\n在注册过程中，服务器会对注册用户信息进行检查，以确保注册的用户名和电子邮件地址是独一无二的。此外，对于用户的密码，你可以在应用程序中进行相应的加密处理后提交。\n\n\n如果注册不成功，你可以查看返回的错误对象。最有可能的情况是，用户名或电子邮件已经被另一个用户注册。这种情况你可以提示用户，要求他们尝试使用不同的用户名进行注册。\n\n\n你也可以要求用户使用Email做为用户名注册，这样做的好处是，你在提交信息的时候可以将输入的“用户名“默认设置为用户的Email地址，以后在用户忘记密码的情况下可以使用Bmob提供重置密码功能。\n\n\n这里需要注意一点的是，有些时候你可能需要在用户注册时发送一封验证邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在应用设置-\n邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在注册时自动发动一封验证给用户。\n\n\n设置邮箱验证功能\n\n\n\n\n登录用户\n\n\n当用户注册成功后，您需要让他们以后能够用注册的用户名登录到他们的账户使用应用。要做到这一点，你可以使用BmobUser类的login方法。\n\n\nbmobUnity.Login\nGameUser\n(\nbmob\n, \n123456\n, (resp, exception) =\n \n{\n    if (exception != null)\n    {\n        print(\n登录失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n登录成功, @\n + resp.username + \n(\n + resp.life + \n)$[\n + resp.sessionToken + \n]\n);\n    print(\n登录成功, 当前用户对象Session： \n + BmobUser.CurrentUser.sessionToken);\n});\n\n\n\n\n获取当前用户\n\n\n登录之后，你可以通过如下示例代码获取当前登录用户的信息：\n\n\nBmobUser buser = BmobUser.CurrentUser;\n// 或者\nGameUser user = BmobUser.CurrentUser as GameUser;\n\n\n\n\n更新用户\n\n\n很多情况下你可能需要修改用户信息，比如你的应用具备修改个人资料的功能，示例代码如下：\n\n\nGameUser user = new GameUser();\nuser.attack = 1000;\n//需要知道用户记录的objectId和sessionToken信息\nbmobUnity.UpdateUser(\nobjectid\n, user, \nsessionToken\n, (resp, exception) =\n\n{\n    if (updateException != null)\n    {\n        print(\n保存失败, 失败原因为： \n + updateException.Message);\n        return;\n    }\n\n    print(\n保存成功, @\n + updateResp.updatedAt);\n});\n\n\n\n\n在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发一封邮件验证信息给用户。\n\n\n查询用户\n\n\n查询用户和查询普通对象一样，只需指定BmobUser类即可，如下查询用户名为bmob的用户：\n\n\nBmobQuery query = new BmobQuery();\nquery.WhereEqualTo(\nusername\n, \nbmob\n);\nbmobUnity.Find\nGameUser\n(BmobUser.TABLE, query, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    List\nGameUser\n list = resp.results;\n    foreach (var user in list)\n    {\n        print(\n获取的对象为： \n + user.ToString());\n    }\n});\n\n\n\n\n密码重置\n\n\n一旦你引入了一个密码系统，那么肯定会有用户忘记密码的情况。对于这种情况，我们提供了一种方法，让用户安全地重置起密码。\n\n\n重置密码的流程很简单，开发者只需要求用户输入注册的电子邮件地址即可，示例代码如下：\n\n\nbmobUnity.Reset(\nsupport@bmob.cn\n, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n重置密码请求失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n重置密码请求发送成功！\n);\n});\n\n\n\n\n密码重置流程如下：\n\n\n\n\n用户输入他们的电子邮件，请求重置自己的密码。\n\n\nBmob向他们的邮箱发送一封包含特殊的密码重置连接的电子邮件。\n\n\n用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，根据提示他们可以输入一个新的密码。\n\n\n用户的密码已被重置为新输入的密码。\n\n\n\n\n邮箱验证\n\n\n设置邮件验证是一个可选的应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会被默认设为false，如果应用设置中开启了邮箱认证功能，Bmob会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.\n\n\nemailVerified 字段有 3 种状态可以考虑：\n\n\n\n\ntrue : 用户可以点击邮件中的链接通过Bmob来验证地址，一个用户永远不会在新创建这个值的时候显示emailVerified为true。\n\n\nfalse : 用户(User)对象最后一次被刷新的时候, 用户并没有确认过他的邮箱地址, 如果你看到emailVerified为false的话，你可以考虑刷新用户(User)对象。\n\n\nmissing : 用户(User)对象已经被创建，但应用设置并没有开启邮件验证功能； 或者用户(User)对象没有email邮箱。\n\n\n\n\n请求验证Email\n\n\n发送给用户的邮箱验证邮件会在一周内失效，可以通过调用 EmailVerify 来强制重新发送：\n\n\nbmobUnity.EmailVerify(\nsupport@bmob.cn\n, (resp, exception) =\n \n{\n    if (exception != null)\n    {\n        print(\n邮箱验证请求失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n邮箱验证请求发送成功！\n);\n});\n\n\n\n\nACL和角色\n\n\n数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看Bmob数据与安全页面，了解Bmob如何保护数据安全）。\n\n\n其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。\n\n\n大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：\n\n\n\n\n对于私有数据，读写权限可以只局限于数据的所有者。\n\n\n对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。\n\n\n对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。\n\n\n属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。\n\n\n一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。\n\n\n用Bmob SDK，你可以对这些数据设置一个默认的ACL，这样，即使黑客反编译了你的应用，获取到Application Key，也仍然无法操作和破坏你的用户数据，确保了用户数据的安全可靠。而作为开发者，当你需要对这些数据进行管理时，可以通过超级权限Key（Master Key）进行。\n\n\n\n\n默认访问权限\n\n\n在没有显示指定的情况下，每一个BmobTable中的ACL(列)属性的默认值是所有人可读可写的。在客户端想要修改这个权限设置，只需要简单调用BmobACL的ReadAccess方法和WriteAccess方法，如设置所有用户的读权限为true，写权限为false的示例代码如下：\n\n\nBmobACL acl = new BmobACL();\nacl.ReadAccess(\n*\n);\n\n\n\n\n这里说明一点的是： \n*\n号表示所有用户。ACL列为空表示所有用户可读可写；在不为空的情况下，读或写空缺表示没有对应权限。\n\n\n指定用户的访问权限\n\n\n如果你想对发表的微博设定一个权限：发表微博的作者有修改和删除的权限，其他用户只有读的权限，那么，可用如下的示例代码：\n\n\n//创建数据对象\nWeibo weibo = new Weibo();\nweibo.message = \n论电影的七个元素\n;\n//创建一个ACL对象\nBmobACL acl = new BmobACL();    \n//设置所有人可读\nacl.ReadAccess(\n*\n);\n//参数是用户的objectId，这里设置为当前用户可写    \nacl.WriteAccess(BmobUser.CurrentUser().objectId);   \n//设置这条数据的ACL信息\nweibo.ACL = acl;    \nbmobUnity.Create(TABLENAME, weibo, (resp, exception) =\n\n{\n    if(exception != null){\n        print(\n保存失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n保存成功, @\n + resp.createdAt);\n});\n\n\n\n\n如果要设定只有微博的作者有读写权限，其他人都没有读写权限，那么，可用如下的示例代码：\n\n\n//创建数据对象\nWeibo weibo = new Weibo();\nweibo.message = \n论电影的七个元素\n;\n//创建一个ACL对象\nBmobACL acl = new BmobACL();    \n//参数是用户的objectId，这里设置为当前用户可读\nacl.ReadAccess(BmobUser.CurrentUser().objectId);\n//参数是用户的objectId，这里设置为当前用户可写    \nacl.WriteAccess(BmobUser.CurrentUser().objectId);   \n//设置这条数据的ACL信息\nweibo.ACL = acl;    \nbmobUnity.Create(TABLENAME, weibo, (resp, exception) =\n\n{\n    if(exception != null){\n        print(\n保存失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n保存成功, @\n + resp.createdAt);\n});\n\n\n\n\n角色管理\n\n\n上面的指定用户访问权限虽然很方便，但是对于有些应用可能会有一定的局限性。比如一家公司的工资系统，员工和公司的出纳们只拥有工资的读权限，而公司的人事和老板才拥有全部的读写权限。要实现这种功能，你也可以通过设置每个用户的ACL权限来实现，如下：\n\n\n//创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.Wage = 100000;   \n\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser boss;\nBmobUser hr_zhang;\nBmobUser cashier_xie;\nBmobUser me;\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\n\n//设置四个用户读的权限\nacl.ReadAccess(boos.objectId);    \nacl.ReadAccess(hr_zhang.objectId);\nacl.ReadAccess(cashier_xie.objectId);\nacl.ReadAccess(me.objectId);\n\n//设置老板和人事小张对这个工资的写权限\nacl.WriteAccess(boss.objectId);\nacl.WriteAccess(hr_zhang.objectId);\n\n//设置工资对象的ACL\nwageinfo.ACL =acl;\nbmobUnity.Create(TABLENAME, wageinfo, (resp, exception) =\n\n{\n    if(exception != null){\n        print(\n保存失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n保存成功, @\n + resp.createdAt);\n});\n\n\n\n\n但是，一个公司的人事、出纳和员工不仅仅只有一个人，同时还会有离职、调换岗位以及新员工加入等问题存在。如果用上面的代码对公司的每个人进行一一设置的话是不现实的，既麻烦也很难维护。针对这个问题，我们可以利用BmobRole来解决。我们只需要对用户进行分类，每个分类赋予不同的权限。如下代码实现：\n\n\n//这里创建四个用户对象指针，分别为老板、人事小张、出纳小谢和自己\n// just for test\nBmobPointer\nBmobUser\n boss = new BmobUser() { objectId = \n1\n };\nBmobPointer\nBmobUser\n hr_zhang = new BmobUser() { objectId = \n2\n };\nBmobPointer\nBmobUser\n hr_luo = new BmobUser() { objectId = \n3\n };\nBmobPointer\nBmobUser\n cashier_xie = new BmobUser() { objectId = \n4\n };\nBmobPointer\nBmobUser\n me = new BmobUser() { objectId = \n5\n };\n\n{\n    //创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\n    BmobRole hr = new BmobRole();\n    hr.name = \nHR\n;\n    var users = new BmobRelation\nBmobUser\n();\n    users.Add(hr_zhang);\n    users.Add(hr_luo);\n\n    //将hr_zhang和hr_luo归属到hr角色中\n    hr.AddUsers(users);\n\n    //保存到云端角色表中（web端可以查看Role表）\n    var future = Bmob.CreateTaskAsync(hr);\n    FinishedCallback(future.Result, null);\n}\n\n{\n    BmobRole cashier = new BmobRole();\n    cashier.name = \nCashier\n;\n    var users = new BmobRelation\nBmobUser\n();\n    users.Add(cashier_xie);\n\n    //将cashier_xie归属到cashier角色中\n    cashier.AddUsers(users);\n\n    //保存到云端角色表中（web端可以查看Role表）\n    var future = Bmob.CreateTaskAsync(cashier);\n    FinishedCallback(future.Result, null);\n}\n\n\n\n\n根据Role设置ACL：\n\n\n//创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.Wage =100000;\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\nacl.setReadAccess(boos, true); // 假设老板只有一个, 设置读权限\nacl.setReadAccess(me, true); // 给自己设置读权限\n// 给hr角色设置读权限\nacl.RoleReadAccess(hr.name);\n// 给cashier角色设置读权限\nacl.RoleReadAccess(cashier.name);\n\n// 设置老板拥有写权限\nacl.RoleWriteAccess(boss.name);\n// 设置hr角色拥有写权限\nacl.RoleWriteAccess(hr.name);\n\n//设置工资对象的ACL\nwageinfo.ACL = acl;\n//添加数据\nbmobUnity.Create(TABLENAME, wageinfo, null);\n\n\n\n\n需要说明一点的是，Web端的Role表也具有ACL的列，你可以将角色管理的权限赋予某些用户。\n\n\n地理位置\n\n\nBmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询，可以轻松实现查找出离当前用户最接近的信息或地点的功能。\n\n\n创建地理位置对象\n\n\n首先需要创建一个BmobGeoPoint对象。例如，创建一个北纬39.913768382429105度-东经116.39727786183357度的BmobGeoPoint对象：\n\n\nBmobGeoPoint point = new BmobGeoPoint(39.913768382429105, 116.39727786183357);\n\n\n\n\n查询地理位置信息\n\n\n现在，你的数据表中有了一定的地理坐标对象的数据， 就可以使用BmobQuery对象的WhereNear方法来找出最接近某个点的信息，示例代码如下（假设Person表中有一个名为area的地理坐标类型的字段）：\n\n\nBmobQuery query = new BmobQuery();\nbmobQuery.WhereNear(\narea\n, new BmobGeoPoint(112.934755, 24.52065));\nbmobQuery.Limit(10);    //获取最接近用户地点的10条数据\nbmobUnity.Find\nPerson\n(\nPerson\n, bmobQuery, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List\nPerson\n list = resp.results;\n    foreach (var p in list)\n    {\n        print(\n获取的对象为： \n + p.ToString());\n    }\n});\n\n\n\n\n要限制查询指定距离范围的数据可以使用WhereWithinDistance，即：\n\n\n//(112.934755, 24.52065)坐标点10公里内\nquery.WhereWithinDistance(\narea\n, new BmobGeoPoint(112.934755, 24.52065), 10);\n\n\n\n\n要查询一个矩形范围内的信息可以使用addWhereWithinGeoBox来实现：\n\n\nBmobGeoPoint southwestOfSF = new BmobGeoPoint(116.10675, 39.711669);\nBmobGeoPoint northeastOfSF = new BmobGeoPoint(116.627623, 40.143687);\nBmobQuery query = new BmobQuery();\nquery.WhereWithinGeoBox(\narea\n, southwestOfSF, northeastOfSF);\nbmobUnity.Find\nPerson\n(\nPerson\n, bmobQuery, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List\nPerson\n list = resp.results;\n    foreach (var p in list)\n    {\n         print(\n获取的对象为： \n + p.ToString());\n    }\n});\n\n\n\n\n注意事项 目前有几个需要注意的地方：\n\n\n\n\n每个BmobTable数据对象中只能有一个BmobGeoPoint对象。\n\n\n地理位置的点不能超过规定的范围。纬度的范围应该是在-90.0到90.0之间。经度的范围应该是在-180.0到180.0之间。如果您添加的经纬度超出了以上范围，将导致程序错误。\n\n\n\n\n原子计数器\n\n\n很多游戏可能会有计数器功能的需求，比如某个玩家的比赛总分score。Bmob提供了非常便捷的方式来保证原子性的修改某一记录（这条记录的objectId为28dd44a271）某字段的值。示例代码如下：\n\n\nGameScore object = new GameScore();\nobject.Increment(\nscore\n, 1000);\n//28dd44a271为这条记录的objectId\nbmobUnity.Update(TABLENAME, \n28dd44a271\n, object, FinishedCallback);\n\n\n\n\n文件\n\n\nBmob可以让你将文件存储到服务器中，常见的文件类型，如图像文件、影像文件、音乐文件和任何其他二进制数据，都可以直接上传到云端文件系统中，示例代码如下：\n\n\nbmobUnity.FileUpload(\nC:/Intel/Logs/IntelGFXCoin.log\n, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n上传失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n    print(\n上传成功，返回数据： \n + resp.ToString());\n});\n\n\n\n\nresp的返回值为UploadCallbackData对象：\n\n\n// 文件名\npublic string filename { get; set; }\n/// 文件组名\npublic string group { get; set; }\n/// 相对于Bmob文件服务器的位置\npublic string url { get; set; }\n/// 文件请求的地址\npublic string getPath()\n\n\n\n\n这里需要说明一点的是：单个上传的文件大小不可超过10M。\n\n\n\n\n与结合用户表实例\n\n\n\n\n一些用户不知道上传的附件和其他表结合怎么使用。下面介绍实际的案例：上传用户的头像\n\n\n对象类：\n\n\n    public class GameUser : BmobUser\n    {\n        public BmobFile File{get; set;}\n\n        public override void readFields(BmobInput input)\n        {\n            base.readFields(input);\n\n            this.File = input.Get\nBmobFile\n(\nfile\n);\n        }\n\n        public override void write(BmobOutput output, Boolean all)\n        {\n            base.write(output, all);\n\n            output.Put(\nfile\n, this.File);\n        }\n\n    }\n\n\n\n\n上传图片，并把图片保存到新用户User记录：\n\n\n    Byte[] data = null;\n    using (var stream = File.OpenRead(\nC:/Users/winse/Desktop/1.png\n))\n    {\n        data = stream.ReadAsBytes();\n    }\n\n    var ffuture = Bmob.FileUploadTaskAsync(new BmobLocalFile(data, \n21.png\n));\n\n    GameUser user = new GameUser();\n    user.email = \n1324@qq.com\n;\n    user.phone = \n1234\n;\n    user.username = \n1234\n;\n    user.password = \n123\n;\n\n    user.File = ffuture.Result;\n\n    var future = Bmob.SignupTaskAsync(user);\n    var signResponse = future.Result;\n...\n\n\n\n\n云端代码\n\n\n云端代码的调用方法非常简单，如下为调用执行云端方法test的实现代码：\n\n\nBmob.Endpoint\nHashtable\n(\ntest\n, (resp, exception) =\n \n{\n    if (exception != null)\n    {\n        print(\n调用失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n返回对象为： \n + resp);\n});\n\n\n\n\n相关云端代码的编写方式，请参考云端代码开发文档。\n\n\nC#调用云端代码的返回值为json字符串，即不能只返回一个单值的对象！\n\n\n\n\n不正确的使用方式：\n\n\n\n\nfunction onRequest(request, response, modules) {\nresponse.end(\njust string...\n);\n}              \n\n\n\n\n\n\nC#中正确的方式：\n\n\n\n\n云端代码：\n\n\nfunction onRequest(request, response, modules) {\n    var res =  {\nvalue\n: \njust string...\n} ;\n    response.end(JSON.stringify(res));\n}                         \n\n\n\n\nC#调用代码：\n\n\n[TestMethod()]\npublic void EndpointParamAndStringTest()\n{\n    var p = new Dictionary\nString, Object\n();\n\n    var future = Bmob.EndpointTaskAsync\nObject\n(\ntestString\n, p);\n    FinishedCallback(future.Result, null);\n}\n\n\n\n\n\n\n带参数返回map和list的例子\n\n\n\n\n[TestMethod()]\npublic void EndPointTest()\n{\n    //var future = Bmob.EndpointTaskAsync\nQueryCallbackData\nObject\n(\nsecond\n, null);\n    //FinishedCallback(future.Result, null);\n\n    var future = Bmob.EndpointTaskAsync\nList\nobject\n(\ntestParam\n, new BmobKV().Put(\na\n, \nwinse\n));\n    FinishedCallback(future.Result, null);\n\n--\n\nfunction onRequest(request, response, modules) {\n\n    //获取数据库对象 \n    var db = modules.oData; \n\n    var name = request.body.a;\n    //获取\n    db.find({ \n        table:'StudentScore',\n        \nwhere\n:{\nname\n:name}  \n    },function(err,data){\n        response.send(JSON.parse(data).results);\n    }); \n\n}\n\n\n\n\n\n\n\n\n获取服务器时间\n\n\n在BmobWindows对象中提供了一个方法，用于获取服务器时间。\n\n\nBmobWindows bmobWindows = new BmobWindows();\nbmobWindows.Timestamp( (resp, exception) =\n \n{\n    if (exception != null)\n    {\n        print(\n请求失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n    //返回服务器时间（单位：秒）\n    print(\n返回时间戳为： \n + resp.timestamp); \n    print(\n返回格式化的日期为： \n + resp.datetime); \n}\n);\n\n\n\n\n时间\n\n\nBmobDate对应服务端的Date类型。以\nyyyy-MM-dd HH:mm:ss\n的格式进行传输。\n\n\nSDK提供了DateTime到BmobDate的隐式转化，简化BmobDate的实例化。\n\n\n例如，查询在某个时间段内新增的数据，由于一个字段涉及到两个条件，需要使用符合查询功能：\n\n\nBmobDate start = new DateTime(2014, 10, 1);\nBmobDate end = new DateTime(2015, 1, 1);\n\nvar startQuery = new BmobQuery();\nstartQuery.WhereGreaterThanOrEqualTo(\ncreatedAt\n, start);\n\nvar endQuery = new BmobQuery();\nendQuery.WhereLessThan(\ncreatedAt\n, end);\n\nvar query = startQuery.And(endQuery);\nquery.Limit(0);\nquery.Count();\n\nvar future = Bmob.FindTaskAsync\nObject\n(TABLENAME, query);\n// 处理结果\n// var result = future.Result;\n\n\n\n\n\nFAQ\n\n\n\n\n请求信息查看\n\n\n\n\n在开发过程中，其实很多问题开发者自己多确认下就能解决问题。SDK提供了查看发送请求到服务端的开关，只需要注册一下调试信息的输出方法即可。\n\n\nBmobDebug.Register(msg =\n { Debug.WriteLine(msg); });\nBmobDebug.level = BmobDebug.Level.TRACE;\n\n\n\n\n在输出窗口，可以查看每次请求的appkey、请求数据。\n\n\n\n\n关于Task，以及Windowsphone开发UI线程问题\n\n\n\n\n新版本的SDK针对每个原有接口增加了对应Task接口方法，方便异步调用。这样就没有必要每次都callback回调，如果调用是多个线性的请求，那么使用callback代码会很难理解。\n\n\n如果是开发desktop的应用，还可以等待结果的返回，但是在手机端，系统不允许有长时间等待的，要么使用callback要么使用异步。\n\n\n使用回调： \n\n\n        private void create_Click(object sender, RoutedEventArgs e)\n        {\n            BmobApi table = new BmobApi();\n            table.name = \nhello wp\n;\n            Bmob.Create(TABLE_NAME, table, (resp, ex) =\n\n            {\n                string status = \nOK\n;\n                if (ex != null)\n                {\n                    status = \nERROR\n;\n                }\n\n                Dispatcher.BeginInvoke(() =\n\n                               {\n                                   updateStatus(create, status);\n                               });\n            });\n        }\n\n\n\n\n注意：在回调用如果需要更新UI，需要转到UI线程才行。\n\n\n使用异步：\n\n\n// async方式异步请求处理，非阻塞访问\n        private async void uploadBtn_Click(object sender, EventArgs e)\n        {\n            formstatus.Text = \n正在上传...\n;\n\n            var Result = await Bmob.FileUploadTaskAsync(fileText.Text);\n            FinishedCallback(Result, resultText);\n\n            bmobFile = Result;\n\n            enterDba.Enabled = true;\n            formstatus.Text = \n上传成功！\n;\n        }", 
            "title": "开发文档"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_1", 
            "text": "Bmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。", 
            "title": "简介"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_2", 
            "text": "在Bmob平台注册后，每个账户可创建多个应用程序，创建的每个应用程序都有其独自的应用程序ID，此后所有的应用程序将凭其ID进行Bmob SDK的使用。即使只有一个应用程序，也可以以不同的版本进行测试和生产。", 
            "title": "应用程序"
        }, 
        {
            "location": "/data/csharp/develop_doc/#bmob", 
            "text": "", 
            "title": "Bmob客户端初始化"
        }, 
        {
            "location": "/data/csharp/develop_doc/#unity", 
            "text": "要使用Bmob提供的服务，首先需要把BmobUnity附加到你应用程序的Camara，然后获取BmobUnity脚本组件，才能进行下一步的操作。(把图中的Application Id换成你应用的appkey)   public class HelloBmob : MonoBehaviour\n{\n    //BmobUnity脚本组件实例\n    private BmobUnity bmobUnity;\n\n    // 初始化\n    void Start()\n    {\n        //获取BmobUnity脚本组件\n        bmobUnity = gameObject.GetComponent BmobUnity ();\n    }", 
            "title": "Unity"
        }, 
        {
            "location": "/data/csharp/develop_doc/#deskstop", 
            "text": "BmobWindows Bmob = new BmobWindows();\nBmob.initialize( 4414150cb439afdf684d37dc184e0f9f ,  e1deb317442129c125b228ddf78e5f22 ); // 替换成你的appkey/RestKey\nBmobDebug.Register(msg =  { Debug.WriteLine(msg); }); // 用于调试输出请求参数", 
            "title": "Deskstop"
        }, 
        {
            "location": "/data/csharp/develop_doc/#windowsphone", 
            "text": "BmobWindowsPhone Bmob = new BmobWindowsPhone();\nBmob.initialize( 4414150cb439afdf684d37dc184e0f9f ,  e1deb317442129c125b228ddf78e5f22 ); // 替换成你的appkey/RestKey\nBmobDebug.Register(msg =  { Debug.WriteLine(msg); }); // 用于调试输出请求参数", 
            "title": "Windowsphone"
        }, 
        {
            "location": "/data/csharp/develop_doc/#bmob_1", 
            "text": "SDK组件目前提供了如下的方法供大家使用：  // 初始化组件（可供动态切换appKey、restKey）\npublic void initialize(string appKey, string restKey);\n\n//////////////////////////////////////////////\n//\n// 数据处理\n//\n//////////////////////////////////////////////\n\npublic void Create(string tablename, IBmobWritable data, BmobCallback cn.bmob.response.CreateCallbackData  callback);\npublic void Create T (T data, BmobCallback cn.bmob.response.CreateCallbackData  callback) where T : BmobTable;\npublic void Delete(string tablename, string objectId, BmobCallback cn.bmob.response.DeleteCallbackData  callback);\npublic void Delete T (T data, BmobCallback cn.bmob.response.DeleteCallbackData  callback) where T : BmobTable;\npublic void Update(string tablename, string objectId, IBmobWritable data, BmobCallback cn.bmob.response.UpdateCallbackData  callback);\npublic void Update T (T data, BmobCallback cn.bmob.response.UpdateCallbackData  callback) where T : BmobTable;\npublic void Find T (string tablename, BmobQuery query, BmobCallback cn.bmob.response.QueryCallbackData T  callback);\npublic void Get T (string tablename, string objectId, BmobCallback T  callback);\npublic void Get T (T data, BmobCallback T  callback) where T : BmobTable;\n\n//////////////////////////////////////////////\n//\n// 用户处理\n//\n//////////////////////////////////////////////\n\n// 用户注册\npublic void Signup(BmobUser user, BmobCallback BmobUser  callback);\npublic void Signup T (T user, BmobCallback T  callback) where T : BmobUser;\npublic void DeleteUser(string objectId, string sessionToken, BmobCallback cn.bmob.response.DeleteCallbackData  callback);\npublic void DeleteUser T (T data, BmobCallback cn.bmob.response.DeleteCallbackData  callback) where T : BmobUser;\npublic void UpdateUser(string objectId, BmobUser data, string sessionToken, BmobCallback cn.bmob.response.UpdateCallbackData  callback);\npublic void UpdateUser T (T data, BmobCallback cn.bmob.response.UpdateCallbackData  callback) where T : BmobUser;\n\n// 发送邮箱验证\npublic void EmailVerify(string email, BmobCallback cn.bmob.response.EmptyCallbackData  callback);\n\n// 重置密码\npublic void Reset(string email, BmobCallback cn.bmob.response.EmptyCallbackData  callback);\n\npublic void Login(string username, string pwd, BmobCallback BmobUser  callback);\npublic void Login T (string username, string pwd, BmobCallback T  callback) where T : BmobUser;\n\n//////////////////////////////////////////////\n//\n// 其他功能\n//\n//////////////////////////////////////////////\n\n// 调用云端代码\npublic void Endpoint T (string eMethod, BmobCallback T  callback);\npublic void Endpoint T (string eMethod, IDictionary string, object  parameters, BmobCallback T  callback);\n\npublic void FileDelete(BmobFile file, BmobCallback cn.bmob.response.EmptyCallbackData  callback);\npublic void FileDelete(string group, string url, BmobCallback cn.bmob.response.EmptyCallbackData  callback);\npublic void FileUpload(BmobLocalFile file, BmobCallback cn.bmob.response.UploadCallbackData  callback);\npublic void FileUpload(string localPath, BmobCallback cn.bmob.response.UploadCallbackData  callback);\n\npublic void Endpoint T (string eMethod, BmobCallback T  callback);\npublic void Endpoint T (string eMethod, IDictionary string, object  parameters, BmobCallback T  callback);\n\npublic void FileDelete(BmobFile file, BmobCallback cn.bmob.response.EmptyCallbackData  callback);\npublic void FileDelete(string group, string url, BmobCallback cn.bmob.response.EmptyCallbackData  callback);\npublic void FileUpload(BmobLocalFile file, BmobCallback cn.bmob.response.UploadCallbackData  callback);\npublic void FileUpload(string localPath, BmobCallback cn.bmob.response.UploadCallbackData  callback);\n\n// 获取服务器时间戳\npublic void Timestamp(BmobCallback cn.bmob.response.TimeStampCallbackData  callback);\n\npublic void Batch(BmobBatch requests, BmobCallback List Dictionary string, object  callback);\n\npublic void Push(PushParamter param, BmobCallback cn.bmob.response.EmptyCallbackData  callback);\npublic void Thumbnail(ThumbnailParameter param, BmobCallback cn.bmob.response.ThumbnailCallbackData  callback);  针对C# 4.0+，SDK为每个接口对应添加了Task功能：  public Task CreateCallbackData  CreateTaskAsync(string tablename, IBmobWritable data);\npublic Task CreateCallbackData  CreateTaskAsync T (T data) where T : BmobTable;\npublic Task UpdateCallbackData  UpdateTaskAsync(string tablename, string objectId, IBmobWritable data);\npublic Task UpdateCallbackData  UpdateTaskAsync T (T data) where T : BmobTable;\npublic Task DeleteCallbackData  DeleteTaskAsync(string tablename, string objectId);\npublic Task DeleteCallbackData  DeleteTaskAsync T (T data) where T : BmobTable;\npublic Task T  GetTaskAsync T (string tablename, string objectId);\npublic Task T  GetTaskAsync T (T data) where T : BmobTable;\npublic Task QueryCallbackData T  FindTaskAsync T (string tablename, BmobQuery query);\n\npublic Task BmobUser  SignupTaskAsync(BmobUser user);\npublic Task T  SignupTaskAsync T (T user) where T : BmobUser;\npublic Task UpdateCallbackData  UpdateUserTaskAsync(string objectId, BmobUser data, string sessionToken);\npublic Task UpdateCallbackData  UpdateUserTaskAsync T (T data) where T : BmobUser;\npublic Task DeleteCallbackData  DeleteUserTaskAsync(string objectId, string sessionToken);\npublic Task DeleteCallbackData  DeleteUserTaskAsync T (T data) where T : BmobUser;\npublic Task EmptyCallbackData  EmailVerifyTaskAsync(string email);\npublic Task EmptyCallbackData  PhoneVerifyTaskAsync(string phone);\n\npublic Task EmptyCallbackData  ResetTaskAsync(string email);\npublic Task EmptyCallbackData  ResetTaskAsync(string phone, string smsCode, string newPassword);\n\npublic Task BmobUser  LoginTaskAsync(string username, string pwd);\npublic Task T  LoginTaskAsync T (string username, string pwd) where T : BmobUser;\n\npublic Task EmptyCallbackData  PushTaskAsync(PushParamter param);\npublic Task TimeStampCallbackData  TimestampTaskAsync();\n\npublic Task T  EndpointTaskAsync T (string eMethod);\npublic Task T  EndpointTaskAsync T (string eMethod, IDictionary string, object  parameters);\n\npublic Task UploadCallbackData  FileUploadTaskAsync(BmobLocalFile file);\npublic Task UploadCallbackData  FileUploadTaskAsync(string localPath);\npublic Task EmptyCallbackData  FileDeleteTaskAsync(BmobFile file);\npublic Task EmptyCallbackData  FileDeleteTaskAsync(string group, string url);\n\npublic Task List Dictionary string, object  BatchTaskAsync(BmobBatch requests);\npublic Task ThumbnailCallbackData  ThumbnailTaskAsync(ThumbnailParameter param);  关于接口方法的使用见详细开发文档。上面列表与实际可能有一点出错，可以查看最新版的源代码 https://github.com/bmob/BmobSharp", 
            "title": "Bmob接口方法"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_3", 
            "text": "目前为止，我们支持的数据类型有String、int、Boolean、Array对象类型。同时Bmob也支持BmobDate、BmobGeoPoint、BmobFile数据类型。", 
            "title": "数据类型"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_4", 
            "text": "一个对象对应了数据表中的一条数据。C# SDK如果需要对数据进行操作，必须创建一个数据对象模型。", 
            "title": "对象"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_5", 
            "text": "Bmob的数据操作是建立在表基础上的，SDK封装了BmobTable来处理，所以任何要操作的数据对象推荐继承自BmobTable类。BmobTable对象包含objectId、createdAt、updatedAt、ACL四个默认的属性，objectId为对象的唯一标识，可以理解为数据表中的主键，createdAt为数据的创建时间，updatedAt为数据的最后修改时间，ACL为数据的操作权限。例如，游戏中可能会用到的分数对象GameScore,它可能包含score、playerName、cheatMode等属性，那么，对应的数据对象模型的示例代码如下：  public class GameScore : BmobTable \n{\n    ///  summary \n    /// 玩家名称\n    ///  /summary \n    public string playerName { get; set; }\n\n    ///  summary \n    /// 游戏分数\n    ///  /summary \n    public BmobInt score { get; set; }\n\n    ///  summary \n    /// 是否作弊\n    ///  /summary \n    public BmobBoolean cheatMode { get; set; }\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n        //读取属性值\n        this.playerName = input.getString( playerName );\n        this.score = input.getInt( score );\n        this.cheatMode = input.getBoolean( cheatMode );\n    }\n\n    public override void write(BmobOutput output, bool all)\n    {\n        base.write(output, all);\n        //写到发送端\n        output.Put( playerName , this.playerName);\n        output.Put( score , this.score);\n        output.Put( cheatMode , this.cheatMode);\n    }\n}", 
            "title": "数据对象模型"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_6", 
            "text": "为了提供更好的服务，BmobSDK中提供了BmobUser和BmobRole两个特殊的BmobTable对象来完成不同的功能，在这里我们统一称为特殊对象。   BmobUser对象主要是针对应用中的用户功能而提供的，它对应着web端的User表，使用BmobUser对象可以很方便的在应用中实现用户的注册、登录、邮箱验证等功能，具体的使用方法可查看文档的用户部分。  BmobRole对象主要用于角色管理中，它对应Web端的Role表。使用BmobRole对象可以方便的为不同的用户提供不同的角色控制权限。", 
            "title": "特殊对象"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_7", 
            "text": "添加数据非常简单，任何BmobTable对象都具有Create方法可以用于将当前对象的内容保存到服务端。 例如，你现在要保存一条游戏分数的记录，可以这样做：  var data = new GameScore();\ndata.score = 25;\ndata.playerName =  bmob ;\ndata.cheatMode = false;\n\nbmobUnity.Create(TABLENAME, data, (resp, exception) = \n{\n    if(exception != null){\n        print( 保存失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 保存成功, @  + resp.createdAt);\n});  运行完以上代码后，数据即可保存到服务器端。为了确认数据是否真的已经保存成功，你可以在Bmob服务器端你应用程序的数据浏览项目中进行查看。你应该看到类似这样的结果：  objectId:  0c6db13c , score: 25, playerName:  bmob , cheatMode: false,createdAt: 2013-09-27 10:32:54 , updatedAt: 2013-09-27 10:32:54   这里需要注意几点：   在运行以上代码时，如果服务器端你创建的应用程序中已经存在GameScore数据表和相应的score、playerName、cheatMode字段，那么你此时添加的数据和数据类型也应该和服务器端的表结构一致，否则将保存数据失败。  如果服务器端不存在GameScore数据表，那么Bmob将根据你第一次(也就是运行的以上代码)保存的GameSocre对象在服务器为你创建此数据表并插入相应数据。  每个BmobTable对象都有几个默认的键(数据列)是不需要开发者指定的，objectId是每个保存成功数据的唯一标识符。createdAt和updatedAt代表每个对象(每条数据)在服务器上创建和最后修改的时间。ACL是数据的操作权限，这个在没有指定的情况下为空。这些键(数据列)的创建和数据内容是由服务器端自主来完成的。", 
            "title": "添加数据"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_8", 
            "text": "数据的查询可能是每个应用都会频繁使用到的，BmobUnity SDK提供了BmobQuery类，它提供了多样的方法来实现不同条件的查询，同时它的使用也是非常的简单和方便的。", 
            "title": "查询数据"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_9", 
            "text": "查询某个数据表中的所有数据是非常简单的查询操作，如查询玩家名字为“bmob”的所有数据的示例代码如下：  //创建一个BmobQuery查询对象\nBmobQuery query = new BmobQuery();\n//查询playerName的值为bmob的记录\nquery.WhereEqualTo( playerName ,  bmob );\nbmobUnity.Find GameScore (TABLENAME, query, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List GameScore  list = resp.results;\n    foreach (var game in list)\n    {\n        print( 获取的对象为：   + game.ToString());\n    }\n});  这里需要注意一点的是： 默认情况下，系统实际上并不会返回所有的数据，而是默认返回10条数据记录，你可以通过setLimit方法设置返回的记录数量。更多细节可点击查看分页查询一节。", 
            "title": "查询所有数据"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_10", 
            "text": "当我们知道某条数据的objectId时，就可以根据objectId直接获取单条数据对象。例如：查询objectId为68ee8131ca的人员信息。  bmobUnity.Get GameScore (TABLENAME,  68ee8131ca , (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    GameScore game = resp;\n    print( 获取的对象为：   + game.ToString());\n});", 
            "title": "查询单条数据"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_11", 
            "text": "上面我们已经看到了一个最简单的“字段值等于某个值”的简单条件的使用方法，BmobUnity为大家提供了更多的支持条件查询的方法。  如果需要查询playerName不等于“Barbie”的数据时可以使用WhereNotEqualTo的查询语法，示例代码如下：  query.WhereNotEqualTo( playerName ,  Barbie );  你可以在你的查询操作中添加多个约束条件，来查询符合要求的数据：  query.WhereNotEqualTo( playerName ,  Barbie );     //名字不等于Barbie\nquery.WhereGreaterThan( score , 60);      //分数大于60岁  你还可以使用一些比较查询，示例代码如下：  //分数   50\nquery.WhereLessThan( score , 50);\n//分数  = 50\nquery.WhereLessThanOrEqualTo( score , 50);\n//分数   50\nquery.WhereGreaterThan( score , 50);\n//分数  = 50\nquery.WhereGreaterThanOrEqualTo( score , 50);  如果你想查询匹配几个不同值的数据，如：要查询“Barbie”,“Joe”,“Julia”三个人的成绩时，可以使用WhereContainedIn方法（查询“字段的值在指定集合中”的记录列表）来实现，示例代码如下：  query.WhereContainedIn( playerName , { Barbie ,  Joe ,  Julia });\n//或者使用下面的语句\nquery.WhereContainedIn( playerName ,  Barbie ,  Joe ,  Julia );", 
            "title": "条件查询"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_12", 
            "text": "在数据比较多的情况下，你往往需要显示加载一部分数据就可以了，这样可以节省用户的流量和提升数据加载速度，提高用户体验。这时候，我们使用Limit方法就可以限制查询结果的数据条数。默认情况下Limit的值为10，示例代码如下：  BmobQuery query = new BmobQuery();\n//设置最多返回20条记录\nquery.Limit( 20 );  在Limit的基础上进行分页显示数据的一个比较合理的解决办法是：使用SKip方法，跳过前多少条数据。默认情况下Skip的值为10，示例代码如下：  BmobQuery query = new BmobQuery();\n//忽略前20条数据\nquery.Skip(20);", 
            "title": "分页查询"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_13", 
            "text": "如果你想对游戏分数进行升序排序，示例代码可如下：  BmobQuery query = new BmobQuery();\nquery.OrderBy( score );  如果你想对游戏分数进行降序排序，示例代码可如下：  BmobQuery query = new BmobQuery();\nquery.OrderByDescending( score );  如果你想对两个或者以上的字段进行升序排序，如对score和cheatMode进行升序排序，示例代码如下：  BmobQuery query = new BmobQuery();\nquery.OrderBy( score ).ThenBy( cheatMode );  如果你想对两个或者以上的字段进行降序排序，如对score和cheatMode进行降序排序，示例代码如下：  BmobQuery query = new BmobQuery();\nquery.OrderByDescending( score ).ThenByDescending( cheatMode );  这些排序的方法还可以混合使用，具体详细用法不再详述。", 
            "title": "结果排序"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_14", 
            "text": "如果你想查询一个特定玩家玩的游戏场数，那么，示例代码可如下：  BmobQuery query = new BmobQuery();\nquery.WhereEqualTo( playerName ,  bmob );\nquery.Count ();\nbmobUnity.Find GameScore (TABLENAME, query, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    List GameScore  list = resp.results;\n    BmobInt count = resp.count;\n    print( 满足条件的对象个数为：   + count.Get());\n    foreach (var game in list)\n    {\n        print( 获取的对象为：   + game.ToString());\n    }\n});", 
            "title": "统计对象数量"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_15", 
            "text": "上面提到的查询语句都是and作为连接词的条件查询，但很多时候你还需要使用到“或（Or）”查询，如，你想查找GameScore表中 score 大于 90 或者 cheatMode 等于 true 的记录，示例代码如下：  BmobQuery q1 = new BmobQuery();\nq1.WhereGreaterThan( score , 90);\n\nBmobQuery q2 = new BmobQuery();\nq2.WhereEqualTo( cheatMode , true);\n\n//Or查询\nq1 = q1.Or(q2);  Or查询是可变参数方法，你可以在里面放更多的查询对象，当然了，在Or查询方法里面的参数连接词为and。", 
            "title": "或查询"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_16", 
            "text": "有的时候，一张表的数据列比较多，而我们只想查询返回某些列的数据时，我们可以使用BmobQuery对象提供的Select方法来实现。如从GameScore表中查找playerName的值的示例代码如下：  BmobQuery query = new BmobQuery();\nquery.Select( playerName );\nbmobUnity.Find GameScore (TABLENAME, query, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    List GameScore  list = resp.results;\n    foreach (var game in list)\n    {\n    }\n});  指定多列时多次调用即可，如：  BmobQuery query = new BmobQuery();\nquery.Select( playerName ,  score );", 
            "title": "查询指定列"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_17", 
            "text": "", 
            "title": "删除与修改数据"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_18", 
            "text": "更新一个对象也是非常简单。例如：将GameScore表中objectId为0c6db13c的游戏分数修改为77.  GameScore game = new GameScore();\ngame.score = 77;\nbmobUnity.Update(TABLENAME,  68ee8131ca , game, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 修改失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 修改成功, @  + resp.updatedAt);\n });", 
            "title": "修改数据"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_19", 
            "text": "从服务器删除对象。例如：将GameScore表中objectId为68ee8131ca的数据删除。  bmobUnity.Delete( GameScore ,  68ee8131ca , (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 删除失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 删除成功, @  + resp.msg);\n});", 
            "title": "删除数据"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_20", 
            "text": "", 
            "title": "数据关联"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_21", 
            "text": "数据可以和其他数据进行关联（使用BmobPointer关联类型），就像是传统数据库中的主外键关系一样，如：一条微博由一个用户发布，可以有多个用户评论，每条评论信息对应一个用户。这时候，微博表对应的对象模型就应该如下：  public class Weibo : BmobTable\n{\n    // 发布的微博\n    public string message { get; set; }\n    // 微博的作者\n    public BmobPointer BmobUser  user { get; set; }\n    // 微博的图片地址\n    public string pic;\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.message = input.getString( message );\n        this.user = input.Get BmobPointer BmobUser ( user );\n        this.pic = input.getString( pic );\n    }\n\n    public override void write(BmobOutput output, Boolean all)\n    {\n        base.write(output, all);\n\n        output.Put( message , this.message);\n        output.Put( user , this.user);\n        output.Put( pic , this.pic);\n    }\n}  评论表对应的对象模型就应该如下：  public class Comment : BmobTable\n{\n    // 用户的评论\n    public string comment { get; set; }\n    // 发布评论的用户\n    public BmobPointer BmobUser  user { get; set; }\n    // 评论的微博\n    public BmobPointer Weibo  weibo { get; set; }\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.comment = input.getString( comment );\n        this.user = input.Get BmobPointer BmobUser ( user );\n        this.weibo = input.Get BmobPointer Weibo ( weibo );\n    }\n\n    public override void write(BmobOutput output, Boolean all)\n    {\n        base.write(output, all);\n\n        output.Put( comment , this.comment);\n        output.Put( user , this.user);\n        output.Put( weibo , this.weibo);\n    }\n}", 
            "title": "关联数据的对象模型"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_22", 
            "text": "保存带有关联关系的评论表的数据的方法和保存其他数据模型的方法一样，还是使用BmobUnity对象的Create方法，示例代码如下：  //获取当前登录用户信息\nGameUser user = BmobUser.CurrentUser();\nvar comment = new Comment();\n// 设定评论内容\ncomment.comment =  发布的评论信息 ;\n// 设定评论人\ncomment.user = new BmobPointer BmobUser (user);\n// 设定评论对应的微博\nWeibo weibo = new Weibo();\nweibo.objectId =  ZGwboItm ;\ncomment.weibo = new BmobPointer Weibo (weibo);;    \n\nbmobUnity.Create(TABLENAME, comment, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 添加失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 添加成功, @  + resp.createAt);\n});", 
            "title": "添加关联关系"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_23", 
            "text": "关联对象的修改和普通BmobTable对象的修改一样，只需设置要更新的属性值，然后调用Update方法即可。下面假设将objectId为ef8e6agg28的评论记录的作者修改为其他人(这里是直接把当前用户的objectId设置为ZGwboItm)。  GameUser user = BmobUser.CurrentUser();\nuser.objectId =  ZGwboItm ;\nComment comment = new Comment();\n// SDK中有添加隐式转换，会把GameUser对象转换成BmobPointer GameUser \ncomment.user = user;\nbmobUnity.Update(TABLENAME,  ef8e6agg28 , comment, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 修改失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 修改成功, @  + resp.updatedAt);\n});", 
            "title": "修改关联对象"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_24", 
            "text": "如果你想要查询当前用户发表的所有评论信息，可以跟其他查询一样使用WhereEqualTo，示例代码如下：  BmobQuery query = new BmobQuery();\n//按发布时间降序排列\nquery.OrderByDescending( updatedAt );\n//获取当前用户信息\nGameUser user = BmobUser.CurrentUser();\n//查询当前用户的所有评论\nquery.WhereEqualTo( user , new BmobPointer BmobUser (user));    \n// or use\n// query.WhereMatchesQuery( user , user);\nbmobUnity.Find Comment (TABLENAME, query, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List Comment  commentList = resp.results;\n    foreach (var comment in commentList)\n    {\n        print( 获取的对象为：   + comment.ToString());\n    }\n});  如果你想要查询带有图片的微博的评论列表，即在Comment表中对Weibo表进行内部的查询，可以使用WhereMatchesQuery 方法(DOC:查询的对象中的某个列符合另一个指针值)进行内部查询：  Weibo wb = new Weibo();\n// Weibo对象赋值（条件赋值）\n\nBmobQuery query = new BmobQuery();\nquery.WhereMatchesQuery Weibo ( pic , new BmobPointer Weibo (wb)); \nbmobUnity.Find Comment (TABLENAME, query, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List Comment  commentList = resp.results;\n    foreach (var comment in commentList)\n    {\n        print( 获取的对象为：   + comment.ToString());\n    }\n});  反之，不想匹配某个子查询，你可以使用WhereDoesNotMatchQuery方法。 比如为了查询不带图片的微博的评论列表，就可以将上面的示例代码中的WhereMatchesQuery方法替换为WhereDoesNotMatchQuery方法。  如果你想获取最新的10条评论，同时包含这些评论对应的微博，实现代码可以为如下：  BmobQuery query = new BmobQuery();\n// 限制10条\nquery.Limit(10); \n//按创建时间排序\nquery.Order( createdAt ); \n//同时将对应的微博信息也查询出来\nquery.Include( weibo );\n//执行查询\nbmobUnity.Find Comment (TABLENAME, query, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List Comment  commentList = resp.results;\n    foreach (var comment in commentList)\n    {\n        print( 获取的对象为：   + comment.ToString());\n    }\n});  你可以使用 . 号（英语句号）操作符来并列获得 Include 中的内嵌的对象。比如，你同时想 Include 一个 Comment 的 weibo 和weibo的 user（微博发布者）对象，你可以这样做：  query.Include( weibo.user );", 
            "title": "查询关联对象"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_25", 
            "text": "用户是一个应用程序的核心。对于个人开发者来说，自己的应用程序积累到越多的用户，就会给自己带来越强的创作动力。因此Bmob提供了一个专门的用户类——BmobUser来自动处理用户账户管理所需的功能。  有了这个类，你就可以在你的应用程序中添加用户账户功能。  BmobUser是BmobTable的一个子类，它继承了BmobTable所有的方法，具有BmobTable相同的功能。不同的是，BmobUser增加了一些特定的关于用户账户管理相关的功能。", 
            "title": "用户"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_26", 
            "text": "BmobUser除了从BmobTable继承的属性外，还有几个特定的属性：    username: 用户的用户名（必需）。   password: 用户的密码（必需）。   email: 用户的电子邮件地址（可选）。", 
            "title": "属性"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_27", 
            "text": "创建用户对象如下：  BmobUser user = new BmobUser();  如果你需要扩展用户资料信息，如给用户表添加生命值life和攻击指数attack，那么需要创建一个新的用户类，继承自BmobUser。示例代码如下：  public class GameUser : BmobUser\n{\n    public BmobInt life { get; set; }\n    public BmobInt attack { get; set; }\n\n    public override void write(BmobOutput output, bool all)\n    {\n        base.write(output, all);\n\n        output.Put( life , this.life);\n        output.Put( attack , this.attack);\n    }\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.life = input.getInt( life );\n        this.attack = input.getInt( attack );\n    }\n}", 
            "title": "创建用户对象"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_28", 
            "text": "你的应用程序可能会要求用户注册。下面的代码是一个典型的注册过程：  BmobUser user = new BmobUser();\nuser.username =  bmob ;\nuser.password =  123456 ;\n//邮箱用于找回密码\nuser.email =  partnet@bmob.cn ;\n//如使用了GameUser表的话，以下注册语句需要更改为：bmobUnity.Signup MyBmobUser (user,(resp, exception) = \nbmobUnity.Signup(user,(resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 注册失败, 失败原因为：   + exception.Message);\n        return;\n    }\n    print( 注册成功 );\n});  在注册过程中，服务器会对注册用户信息进行检查，以确保注册的用户名和电子邮件地址是独一无二的。此外，对于用户的密码，你可以在应用程序中进行相应的加密处理后提交。  如果注册不成功，你可以查看返回的错误对象。最有可能的情况是，用户名或电子邮件已经被另一个用户注册。这种情况你可以提示用户，要求他们尝试使用不同的用户名进行注册。  你也可以要求用户使用Email做为用户名注册，这样做的好处是，你在提交信息的时候可以将输入的“用户名“默认设置为用户的Email地址，以后在用户忘记密码的情况下可以使用Bmob提供重置密码功能。  这里需要注意一点的是，有些时候你可能需要在用户注册时发送一封验证邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在应用设置- 邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在注册时自动发动一封验证给用户。", 
            "title": "注册用户"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_29", 
            "text": "", 
            "title": "设置邮箱验证功能"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_30", 
            "text": "当用户注册成功后，您需要让他们以后能够用注册的用户名登录到他们的账户使用应用。要做到这一点，你可以使用BmobUser类的login方法。  bmobUnity.Login GameUser ( bmob ,  123456 , (resp, exception) =  \n{\n    if (exception != null)\n    {\n        print( 登录失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 登录成功, @  + resp.username +  (  + resp.life +  )$[  + resp.sessionToken +  ] );\n    print( 登录成功, 当前用户对象Session：   + BmobUser.CurrentUser.sessionToken);\n});", 
            "title": "登录用户"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_31", 
            "text": "登录之后，你可以通过如下示例代码获取当前登录用户的信息：  BmobUser buser = BmobUser.CurrentUser;\n// 或者\nGameUser user = BmobUser.CurrentUser as GameUser;", 
            "title": "获取当前用户"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_32", 
            "text": "很多情况下你可能需要修改用户信息，比如你的应用具备修改个人资料的功能，示例代码如下：  GameUser user = new GameUser();\nuser.attack = 1000;\n//需要知道用户记录的objectId和sessionToken信息\nbmobUnity.UpdateUser( objectid , user,  sessionToken , (resp, exception) = \n{\n    if (updateException != null)\n    {\n        print( 保存失败, 失败原因为：   + updateException.Message);\n        return;\n    }\n\n    print( 保存成功, @  + updateResp.updatedAt);\n});  在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发一封邮件验证信息给用户。", 
            "title": "更新用户"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_33", 
            "text": "查询用户和查询普通对象一样，只需指定BmobUser类即可，如下查询用户名为bmob的用户：  BmobQuery query = new BmobQuery();\nquery.WhereEqualTo( username ,  bmob );\nbmobUnity.Find GameUser (BmobUser.TABLE, query, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    List GameUser  list = resp.results;\n    foreach (var user in list)\n    {\n        print( 获取的对象为：   + user.ToString());\n    }\n});", 
            "title": "查询用户"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_34", 
            "text": "一旦你引入了一个密码系统，那么肯定会有用户忘记密码的情况。对于这种情况，我们提供了一种方法，让用户安全地重置起密码。  重置密码的流程很简单，开发者只需要求用户输入注册的电子邮件地址即可，示例代码如下：  bmobUnity.Reset( support@bmob.cn , (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 重置密码请求失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 重置密码请求发送成功！ );\n});  密码重置流程如下：   用户输入他们的电子邮件，请求重置自己的密码。  Bmob向他们的邮箱发送一封包含特殊的密码重置连接的电子邮件。  用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，根据提示他们可以输入一个新的密码。  用户的密码已被重置为新输入的密码。", 
            "title": "密码重置"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_35", 
            "text": "设置邮件验证是一个可选的应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会被默认设为false，如果应用设置中开启了邮箱认证功能，Bmob会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.  emailVerified 字段有 3 种状态可以考虑：   true : 用户可以点击邮件中的链接通过Bmob来验证地址，一个用户永远不会在新创建这个值的时候显示emailVerified为true。  false : 用户(User)对象最后一次被刷新的时候, 用户并没有确认过他的邮箱地址, 如果你看到emailVerified为false的话，你可以考虑刷新用户(User)对象。  missing : 用户(User)对象已经被创建，但应用设置并没有开启邮件验证功能； 或者用户(User)对象没有email邮箱。", 
            "title": "邮箱验证"
        }, 
        {
            "location": "/data/csharp/develop_doc/#email", 
            "text": "发送给用户的邮箱验证邮件会在一周内失效，可以通过调用 EmailVerify 来强制重新发送：  bmobUnity.EmailVerify( support@bmob.cn , (resp, exception) =  \n{\n    if (exception != null)\n    {\n        print( 邮箱验证请求失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 邮箱验证请求发送成功！ );\n});", 
            "title": "请求验证Email"
        }, 
        {
            "location": "/data/csharp/develop_doc/#acl", 
            "text": "数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看Bmob数据与安全页面，了解Bmob如何保护数据安全）。  其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。  大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：   对于私有数据，读写权限可以只局限于数据的所有者。  对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。  对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。  属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。  一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。  用Bmob SDK，你可以对这些数据设置一个默认的ACL，这样，即使黑客反编译了你的应用，获取到Application Key，也仍然无法操作和破坏你的用户数据，确保了用户数据的安全可靠。而作为开发者，当你需要对这些数据进行管理时，可以通过超级权限Key（Master Key）进行。", 
            "title": "ACL和角色"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_36", 
            "text": "在没有显示指定的情况下，每一个BmobTable中的ACL(列)属性的默认值是所有人可读可写的。在客户端想要修改这个权限设置，只需要简单调用BmobACL的ReadAccess方法和WriteAccess方法，如设置所有用户的读权限为true，写权限为false的示例代码如下：  BmobACL acl = new BmobACL();\nacl.ReadAccess( * );  这里说明一点的是：  * 号表示所有用户。ACL列为空表示所有用户可读可写；在不为空的情况下，读或写空缺表示没有对应权限。", 
            "title": "默认访问权限"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_37", 
            "text": "如果你想对发表的微博设定一个权限：发表微博的作者有修改和删除的权限，其他用户只有读的权限，那么，可用如下的示例代码：  //创建数据对象\nWeibo weibo = new Weibo();\nweibo.message =  论电影的七个元素 ;\n//创建一个ACL对象\nBmobACL acl = new BmobACL();    \n//设置所有人可读\nacl.ReadAccess( * );\n//参数是用户的objectId，这里设置为当前用户可写    \nacl.WriteAccess(BmobUser.CurrentUser().objectId);   \n//设置这条数据的ACL信息\nweibo.ACL = acl;    \nbmobUnity.Create(TABLENAME, weibo, (resp, exception) = \n{\n    if(exception != null){\n        print( 保存失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 保存成功, @  + resp.createdAt);\n});  如果要设定只有微博的作者有读写权限，其他人都没有读写权限，那么，可用如下的示例代码：  //创建数据对象\nWeibo weibo = new Weibo();\nweibo.message =  论电影的七个元素 ;\n//创建一个ACL对象\nBmobACL acl = new BmobACL();    \n//参数是用户的objectId，这里设置为当前用户可读\nacl.ReadAccess(BmobUser.CurrentUser().objectId);\n//参数是用户的objectId，这里设置为当前用户可写    \nacl.WriteAccess(BmobUser.CurrentUser().objectId);   \n//设置这条数据的ACL信息\nweibo.ACL = acl;    \nbmobUnity.Create(TABLENAME, weibo, (resp, exception) = \n{\n    if(exception != null){\n        print( 保存失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 保存成功, @  + resp.createdAt);\n});", 
            "title": "指定用户的访问权限"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_38", 
            "text": "上面的指定用户访问权限虽然很方便，但是对于有些应用可能会有一定的局限性。比如一家公司的工资系统，员工和公司的出纳们只拥有工资的读权限，而公司的人事和老板才拥有全部的读写权限。要实现这种功能，你也可以通过设置每个用户的ACL权限来实现，如下：  //创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.Wage = 100000;   \n\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser boss;\nBmobUser hr_zhang;\nBmobUser cashier_xie;\nBmobUser me;\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\n\n//设置四个用户读的权限\nacl.ReadAccess(boos.objectId);    \nacl.ReadAccess(hr_zhang.objectId);\nacl.ReadAccess(cashier_xie.objectId);\nacl.ReadAccess(me.objectId);\n\n//设置老板和人事小张对这个工资的写权限\nacl.WriteAccess(boss.objectId);\nacl.WriteAccess(hr_zhang.objectId);\n\n//设置工资对象的ACL\nwageinfo.ACL =acl;\nbmobUnity.Create(TABLENAME, wageinfo, (resp, exception) = \n{\n    if(exception != null){\n        print( 保存失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 保存成功, @  + resp.createdAt);\n});  但是，一个公司的人事、出纳和员工不仅仅只有一个人，同时还会有离职、调换岗位以及新员工加入等问题存在。如果用上面的代码对公司的每个人进行一一设置的话是不现实的，既麻烦也很难维护。针对这个问题，我们可以利用BmobRole来解决。我们只需要对用户进行分类，每个分类赋予不同的权限。如下代码实现：  //这里创建四个用户对象指针，分别为老板、人事小张、出纳小谢和自己\n// just for test\nBmobPointer BmobUser  boss = new BmobUser() { objectId =  1  };\nBmobPointer BmobUser  hr_zhang = new BmobUser() { objectId =  2  };\nBmobPointer BmobUser  hr_luo = new BmobUser() { objectId =  3  };\nBmobPointer BmobUser  cashier_xie = new BmobUser() { objectId =  4  };\nBmobPointer BmobUser  me = new BmobUser() { objectId =  5  };\n\n{\n    //创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\n    BmobRole hr = new BmobRole();\n    hr.name =  HR ;\n    var users = new BmobRelation BmobUser ();\n    users.Add(hr_zhang);\n    users.Add(hr_luo);\n\n    //将hr_zhang和hr_luo归属到hr角色中\n    hr.AddUsers(users);\n\n    //保存到云端角色表中（web端可以查看Role表）\n    var future = Bmob.CreateTaskAsync(hr);\n    FinishedCallback(future.Result, null);\n}\n\n{\n    BmobRole cashier = new BmobRole();\n    cashier.name =  Cashier ;\n    var users = new BmobRelation BmobUser ();\n    users.Add(cashier_xie);\n\n    //将cashier_xie归属到cashier角色中\n    cashier.AddUsers(users);\n\n    //保存到云端角色表中（web端可以查看Role表）\n    var future = Bmob.CreateTaskAsync(cashier);\n    FinishedCallback(future.Result, null);\n}  根据Role设置ACL：  //创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.Wage =100000;\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\nacl.setReadAccess(boos, true); // 假设老板只有一个, 设置读权限\nacl.setReadAccess(me, true); // 给自己设置读权限\n// 给hr角色设置读权限\nacl.RoleReadAccess(hr.name);\n// 给cashier角色设置读权限\nacl.RoleReadAccess(cashier.name);\n\n// 设置老板拥有写权限\nacl.RoleWriteAccess(boss.name);\n// 设置hr角色拥有写权限\nacl.RoleWriteAccess(hr.name);\n\n//设置工资对象的ACL\nwageinfo.ACL = acl;\n//添加数据\nbmobUnity.Create(TABLENAME, wageinfo, null);  需要说明一点的是，Web端的Role表也具有ACL的列，你可以将角色管理的权限赋予某些用户。", 
            "title": "角色管理"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_39", 
            "text": "Bmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询，可以轻松实现查找出离当前用户最接近的信息或地点的功能。", 
            "title": "地理位置"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_40", 
            "text": "首先需要创建一个BmobGeoPoint对象。例如，创建一个北纬39.913768382429105度-东经116.39727786183357度的BmobGeoPoint对象：  BmobGeoPoint point = new BmobGeoPoint(39.913768382429105, 116.39727786183357);", 
            "title": "创建地理位置对象"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_41", 
            "text": "现在，你的数据表中有了一定的地理坐标对象的数据， 就可以使用BmobQuery对象的WhereNear方法来找出最接近某个点的信息，示例代码如下（假设Person表中有一个名为area的地理坐标类型的字段）：  BmobQuery query = new BmobQuery();\nbmobQuery.WhereNear( area , new BmobGeoPoint(112.934755, 24.52065));\nbmobQuery.Limit(10);    //获取最接近用户地点的10条数据\nbmobUnity.Find Person ( Person , bmobQuery, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List Person  list = resp.results;\n    foreach (var p in list)\n    {\n        print( 获取的对象为：   + p.ToString());\n    }\n});  要限制查询指定距离范围的数据可以使用WhereWithinDistance，即：  //(112.934755, 24.52065)坐标点10公里内\nquery.WhereWithinDistance( area , new BmobGeoPoint(112.934755, 24.52065), 10);  要查询一个矩形范围内的信息可以使用addWhereWithinGeoBox来实现：  BmobGeoPoint southwestOfSF = new BmobGeoPoint(116.10675, 39.711669);\nBmobGeoPoint northeastOfSF = new BmobGeoPoint(116.627623, 40.143687);\nBmobQuery query = new BmobQuery();\nquery.WhereWithinGeoBox( area , southwestOfSF, northeastOfSF);\nbmobUnity.Find Person ( Person , bmobQuery, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List Person  list = resp.results;\n    foreach (var p in list)\n    {\n         print( 获取的对象为：   + p.ToString());\n    }\n});  注意事项 目前有几个需要注意的地方：   每个BmobTable数据对象中只能有一个BmobGeoPoint对象。  地理位置的点不能超过规定的范围。纬度的范围应该是在-90.0到90.0之间。经度的范围应该是在-180.0到180.0之间。如果您添加的经纬度超出了以上范围，将导致程序错误。", 
            "title": "查询地理位置信息"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_42", 
            "text": "很多游戏可能会有计数器功能的需求，比如某个玩家的比赛总分score。Bmob提供了非常便捷的方式来保证原子性的修改某一记录（这条记录的objectId为28dd44a271）某字段的值。示例代码如下：  GameScore object = new GameScore();\nobject.Increment( score , 1000);\n//28dd44a271为这条记录的objectId\nbmobUnity.Update(TABLENAME,  28dd44a271 , object, FinishedCallback);", 
            "title": "原子计数器"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_43", 
            "text": "Bmob可以让你将文件存储到服务器中，常见的文件类型，如图像文件、影像文件、音乐文件和任何其他二进制数据，都可以直接上传到云端文件系统中，示例代码如下：  bmobUnity.FileUpload( C:/Intel/Logs/IntelGFXCoin.log , (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 上传失败, 失败原因为：   + exception.Message);\n        return;\n    }\n    print( 上传成功，返回数据：   + resp.ToString());\n});  resp的返回值为UploadCallbackData对象：  // 文件名\npublic string filename { get; set; }\n/// 文件组名\npublic string group { get; set; }\n/// 相对于Bmob文件服务器的位置\npublic string url { get; set; }\n/// 文件请求的地址\npublic string getPath()  这里需要说明一点的是：单个上传的文件大小不可超过10M。   与结合用户表实例   一些用户不知道上传的附件和其他表结合怎么使用。下面介绍实际的案例：上传用户的头像  对象类：      public class GameUser : BmobUser\n    {\n        public BmobFile File{get; set;}\n\n        public override void readFields(BmobInput input)\n        {\n            base.readFields(input);\n\n            this.File = input.Get BmobFile ( file );\n        }\n\n        public override void write(BmobOutput output, Boolean all)\n        {\n            base.write(output, all);\n\n            output.Put( file , this.File);\n        }\n\n    }  上传图片，并把图片保存到新用户User记录：      Byte[] data = null;\n    using (var stream = File.OpenRead( C:/Users/winse/Desktop/1.png ))\n    {\n        data = stream.ReadAsBytes();\n    }\n\n    var ffuture = Bmob.FileUploadTaskAsync(new BmobLocalFile(data,  21.png ));\n\n    GameUser user = new GameUser();\n    user.email =  1324@qq.com ;\n    user.phone =  1234 ;\n    user.username =  1234 ;\n    user.password =  123 ;\n\n    user.File = ffuture.Result;\n\n    var future = Bmob.SignupTaskAsync(user);\n    var signResponse = future.Result;\n...", 
            "title": "文件"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_44", 
            "text": "云端代码的调用方法非常简单，如下为调用执行云端方法test的实现代码：  Bmob.Endpoint Hashtable ( test , (resp, exception) =  \n{\n    if (exception != null)\n    {\n        print( 调用失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 返回对象为：   + resp);\n});  相关云端代码的编写方式，请参考云端代码开发文档。  C#调用云端代码的返回值为json字符串，即不能只返回一个单值的对象！   不正确的使用方式：   function onRequest(request, response, modules) {\nresponse.end( just string... );\n}                 C#中正确的方式：   云端代码：  function onRequest(request, response, modules) {\n    var res =  { value :  just string... } ;\n    response.end(JSON.stringify(res));\n}                           C#调用代码：  [TestMethod()]\npublic void EndpointParamAndStringTest()\n{\n    var p = new Dictionary String, Object ();\n\n    var future = Bmob.EndpointTaskAsync Object ( testString , p);\n    FinishedCallback(future.Result, null);\n}   带参数返回map和list的例子   [TestMethod()]\npublic void EndPointTest()\n{\n    //var future = Bmob.EndpointTaskAsync QueryCallbackData Object ( second , null);\n    //FinishedCallback(future.Result, null);\n\n    var future = Bmob.EndpointTaskAsync List object ( testParam , new BmobKV().Put( a ,  winse ));\n    FinishedCallback(future.Result, null);\n\n--\n\nfunction onRequest(request, response, modules) {\n\n    //获取数据库对象 \n    var db = modules.oData; \n\n    var name = request.body.a;\n    //获取\n    db.find({ \n        table:'StudentScore',\n         where :{ name :name}  \n    },function(err,data){\n        response.send(JSON.parse(data).results);\n    }); \n\n}", 
            "title": "云端代码"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_45", 
            "text": "在BmobWindows对象中提供了一个方法，用于获取服务器时间。  BmobWindows bmobWindows = new BmobWindows();\nbmobWindows.Timestamp( (resp, exception) =  \n{\n    if (exception != null)\n    {\n        print( 请求失败, 失败原因为：   + exception.Message);\n        return;\n    }\n    //返回服务器时间（单位：秒）\n    print( 返回时间戳为：   + resp.timestamp); \n    print( 返回格式化的日期为：   + resp.datetime); \n}\n);", 
            "title": "获取服务器时间"
        }, 
        {
            "location": "/data/csharp/develop_doc/#_46", 
            "text": "BmobDate对应服务端的Date类型。以 yyyy-MM-dd HH:mm:ss 的格式进行传输。  SDK提供了DateTime到BmobDate的隐式转化，简化BmobDate的实例化。  例如，查询在某个时间段内新增的数据，由于一个字段涉及到两个条件，需要使用符合查询功能：  BmobDate start = new DateTime(2014, 10, 1);\nBmobDate end = new DateTime(2015, 1, 1);\n\nvar startQuery = new BmobQuery();\nstartQuery.WhereGreaterThanOrEqualTo( createdAt , start);\n\nvar endQuery = new BmobQuery();\nendQuery.WhereLessThan( createdAt , end);\n\nvar query = startQuery.And(endQuery);\nquery.Limit(0);\nquery.Count();\n\nvar future = Bmob.FindTaskAsync Object (TABLENAME, query);\n// 处理结果\n// var result = future.Result;", 
            "title": "时间"
        }, 
        {
            "location": "/data/csharp/develop_doc/#faq", 
            "text": "请求信息查看   在开发过程中，其实很多问题开发者自己多确认下就能解决问题。SDK提供了查看发送请求到服务端的开关，只需要注册一下调试信息的输出方法即可。  BmobDebug.Register(msg =  { Debug.WriteLine(msg); });\nBmobDebug.level = BmobDebug.Level.TRACE;  在输出窗口，可以查看每次请求的appkey、请求数据。   关于Task，以及Windowsphone开发UI线程问题   新版本的SDK针对每个原有接口增加了对应Task接口方法，方便异步调用。这样就没有必要每次都callback回调，如果调用是多个线性的请求，那么使用callback代码会很难理解。  如果是开发desktop的应用，还可以等待结果的返回，但是在手机端，系统不允许有长时间等待的，要么使用callback要么使用异步。  使用回调：           private void create_Click(object sender, RoutedEventArgs e)\n        {\n            BmobApi table = new BmobApi();\n            table.name =  hello wp ;\n            Bmob.Create(TABLE_NAME, table, (resp, ex) = \n            {\n                string status =  OK ;\n                if (ex != null)\n                {\n                    status =  ERROR ;\n                }\n\n                Dispatcher.BeginInvoke(() = \n                               {\n                                   updateStatus(create, status);\n                               });\n            });\n        }  注意：在回调用如果需要更新UI，需要转到UI线程才行。  使用异步：  // async方式异步请求处理，非阻塞访问\n        private async void uploadBtn_Click(object sender, EventArgs e)\n        {\n            formstatus.Text =  正在上传... ;\n\n            var Result = await Bmob.FileUploadTaskAsync(fileText.Text);\n            FinishedCallback(Result, resultText);\n\n            bmobFile = Result;\n\n            enterDba.Enabled = true;\n            formstatus.Text =  上传成功！ ;\n        }", 
            "title": "FAQ"
        }, 
        {
            "location": "/data/csharp/example/", 
            "text": "快速入门相关源码\nhttp://www.bmob.cn/static/Bmob_unity_quickstart.zip\n\n\n有关C#相关的案例源码大家可以移步Github代码仓库：\nhttps://github.com/bmob/bmob-demo-csharp", 
            "title": "示例/功能"
        }, 
        {
            "location": "/data/go/", 
            "text": "准备工作\n\n\nSDK下载\n\n\ngo get github.com/bmob/bmob-go-sdk\n\n\n运行效果\n\n\n打开项目中的\nexamples/main.go\n文件，可以看到如何使用Go SDK相关的方法。\n\n\npackage main\n\nimport (\n    \nlog\n\n\n    \ngithub.com/bmob/bmob-go-sdk\n\n)\n\nvar (\n    appConfig = bmob.RestConfig{\n,\n        \n}\n)\n\ntype TestData struct {\n    Score string\n    //data  DataType\n}\n\ntype MyRes struct {\n    bmob.RestResponse\n    bmob.ImageResponse\n}\n\ntype TestDataRes struct {\n    TestData\n    MyRes\n}\n\nfunc main() {\n    a := bmob.RestResponse{}\n    log.Println(a)\n    log.Println(\n****************************************\n)\n    var respDst = TestDataRes{}\n\n    header, err := bmob.DoRestReq(appConfig,\n        bmob.RestRequest{\n            bmob.BaseReq{\n                \nGET\n,\n                bmob.ApiRestURL(\nGameScore\n) + \n/\n,\n                \n},\n            \napplication/json\n,\n            nil},\n        \nrespDst)\n    if err == nil {\n        log.Println(header)\n        log.Println(respDst)\n    } else {\n        log.Panic(err)\n    }\n\n    log.Println(\n****************************************\n)\n}\n\n\n\n\n类库说明\n\n\n\n\n\n\nRestConfig - Bmob配置类，使用的时候需要修改里面的配置信息\n\n\n\n\n\n\n数据类型 - 封装了Bmob预定义的数据类型，用户可在此基础上进行定制，在users.go等文件里定义\n\n\n\n\n\n\nDoRestRequest - Bmob基础方法，用于完成REST API请求\n\n\n\n\n\n\nBmob官方信息\n\n\n官方网址：\nhttp://www.bmob.cn\n\n\n问答社区：\nhttp://wenda.bmob.cn\n\n\n技术邮箱：support@bmob.cn", 
            "title": "快速入门"
        }, 
        {
            "location": "/data/go/#_1", 
            "text": "", 
            "title": "准备工作"
        }, 
        {
            "location": "/data/go/#sdk", 
            "text": "go get github.com/bmob/bmob-go-sdk", 
            "title": "SDK下载"
        }, 
        {
            "location": "/data/go/#_2", 
            "text": "打开项目中的 examples/main.go 文件，可以看到如何使用Go SDK相关的方法。  package main\n\nimport (\n     log \n\n     github.com/bmob/bmob-go-sdk \n)\n\nvar (\n    appConfig = bmob.RestConfig{ ,\n         }\n)\n\ntype TestData struct {\n    Score string\n    //data  DataType\n}\n\ntype MyRes struct {\n    bmob.RestResponse\n    bmob.ImageResponse\n}\n\ntype TestDataRes struct {\n    TestData\n    MyRes\n}\n\nfunc main() {\n    a := bmob.RestResponse{}\n    log.Println(a)\n    log.Println( **************************************** )\n    var respDst = TestDataRes{}\n\n    header, err := bmob.DoRestReq(appConfig,\n        bmob.RestRequest{\n            bmob.BaseReq{\n                 GET ,\n                bmob.ApiRestURL( GameScore ) +  / ,\n                 },\n             application/json ,\n            nil},\n         respDst)\n    if err == nil {\n        log.Println(header)\n        log.Println(respDst)\n    } else {\n        log.Panic(err)\n    }\n\n    log.Println( **************************************** )\n}", 
            "title": "运行效果"
        }, 
        {
            "location": "/data/go/#_3", 
            "text": "RestConfig - Bmob配置类，使用的时候需要修改里面的配置信息    数据类型 - 封装了Bmob预定义的数据类型，用户可在此基础上进行定制，在users.go等文件里定义    DoRestRequest - Bmob基础方法，用于完成REST API请求", 
            "title": "类库说明"
        }, 
        {
            "location": "/data/go/#bmob", 
            "text": "官方网址： http://www.bmob.cn  问答社区： http://wenda.bmob.cn  技术邮箱：support@bmob.cn", 
            "title": "Bmob官方信息"
        }, 
        {
            "location": "/data/go/develop_doc/", 
            "text": "简介\n\n\nBmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。\nGo SDK封装了Bmob RESTful API，但并不包含功能封装，如果需要调用具体的功能，请参考官方RESTful API开发文档\nhttp://docs.bmob.cn/data/Restful/b_developdoc/doc/index.html\n\n\n快速入门\n\n\n建议您在阅读本开发文档之前，先阅读我们提供的 \ngo快速入门文档\n，便于您后续的开发。\n\n\n应用程序\n\n\n在Bmob平台注册后，每个账户可创建多个应用程序，创建的每个应用程序有各自的Application ID，应用程序将凭其Application ID使用Bmob SDK。\n\n\n应用安全\n\n\n请大家在使用Bmob开发应用程序之前，仔细阅读“数据与安全”的文档：\nhttp://docs.bmob.cn/other/Other/m_bql/doc/index.html\n\n\n数据类型\n\n\n除了JSON标准里定义的数据类型外，还支持Bmob自定义的数据类型：\nhttp://docs.bmob.cn/data/Restful/b_developdoc/doc/index.html#对象\n\n这些类型操作相关的基本数据结构在types.go中定义，由于JSON是schema-less的，你可以只填充必要的字段来完成操作\n\n\nRESTful请求\n\n\n一次典型的RESTFul请求如下：\n\n\n  header, err := bmob.DoRestReq(appConfig,\n    bmob.RestRequest{\n      bmob.BaseReq{\n        \nGET\n,\n        bmob.ApiRestURL(\nGameScore\n) + \n/\n,\n        \n},\n      \napplication/json\n,\n      nil},\n    \nrespDst}\n  if err == nil {\n    log.Println(header}\n    log.Println(respDst}\n  } else {\n    log.Panic(err}\n  }\n\n\n\n\n参数：\n\n appConfig - 保存了APP相关的key等信息\n\n RestRequest - 使用Bmob RESTful API 所需的信息： {方法， url， sessionToken}， 数据类型， body\n\n respDst - 用于保存解析后的response\n返回值：\n\n header - http.Header， 请求返回的标准HTTP头\n* err - 错误信息\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\ncreatedAt\n:{\n$gte\n:{\n__type\n:\nDate\n,\niso\n:\n2011-08-21 18:02:52\n}}}' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n再一次请求中，你需要指定的HTTP方法，URL，sessionToken等均可以在BaseReq中指定，\nAPP验证需要的KEY等在RestConfig中指定\n数据段则在转成[]byte类型后传入\n上传不同类型的格式时，需要指定编码格式，默认为text/plain，\n\n\n数据对象\n\n\nBmob请求格式化数据时，body为JSON格式，用户可以自定义需要的字段，但是由于返回的数据会附加Bmob预定义的字段，所以需要单独处理。 SDK中采取的写法如下：\n\n\ntype TestDataType struct {\n  Score string\n  data  DataType\n}\n\ntype TestDataRes struct {\n  TestData\n  bmob.RestResponse\n}\n\n\n\n\n通过继承自定义的Response结构体，我们可以同时解析返回的数据里的用户定义数据和系统定义数据。\n\n\nRestResponse包含了解析最常用的请求响应所需的字段，如果需要其他解析其他请求的响应，可以继承SDK中提供的相应的结构体，如ImageResponse\n\n\ntype MyRes struct {\n  bmob.RestResponse\n  bmob.ImageResponse\n}\n\n\n\n\n这个结构体可以解析标准的RESTful响应和Image请求相关的响应", 
            "title": "开发文档"
        }, 
        {
            "location": "/data/go/develop_doc/#_1", 
            "text": "Bmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。\nGo SDK封装了Bmob RESTful API，但并不包含功能封装，如果需要调用具体的功能，请参考官方RESTful API开发文档 http://docs.bmob.cn/data/Restful/b_developdoc/doc/index.html", 
            "title": "简介"
        }, 
        {
            "location": "/data/go/develop_doc/#_2", 
            "text": "建议您在阅读本开发文档之前，先阅读我们提供的  go快速入门文档 ，便于您后续的开发。", 
            "title": "快速入门"
        }, 
        {
            "location": "/data/go/develop_doc/#_3", 
            "text": "在Bmob平台注册后，每个账户可创建多个应用程序，创建的每个应用程序有各自的Application ID，应用程序将凭其Application ID使用Bmob SDK。", 
            "title": "应用程序"
        }, 
        {
            "location": "/data/go/develop_doc/#_4", 
            "text": "请大家在使用Bmob开发应用程序之前，仔细阅读“数据与安全”的文档： http://docs.bmob.cn/other/Other/m_bql/doc/index.html", 
            "title": "应用安全"
        }, 
        {
            "location": "/data/go/develop_doc/#_5", 
            "text": "除了JSON标准里定义的数据类型外，还支持Bmob自定义的数据类型： http://docs.bmob.cn/data/Restful/b_developdoc/doc/index.html#对象 \n这些类型操作相关的基本数据结构在types.go中定义，由于JSON是schema-less的，你可以只填充必要的字段来完成操作", 
            "title": "数据类型"
        }, 
        {
            "location": "/data/go/develop_doc/#restful", 
            "text": "一次典型的RESTFul请求如下：    header, err := bmob.DoRestReq(appConfig,\n    bmob.RestRequest{\n      bmob.BaseReq{\n         GET ,\n        bmob.ApiRestURL( GameScore ) +  / ,\n         },\n       application/json ,\n      nil},\n     respDst}\n  if err == nil {\n    log.Println(header}\n    log.Println(respDst}\n  } else {\n    log.Panic(err}\n  }  参数：  appConfig - 保存了APP相关的key等信息  RestRequest - 使用Bmob RESTful API 所需的信息： {方法， url， sessionToken}， 数据类型， body  respDst - 用于保存解析后的response\n返回值：  header - http.Header， 请求返回的标准HTTP头\n* err - 错误信息  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ createdAt :{ $gte :{ __type : Date , iso : 2011-08-21 18:02:52 }}}' \\\n    https://api.bmob.cn/1/classes/GameScore  再一次请求中，你需要指定的HTTP方法，URL，sessionToken等均可以在BaseReq中指定，\nAPP验证需要的KEY等在RestConfig中指定\n数据段则在转成[]byte类型后传入\n上传不同类型的格式时，需要指定编码格式，默认为text/plain，", 
            "title": "RESTful请求"
        }, 
        {
            "location": "/data/go/develop_doc/#_6", 
            "text": "Bmob请求格式化数据时，body为JSON格式，用户可以自定义需要的字段，但是由于返回的数据会附加Bmob预定义的字段，所以需要单独处理。 SDK中采取的写法如下：  type TestDataType struct {\n  Score string\n  data  DataType\n}\n\ntype TestDataRes struct {\n  TestData\n  bmob.RestResponse\n}  通过继承自定义的Response结构体，我们可以同时解析返回的数据里的用户定义数据和系统定义数据。  RestResponse包含了解析最常用的请求响应所需的字段，如果需要其他解析其他请求的响应，可以继承SDK中提供的相应的结构体，如ImageResponse  type MyRes struct {\n  bmob.RestResponse\n  bmob.ImageResponse\n}  这个结构体可以解析标准的RESTful响应和Image请求相关的响应", 
            "title": "数据对象"
        }, 
        {
            "location": "/data/javascript/", 
            "text": "注册Bmob帐号\n\n\n在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。\n\n\n\n\n网站后台创建应用\n\n\n登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。\n\n\n\n\n获取应用密钥和下载SDK\n\n\n选择你要开发的应用，进入该应用\n\n\n\n\n在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID\n\n\n\n\n获取Application ID和REST API Key后，下载SDK。\n\n\n安装BmobSDK\n\n\n一、把下面这行代码加入你的页面中，其中，\"bmob-min.js\"为SDK文件：\n\n\nscript src=\nbmob-min.js\n/script\n\n\n\n\n\n二、接着是加入下面这行代码进行初始化\n\n\nBmob.initialize(\n你的Application ID\n, \n你的REST API Key\n);\n\n\n\n\n\n添加一行数据\n\n\n添加数据\n\n\n    var GameScore = Bmob.Object.extend(\nGameScore\n);\n    var gameScore = new GameScore();\n    gameScore.set(\nscore\n, 1337);\n    gameScore.save(null, {\n      success: function(object) {\n        alert(\ncreate object success, object id:\n+object.id);\n      },\n      error: function(model, error) {\n        alert(\ncreate object fail\n);\n      }\n    });\n\n\n\n\n获取一行数据\n\n\n    var GameScore = Bmob.Object.extend(\nGameScore\n);\n    var query = new Bmob.Query(GameScore);\n    query.get(\n4edc3f6ee9\n, {\n      success: function(object) {\n        // The object was retrieved successfully.\n        alert(object.get(\nscore\n));\n      },\n      error: function(object, error) {\n        alert(\nquery object fail\n);\n      }\n    });\n\n\n\n\n修改一行数据\n\n\n    var GameScore = Bmob.Object.extend(\nGameScore\n);\n    var query = new Bmob.Query(GameScore);\n    query.get(\n4edc3f6ee9\n, {\n      success: function(object) {\n        // The object was retrieved successfully.\n        object.set(\nscore\n, 1338);\n        object.save(null, {\n          success: function(objectUpdate) {\n            alert(\ncreate object success, object score:\n+objectUpdate.get(\nscore\n));\n          },\n          error: function(model, error) {\n            alert(\ncreate object fail\n);\n          }\n        });\n      },\n      error: function(object, error) {\n        alert(\nquery object fail\n);\n      }\n    });\n\n\n\n\n删除一行数据\n\n\n    var GameScore = Bmob.Object.extend(\nGameScore\n);\n    var query = new Bmob.Query(GameScore);\n    query.get(\n4edc3f6ee9\n, {\n      success: function(object) {\n        // The object was retrieved successfully.\n        object.destroy({\n          success: function(deleteObject) {\n          alert(\ndelete success\n);\n          },\n          error: function(GameScoretest, error) {\n          alert(\ndelete fail\n);\n          }\n        });\n      },\n      error: function(object, error) {\n        alert(\nquery object fail\n);\n      }\n    });\n\n\n\n\n源码下载\n\n\n快速入门相关源码下载", 
            "title": "快速入门"
        }, 
        {
            "location": "/data/javascript/#bmob", 
            "text": "在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。", 
            "title": "注册Bmob帐号"
        }, 
        {
            "location": "/data/javascript/#_1", 
            "text": "登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。", 
            "title": "网站后台创建应用"
        }, 
        {
            "location": "/data/javascript/#sdk", 
            "text": "选择你要开发的应用，进入该应用   在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID   获取Application ID和REST API Key后，下载SDK。", 
            "title": "获取应用密钥和下载SDK"
        }, 
        {
            "location": "/data/javascript/#bmobsdk", 
            "text": "一、把下面这行代码加入你的页面中，其中，\"bmob-min.js\"为SDK文件：  script src= bmob-min.js /script   二、接着是加入下面这行代码进行初始化  Bmob.initialize( 你的Application ID ,  你的REST API Key );", 
            "title": "安装BmobSDK"
        }, 
        {
            "location": "/data/javascript/#_2", 
            "text": "添加数据      var GameScore = Bmob.Object.extend( GameScore );\n    var gameScore = new GameScore();\n    gameScore.set( score , 1337);\n    gameScore.save(null, {\n      success: function(object) {\n        alert( create object success, object id: +object.id);\n      },\n      error: function(model, error) {\n        alert( create object fail );\n      }\n    });", 
            "title": "添加一行数据"
        }, 
        {
            "location": "/data/javascript/#_3", 
            "text": "var GameScore = Bmob.Object.extend( GameScore );\n    var query = new Bmob.Query(GameScore);\n    query.get( 4edc3f6ee9 , {\n      success: function(object) {\n        // The object was retrieved successfully.\n        alert(object.get( score ));\n      },\n      error: function(object, error) {\n        alert( query object fail );\n      }\n    });", 
            "title": "获取一行数据"
        }, 
        {
            "location": "/data/javascript/#_4", 
            "text": "var GameScore = Bmob.Object.extend( GameScore );\n    var query = new Bmob.Query(GameScore);\n    query.get( 4edc3f6ee9 , {\n      success: function(object) {\n        // The object was retrieved successfully.\n        object.set( score , 1338);\n        object.save(null, {\n          success: function(objectUpdate) {\n            alert( create object success, object score: +objectUpdate.get( score ));\n          },\n          error: function(model, error) {\n            alert( create object fail );\n          }\n        });\n      },\n      error: function(object, error) {\n        alert( query object fail );\n      }\n    });", 
            "title": "修改一行数据"
        }, 
        {
            "location": "/data/javascript/#_5", 
            "text": "var GameScore = Bmob.Object.extend( GameScore );\n    var query = new Bmob.Query(GameScore);\n    query.get( 4edc3f6ee9 , {\n      success: function(object) {\n        // The object was retrieved successfully.\n        object.destroy({\n          success: function(deleteObject) {\n          alert( delete success );\n          },\n          error: function(GameScoretest, error) {\n          alert( delete fail );\n          }\n        });\n      },\n      error: function(object, error) {\n        alert( query object fail );\n      }\n    });", 
            "title": "删除一行数据"
        }, 
        {
            "location": "/data/javascript/#_6", 
            "text": "快速入门相关源码下载", 
            "title": "源码下载"
        }, 
        {
            "location": "/data/javascript/develop_doc/", 
            "text": "简介\n\n\n\n\n\n\nBmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。\n\n\n\n\n\n\nBmob的JavaScript SDK基于\nBackbone.js\n框架开发，在使用过程中除\nBmob.view\n类需要提供jQuery或者类似JQuery的\n$\n方法外，不需要再引入其他类库。\n\n\n\n\n\n\n典型案例\n\n\n聊天室：\nhttp://chatroom.bmob.cn\n （采用实时数据同步SDK开发，右击可直接查看源码）\n\n\n应用程序\n\n\n在Bmob平台注册后，每个账户可创建多个应用程序，创建的每个应用程序都有其独自的应用程序ID，此后所有的应用程序将凭其ID进行Bmob SDK的使用。即使只有一个应用程序，也可以以不同的版本进行测试和生产。\n\n\n对象\n\n\n数据对象\n\n\nBmob数据存储是建立在\nBmob.Object\n基础上的。如记录游戏成绩的\nBmob.Object\n示例如下：\n\n\nscore: 1337, playerName: \nbmob\n, cheatMode: false\n\n\n\n\n这里需要注意的是：\n\n\n\n\n键必须是字母或者数字的字符串，值可以是字符串、数字、布尔值或者数组和字典。\n\n\n每一个\nBmob.Object\n都是一个特定子类的实例，子类名可以来区分各种数据，如我们可以把记录游戏成绩的类称之为\nGameScore\n。\n\n\n\n\n创建对象\n\n\n你可以使用\nBmob.Object.extend\n方法来创建新的\nBmob.Object\n子类，示例代码如下：\n\n\n// 创建Bmob.Object子类\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\n\n// 创建该类的一个实例\nvar gameScore = new GameScore();\n\n\n\n\n\n如果你想为\nBmob.Object\n的子类添加一些实例方法和类方法，示例代码如下：\n\n\n// 为Bmob.Object的子类添加实例方法和类方法\nvar GameScore = Bmob.Object.extend(\nGameScore\n, {\n  //实例方法\n  gleaterThanOneHundred: function() {\n    return this.get(\nscore\n) \n 100;\n  }\n}, {\n  //类方法\n  spawn: function(score) {\n    var gameScore = new GameScore();\n    gameScore.set(\nscore\n, score);\n    return gameScore;\n  }\n});\n\nvar gameScore = GameScore.spawn(200);\nalert(gameScore.gleaterThanOneHundred()); \n\n\n\n\n添加数据\n\n\n添加数据非常简单，任何\nBmob.Object\n子类都有\nsave\n方法可以用于将当前对象的内容保存到服务端。示例代码如下：\n\n\n//创建类和实例\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar gameScore = new GameScore();\ngameScore.set(\nscore\n, 137);\ngameScore.set(\nplayerName\n, \nbmob\n);\ngameScore.set(\ncheatMode\n, false);\n//添加数据，第一个入口参数是null\ngameScore.save(null, {\n  success: function(gameScore) {\n    // 添加成功，返回成功之后的objectId（注意：返回的属性名字是id，不是objectId），你还可以在Bmob的Web管理后台看到对应的数据\n    alert('添加数据成功，返回的objectId是：' + gameScore.id);\n  },\n  error: function(gameScore, error) {\n    // 添加失败\n    alert('添加数据失败，返回错误信息：' + error.description);\n  }\n});\n\n\n\n\n你也可以用如下的示例代码添加数据：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar gameScore = new GameScore();\n// 添加数据，第一个入口参数是Json数据\ngameScore.save({\n  score: 1337,\n  playerName: \nbmob\n,\n  cheatMode: false\n}, {\n  success: function(gameScore) {\n    // 添加成功\n  },\n  error: function(gameScore, error) {\n    // 添加失败\n  }\n});\n\n\n\n\n这里有几点需要注意的是:\n\n\n\n\n如果云端数据库中不存在\nGameScore\n表，Bmob会自动地在你第一次使用它的时候创建。\n\n\n每个\nBmob.Object\n对象都有几个默认的字段是自动创建的：\nobjectId\n是一个对于每一个保存的对象为一个标志；\ncreatedAt\n和\nupdatedAt\n表示对象在Bmob中创建和最后一次更改的时间。这些字段的创建和内容是由服务器端自动完成的，在保存\nBmob.Object\n之前不会存在。\n\n\n添加成功后，可以通过\ngameScore.createdAt\n获取对象的创建时间，通过\ngameScore.updatedAt\n获取对象的更新时间；可以通过\ngameScore.id\n获取对象的objectId。\n\n\n\n\n查询数据\n\n\n数据的查询是每个应用都会频繁使用到的，Bmob提供了\nBmob.Object\n类，方便大家实现不同条件的查询。\n\n\n查询所有数据\n\n\n查询某个数据表中的所有数据是非常简单的，只需要使用\nBmob.Query\n的\nfind\n方法就可以了，示例代码如下：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar query = new Bmob.Query(GameScore);\n// 查询所有数据\nquery.find({\n  success: function(results) {\n    alert(\n共查询到 \n + results.length + \n 条记录\n);\n    // 循环处理查询到的数据\n    for (var i = 0; i \n results.length; i++) {\n      var object = results[i];\n      alert(object.id + ' - ' + object.get('playerName'));\n    }\n  },\n  error: function(error) {\n    alert(\n查询失败: \n + error.code + \n \n + error.message);\n  }\n});\n\n\n\n\n如果你只想要一个结果，一个更加方便的方法是使用\nfirst\n，而不是\nfind\n方法，示例代码如下：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar query = new Bmob.Query(GameScore);\nquery.first({\n  success: function(object) {\n    // 查询成功\n  },\n  error: function(error) {\n    alert(\n查询失败: \n + error.code + \n \n + error.message);\n  }\n});\n\n\n\n\n这里需要注意一点的是：\n\n默认情况下，系统实际上并不会返回所有的数据，而是默认返回10条数据记录，你可以通过setLimit方法设置返回的记录数量。更多细节可\n点击查看分页查询\n一节。\n\n\n获取对象的特殊属性\n\n\n注意，在对象中获取objectId，createdAt，updatedAt的方法分别如下：\nobj.id\nobj.createdAt\nobj.updatedAt\n\n\n查询单条数据\n\n\n当我们知道某条数据的\nobjectId\n时，就可以根据\nobjectId\n值直接获取单条数据对象，示例代码如下：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\n//创建查询对象，入口参数是对象类的实例\nvar query = new Bmob.Query(GameScore);\n//查询单条数据，第一个参数是这条数据的objectId值\nquery.get(\n82c3e62d2c\n, {\n  success: function(gameScore) {\n    // 查询成功，调用get方法获取对应属性的值\n    var score = gameScore.get(\nscore\n);\n    var playerName = gameScore.get(\nplayerName\n);\n    var cheatMode = gameScore.get(\ncheatMode\n);\n  },\n  error: function(object, error) {\n    // 查询失败\n  }\n});\n\n\n\n\n条件查询\n\n\n如果要查询某个属性等于某个值，示例代码如下：\n\n\nquery.equalTo(\nplayerName\n, \nbmob\n);\n\n\n\n\n如果要查询某个属性不等于某个值，示例代码如下：\n\n\nquery.notEqualTo(\nplayerName\n, \nbmob cloud\n);\n\n\n\n\n对查询的属性值进行大小比较的示例代码如下：\n\n\n// score \n 50\nquery.lessThan(\nscore\n, 50);\n\n// score \n= 50\nquery.lessThanOrEqualTo(\nscore\n, 50);\n\n// score \n 50\nquery.greaterThan(\nscore\n, 50);\n\n// score \n= 50\nquery.greaterThanOrEqualTo(\nscore\n, 50);\n\n\n\n\n两条查询语句一起写，就相当于\nAND\n查询，如下示例代码，查询同时满足\n\"playerName\"=\"bmob\" and \"score\"\n100\n的数据：\n\n\nquery.notEqualTo(\nplayerName\n, \nbmob\n);\nquery.greaterThan(\nscore\n, 100);\n\n\n\n\n一个完整的例子：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar query = new Bmob.Query(GameScore);\nquery.equalTo(\nplayerName\n, \nbmob\n); \n// 查询所有数据\nquery.find({\n    success: function(results) {\n        alert(\n共查询到 \n + results.length + \n 条记录\n);\n        // 循环处理查询到的数据\n        for (var i = 0; i \n results.length; i++) {\n        var object = results[i];\n        alert(object.id + ' - ' + object.get('playerName'));\n        }\n    },\n    error: function(error) {\n        alert(\n查询失败: \n + error.code + \n \n + error.message);\n    }\n});\n\n\n\n\n分页查询\n\n\n有时，在数据比较多的情况下，你希望查询出的符合要求的所有数据能按照多少条为一页来显示，这时可以使用\nlimit\n方法来限制查询结果的数据条数来进行分页。默认情况下，Limit的值为10，最大有效设置值1000（设置的数值超过1000还是视为1000）。\n\n\n// 返回最多10条数据\nquery.limit(10); \n\n\n\n\n在数据较多的情况下，在\nlimit\n的基础上分页显示数据是比较合理的解决办法，\nskip\n方法可以做到跳过查询的前多少条数据来实现分页查询的功能。默认情况下\nskip\n的值为10。\n\n\nquery.skip(10); // skip the first 10 results\n\n\n\n\n结果排序\n\n\n我们可以对返回的结果进行排序（只支持\nnumber\n和\nstring\n类型的排序），示例代码如下：\n\n\n// 对score字段升序排列\nquery.ascending(\nscore\n);\n\n// 对score字段降序排列\nquery.descending(\nscore\n);\n\n\n\n\n统计记录数量\n\n\n如果你只是想统计满足\nquery\n的结果集到底有多条记录，你可以使用\ncount\n方法。如为了获得GameScore表的记录数量，示例代码如下：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar query = new Bmob.Query(GameScore);\nquery.count({\n  success: function(count) {\n    // 查询成功，返回记录数量\n    alert(\n共有 \n + count + \n 条记录\n);\n  },\n  error: function(error) {\n    // 查询失败\n  }\n});\n\n\n\n\n\n复杂查询\n\n\n如果你想查询某一字段值在某一集合中的记录的话，可以使用\ncontainedIn\n方法，如获取\n\"Bmob\"、\"Codenow\"、\"JS\"\n这三位玩家的记录信息，那么示例代码如下：\n\n\n// 第一个参数是字段名称，第二个参数是数组\nquery.containedIn(\nplayerName\n, [\nBmob\n, \nCodenow\n, \nJS\n]);\n\n\n\n\n\n相反地，你可以使用\nnotContainedIn\n方法来查询在集合外的目标对象。\n\n\n如果想要查询含有某一特定属性的对象，可以使用\nexists\n。相对地，如果你想获取没有这一特定属性的对象，你可以使用\ndoesNotExist\n，示例代码如下：\n\n\n// 查询含有score属性的对象\nquery.exists(\nscore\n);\n\n// 查询不含有score属性的对象\nquery.doesNotExist(\nscore\n);\n\n\n\n\n你可以使用\nmatchesKeyInQuery\n方法来进行嵌套的子查询。举例说，如果你有一个类包含了运动队， 而你在用户类中存储了用户的家乡信息，你可以构造一个查询来查找某地的运动队有赢的记录的用户，示例代码如下：\n\n\nvar Team = Bmob.Object.extend(\nTeam\n);\nvar teamQuery = new Bmob.Query(Team);\nteamQuery.greaterThan(\nwinPct\n, 0.5);\nvar userQuery = new Bmob.Query(Bmob.User);\nuserQuery.matchesKeyInQuery(\nhometown\n, \ncity\n, teamQuery);\nuserQuery.find({\n  success: function(results) {\n    // results has the list of users with a hometown team with a winning record\n  }\n});\n\n\n\n\n相对地，可以使用\ndoesNotMatchKeyInQuery\n来获取属性不在子查询结果中的对象。比如为了获得用户的家乡队输了的情况：\n\n\nvar Team = Bmob.Object.extend(\nTeam\n);\nvar teamQuery = new Bmob.Query(Team);\nteamQuery.greaterThan(\nwinPct\n, 0.5);\nvar userQuery = new Bmob.Query(Bmob.User);\nuserQuery.doesNotMatchKeyInQuery(\nhometown\n, \ncity\n, teamQuery);\nuserQuery.find({\n  success: function(results) {\n    // results has the list of users with a hometown team with a winning record\n  }\n});\n\n\n\n\n查询指定列\n\n\n有时候你不想返回所有的字段信息，那么就可以用\nselect\n方法来限定返回的字段。示例代码如下：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar query = new Bmob.Query(GameScore);\n// 只返回score和playerName字段值\nquery.select(\nscore\n, \nplayerName\n);\nquery.find().then(function(results) {\n  // 返回成功\n});\n\n\n\n\n注意：系统默认的字段\nobjectId\n、\ncreatedAt\n、\nupdatedAt\n、\nACL\n也会返回。\n\n\n对字符串类型做查询\n\n\n如果想要查询以某一个特定字符串开头的记录，可以使用\nstartWith\n方法，示例代码如下：\n\n\n// 查询在playerName字段中以bm开头的记录\nvar query = new Bmob.Query(GameScore);\nquery.startsWith(\nplayerName\n, \nbm\n);\n\n\n\n\n或查询\n\n\n你可以使用\nBmob.Query.or\n方法操作或查询，示例代码如下：\n\n\nvar lotsOfWins = new Bmob.Query(GameScore);\nlotsOfWins.greaterThan(\nscore\n, 150);\n\nvar fewWins = new Bmob.Query(GameScore);\nfewWins.lessThan(\nscore\n, 5);\n\nvar mainQuery = Bmob.Query.or(lotsOfWins, fewWins);\nmainQuery.find({\n  success: function(results) {\n     // 返回 score \n 150 or score \n 5 的值\n  },\n  error: function(error) {\n    // 返回失败\n  }\n});\n\n\n\n\n注意：我们不会在组合查询的子查询中支持非过滤型的条件 (比如:limit,skip,ascending/descending,include)\n\n\n修改数据\n\n\n修改数据非常简单，首先需要获取到要更新的\nBmob.Object\n对象，修改值后保存数据就可以了，示例代码如下：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar query = new Bmob.Query(GameScore);\n\n// 这个 id 是要修改条目的 id，你在生成这个存储并成功时可以获取到，请看前面的文档\nquery.get('3453453453fdsdf', {\n    success: function(gameScore) {\n      // 回调中可以取得这个 GameScore 对象的一个实例，然后就可以修改它了\n      gameScore.set('title', 'test!');\n      gameScore.save();\n\n      // The object was retrieved successfully.\n    },\n    error: function(object, error) {\n\n    }\n});\n\n\n\n\n或者\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar gameScore = new GameScore();\ngameScore.set(\ncheatMode\n, true);\ngameScore.set(\nscore\n, 1338);\n//添加数据\ngameScore.save(null, {\n  success: function(gameScore) {\n    // 修改数据\n    gameScore.set(\ncheatMode\n, true);\n    gameScore.set(\nscore\n, 1338);\n    gameScore.save();\n  }\n})\n\n\n\n\n如果想更新成功后获取更新后的对象属性，请设置\nfetchWhenSave\n：\n\n\n //假设gamescore是已经存在的对象\n    gameScore.fetchWhenSave(true);\n    gameScore.set(\ncheatMode\n, true);\n    gameScore.set(\nscore\n, 1338);\n    gameScore.save();\n\n\n\n\n删除数据\n\n\n删除数据可以使用\nBmob.Object\n的\ndestroy\n方法，示例代码如下：\n\n\nmyObject.destroy({\n  success: function(myObject) {\n    // 删除成功\n  },\n  error: function(myObject, error) {\n    // 删除失败\n  }\n});\n\n\n\n\n\n删除字段\n\n\n你可以使用\nunset\n方法在删除一个字段：\n\n\n// 删除playerName字段\nmyObject.unset(\nplayerName\n);\nmyObject.save();\n\n\n\n\n常见数据类型的操作\n\n\nvar number = 42;\nvar string = \nthe number is \n + number;\nvar date = new Date();\nvar array = [string, number];\nvar object = { number: number, string: string };\n\nvar bigObject = new BigObject();\nbigObject.set(\nmyNumber\n, number);\nbigObject.set(\nmyString\n, string);\nbigObject.set(\nmyDate\n, date);\nbigObject.set(\nmyArray\n, array);\nbigObject.set(\nmyObject\n, object);\nbigObject.set(\nmyNull\n, null);\nbigObject.save();\n\n\n\n\n数组操作\n\n\n添加及更新数组\n\n\n为了帮你存储数组类数据，有三种操作你可以原子性地改动一个数组，这需要一个给定的 key：\n\n\n\n\nadd\n在一个数组的末尾加入一个给定的对象。\n\n\naddUnique\n只会把原本不存在的对象加入数组，所以加入的位置没有保证。\n\n\n\n\n比如, 我们想在数组\"skills\"中加入项目：\n\n\ngameScore.addUnique(\nskills\n, \nflying\n);\ngameScore.addUnique(\nskills\n, \nkungfu\n);\ngameScore.save();\n\n\n\n\n数组查询\n\n\n对于value是数组的情况，你可以这样查询数组中的值有\n2\n的情况的对象：\n\n\n// Find objects where the array in arrayKey contains 2.\nquery.equalTo(\narrayKey\n, 2);\n\n\n\n\n你同样可以用下面的方式找到同时包含元素\n2、3、4\n的数组：\n\n\n// Find objects where the array in arrayKey contains all of the elements 2, 3, and 4.\nquery.containsAll(\narrayKey\n, [2, 3, 4]);\n\n\n\n\n删除数组\n\n\nremove\n在一个数组中删除所有指定的所有实例：\n\n\nvar GameScoretest = Bmob.Object.extend(\nGameScoretest\n);\nvar query = new Bmob.Query(GameScoretest);\nquery.get(\nbc5da708dc\n,{\n  success: function(gameScore) {\n    gameScore.remove(\nskills\n,\ntest\n);\n    gameScore.save();\n  },\n  error: function(error) {\n    alert(\nError: \n + error.code + \n \n + error.message);\n  }\n}); \n\n\n\n\n数据关联\n\n\n添加及修改关联关系\n\n\n一对一关系和一对多关系\n\n\n一对一关系和一对多关系都可以通过在一个\nBmob.Object\n内保存另一个对象来实现。比如，每一个 Comment都对应了一个Post，创建一个有一个Comment的Post，你可以这样写：\n\n\n// Declare the types.\nvar Post = Bmob.Object.extend(\nPost\n);\nvar Comment = Bmob.Object.extend(\nComment\n);\n\n// Create the post\nvar myPost = new Post();\nmyPost.set(\ntitle\n, \nI'm Hungry\n);\nmyPost.set(\ncontent\n, \nWhere should we go for lunch?\n);\n\n// Create the comment\nvar myComment = new Comment();\nmyComment.set(\ncontent\n, \nLet's do Sushirrito.\n);\n\n// Add the post as a value in the comment\nmyComment.set(\nparent\n, myPost);\n\n// This will save both myPost and myComment\nmyComment.save();\n\n\n\n\nBmob内部会自动处理，调用Comment的\nsave\n方法就可以同时保存两个新对象。\n\n\n如果是现有对象想要关联到新对象，你同样可以通过只用它们的\nobjectId\n来连接彼此。请注意，不能直接像上面的例子那样将现有对象设置进去，而是必须\nnew\n一个新对象并只设置\nid\n属性：\n\n\nvar post = Bmob.Object.createWithoutData(\nPost\n, \n320b0395f3\n);\nmyComment.set(\nparent\n, post);\n\n\n\n\n或者：\n\n\nvar post = new Post();\npost.id = '520c7e1ae4b0a3ac9ebe326a';\nmyComment.set(\nparent\n, post);\n\n\n\n\n默认情况下，当获取一个对象时，关联的\nBmob.Object\n不会被获取到，这些对象的值不能访问，除非像下面这样获取它们：\n\n\nvar post = fetchedComment.get(\nparent\n);\npost.fetch({\n  success: function(post) {\n    var title = post.get(\ntitle\n);\n  }\n});\n\n\n\n\n多对多关系\n\n\n多对多关系是通过\nBmob.Relation\n来建模的，这样很像在一个key中存储一个\nBmob.Object\n数组，但是你不需要一次性下载关系中的所有对象。这使得\nBmob.Relation\n比数组可以更好地扩展到更多对象。例如，一个User可能喜欢很多Post，在这种情况下，你可以把一个用户喜欢的所有Post存为一个Relation，为了将一个Post加入一个User的like列表，你可以：\n\n\nvar user = Bmob.User.current();\nvar relation = user.relation(\nlikes\n);\nrelation.add(post);\nuser.save();\n\n\n\n\n你还可以传入一个\nBmob.Object\n数组来做\nadd\n和\nremove\n：\n\n\nrelation.add([post1, post2, post3]);\nuser.save();\n\n\n\n\n查询关联关系\n\n\n默认情况下，\nrelation\n关联的对象并不会被下载，你可以通过使用\nquery\n方法返回的\nBmob.Query\n对象来获取\nBmob.Object\n的列表，例如：\n\n\nrelation.query().find({\n  success: function(list) {\n    // list contains the posts that the current user likes.\n  }\n});\n\n\n\n\n如果你仅仅要一个Post的子集，你可以在\nBmob.Query\n中加入更多的条件：\n\n\nvar query = relation.query();\nquery.equalTo(\ntitle\n, \nI'm Hungry\n);\nquery.find({\n  success:function(list) {\n    // list contains post liked by the current user which have the title \nI'm Hungry\n.\n  }\n});\n\n\n\n\n如果希望查询结果中包含多个相关联的其他数据类型。你可以使用 include 方 法。例如有个comments，你可能想同时获取它们相关的 post 数据:\n\n\nvar query = new Bmob.Query(Comment);\n\nquery.include(\npost\n);\n\n\n\n\n你可以在接下来关于\nBmob.Query\n的章节中看到更详细的内容。一个\nBmob.Relation\n的行为很像一个\nBmob.Object\n数组，所以任何在数组可做的查询操作，也都可以作用在\nBmob.Relation\n上。\n\n\n如果你知道post，想反向查询user，可以通过\nBmob.Relation.reverseQuery\n方法：\n\n\nvar query = Bmob.Relation.reverseQuery('_User', 'likes', post);\nquery.find({\n  success:function(users) {\n   //users是表示喜欢这个post的用户列表。\n  }\n});\n\n\n\n\n删除关联关系\n\n\n你可以从一个\nBmob.Relation\n中删除一个post：\n\n\nrelation.remove(post);\nuser.save();\n\n\n\n\n你可以在用\nsave\n方法保存前多次调用\nadd\n和\nremove\n方法：\n\n\nrelation.remove(post1);\nrelation.remove(post2);\nuser.save();\n\n\n\n\n原子计数器\n\n\n许多应用都需要维持一些计数器数据，譬如用来跟踪游戏分数、金币甚至道具的数目等等。Bmob提供了便捷的方式来对任何数字字段进行原子性的增加或者减少：\n\n\ngameScore.increment(\nscore\n);\ngameScore.save();\n\n\n\n\n你可以同样传入第二个参数到\nincrement\n方法来指定增加多少，\n1\n是默认值。\n\n\n文件\n\n\n整个文件上传\n\n\n上传文件有两种方法：\n\n\n直接上传文件，例如，我们上传一个内容为\"Hello, World!\"，名称为\"hello.txt\"的文件，可用如下的代码：\n\n\nvar bytes = \nHello, World!\n;\nvar file = new Bmob.File(\nhello.txt\n, bytes);\nfile.save().then(function(obj) {\n  //alert(obj.url());\n}, function(error) {\n  // the save failed.\n});\n\n\n\n\n最经常的对于HTML5的应用来说，可能需要用html表单和一个文件上传控制器。在现代的浏览器中这很容易，只需要创建一个file input tag来允许用户选择他们磁盘上的文件就可以了。\n\n\ninput type=\nfile\n id=\nprofilePhotoFileUpload\n\n\n\n\n\n然后，在一个处理\nclick\n或其他的函数里，获取对那个文件的一个引用：\n\n\n        var fileUploadControl = $(\n#profilePhotoFileUpload\n)[0];\n        if (fileUploadControl.files.length \n 0) {\n        var file = fileUploadControl.files[0];\n        var name = \nlogo.jpg\n;\n        var file = new Bmob.File(name, file);     \n        file.save();\n\n\n\n\n文件删除\n\n\n  file.destroy(); //删除文件\n\n\n\n\n\n图片处理\n\n\n提供一些工具接口，方便开发者处理图片。\n\n\n缩微图\n\n\n提供原图的URL地址和相应的参数， 返回缩微图的URL地址， 具体参数定义如下：\n\n\nmode:模式 0: 指定宽， 高自适应，等比例缩放\n     模式 1: 指定高， 宽自适应，等比例缩放\n     模式 2: 指定最长边，短边自适应，等比例缩放\n     模式 3: 指定最短边，长边自适应，等比例缩放\n     模式 4: 指定最大宽高， 等比例缩放\n     模式 5: 固定宽高， 居中裁剪    \nimage:原图片url\nwidth:宽度，模式 0, 4, 5必填\nheight：高度，模式 1, 4, 5必填\nlongEdge：长边，模式 2必填\nshortEdge：短边，模式 3必填\nquality：质量，选填, 范围 1-100\noutType：输出类型，0:默认，输出url；1:输出base64编码的字符串流\n\n\n\n\n调用的代码：\n\n\nBmob.Image.thumbnail({\nimage\n:\nhttp://file.bmob.cn/M00/01/26/wKgBP1OX9LLVh5gNAAHGYsmKRjk666.jpg\n,\nmode\n:0,\nquality\n:100,\nwidth\n:100}\n\n  ).then(function(obj) {\n\n  alert(\nfilename:\n+obj.filename); //\n  alert(\nurl:\n+obj.url); //\n});\n\n\n\n\n\n如果\noutType = 0\n返回云端url地址:\n\n\n{\n  \nfilename\n: \ne6c8ac18c9.jpg\n,\n  \ngroup\n: \ngroup1\n,\n  \nurl\n: \nM00/01/6E/wKhkA1OGpWKAGdNUAAAjdkbUqo4612.jpg\n\n}\n\n\n\n\n如果 \noutType = 1\n 返回文件内容的 base64 字符串：\n\n\n{\n  \nfile\n:\nbase64的文件内容\n\n}\n\n\n\n\n水印图\n\n\n提供原图的URL地址，水印图的URL地址和相应的参数，返回缩微图的URL地址，具体参数定义如下：\n\n\nimage：原图路径\nwatermark：水印图路径\ndissolve:透明度，0-255\ndistanceX：横轴边距，单位:像素(px)，缺省值为10\ndistanceY：纵轴边距，单位:像素(px)，缺省值为10\noutType：输出类型，0:默认，输出url；1:输出base64编码的字符串流\ngravity:水印位置，见下图\n\n\n\n\n\n\n调用的代码：\n\n\n//get image thumbnail\nBmob.Image.watermark({\nimage\n:\nhttp://test.com/new/images/banner005.jpg\n,\nwatermark\n:\nhttp://test.com/new/images/header2.png\n,\ndissolve\n:100,\ngravity\n:\nSouthWest\n,\ndistanceX\n:10,\ndistanceY\n:10}\n\n  ).then(function(obj) {\n\n  alert(\nfilename:\n+obj.filename); //\n  alert(\nurl:\n+obj.url); //\n});\n\n\n\n\n\n如果 \noutType = 0\n 返回云端url地址:\n\n\n{\n  \nfilename\n: \ne6c8ac18c9.jpg\n,\n  \ngroup\n: \ngroup1\n,\n  \nurl\n: \nM00/01/6E/wKhkA1OGpWKAGdNUAAAjdkbUqo4612.jpg\n\n}\n\n\n\n\n如果 \noutType = 1\n 返回文件内容的 base64 字符串：\n\n\n{\n  \nfile\n:\nbase64的文件内容\n\n}\n\n\n\n\nPromise\n\n\n除了回调函数之外，每一个在Bmob JavaScript SDK中的异步方法都会返回一个 Promise. 使用 Promise，你的代码可以比原来的嵌套 callback 的方法看起来优雅得多.\n\n\nthen 方法\n\n\n每一个\nPromise\n都有一个叫\nthen\n的方法, 这个方法接受一对\ncallback\n。第一个\ncallback\n在\npromise\n被解决的时候调用，第二个会在\npromise\n被拒绝的时候调用。\n\n\nobj.save().then(function(obj) {\n  // the object was saved successfully.\n}, function(error) {\n  // the save failed.\n});\n\n\n\n\n将Promise 组织在一起\n\n\nPromise\n比较神奇，可以代替多层嵌套方式来解决发送异步请求代码的调用顺序问题。 如果一个\nPromise\n的回调会返回一个\nPromise\n，那么第二个\nthen\n里的\ncallback\n在第一个\nthen\n的\ncallback\n没有解决前是不会解决的。\n\n\nvar query = new Bmob.Query(\nStudent\n);\nquery.descending(\ngpa\n);\nquery.find().then(function(students) {\n  students[0].set(\nvaledictorian\n, true);\n  return students[0].save();\n\n}).then(function(valedictorian) {\n  return query.find();\n\n}).then(function(students) {\n  students[1].set(\nsalutatorian\n, true);\n  return students[1].save();\n\n}).then(function(salutatorian) {\n  // Everything is done!\n\n});\n\n\n\n\n错误处理\n\n\n如果任意一个在链中的\nPromise\n返回一个错误的话，所有的成功的\ncallback\n在接下来都会被跳过直到遇到一个处理错误的\ncallback\n。处理\nerror\n的\ncallback\n可以转换\nerror\n或者可以通过返回一个新的\nPromise\n的方式来处理它。你可以想象成拒绝的\npromise\n有点像异常，而\nerror callback\n则像是一个\ncatch\n来处理这个异常或者抛出异常。\n\n\nvar query = new Bmob.Query(\nStudent\n);\nquery.descending(\ngpa\n);\nquery.find().then(function(students) {\n  students[0].set(\nvaledictorian\n, true);\n  // Force this callback to fail.\n  return Bmob.Promise.error(\nThere was an error.\n);\n\n}).then(function(valedictorian) {\n  // Now this will be skipped.\n  return query.find();\n\n}).then(function(students) {\n  // This will also be skipped.\n  students[1].set(\nsalutatorian\n, true);\n  return students[1].save();\n}, function(error) {\n  // This error handler WILL be called. error will be \nThere was an error.\n.\n  // Let's handle the error by returning a new promise.\n  return Bmob.Promise.as(\nHello!\n);\n\n}).then(function(hello) {\n  // Everything is done!\n}, function(error) {\n  // This isn't called because the error was already handled.\n});\n\n\n\n\n通常来说，在正常情况的回调函数链的末尾，加一个错误处理的回调函数会是很方便的做法.\n\n\n创建 Promise\n\n\n在开始阶段，你可以只用系统（譬如\nfind\n和\nsave\n方法等）返回的\npromise\n。但在更高级的场景下，你可能需要创建自己的\npromise\n。在创建了\nPromise\n之后，你需要调用\nresolve\n或者\nreject\n来触发它的\ncallback\n。\n\n\nvar successful = new Bmob.Promise();\nsuccessful.resolve(\nThe good result.\n);\n\nvar failed = new Bmob.Promise();\nfailed.reject(\nAn error message.\n);\n\n\n\n\n如果你在创建\npromise\n的时候就知道它的结果，下面有两个很方便的方法可以使用：\n\n\nvar successful = Bmob.Promise.as(\nThe good result.\n);\nvar failed = Bmob.Promise.error(\nAn error message.\n);\n\n\n\n\n顺序的Promise\n\n\nvar query = new Bmob.Query(\nComments\n);\nquery.equalTo(\npost\n, 123);\n\nquery.find().then(function(results) {\n  // Create a trivial resolved promise as a base case.\n  var promise = Bmob.Promise.as();\n  _.each(results, function(result) {\n    // For each item, extend the promise with a function to delete it.\n    promise = promise.then(function() {\n      // Return a promise that will be resolved when the delete is finished.\n      return result.destroy();\n    });\n  });\n  return promise;\n\n}).then(function() {\n  // Every comment was deleted.\n});\n\n\n\n\n并行的Promise\n\n\n你也可以用\nPromise\n来并行的进行多个任务，这时需要使用\nwhen\n方法。你可以一次同时开始几个操作，使用\nBmob.Promise.when\n来创建一个新的\npromise\n，它会在所有输入的\nPromise\n被解决之后才被解决。即便一些输入的\npromise\n失败了，新的\nPromise\n也会被成功执行。你可以在 \ncallback\n的参数部分检查每一个\npromise\n的结果，并行地进行操作会比顺序进行更快，但是也会消耗更多的系统资源和带宽。\n\n\nvar query = new Bmob.Query(\nComments\n);\nquery.equalTo(\npost\n, 123);\n\nquery.find().then(function(results) {\n  // Collect one promise for each delete into an array.\n  var promises = [];\n  _.each(results, function(result) {\n    // Start this delete immediately and add its promise to the list.\n    promises.push(result.destroy());\n  });\n  // Return a new promise that is resolved when all of the deletes are finished.\n  return Bmob.Promise.when(promises);\n\n}).then(function() {\n  // Every comment was deleted.\n});\n\n\n\n\n创建异步方法\n\n\n有了上面这些工具以后, 就很容易创建你自己的异步方法来返回\npromise\n了。举例说，你可以创建一个有\npromise\n版本的\nsetTimeout\n。\n\n\nvar delay = function(millis) {\n  var promise = new Bmob.Promise();\n  setTimeout(function() {\n    promise.resolve();\n  }, millis);\n  return promise;\n};\n\ndelay(100).then(function() {\n  // This ran after 100ms!\n});\n\n\n\n\nCollection\n\n\n一个\nBmob.Collection\n就是一个\nBmob.Objects\n的有序集合，它和\nBackbone.Collection\n是兼容的，有相同的特性和功能，你可以通过用一个模型类或者一个特定的\nBmob.Query\n来创建一个新的子类。\n\n\n// A Collection containing all instances of TestObject.\nvar TestCollection = Bmob.Collection.extend({\n  model: TestObject\n});\nvar collection = new TestCollection();\n\n// A Collection of TestObjects whose temperature is \nhot\n.\nvar HotCollection = Bmob.Collection.extend({\n  model: TestObject,\n  query: (new Bmob.Query(TestObject)).equalTo(\ntemperature\n, \nhot\n)\n});\nvar collection = new HotCollection();\n\n// The Collection of TestObjects that match a complex query.\nvar query = new Bmob.Query(TestObject);\nquery.equalTo(\ntemperature\n, \nhot\n);\nquery.greaterThan(\ndegreesF\n, 100);\nvar collection = query.collection();\n\n\n\n\n获取Collection\n\n\n使用\nfetch\n方法来获取一个\ncollection\n里的所有元素:\n\n\nvar collection = new TestCollection();\ncollection.fetch({\n  success: function(collection) {\n    collection.each(function(object) {\n      console.warn(object);\n    });\n  },\n  error: function(collection, error) {\n    // The collection could not be retrieved.\n  }\n});\n\n\n\n\nCollection 排序\n\n\n你可以设定一个\ncomparator\n来对\ncollection\n中的元素进行排序:\n\n\nvar collection = new TestCollection();\ncollection.comparator = function(object) {\n  return object.get(\ntemperature\n);\n};\n\n\n\n\n修改一个 Collection\n\n\nCollection\n是可变的，你可以访问所有元素，增加或者删除元素：\n\n\nvar collection = new TestCollection();\n\ncollection.add([\n  {\nname\n: \nDuke\n},\n  {\nname\n: \nScarlett\n}\n]);\n\n// Get the \nDuke\n Bmob.Object by its sorted position.\nvar model = collection.at(0);\n\n// Or you can get it by Bmob objectId.\nvar modelAgain = collection.get(model.id);\n\n// Remove \nDuke\n from the collection.\ncollection.remove(model);\n\n// Completely replace all items in the collection.\ncollection.reset([\n  {\nname\n: \nHawk\n},\n  {\nname\n: \nJane\n}\n]);\n\n\n\n\n用户\n\n\n在许多应用中，都有一个用户账户的概念，用户账户让用户可以用安全的方式访问他们自己的信息。我们提供了一个特殊的用户类叫\nBmob.User\n来自动处理有关用户的账户管理的功能。\n\n\nBmob.User\n是\nBmob.Object\n的一个子类，而且有\nBmob.Object\n一样的功能，比如可变的模式、自动的持久化、键值对接口等。所有对\nBmob.Object\n有用的方法同样可以作用于\nBmob.User\n。\nBmob.User\n的不同之处在于\nBmob.User\n对于用户的账户有一些特定的功能。\n\n\n属性\n\n\nBmob.User\n有一些与\nBmob.Object\n不一样的字段:\n\n\nusername\n：用户的用户名（必须提供）\n\npassword\n：用户的密码（在注册的时候必须提供）\n\nemail\n：用户的 email（可选）\n我们会在下面的用例中详细介绍细节\n\n\n注册\n\n\n通常你的app第一件要做的事情就是让用户进行注册，下面的代码展示了怎样进行通常的注册过程：\n\n\nvar user = new Bmob.User();\nuser.set(\nusername\n, \nmy name\n);\nuser.set(\npassword\n, \nmy pass\n);\nuser.set(\nemail\n, \nemail@example.com\n);\n\n// other fields can be set just like with Bmob.Object\nuser.set(\nphone\n, \n415-392-0202\n);\n\nuser.signUp(null, {\n  success: function(user) {\n    // Hooray! Let them use the app now.\n  },\n  error: function(user, error) {\n    // Show the error message somewhere and let the user try again.\n    alert(\nError: \n + error.code + \n \n + error.message);\n  }\n});\n\n\n\n\n这个调用会异步地在在你的应用中创建一个新的用户。在它这样做之前，它同样会确认用户名和\nemail\n在应用内都是唯一的。同样，我们从不会将用户密码以明文向任何客户端发送。\n\n\n注意我们使用了\nsignUp\n方法而不是\nsave\n方法，新的\nBmob.User\n永远应该使用\nsignUp\n方法来新建。而随后的用户的信息更新可以调用\nsave\n来做。\n\n\n如果一个\nsignup\n没有成功的话，你应该读取返回的错误对象。最常见的问题是\nusername\n或者\nemail\n已经被其他用户所使用了。你应该清楚地反馈给你的用户，让他们再次用一个不同的用户名来注册。\n\n\n你也可以使用\nemail\n来作为用户名，只要求你的用户输入他们的\nemail\n但是同时自动填充好\nusername\n属性就可以了，\nBmob.User\n会跟原来一样工作，我们会在下面的重设密码环节再次说明这个细节。\n\n\n登录\n\n\n在你要求你的用户注册之后，当然应该让他们在以后用自己的账户登录进来，你可以使用\nlogIn\n方法来进行登陆：\n\n\nBmob.User.logIn(\nmyname\n, \nmypass\n, {\n  success: function(user) {\n    // Do stuff after successful login.\n  },\n  error: function(user, error) {\n    // The login failed. Check error to see why.\n  }\n});\n\n\n\n\n验证 Email\n\n\n在application设置中启用email验证可以让你的应用给最终用户一些更安全的使用体验，譬如部分功能只开放给验证过邮箱的用户使用等等。Email验证会在\nBmob.User\n上加入一个\nemailVerified\n字段。当一个\nBmob.User\n的\nemail\n被设定或者修改后,\nemailVerfied\n会被设定为\nfalse\n。Bmob 会向用户的\nemail\n来发送一个链接，点击这个链接会设置\nemailVerified\n为\ntrue\n：\n\n\n有三种\nemailVerified\n状态可以供参考：\n\n\n\n\ntrue\n：用户已经通过点击Bmob发过来的链接来确认邮箱地址. 当用户账户新创建的时候这个值永远不应该是true。\n\n\nfalse\n：在 \nBmob.User\n对象最后一次刷新的时候，用户还是没有确认他们的\nemail\n地址，如果\nemailVerified\n是false 的话，你应该考虑调用\nBmob.User\n的\nfetch\n方法。\n\n\nmissing\n：\nBmob.User\n被创建了，但是当时的\nemail\n验证功能还没有开启, 或者说\nBmob.User\n没有email地址。\n\n\n\n\n代码例子如下：\n\n\n//reset password\n Bmob.User.requestEmailVerify(\nh6k65@126.com\n, {\n  success: function() {\n    // Password reset request was sent successfully\n  },\n  error: function(error) {\n    // Show the error message somewhere\n    alert(\nError: \n + error.code + \n \n + error.message);\n  }\n});\n\n\n\n\n当前用户\n\n\n如果用户每次打开App的时候都要求登录无疑是令人感到厌烦的，你可以通过缓存当前的\nBmob.User\n对象来避免这个问题。\n\n\n无论你使用任何注册或者登录方法，用户都会在\nlocalStorage\n中储存，你可以把缓存作为一个\nsession\n对待，并且自动假设用户已经登录了。\n\n\nvar currentUser = Bmob.User.current();\nif (currentUser) {\n    // do stuff with the user\n} else {\n    // show the signup or login page\n}\n\n\n\n\n你可以通过\nlogout\n来清除掉当前的用户：\n\n\nBmob.User.logOut();\n\nvar currentUser = Bmob.User.current();  // this will now be null\n\n\n\n\n用户对象的安全\n\n\nBmob.User\n类默认就是受保护的，在\nBmob.User\n中保存的数据只能被那个用户所修改。默认地，数据仍然可以被任意客户端所读取。这样就是说，有些\nBmob.User\n对象被认证后是可以修改的，其他的仍然是只读的。\n\n\n特别的，你不能调用\nsave\n或者\ndelete\n方法除非\nBmob.User\n经过了认证，就比如调用过了\nlogIn\n或者\nsignUp\n方法，这样保证只有用户能改动他们自身的数据。\n\n\n下面的代码展示了上面说的安全策略：\n\n\nvar user = Bmob.User.logIn(\nmy_username\n, \nmy_password\n, {\n  success: function(user) {\n    user.set(\nusername\n, \nmy_new_username\n);  // attempt to change username\n    user.save(null, {\n      success: function(user) {\n        // This succeeds, since the user was authenticated on the device\n\n        // Get the user from a non-authenticated method\n        var query = new Bmob.Query(Bmob.User);\n        query.get(user.objectId, {\n          success: function(userAgain) {\n            userAgain.set(\nusername\n, \nanother_username\n);\n            userAgain.save(null, {\n              error: function(userAgain, error) {\n                // This will error, since the Bmob.User is not authenticated\n              }\n            });\n          }\n        });\n      }\n    });\n  }\n});\n\n\n\n\n从\nBmob.User.current()\n获取的\nBmob.User\n总是已经通过验证了的。\n\n\n如果你需要查看一个\nBmob.User\n是否已经认证过了，你可以调用\nauthenticated\n方法，你不需要查看一个认证方法中返回的\nBmob.User\n对象是否已经通过验证了。\n\n\n其他对象的安全\n\n\n和\nBmob.User\n相同的安全模型也使用于其他对象。对于任何对象来说，你可以指定哪些用户会被允许读取对象，哪些用户被允许修改对象。为了支持这种安全机制，每一个对象都有一个允许访问列表 (ACL)，是被\nBmob.ACL\n类所实现的。\n\n\n使用一个\nBmob.ACL\n最简单的方式是指定一个对象只能被一个单一的用户读或者写。为了创建这样的对象，首先必须有一个已经登录的\nBmob.User\n。然后，新的\nBmob.ACL(user)\n生成一个\nBmob.ACL\n来限定\nuser\n的访问。一个对象的ACL会在对象保存的时候被存储起来，就像其他的属性一样，这样，为了创建一个当前user私有的一个note：\n\n\nvar Note = Bmob.Object.extend(\nNote\n);\nvar privateNote = new Note();\nprivateNote.set(\ncontent\n, \nThis note is private!\n);\nprivateNote.setACL(new Bmob.ACL(Bmob.User.current()));\nprivateNote.save();\n\n\n\n\n这个note只能由当前的用户所访问，但是可以在用户登录的任何设备上访问，只要是相同的用户就可以了。这项功能对于你如果想让用户再任何其他的设备上保存和访问数据十分有用，比如说一个私人的todo list应用。\n\n\n权限也能在使用者的基础上授予，你可以通过\nsetReadAccess\n和\nsetWriteAccess\n方法独立的向\nBmob.ACL\n中添加权限。比如，假设你有一条消息想要发送给一个组里的多个用户，他们中的每一个都有读和写的权限：\n\n\nvar Message = Bmob.Object.extend(\nMessage\n);\nvar groupMessage = new Message();\nvar groupACL = new Bmob.ACL();\n\n// userList is an array with the users we are sending this message to.\nfor (var i = 0; i \n userList.length; i++) {\n  groupACL.setReadAccess(userList[i], true);\n  groupACL.setWriteAccess(userList[i], true);\n}\n\ngroupMessage.setACL(groupACL);\ngroupMessage.save();\n\n\n\n\n你同样可以对所有的用户授权，只要使用\nsetPublicReadAccess\n和\nsetPublicWriteAccess\n就可以了。这样允许了在一个消息板上发评论的模式，比如，我们要创建一个post只能被它的作者修改，但是可以被所有人读取：\n\n\nvar publicPost = new Post();\nvar postACL = new Bmob.ACL(Bmob.User.current());\npostACL.setPublicReadAccess(true);\npublicPost.setACL(postACL);\npublicPost.save();\n\n\n\n\n比如说删除一个对象，但是你没有写的权限这种操作是禁止的，这样会返回一个\nBmob.Error.OBJECT_NOT_FOUND\n的错误码，为了安全起见，这样防止了客户端区分出到底有哪些对象被创建了但是无法读取还是根本不存在。\n\n\n重设密码\n\n\n在现实中只要你引入了密码系统，总会有用户会忘掉他们的密码。在这种情形下，我们的库提供一个让他们安全地重设密码的功能。\n\n\n为了能让用户重设密码，应该要求用户提供他们的email地址，然后这样调用：\n\n\n Bmob.User.requestPasswordReset(\ntest@126.com\n, {\n  success: function() {\n    // Password reset request was sent successfully\n  },\n  error: function(error) {\n    // Show the error message somewhere\n    alert(\nError: \n + error.code + \n \n + error.message);\n  }\n});\n\n\n\n\n这样会尝试匹配给定的email和用户的email或者username字段，然后会发送用户的密码重设邮件。由于我们是这样做的，所以你可以选择用户是否拿email作为他们的用户名，或者说用户把email作为用户的另一个信息保存。\n\n\n密码重设的流程如下:\n\n\n\n\n用户输入email来请求重设他们的密码。\n\n\nBmob向用户的email地址发送邮件，包含了一个重设密码的链接。\n\n\n用户点击这个重设密码的链接，会重定向到一个Bmob页面来允许他们重设密码。\n\n\n用户输入新的密码，他们的密码现在会更新为输入的新密码。\n\n\n\n\n查询\n\n\n为了查询用户，你可以简单的创建一个\nBmob.Query\n针对\nBmob.Users\n：\n\n\nvar query = new Bmob.Query(Bmob.User);\nquery.equalTo(gender, \nfemale\n);  // find all the women\nquery.find({\n  success: function(women) {\n    // Do stuff\n  }\n});\n\n\n\n\n关联\n\n\n关联一个\nBmob.User\n的对象可以很快就见效，比如说，假设你有一个blog程序，为了保存一个用户的新post还有读取他们所有的post。\n\n\nvar user = Bmob.User.current();\n\n// Make a new post\nvar Post = Bmob.Object.extend(\nPost\n);\nvar post = new Post();\npost.set(\ntitle\n, \nMy New Post\n);\npost.set(\nbody\n, \nThis is some great content.\n);\npost.set(\nuser\n, user);\npost.save(null, {\n  success: function(post) {\n    // Find all posts by the current user\n    var query = new Bmob.Query(Post);\n    query.equalTo(\nuser\n, user);\n    query.find({\n      success: function(usersPosts) {\n        // userPosts contains all of the posts by the current user.\n      }\n    });\n  }\n});\n\n\n\n\n实时数据平台\n\n\n实时功能简介\n\n\nBmob提供了数据实时功能，当开发者监听某个变化事件，例如监听表更新时，表的内容一旦变化，服务器就会通知SDK，SDK提供了相应回调函数来给开发者使用。当然开发者也可以取消相对应的监听，这样就不会收到数据变化的消息了。\n\n\n注意！！！运行的html文件应该是在web环境中，不能在本地环境中运行。\n\n例如，合法的运行环境：http://local.project/appweb/sdk/js/demo/bmobSocketIo.html\n无效的本地运行环境：file:///D:/jeff/project/appweb/sdk/js/%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E5%B9%B3%E5%8F%B0/test/bmobSocketIo.html\n\n\n安装实时数据平台的js\n\n\n一、把下面这行代码加入你的页面中，其中，\"bmobSocketIo.js\"为实时数据平台的js文件。\n\n\nscript type=\ntext/javascript\n src=\nbmobSocketIo.js\n/script\n\n\n\n\n\n二、接着是加入下面这行代码进行初始化。\n\n\nBmobSocketIo.initialize(\n你的Application ID\n);\n\n\n\n\n订阅事件\n\n\n订阅表更新的事件\n\n\n订阅表\"GameScore\"更新的事件。\n\n\nBmobSocketIo.updateTable(\nGameScore\n);\n\n\n\n\n订阅行更新的事件\n\n\n订阅表\"GameScore\"中行objectId为\"3342e40e4f\"更新的事件。\n\n\nBmobSocketIo.updateRow(\nGameScore\n,\n3342e40e4f\n);\n\n\n\n\n订阅行删除的事件\n\n\n订阅表\"GameScore\"中行objectId为\"3342e40e4f\"删除的事件。\n\n\nBmobSocketIo.deleteRow(\nGameScore\n,\n1256e40e4f\n);\n\n\n\n\n取消订阅事件\n\n\n取消订阅表更新的事件\n\n\n取消订阅表\"GameScore\"更新的事件。\n\n\nBmobSocketIo.unsubUpdateTable(\nGameScore\n);\n\n\n\n\n取消订阅行更新的事件\n\n\n取消订阅表\"GameScore\"中objectId为\"3342e40e4f\"行更新的事件。\n\n\nBmobSocketIo.unsubUpdateRow(\nGameScore\n,\n3342e40e4f\n);\n\n\n\n\n取消订阅行删除的事件\n\n\n取消订阅表\"GameScore\"中objectId为\"3342e40e4f\"行删除的事件。\n\n\nBmobSocketIo.unsubDeleteRow(\nGameScore\n,\n1256e40e4f\n);\n\n\n\n\n监听触发的事件\n\n\n监听更新表的事件\n\n\n当订阅了表更新的表数据发送变化时，js中会触发函数onUpdateTable。\n\n\ntablename为更新的表，data为服务端返回的更新数据。\n\n\n   BmobSocketIo.onUpdateTable = function(tablename,data) {    \n      //业务逻辑的代码\n   };\n\n\n\n\n监听行更新的事件\n\n\ntablename为更新的表，objectId为更新行的objectId，data为服务端返回的更新数据。\n\n\n   BmobSocketIo.onUpdateRow = function(tablename,objectId,data) {    \n      //业务逻辑的代码\n   };\n\n\n\n\n监听行删除的事件\n\n\ntablename为更新的表，objectId为更新行的objectId，data为服务端返回的更新数据。\n\n\n   BmobSocketIo.onDeleteRow = function(tablename,objectId,data) {    \n      //业务逻辑的代码\n   };\n\n\n\n\ndemo\n\n\n在线上演示实时数据平台的一个聊天应用的demo：\nchat room demo\n ，演示了如何使用实时数据服务实现聊天的功能。\n\n\n用浏览器打开两个窗口，在其中一个窗口输入\n昵称\n和\n内容\n，按\n发送\n按钮，在另外一个窗口能看到发送的内容。\n\n\n\n\nACL和角色\n\n\n数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看\nBmob数据与安全页面\n，了解Bmob如何保护数据安全）。\n\n\n其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。\n\n\n大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：\n\n\n\n\n对于私有数据，读写权限可以只局限于数据的所有者。\n\n\n对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。\n\n\n对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。\n\n\n属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。\n\n\n一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。\n\n\n\n\nACL的格式\n\n\n在Bmob中，ACL是按JSON对象格式（key-value）来表示的。这个JSON对象的key是objectId（用户表某个用户对应的objectId）或者是*(表示公共的访问权限)，ACL 的值是\"读和写的权限\"，这个JSON对象的key总是权限名，而这些key的值总是true。\n\n\n如果您想让一个id为\"Kc3M222k\"的用户有读和写一条数据的权限，而且这个数据应该可以被全部人读取的话，这个ACL的表达方式如下：\n\n\n{\n  \nKc3M222k\n: {\n    \nread\n: true,\n    \nwrite\n: true\n  },\n  \n*\n: {\n    \nread\n: true\n  }\n}\n\n\n\n\n角色和相关操作\n\n\n在很多情况下，你需要定义一些用户具有某种相同的数据操作权限，而另外一群用户具有另外一种相同的数据操作权限，这时你就可以使用到Bmob的角色（对应Bmob在Web提供的Role表、SDK中的BmobRole类）功能，设置不同的用户组不同的操作权限。角色表有三个特殊字段：\n\n\nname\n : 必须字段，表示角色名称,而且只允许被设置一次（命名必须由字母, 空格, 减号或者下划线构成）。\n\n\nusers\n :一个指向一系列用户的关系, 这些用户会继承角色的权限。\n\n\nroles\n : 一个指向一系列子角色的关系, 这些子关系会继承父角色所有的权限。\n\n\n创建角色\n\n\nvar roleACL = new Bmob.ACL();\nroleACL.setPublicReadAccess(true);\nvar role = new Bmob.Role(\ntest\n, roleACL);\nrole.save();\n\n\n\n\n角色对象的安全性\n\n\nBmob.Role\n使用和其他Bmob对象一样的ACL权限策略, 除开它需要ACL被显式地设置以外。通常来说，只有用户有极大的权限（比如管理员）才应该被允许创建或者更改Role，所以你应该按这种标准来设定Role的ACL。请注意，如果你给了用户一个\nBmob.Role\n一个写权限，这个用户有可能会在这个权限中加入另一个user，或者甚至直接把角色删除掉。\n\n\n为了创建一个新的\nBmob.Role\n，你应该如下写：\n\n\n// By specifying no write privileges for the ACL, we can ensure the role cannot be altered.\nvar roleACL = new Bmob.ACL();\nroleACL.setPublicReadAccess(true);\nvar role = new Bmob.Role(\nAdministrator\n, roleACL);\nrole.save();\n\n\n\n\n你可以通过增加\"user\"和\"roles\"关系的成员来在\nBmob.Role\n中加入用户或者子角色：\n\n\nvar role = new Bmob.Role(roleName, roleACL);\nfor (var i = 0; i \n usersToAddToRole.length; i++) {\n  role.getUsers().add(usersToAddToRole[i]);\n}\nfor (var i = 0; i \n rolesToAddToRole.length; i++) {\n  role.getRoles().add(rolesToAddToRole[i]);\n}\nrole.save();\n\n\n\n\n请非常注意一点，注册角色的ACL的时候，它们只能被应该有权限修改它的人修改。\n\n\n其他对象的安全性\n\n\n现在你应该已经创建了在你的程序中要使用的一系列的角色，你可以用ACL来定义他们的用户可以拥有的权限，每一个\nBmob.Object\n都可以指定一个\nBmob.ACL\n，这样提供了哪些用户或者角色应该有权限来读或者写这个对象。\n\n\n将一个读或者写的权限授予一个角色是很直观的，你可以使用\nBmob.Role\n：\n\n\nvar moderators = /* Query for some Bmob.Role */;\nvar wallPost = new Bmob.Object(\nWallPost\n);\nvar postACL = new Bmob.ACL();\npostACL.setRoleWriteAccess(moderators, true);\nwallPost.setACL(postACL);\nwallPost.save();\n\n\n\n\n你可以不需要查找这个Role，直接把名字提供给ACL：\n\n\nvar wallPost = new Bmob.Object(\nWallPost\n);\nvar postACL = new Bmob.ACL();\npostACL.setRoleWriteAccess(\nModerators\n, true);\nwallPost.setACL(postACL);\nwallPost.save();\n\n\n\n\n角色继承\n\n\n就像上面所描述的一样，一个角色可能包含其他的角色，表示两个角色之间的父-子关系，这样做的结果就是任何被授予一个角色的权限都会被隐式地授予这个角 色的所有子角色。\n\n\n这样的关系很经常会在有用户管理内容的程序之中看到，比如论坛，有一个很少量的用户称为管理员，有最高的权限，比如程序设定、创建新的论坛、设定所有人能看到的内容等等。另一类有一部分类似于\"版主\" 的用户，这些人有责任保持用户创建的内容是合适的，任何一个\"版主\"有的权限\"管理员\"都应该有。为了启用这种关系，你应该使\"管理员\"成为\"版主\"的一个子角色。\n\n\nvar administrators = /* Your \nAdministrators\n role */;\nvar moderators = /* Your \nModerators\n role */;\nmoderators.getRoles().add(administrators);\nmoderators.save();\n\n\n\n\n地理位置\n\n\n创建地理位置对象\n\n\n地理位置对象的创建需要用到\nBmob.GeoPoint\n类，如创建一个地理位置在纬度40度，经度在-30度的点的示例代码如下：\n\n\nvar point = new Bmob.GeoPoint({latitude: 40.0, longitude: -30.0});\n\n\n\n\n查询地理位置对象\n\n\n现在你可以有一系列的对象可以做空间坐标查询了，如果能轻松地发现有哪些对象离一个点最近就好了。这样可以通过在\nBmob.Query\n中加入一个\nnear\n来做查询，为了获得离用户最近的10个地点列表，可以这样：\n\n\n// location对应Web后台的一个字段名称\nvar userGeoPoint = userObject.get(\nlocation\n);\n// 创建查询\nvar query = new Bmob.Query(PlaceObject);\n// location附近的位置\nquery.near(\nlocation\n, userGeoPoint);\n// 返回10个地点数据\nquery.limit(10);\n// 查询\nquery.find({\n  success: function(placesObjects) {\n  }\n});\n\n\n\n\n在这时\nplaceObjects\n会返回一个按离\nuserGeoPoint\n的距离排序的列表，注意如果一个\nascending()/descending()\n给了查询的话，会取代按距离排序这项特性。\n\n\n为了按距离限制返回的结果，你可以使用\nwithinMiles\n、\nwithinKilometers\n和\nwithinRadians\n。\n\n\n同样，查询在特定地域的Object是可以的。为了找到用矩形表示的一块地域中的对象，加入\nwithinGeoBox\n来在\nBmob.Query\n中加入约束。\n\n\nvar southwestOfSF = new Bmob.GeoPoint(37.708813, -122.526398);\nvar northeastOfSF = new Bmob.GeoPoint(37.822802, -122.373962);\n\nvar query = new Bmob.Query(PizzaPlaceObject);\nquery.withinGeoBox(\nlocation\n, southwestOfSF, northeastOfSF);\nquery.find({\n  success: function(pizzaPlacesInSF) {\n    ...\n  }\n});\n\n\n\n\n错误代码详细说明\n\n\n错误码列表", 
            "title": "开发文档"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_1", 
            "text": "Bmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。    Bmob的JavaScript SDK基于 Backbone.js 框架开发，在使用过程中除 Bmob.view 类需要提供jQuery或者类似JQuery的 $ 方法外，不需要再引入其他类库。", 
            "title": "简介"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_2", 
            "text": "聊天室： http://chatroom.bmob.cn  （采用实时数据同步SDK开发，右击可直接查看源码）", 
            "title": "典型案例"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_3", 
            "text": "在Bmob平台注册后，每个账户可创建多个应用程序，创建的每个应用程序都有其独自的应用程序ID，此后所有的应用程序将凭其ID进行Bmob SDK的使用。即使只有一个应用程序，也可以以不同的版本进行测试和生产。", 
            "title": "应用程序"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_4", 
            "text": "", 
            "title": "对象"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_5", 
            "text": "Bmob数据存储是建立在 Bmob.Object 基础上的。如记录游戏成绩的 Bmob.Object 示例如下：  score: 1337, playerName:  bmob , cheatMode: false  这里需要注意的是：   键必须是字母或者数字的字符串，值可以是字符串、数字、布尔值或者数组和字典。  每一个 Bmob.Object 都是一个特定子类的实例，子类名可以来区分各种数据，如我们可以把记录游戏成绩的类称之为 GameScore 。", 
            "title": "数据对象"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_6", 
            "text": "你可以使用 Bmob.Object.extend 方法来创建新的 Bmob.Object 子类，示例代码如下：  // 创建Bmob.Object子类\nvar GameScore = Bmob.Object.extend( GameScore );\n\n// 创建该类的一个实例\nvar gameScore = new GameScore();  如果你想为 Bmob.Object 的子类添加一些实例方法和类方法，示例代码如下：  // 为Bmob.Object的子类添加实例方法和类方法\nvar GameScore = Bmob.Object.extend( GameScore , {\n  //实例方法\n  gleaterThanOneHundred: function() {\n    return this.get( score )   100;\n  }\n}, {\n  //类方法\n  spawn: function(score) {\n    var gameScore = new GameScore();\n    gameScore.set( score , score);\n    return gameScore;\n  }\n});\n\nvar gameScore = GameScore.spawn(200);\nalert(gameScore.gleaterThanOneHundred());", 
            "title": "创建对象"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_7", 
            "text": "添加数据非常简单，任何 Bmob.Object 子类都有 save 方法可以用于将当前对象的内容保存到服务端。示例代码如下：  //创建类和实例\nvar GameScore = Bmob.Object.extend( GameScore );\nvar gameScore = new GameScore();\ngameScore.set( score , 137);\ngameScore.set( playerName ,  bmob );\ngameScore.set( cheatMode , false);\n//添加数据，第一个入口参数是null\ngameScore.save(null, {\n  success: function(gameScore) {\n    // 添加成功，返回成功之后的objectId（注意：返回的属性名字是id，不是objectId），你还可以在Bmob的Web管理后台看到对应的数据\n    alert('添加数据成功，返回的objectId是：' + gameScore.id);\n  },\n  error: function(gameScore, error) {\n    // 添加失败\n    alert('添加数据失败，返回错误信息：' + error.description);\n  }\n});  你也可以用如下的示例代码添加数据：  var GameScore = Bmob.Object.extend( GameScore );\nvar gameScore = new GameScore();\n// 添加数据，第一个入口参数是Json数据\ngameScore.save({\n  score: 1337,\n  playerName:  bmob ,\n  cheatMode: false\n}, {\n  success: function(gameScore) {\n    // 添加成功\n  },\n  error: function(gameScore, error) {\n    // 添加失败\n  }\n});  这里有几点需要注意的是:   如果云端数据库中不存在 GameScore 表，Bmob会自动地在你第一次使用它的时候创建。  每个 Bmob.Object 对象都有几个默认的字段是自动创建的： objectId 是一个对于每一个保存的对象为一个标志； createdAt 和 updatedAt 表示对象在Bmob中创建和最后一次更改的时间。这些字段的创建和内容是由服务器端自动完成的，在保存 Bmob.Object 之前不会存在。  添加成功后，可以通过 gameScore.createdAt 获取对象的创建时间，通过 gameScore.updatedAt 获取对象的更新时间；可以通过 gameScore.id 获取对象的objectId。", 
            "title": "添加数据"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_8", 
            "text": "数据的查询是每个应用都会频繁使用到的，Bmob提供了 Bmob.Object 类，方便大家实现不同条件的查询。", 
            "title": "查询数据"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_9", 
            "text": "查询某个数据表中的所有数据是非常简单的，只需要使用 Bmob.Query 的 find 方法就可以了，示例代码如下：  var GameScore = Bmob.Object.extend( GameScore );\nvar query = new Bmob.Query(GameScore);\n// 查询所有数据\nquery.find({\n  success: function(results) {\n    alert( 共查询到   + results.length +   条记录 );\n    // 循环处理查询到的数据\n    for (var i = 0; i   results.length; i++) {\n      var object = results[i];\n      alert(object.id + ' - ' + object.get('playerName'));\n    }\n  },\n  error: function(error) {\n    alert( 查询失败:   + error.code +     + error.message);\n  }\n});  如果你只想要一个结果，一个更加方便的方法是使用 first ，而不是 find 方法，示例代码如下：  var GameScore = Bmob.Object.extend( GameScore );\nvar query = new Bmob.Query(GameScore);\nquery.first({\n  success: function(object) {\n    // 查询成功\n  },\n  error: function(error) {\n    alert( 查询失败:   + error.code +     + error.message);\n  }\n});  这里需要注意一点的是： \n默认情况下，系统实际上并不会返回所有的数据，而是默认返回10条数据记录，你可以通过setLimit方法设置返回的记录数量。更多细节可 点击查看分页查询 一节。", 
            "title": "查询所有数据"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_10", 
            "text": "注意，在对象中获取objectId，createdAt，updatedAt的方法分别如下：\nobj.id\nobj.createdAt\nobj.updatedAt", 
            "title": "获取对象的特殊属性"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_11", 
            "text": "当我们知道某条数据的 objectId 时，就可以根据 objectId 值直接获取单条数据对象，示例代码如下：  var GameScore = Bmob.Object.extend( GameScore );\n//创建查询对象，入口参数是对象类的实例\nvar query = new Bmob.Query(GameScore);\n//查询单条数据，第一个参数是这条数据的objectId值\nquery.get( 82c3e62d2c , {\n  success: function(gameScore) {\n    // 查询成功，调用get方法获取对应属性的值\n    var score = gameScore.get( score );\n    var playerName = gameScore.get( playerName );\n    var cheatMode = gameScore.get( cheatMode );\n  },\n  error: function(object, error) {\n    // 查询失败\n  }\n});", 
            "title": "查询单条数据"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_12", 
            "text": "如果要查询某个属性等于某个值，示例代码如下：  query.equalTo( playerName ,  bmob );  如果要查询某个属性不等于某个值，示例代码如下：  query.notEqualTo( playerName ,  bmob cloud );  对查询的属性值进行大小比较的示例代码如下：  // score   50\nquery.lessThan( score , 50);\n\n// score  = 50\nquery.lessThanOrEqualTo( score , 50);\n\n// score   50\nquery.greaterThan( score , 50);\n\n// score  = 50\nquery.greaterThanOrEqualTo( score , 50);  两条查询语句一起写，就相当于 AND 查询，如下示例代码，查询同时满足 \"playerName\"=\"bmob\" and \"score\" 100 的数据：  query.notEqualTo( playerName ,  bmob );\nquery.greaterThan( score , 100);  一个完整的例子：  var GameScore = Bmob.Object.extend( GameScore );\nvar query = new Bmob.Query(GameScore);\nquery.equalTo( playerName ,  bmob ); \n// 查询所有数据\nquery.find({\n    success: function(results) {\n        alert( 共查询到   + results.length +   条记录 );\n        // 循环处理查询到的数据\n        for (var i = 0; i   results.length; i++) {\n        var object = results[i];\n        alert(object.id + ' - ' + object.get('playerName'));\n        }\n    },\n    error: function(error) {\n        alert( 查询失败:   + error.code +     + error.message);\n    }\n});", 
            "title": "条件查询"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_13", 
            "text": "有时，在数据比较多的情况下，你希望查询出的符合要求的所有数据能按照多少条为一页来显示，这时可以使用 limit 方法来限制查询结果的数据条数来进行分页。默认情况下，Limit的值为10，最大有效设置值1000（设置的数值超过1000还是视为1000）。  // 返回最多10条数据\nquery.limit(10);   在数据较多的情况下，在 limit 的基础上分页显示数据是比较合理的解决办法， skip 方法可以做到跳过查询的前多少条数据来实现分页查询的功能。默认情况下 skip 的值为10。  query.skip(10); // skip the first 10 results", 
            "title": "分页查询"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_14", 
            "text": "我们可以对返回的结果进行排序（只支持 number 和 string 类型的排序），示例代码如下：  // 对score字段升序排列\nquery.ascending( score );\n\n// 对score字段降序排列\nquery.descending( score );", 
            "title": "结果排序"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_15", 
            "text": "如果你只是想统计满足 query 的结果集到底有多条记录，你可以使用 count 方法。如为了获得GameScore表的记录数量，示例代码如下：  var GameScore = Bmob.Object.extend( GameScore );\nvar query = new Bmob.Query(GameScore);\nquery.count({\n  success: function(count) {\n    // 查询成功，返回记录数量\n    alert( 共有   + count +   条记录 );\n  },\n  error: function(error) {\n    // 查询失败\n  }\n});", 
            "title": "统计记录数量"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_16", 
            "text": "如果你想查询某一字段值在某一集合中的记录的话，可以使用 containedIn 方法，如获取 \"Bmob\"、\"Codenow\"、\"JS\" 这三位玩家的记录信息，那么示例代码如下：  // 第一个参数是字段名称，第二个参数是数组\nquery.containedIn( playerName , [ Bmob ,  Codenow ,  JS ]);  相反地，你可以使用 notContainedIn 方法来查询在集合外的目标对象。  如果想要查询含有某一特定属性的对象，可以使用 exists 。相对地，如果你想获取没有这一特定属性的对象，你可以使用 doesNotExist ，示例代码如下：  // 查询含有score属性的对象\nquery.exists( score );\n\n// 查询不含有score属性的对象\nquery.doesNotExist( score );  你可以使用 matchesKeyInQuery 方法来进行嵌套的子查询。举例说，如果你有一个类包含了运动队， 而你在用户类中存储了用户的家乡信息，你可以构造一个查询来查找某地的运动队有赢的记录的用户，示例代码如下：  var Team = Bmob.Object.extend( Team );\nvar teamQuery = new Bmob.Query(Team);\nteamQuery.greaterThan( winPct , 0.5);\nvar userQuery = new Bmob.Query(Bmob.User);\nuserQuery.matchesKeyInQuery( hometown ,  city , teamQuery);\nuserQuery.find({\n  success: function(results) {\n    // results has the list of users with a hometown team with a winning record\n  }\n});  相对地，可以使用 doesNotMatchKeyInQuery 来获取属性不在子查询结果中的对象。比如为了获得用户的家乡队输了的情况：  var Team = Bmob.Object.extend( Team );\nvar teamQuery = new Bmob.Query(Team);\nteamQuery.greaterThan( winPct , 0.5);\nvar userQuery = new Bmob.Query(Bmob.User);\nuserQuery.doesNotMatchKeyInQuery( hometown ,  city , teamQuery);\nuserQuery.find({\n  success: function(results) {\n    // results has the list of users with a hometown team with a winning record\n  }\n});", 
            "title": "复杂查询"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_17", 
            "text": "有时候你不想返回所有的字段信息，那么就可以用 select 方法来限定返回的字段。示例代码如下：  var GameScore = Bmob.Object.extend( GameScore );\nvar query = new Bmob.Query(GameScore);\n// 只返回score和playerName字段值\nquery.select( score ,  playerName );\nquery.find().then(function(results) {\n  // 返回成功\n});  注意：系统默认的字段 objectId 、 createdAt 、 updatedAt 、 ACL 也会返回。", 
            "title": "查询指定列"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_18", 
            "text": "如果想要查询以某一个特定字符串开头的记录，可以使用 startWith 方法，示例代码如下：  // 查询在playerName字段中以bm开头的记录\nvar query = new Bmob.Query(GameScore);\nquery.startsWith( playerName ,  bm );", 
            "title": "对字符串类型做查询"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_19", 
            "text": "你可以使用 Bmob.Query.or 方法操作或查询，示例代码如下：  var lotsOfWins = new Bmob.Query(GameScore);\nlotsOfWins.greaterThan( score , 150);\n\nvar fewWins = new Bmob.Query(GameScore);\nfewWins.lessThan( score , 5);\n\nvar mainQuery = Bmob.Query.or(lotsOfWins, fewWins);\nmainQuery.find({\n  success: function(results) {\n     // 返回 score   150 or score   5 的值\n  },\n  error: function(error) {\n    // 返回失败\n  }\n});  注意：我们不会在组合查询的子查询中支持非过滤型的条件 (比如:limit,skip,ascending/descending,include)", 
            "title": "或查询"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_20", 
            "text": "修改数据非常简单，首先需要获取到要更新的 Bmob.Object 对象，修改值后保存数据就可以了，示例代码如下：  var GameScore = Bmob.Object.extend( GameScore );\nvar query = new Bmob.Query(GameScore);\n\n// 这个 id 是要修改条目的 id，你在生成这个存储并成功时可以获取到，请看前面的文档\nquery.get('3453453453fdsdf', {\n    success: function(gameScore) {\n      // 回调中可以取得这个 GameScore 对象的一个实例，然后就可以修改它了\n      gameScore.set('title', 'test!');\n      gameScore.save();\n\n      // The object was retrieved successfully.\n    },\n    error: function(object, error) {\n\n    }\n});  或者  var GameScore = Bmob.Object.extend( GameScore );\nvar gameScore = new GameScore();\ngameScore.set( cheatMode , true);\ngameScore.set( score , 1338);\n//添加数据\ngameScore.save(null, {\n  success: function(gameScore) {\n    // 修改数据\n    gameScore.set( cheatMode , true);\n    gameScore.set( score , 1338);\n    gameScore.save();\n  }\n})  如果想更新成功后获取更新后的对象属性，请设置 fetchWhenSave ：   //假设gamescore是已经存在的对象\n    gameScore.fetchWhenSave(true);\n    gameScore.set( cheatMode , true);\n    gameScore.set( score , 1338);\n    gameScore.save();", 
            "title": "修改数据"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_21", 
            "text": "删除数据可以使用 Bmob.Object 的 destroy 方法，示例代码如下：  myObject.destroy({\n  success: function(myObject) {\n    // 删除成功\n  },\n  error: function(myObject, error) {\n    // 删除失败\n  }\n});", 
            "title": "删除数据"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_22", 
            "text": "你可以使用 unset 方法在删除一个字段：  // 删除playerName字段\nmyObject.unset( playerName );\nmyObject.save();", 
            "title": "删除字段"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_23", 
            "text": "var number = 42;\nvar string =  the number is   + number;\nvar date = new Date();\nvar array = [string, number];\nvar object = { number: number, string: string };\n\nvar bigObject = new BigObject();\nbigObject.set( myNumber , number);\nbigObject.set( myString , string);\nbigObject.set( myDate , date);\nbigObject.set( myArray , array);\nbigObject.set( myObject , object);\nbigObject.set( myNull , null);\nbigObject.save();", 
            "title": "常见数据类型的操作"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_24", 
            "text": "", 
            "title": "数组操作"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_25", 
            "text": "为了帮你存储数组类数据，有三种操作你可以原子性地改动一个数组，这需要一个给定的 key：   add 在一个数组的末尾加入一个给定的对象。  addUnique 只会把原本不存在的对象加入数组，所以加入的位置没有保证。   比如, 我们想在数组\"skills\"中加入项目：  gameScore.addUnique( skills ,  flying );\ngameScore.addUnique( skills ,  kungfu );\ngameScore.save();", 
            "title": "添加及更新数组"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_26", 
            "text": "对于value是数组的情况，你可以这样查询数组中的值有 2 的情况的对象：  // Find objects where the array in arrayKey contains 2.\nquery.equalTo( arrayKey , 2);  你同样可以用下面的方式找到同时包含元素 2、3、4 的数组：  // Find objects where the array in arrayKey contains all of the elements 2, 3, and 4.\nquery.containsAll( arrayKey , [2, 3, 4]);", 
            "title": "数组查询"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_27", 
            "text": "remove 在一个数组中删除所有指定的所有实例：  var GameScoretest = Bmob.Object.extend( GameScoretest );\nvar query = new Bmob.Query(GameScoretest);\nquery.get( bc5da708dc ,{\n  success: function(gameScore) {\n    gameScore.remove( skills , test );\n    gameScore.save();\n  },\n  error: function(error) {\n    alert( Error:   + error.code +     + error.message);\n  }\n});", 
            "title": "删除数组"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_28", 
            "text": "", 
            "title": "数据关联"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_29", 
            "text": "", 
            "title": "添加及修改关联关系"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_30", 
            "text": "一对一关系和一对多关系都可以通过在一个 Bmob.Object 内保存另一个对象来实现。比如，每一个 Comment都对应了一个Post，创建一个有一个Comment的Post，你可以这样写：  // Declare the types.\nvar Post = Bmob.Object.extend( Post );\nvar Comment = Bmob.Object.extend( Comment );\n\n// Create the post\nvar myPost = new Post();\nmyPost.set( title ,  I'm Hungry );\nmyPost.set( content ,  Where should we go for lunch? );\n\n// Create the comment\nvar myComment = new Comment();\nmyComment.set( content ,  Let's do Sushirrito. );\n\n// Add the post as a value in the comment\nmyComment.set( parent , myPost);\n\n// This will save both myPost and myComment\nmyComment.save();  Bmob内部会自动处理，调用Comment的 save 方法就可以同时保存两个新对象。  如果是现有对象想要关联到新对象，你同样可以通过只用它们的 objectId 来连接彼此。请注意，不能直接像上面的例子那样将现有对象设置进去，而是必须 new 一个新对象并只设置 id 属性：  var post = Bmob.Object.createWithoutData( Post ,  320b0395f3 );\nmyComment.set( parent , post);  或者：  var post = new Post();\npost.id = '520c7e1ae4b0a3ac9ebe326a';\nmyComment.set( parent , post);  默认情况下，当获取一个对象时，关联的 Bmob.Object 不会被获取到，这些对象的值不能访问，除非像下面这样获取它们：  var post = fetchedComment.get( parent );\npost.fetch({\n  success: function(post) {\n    var title = post.get( title );\n  }\n});", 
            "title": "一对一关系和一对多关系"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_31", 
            "text": "多对多关系是通过 Bmob.Relation 来建模的，这样很像在一个key中存储一个 Bmob.Object 数组，但是你不需要一次性下载关系中的所有对象。这使得 Bmob.Relation 比数组可以更好地扩展到更多对象。例如，一个User可能喜欢很多Post，在这种情况下，你可以把一个用户喜欢的所有Post存为一个Relation，为了将一个Post加入一个User的like列表，你可以：  var user = Bmob.User.current();\nvar relation = user.relation( likes );\nrelation.add(post);\nuser.save();  你还可以传入一个 Bmob.Object 数组来做 add 和 remove ：  relation.add([post1, post2, post3]);\nuser.save();", 
            "title": "多对多关系"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_32", 
            "text": "默认情况下， relation 关联的对象并不会被下载，你可以通过使用 query 方法返回的 Bmob.Query 对象来获取 Bmob.Object 的列表，例如：  relation.query().find({\n  success: function(list) {\n    // list contains the posts that the current user likes.\n  }\n});  如果你仅仅要一个Post的子集，你可以在 Bmob.Query 中加入更多的条件：  var query = relation.query();\nquery.equalTo( title ,  I'm Hungry );\nquery.find({\n  success:function(list) {\n    // list contains post liked by the current user which have the title  I'm Hungry .\n  }\n});  如果希望查询结果中包含多个相关联的其他数据类型。你可以使用 include 方 法。例如有个comments，你可能想同时获取它们相关的 post 数据:  var query = new Bmob.Query(Comment);\n\nquery.include( post );  你可以在接下来关于 Bmob.Query 的章节中看到更详细的内容。一个 Bmob.Relation 的行为很像一个 Bmob.Object 数组，所以任何在数组可做的查询操作，也都可以作用在 Bmob.Relation 上。  如果你知道post，想反向查询user，可以通过 Bmob.Relation.reverseQuery 方法：  var query = Bmob.Relation.reverseQuery('_User', 'likes', post);\nquery.find({\n  success:function(users) {\n   //users是表示喜欢这个post的用户列表。\n  }\n});", 
            "title": "查询关联关系"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_33", 
            "text": "你可以从一个 Bmob.Relation 中删除一个post：  relation.remove(post);\nuser.save();  你可以在用 save 方法保存前多次调用 add 和 remove 方法：  relation.remove(post1);\nrelation.remove(post2);\nuser.save();", 
            "title": "删除关联关系"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_34", 
            "text": "许多应用都需要维持一些计数器数据，譬如用来跟踪游戏分数、金币甚至道具的数目等等。Bmob提供了便捷的方式来对任何数字字段进行原子性的增加或者减少：  gameScore.increment( score );\ngameScore.save();  你可以同样传入第二个参数到 increment 方法来指定增加多少， 1 是默认值。", 
            "title": "原子计数器"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_35", 
            "text": "", 
            "title": "文件"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_36", 
            "text": "上传文件有两种方法：  直接上传文件，例如，我们上传一个内容为\"Hello, World!\"，名称为\"hello.txt\"的文件，可用如下的代码：  var bytes =  Hello, World! ;\nvar file = new Bmob.File( hello.txt , bytes);\nfile.save().then(function(obj) {\n  //alert(obj.url());\n}, function(error) {\n  // the save failed.\n});  最经常的对于HTML5的应用来说，可能需要用html表单和一个文件上传控制器。在现代的浏览器中这很容易，只需要创建一个file input tag来允许用户选择他们磁盘上的文件就可以了。  input type= file  id= profilePhotoFileUpload   然后，在一个处理 click 或其他的函数里，获取对那个文件的一个引用：          var fileUploadControl = $( #profilePhotoFileUpload )[0];\n        if (fileUploadControl.files.length   0) {\n        var file = fileUploadControl.files[0];\n        var name =  logo.jpg ;\n        var file = new Bmob.File(name, file);     \n        file.save();", 
            "title": "整个文件上传"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_37", 
            "text": "file.destroy(); //删除文件", 
            "title": "文件删除"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_38", 
            "text": "提供一些工具接口，方便开发者处理图片。", 
            "title": "图片处理"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_39", 
            "text": "提供原图的URL地址和相应的参数， 返回缩微图的URL地址， 具体参数定义如下：  mode:模式 0: 指定宽， 高自适应，等比例缩放\n     模式 1: 指定高， 宽自适应，等比例缩放\n     模式 2: 指定最长边，短边自适应，等比例缩放\n     模式 3: 指定最短边，长边自适应，等比例缩放\n     模式 4: 指定最大宽高， 等比例缩放\n     模式 5: 固定宽高， 居中裁剪    \nimage:原图片url\nwidth:宽度，模式 0, 4, 5必填\nheight：高度，模式 1, 4, 5必填\nlongEdge：长边，模式 2必填\nshortEdge：短边，模式 3必填\nquality：质量，选填, 范围 1-100\noutType：输出类型，0:默认，输出url；1:输出base64编码的字符串流  调用的代码：  Bmob.Image.thumbnail({ image : http://file.bmob.cn/M00/01/26/wKgBP1OX9LLVh5gNAAHGYsmKRjk666.jpg , mode :0, quality :100, width :100}\n\n  ).then(function(obj) {\n\n  alert( filename: +obj.filename); //\n  alert( url: +obj.url); //\n});  如果 outType = 0 返回云端url地址:  {\n   filename :  e6c8ac18c9.jpg ,\n   group :  group1 ,\n   url :  M00/01/6E/wKhkA1OGpWKAGdNUAAAjdkbUqo4612.jpg \n}  如果  outType = 1  返回文件内容的 base64 字符串：  {\n   file : base64的文件内容 \n}", 
            "title": "缩微图"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_40", 
            "text": "提供原图的URL地址，水印图的URL地址和相应的参数，返回缩微图的URL地址，具体参数定义如下：  image：原图路径\nwatermark：水印图路径\ndissolve:透明度，0-255\ndistanceX：横轴边距，单位:像素(px)，缺省值为10\ndistanceY：纵轴边距，单位:像素(px)，缺省值为10\noutType：输出类型，0:默认，输出url；1:输出base64编码的字符串流\ngravity:水印位置，见下图   调用的代码：  //get image thumbnail\nBmob.Image.watermark({ image : http://test.com/new/images/banner005.jpg , watermark : http://test.com/new/images/header2.png , dissolve :100, gravity : SouthWest , distanceX :10, distanceY :10}\n\n  ).then(function(obj) {\n\n  alert( filename: +obj.filename); //\n  alert( url: +obj.url); //\n});  如果  outType = 0  返回云端url地址:  {\n   filename :  e6c8ac18c9.jpg ,\n   group :  group1 ,\n   url :  M00/01/6E/wKhkA1OGpWKAGdNUAAAjdkbUqo4612.jpg \n}  如果  outType = 1  返回文件内容的 base64 字符串：  {\n   file : base64的文件内容 \n}", 
            "title": "水印图"
        }, 
        {
            "location": "/data/javascript/develop_doc/#promise", 
            "text": "除了回调函数之外，每一个在Bmob JavaScript SDK中的异步方法都会返回一个 Promise. 使用 Promise，你的代码可以比原来的嵌套 callback 的方法看起来优雅得多.", 
            "title": "Promise"
        }, 
        {
            "location": "/data/javascript/develop_doc/#then", 
            "text": "每一个 Promise 都有一个叫 then 的方法, 这个方法接受一对 callback 。第一个 callback 在 promise 被解决的时候调用，第二个会在 promise 被拒绝的时候调用。  obj.save().then(function(obj) {\n  // the object was saved successfully.\n}, function(error) {\n  // the save failed.\n});", 
            "title": "then 方法"
        }, 
        {
            "location": "/data/javascript/develop_doc/#promise_1", 
            "text": "Promise 比较神奇，可以代替多层嵌套方式来解决发送异步请求代码的调用顺序问题。 如果一个 Promise 的回调会返回一个 Promise ，那么第二个 then 里的 callback 在第一个 then 的 callback 没有解决前是不会解决的。  var query = new Bmob.Query( Student );\nquery.descending( gpa );\nquery.find().then(function(students) {\n  students[0].set( valedictorian , true);\n  return students[0].save();\n\n}).then(function(valedictorian) {\n  return query.find();\n\n}).then(function(students) {\n  students[1].set( salutatorian , true);\n  return students[1].save();\n\n}).then(function(salutatorian) {\n  // Everything is done!\n\n});", 
            "title": "将Promise 组织在一起"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_41", 
            "text": "如果任意一个在链中的 Promise 返回一个错误的话，所有的成功的 callback 在接下来都会被跳过直到遇到一个处理错误的 callback 。处理 error 的 callback 可以转换 error 或者可以通过返回一个新的 Promise 的方式来处理它。你可以想象成拒绝的 promise 有点像异常，而 error callback 则像是一个 catch 来处理这个异常或者抛出异常。  var query = new Bmob.Query( Student );\nquery.descending( gpa );\nquery.find().then(function(students) {\n  students[0].set( valedictorian , true);\n  // Force this callback to fail.\n  return Bmob.Promise.error( There was an error. );\n\n}).then(function(valedictorian) {\n  // Now this will be skipped.\n  return query.find();\n\n}).then(function(students) {\n  // This will also be skipped.\n  students[1].set( salutatorian , true);\n  return students[1].save();\n}, function(error) {\n  // This error handler WILL be called. error will be  There was an error. .\n  // Let's handle the error by returning a new promise.\n  return Bmob.Promise.as( Hello! );\n\n}).then(function(hello) {\n  // Everything is done!\n}, function(error) {\n  // This isn't called because the error was already handled.\n});  通常来说，在正常情况的回调函数链的末尾，加一个错误处理的回调函数会是很方便的做法.", 
            "title": "错误处理"
        }, 
        {
            "location": "/data/javascript/develop_doc/#promise_2", 
            "text": "在开始阶段，你可以只用系统（譬如 find 和 save 方法等）返回的 promise 。但在更高级的场景下，你可能需要创建自己的 promise 。在创建了 Promise 之后，你需要调用 resolve 或者 reject 来触发它的 callback 。  var successful = new Bmob.Promise();\nsuccessful.resolve( The good result. );\n\nvar failed = new Bmob.Promise();\nfailed.reject( An error message. );  如果你在创建 promise 的时候就知道它的结果，下面有两个很方便的方法可以使用：  var successful = Bmob.Promise.as( The good result. );\nvar failed = Bmob.Promise.error( An error message. );", 
            "title": "创建 Promise"
        }, 
        {
            "location": "/data/javascript/develop_doc/#promise_3", 
            "text": "var query = new Bmob.Query( Comments );\nquery.equalTo( post , 123);\n\nquery.find().then(function(results) {\n  // Create a trivial resolved promise as a base case.\n  var promise = Bmob.Promise.as();\n  _.each(results, function(result) {\n    // For each item, extend the promise with a function to delete it.\n    promise = promise.then(function() {\n      // Return a promise that will be resolved when the delete is finished.\n      return result.destroy();\n    });\n  });\n  return promise;\n\n}).then(function() {\n  // Every comment was deleted.\n});", 
            "title": "顺序的Promise"
        }, 
        {
            "location": "/data/javascript/develop_doc/#promise_4", 
            "text": "你也可以用 Promise 来并行的进行多个任务，这时需要使用 when 方法。你可以一次同时开始几个操作，使用 Bmob.Promise.when 来创建一个新的 promise ，它会在所有输入的 Promise 被解决之后才被解决。即便一些输入的 promise 失败了，新的 Promise 也会被成功执行。你可以在  callback 的参数部分检查每一个 promise 的结果，并行地进行操作会比顺序进行更快，但是也会消耗更多的系统资源和带宽。  var query = new Bmob.Query( Comments );\nquery.equalTo( post , 123);\n\nquery.find().then(function(results) {\n  // Collect one promise for each delete into an array.\n  var promises = [];\n  _.each(results, function(result) {\n    // Start this delete immediately and add its promise to the list.\n    promises.push(result.destroy());\n  });\n  // Return a new promise that is resolved when all of the deletes are finished.\n  return Bmob.Promise.when(promises);\n\n}).then(function() {\n  // Every comment was deleted.\n});", 
            "title": "并行的Promise"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_42", 
            "text": "有了上面这些工具以后, 就很容易创建你自己的异步方法来返回 promise 了。举例说，你可以创建一个有 promise 版本的 setTimeout 。  var delay = function(millis) {\n  var promise = new Bmob.Promise();\n  setTimeout(function() {\n    promise.resolve();\n  }, millis);\n  return promise;\n};\n\ndelay(100).then(function() {\n  // This ran after 100ms!\n});", 
            "title": "创建异步方法"
        }, 
        {
            "location": "/data/javascript/develop_doc/#collection", 
            "text": "一个 Bmob.Collection 就是一个 Bmob.Objects 的有序集合，它和 Backbone.Collection 是兼容的，有相同的特性和功能，你可以通过用一个模型类或者一个特定的 Bmob.Query 来创建一个新的子类。  // A Collection containing all instances of TestObject.\nvar TestCollection = Bmob.Collection.extend({\n  model: TestObject\n});\nvar collection = new TestCollection();\n\n// A Collection of TestObjects whose temperature is  hot .\nvar HotCollection = Bmob.Collection.extend({\n  model: TestObject,\n  query: (new Bmob.Query(TestObject)).equalTo( temperature ,  hot )\n});\nvar collection = new HotCollection();\n\n// The Collection of TestObjects that match a complex query.\nvar query = new Bmob.Query(TestObject);\nquery.equalTo( temperature ,  hot );\nquery.greaterThan( degreesF , 100);\nvar collection = query.collection();", 
            "title": "Collection"
        }, 
        {
            "location": "/data/javascript/develop_doc/#collection_1", 
            "text": "使用 fetch 方法来获取一个 collection 里的所有元素:  var collection = new TestCollection();\ncollection.fetch({\n  success: function(collection) {\n    collection.each(function(object) {\n      console.warn(object);\n    });\n  },\n  error: function(collection, error) {\n    // The collection could not be retrieved.\n  }\n});", 
            "title": "获取Collection"
        }, 
        {
            "location": "/data/javascript/develop_doc/#collection_2", 
            "text": "你可以设定一个 comparator 来对 collection 中的元素进行排序:  var collection = new TestCollection();\ncollection.comparator = function(object) {\n  return object.get( temperature );\n};", 
            "title": "Collection 排序"
        }, 
        {
            "location": "/data/javascript/develop_doc/#collection_3", 
            "text": "Collection 是可变的，你可以访问所有元素，增加或者删除元素：  var collection = new TestCollection();\n\ncollection.add([\n  { name :  Duke },\n  { name :  Scarlett }\n]);\n\n// Get the  Duke  Bmob.Object by its sorted position.\nvar model = collection.at(0);\n\n// Or you can get it by Bmob objectId.\nvar modelAgain = collection.get(model.id);\n\n// Remove  Duke  from the collection.\ncollection.remove(model);\n\n// Completely replace all items in the collection.\ncollection.reset([\n  { name :  Hawk },\n  { name :  Jane }\n]);", 
            "title": "修改一个 Collection"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_43", 
            "text": "在许多应用中，都有一个用户账户的概念，用户账户让用户可以用安全的方式访问他们自己的信息。我们提供了一个特殊的用户类叫 Bmob.User 来自动处理有关用户的账户管理的功能。  Bmob.User 是 Bmob.Object 的一个子类，而且有 Bmob.Object 一样的功能，比如可变的模式、自动的持久化、键值对接口等。所有对 Bmob.Object 有用的方法同样可以作用于 Bmob.User 。 Bmob.User 的不同之处在于 Bmob.User 对于用户的账户有一些特定的功能。", 
            "title": "用户"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_44", 
            "text": "Bmob.User 有一些与 Bmob.Object 不一样的字段:  username ：用户的用户名（必须提供） password ：用户的密码（在注册的时候必须提供） email ：用户的 email（可选）\n我们会在下面的用例中详细介绍细节", 
            "title": "属性"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_45", 
            "text": "通常你的app第一件要做的事情就是让用户进行注册，下面的代码展示了怎样进行通常的注册过程：  var user = new Bmob.User();\nuser.set( username ,  my name );\nuser.set( password ,  my pass );\nuser.set( email ,  email@example.com );\n\n// other fields can be set just like with Bmob.Object\nuser.set( phone ,  415-392-0202 );\n\nuser.signUp(null, {\n  success: function(user) {\n    // Hooray! Let them use the app now.\n  },\n  error: function(user, error) {\n    // Show the error message somewhere and let the user try again.\n    alert( Error:   + error.code +     + error.message);\n  }\n});  这个调用会异步地在在你的应用中创建一个新的用户。在它这样做之前，它同样会确认用户名和 email 在应用内都是唯一的。同样，我们从不会将用户密码以明文向任何客户端发送。  注意我们使用了 signUp 方法而不是 save 方法，新的 Bmob.User 永远应该使用 signUp 方法来新建。而随后的用户的信息更新可以调用 save 来做。  如果一个 signup 没有成功的话，你应该读取返回的错误对象。最常见的问题是 username 或者 email 已经被其他用户所使用了。你应该清楚地反馈给你的用户，让他们再次用一个不同的用户名来注册。  你也可以使用 email 来作为用户名，只要求你的用户输入他们的 email 但是同时自动填充好 username 属性就可以了， Bmob.User 会跟原来一样工作，我们会在下面的重设密码环节再次说明这个细节。", 
            "title": "注册"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_46", 
            "text": "在你要求你的用户注册之后，当然应该让他们在以后用自己的账户登录进来，你可以使用 logIn 方法来进行登陆：  Bmob.User.logIn( myname ,  mypass , {\n  success: function(user) {\n    // Do stuff after successful login.\n  },\n  error: function(user, error) {\n    // The login failed. Check error to see why.\n  }\n});", 
            "title": "登录"
        }, 
        {
            "location": "/data/javascript/develop_doc/#email", 
            "text": "在application设置中启用email验证可以让你的应用给最终用户一些更安全的使用体验，譬如部分功能只开放给验证过邮箱的用户使用等等。Email验证会在 Bmob.User 上加入一个 emailVerified 字段。当一个 Bmob.User 的 email 被设定或者修改后, emailVerfied 会被设定为 false 。Bmob 会向用户的 email 来发送一个链接，点击这个链接会设置 emailVerified 为 true ：  有三种 emailVerified 状态可以供参考：   true ：用户已经通过点击Bmob发过来的链接来确认邮箱地址. 当用户账户新创建的时候这个值永远不应该是true。  false ：在  Bmob.User 对象最后一次刷新的时候，用户还是没有确认他们的 email 地址，如果 emailVerified 是false 的话，你应该考虑调用 Bmob.User 的 fetch 方法。  missing ： Bmob.User 被创建了，但是当时的 email 验证功能还没有开启, 或者说 Bmob.User 没有email地址。   代码例子如下：  //reset password\n Bmob.User.requestEmailVerify( h6k65@126.com , {\n  success: function() {\n    // Password reset request was sent successfully\n  },\n  error: function(error) {\n    // Show the error message somewhere\n    alert( Error:   + error.code +     + error.message);\n  }\n});", 
            "title": "验证 Email"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_47", 
            "text": "如果用户每次打开App的时候都要求登录无疑是令人感到厌烦的，你可以通过缓存当前的 Bmob.User 对象来避免这个问题。  无论你使用任何注册或者登录方法，用户都会在 localStorage 中储存，你可以把缓存作为一个 session 对待，并且自动假设用户已经登录了。  var currentUser = Bmob.User.current();\nif (currentUser) {\n    // do stuff with the user\n} else {\n    // show the signup or login page\n}  你可以通过 logout 来清除掉当前的用户：  Bmob.User.logOut();\n\nvar currentUser = Bmob.User.current();  // this will now be null", 
            "title": "当前用户"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_48", 
            "text": "Bmob.User 类默认就是受保护的，在 Bmob.User 中保存的数据只能被那个用户所修改。默认地，数据仍然可以被任意客户端所读取。这样就是说，有些 Bmob.User 对象被认证后是可以修改的，其他的仍然是只读的。  特别的，你不能调用 save 或者 delete 方法除非 Bmob.User 经过了认证，就比如调用过了 logIn 或者 signUp 方法，这样保证只有用户能改动他们自身的数据。  下面的代码展示了上面说的安全策略：  var user = Bmob.User.logIn( my_username ,  my_password , {\n  success: function(user) {\n    user.set( username ,  my_new_username );  // attempt to change username\n    user.save(null, {\n      success: function(user) {\n        // This succeeds, since the user was authenticated on the device\n\n        // Get the user from a non-authenticated method\n        var query = new Bmob.Query(Bmob.User);\n        query.get(user.objectId, {\n          success: function(userAgain) {\n            userAgain.set( username ,  another_username );\n            userAgain.save(null, {\n              error: function(userAgain, error) {\n                // This will error, since the Bmob.User is not authenticated\n              }\n            });\n          }\n        });\n      }\n    });\n  }\n});  从 Bmob.User.current() 获取的 Bmob.User 总是已经通过验证了的。  如果你需要查看一个 Bmob.User 是否已经认证过了，你可以调用 authenticated 方法，你不需要查看一个认证方法中返回的 Bmob.User 对象是否已经通过验证了。", 
            "title": "用户对象的安全"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_49", 
            "text": "和 Bmob.User 相同的安全模型也使用于其他对象。对于任何对象来说，你可以指定哪些用户会被允许读取对象，哪些用户被允许修改对象。为了支持这种安全机制，每一个对象都有一个允许访问列表 (ACL)，是被 Bmob.ACL 类所实现的。  使用一个 Bmob.ACL 最简单的方式是指定一个对象只能被一个单一的用户读或者写。为了创建这样的对象，首先必须有一个已经登录的 Bmob.User 。然后，新的 Bmob.ACL(user) 生成一个 Bmob.ACL 来限定 user 的访问。一个对象的ACL会在对象保存的时候被存储起来，就像其他的属性一样，这样，为了创建一个当前user私有的一个note：  var Note = Bmob.Object.extend( Note );\nvar privateNote = new Note();\nprivateNote.set( content ,  This note is private! );\nprivateNote.setACL(new Bmob.ACL(Bmob.User.current()));\nprivateNote.save();  这个note只能由当前的用户所访问，但是可以在用户登录的任何设备上访问，只要是相同的用户就可以了。这项功能对于你如果想让用户再任何其他的设备上保存和访问数据十分有用，比如说一个私人的todo list应用。  权限也能在使用者的基础上授予，你可以通过 setReadAccess 和 setWriteAccess 方法独立的向 Bmob.ACL 中添加权限。比如，假设你有一条消息想要发送给一个组里的多个用户，他们中的每一个都有读和写的权限：  var Message = Bmob.Object.extend( Message );\nvar groupMessage = new Message();\nvar groupACL = new Bmob.ACL();\n\n// userList is an array with the users we are sending this message to.\nfor (var i = 0; i   userList.length; i++) {\n  groupACL.setReadAccess(userList[i], true);\n  groupACL.setWriteAccess(userList[i], true);\n}\n\ngroupMessage.setACL(groupACL);\ngroupMessage.save();  你同样可以对所有的用户授权，只要使用 setPublicReadAccess 和 setPublicWriteAccess 就可以了。这样允许了在一个消息板上发评论的模式，比如，我们要创建一个post只能被它的作者修改，但是可以被所有人读取：  var publicPost = new Post();\nvar postACL = new Bmob.ACL(Bmob.User.current());\npostACL.setPublicReadAccess(true);\npublicPost.setACL(postACL);\npublicPost.save();  比如说删除一个对象，但是你没有写的权限这种操作是禁止的，这样会返回一个 Bmob.Error.OBJECT_NOT_FOUND 的错误码，为了安全起见，这样防止了客户端区分出到底有哪些对象被创建了但是无法读取还是根本不存在。", 
            "title": "其他对象的安全"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_50", 
            "text": "在现实中只要你引入了密码系统，总会有用户会忘掉他们的密码。在这种情形下，我们的库提供一个让他们安全地重设密码的功能。  为了能让用户重设密码，应该要求用户提供他们的email地址，然后这样调用：   Bmob.User.requestPasswordReset( test@126.com , {\n  success: function() {\n    // Password reset request was sent successfully\n  },\n  error: function(error) {\n    // Show the error message somewhere\n    alert( Error:   + error.code +     + error.message);\n  }\n});  这样会尝试匹配给定的email和用户的email或者username字段，然后会发送用户的密码重设邮件。由于我们是这样做的，所以你可以选择用户是否拿email作为他们的用户名，或者说用户把email作为用户的另一个信息保存。  密码重设的流程如下:   用户输入email来请求重设他们的密码。  Bmob向用户的email地址发送邮件，包含了一个重设密码的链接。  用户点击这个重设密码的链接，会重定向到一个Bmob页面来允许他们重设密码。  用户输入新的密码，他们的密码现在会更新为输入的新密码。", 
            "title": "重设密码"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_51", 
            "text": "为了查询用户，你可以简单的创建一个 Bmob.Query 针对 Bmob.Users ：  var query = new Bmob.Query(Bmob.User);\nquery.equalTo(gender,  female );  // find all the women\nquery.find({\n  success: function(women) {\n    // Do stuff\n  }\n});", 
            "title": "查询"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_52", 
            "text": "关联一个 Bmob.User 的对象可以很快就见效，比如说，假设你有一个blog程序，为了保存一个用户的新post还有读取他们所有的post。  var user = Bmob.User.current();\n\n// Make a new post\nvar Post = Bmob.Object.extend( Post );\nvar post = new Post();\npost.set( title ,  My New Post );\npost.set( body ,  This is some great content. );\npost.set( user , user);\npost.save(null, {\n  success: function(post) {\n    // Find all posts by the current user\n    var query = new Bmob.Query(Post);\n    query.equalTo( user , user);\n    query.find({\n      success: function(usersPosts) {\n        // userPosts contains all of the posts by the current user.\n      }\n    });\n  }\n});", 
            "title": "关联"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_53", 
            "text": "", 
            "title": "实时数据平台"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_54", 
            "text": "Bmob提供了数据实时功能，当开发者监听某个变化事件，例如监听表更新时，表的内容一旦变化，服务器就会通知SDK，SDK提供了相应回调函数来给开发者使用。当然开发者也可以取消相对应的监听，这样就不会收到数据变化的消息了。  注意！！！运行的html文件应该是在web环境中，不能在本地环境中运行。 \n例如，合法的运行环境：http://local.project/appweb/sdk/js/demo/bmobSocketIo.html\n无效的本地运行环境：file:///D:/jeff/project/appweb/sdk/js/%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E5%B9%B3%E5%8F%B0/test/bmobSocketIo.html", 
            "title": "实时功能简介"
        }, 
        {
            "location": "/data/javascript/develop_doc/#js", 
            "text": "一、把下面这行代码加入你的页面中，其中，\"bmobSocketIo.js\"为实时数据平台的js文件。  script type= text/javascript  src= bmobSocketIo.js /script   二、接着是加入下面这行代码进行初始化。  BmobSocketIo.initialize( 你的Application ID );", 
            "title": "安装实时数据平台的js"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_55", 
            "text": "", 
            "title": "订阅事件"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_56", 
            "text": "订阅表\"GameScore\"更新的事件。  BmobSocketIo.updateTable( GameScore );", 
            "title": "订阅表更新的事件"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_57", 
            "text": "订阅表\"GameScore\"中行objectId为\"3342e40e4f\"更新的事件。  BmobSocketIo.updateRow( GameScore , 3342e40e4f );", 
            "title": "订阅行更新的事件"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_58", 
            "text": "订阅表\"GameScore\"中行objectId为\"3342e40e4f\"删除的事件。  BmobSocketIo.deleteRow( GameScore , 1256e40e4f );", 
            "title": "订阅行删除的事件"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_59", 
            "text": "", 
            "title": "取消订阅事件"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_60", 
            "text": "取消订阅表\"GameScore\"更新的事件。  BmobSocketIo.unsubUpdateTable( GameScore );", 
            "title": "取消订阅表更新的事件"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_61", 
            "text": "取消订阅表\"GameScore\"中objectId为\"3342e40e4f\"行更新的事件。  BmobSocketIo.unsubUpdateRow( GameScore , 3342e40e4f );", 
            "title": "取消订阅行更新的事件"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_62", 
            "text": "取消订阅表\"GameScore\"中objectId为\"3342e40e4f\"行删除的事件。  BmobSocketIo.unsubDeleteRow( GameScore , 1256e40e4f );", 
            "title": "取消订阅行删除的事件"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_63", 
            "text": "", 
            "title": "监听触发的事件"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_64", 
            "text": "当订阅了表更新的表数据发送变化时，js中会触发函数onUpdateTable。  tablename为更新的表，data为服务端返回的更新数据。     BmobSocketIo.onUpdateTable = function(tablename,data) {    \n      //业务逻辑的代码\n   };", 
            "title": "监听更新表的事件"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_65", 
            "text": "tablename为更新的表，objectId为更新行的objectId，data为服务端返回的更新数据。     BmobSocketIo.onUpdateRow = function(tablename,objectId,data) {    \n      //业务逻辑的代码\n   };", 
            "title": "监听行更新的事件"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_66", 
            "text": "tablename为更新的表，objectId为更新行的objectId，data为服务端返回的更新数据。     BmobSocketIo.onDeleteRow = function(tablename,objectId,data) {    \n      //业务逻辑的代码\n   };", 
            "title": "监听行删除的事件"
        }, 
        {
            "location": "/data/javascript/develop_doc/#demo", 
            "text": "在线上演示实时数据平台的一个聊天应用的demo： chat room demo  ，演示了如何使用实时数据服务实现聊天的功能。  用浏览器打开两个窗口，在其中一个窗口输入 昵称 和 内容 ，按 发送 按钮，在另外一个窗口能看到发送的内容。", 
            "title": "demo"
        }, 
        {
            "location": "/data/javascript/develop_doc/#acl", 
            "text": "数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看 Bmob数据与安全页面 ，了解Bmob如何保护数据安全）。  其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。  大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：   对于私有数据，读写权限可以只局限于数据的所有者。  对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。  对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。  属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。  一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。", 
            "title": "ACL和角色"
        }, 
        {
            "location": "/data/javascript/develop_doc/#acl_1", 
            "text": "在Bmob中，ACL是按JSON对象格式（key-value）来表示的。这个JSON对象的key是objectId（用户表某个用户对应的objectId）或者是*(表示公共的访问权限)，ACL 的值是\"读和写的权限\"，这个JSON对象的key总是权限名，而这些key的值总是true。  如果您想让一个id为\"Kc3M222k\"的用户有读和写一条数据的权限，而且这个数据应该可以被全部人读取的话，这个ACL的表达方式如下：  {\n   Kc3M222k : {\n     read : true,\n     write : true\n  },\n   * : {\n     read : true\n  }\n}", 
            "title": "ACL的格式"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_67", 
            "text": "在很多情况下，你需要定义一些用户具有某种相同的数据操作权限，而另外一群用户具有另外一种相同的数据操作权限，这时你就可以使用到Bmob的角色（对应Bmob在Web提供的Role表、SDK中的BmobRole类）功能，设置不同的用户组不同的操作权限。角色表有三个特殊字段：  name  : 必须字段，表示角色名称,而且只允许被设置一次（命名必须由字母, 空格, 减号或者下划线构成）。  users  :一个指向一系列用户的关系, 这些用户会继承角色的权限。  roles  : 一个指向一系列子角色的关系, 这些子关系会继承父角色所有的权限。", 
            "title": "角色和相关操作"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_68", 
            "text": "var roleACL = new Bmob.ACL();\nroleACL.setPublicReadAccess(true);\nvar role = new Bmob.Role( test , roleACL);\nrole.save();", 
            "title": "创建角色"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_69", 
            "text": "Bmob.Role 使用和其他Bmob对象一样的ACL权限策略, 除开它需要ACL被显式地设置以外。通常来说，只有用户有极大的权限（比如管理员）才应该被允许创建或者更改Role，所以你应该按这种标准来设定Role的ACL。请注意，如果你给了用户一个 Bmob.Role 一个写权限，这个用户有可能会在这个权限中加入另一个user，或者甚至直接把角色删除掉。  为了创建一个新的 Bmob.Role ，你应该如下写：  // By specifying no write privileges for the ACL, we can ensure the role cannot be altered.\nvar roleACL = new Bmob.ACL();\nroleACL.setPublicReadAccess(true);\nvar role = new Bmob.Role( Administrator , roleACL);\nrole.save();  你可以通过增加\"user\"和\"roles\"关系的成员来在 Bmob.Role 中加入用户或者子角色：  var role = new Bmob.Role(roleName, roleACL);\nfor (var i = 0; i   usersToAddToRole.length; i++) {\n  role.getUsers().add(usersToAddToRole[i]);\n}\nfor (var i = 0; i   rolesToAddToRole.length; i++) {\n  role.getRoles().add(rolesToAddToRole[i]);\n}\nrole.save();  请非常注意一点，注册角色的ACL的时候，它们只能被应该有权限修改它的人修改。", 
            "title": "角色对象的安全性"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_70", 
            "text": "现在你应该已经创建了在你的程序中要使用的一系列的角色，你可以用ACL来定义他们的用户可以拥有的权限，每一个 Bmob.Object 都可以指定一个 Bmob.ACL ，这样提供了哪些用户或者角色应该有权限来读或者写这个对象。  将一个读或者写的权限授予一个角色是很直观的，你可以使用 Bmob.Role ：  var moderators = /* Query for some Bmob.Role */;\nvar wallPost = new Bmob.Object( WallPost );\nvar postACL = new Bmob.ACL();\npostACL.setRoleWriteAccess(moderators, true);\nwallPost.setACL(postACL);\nwallPost.save();  你可以不需要查找这个Role，直接把名字提供给ACL：  var wallPost = new Bmob.Object( WallPost );\nvar postACL = new Bmob.ACL();\npostACL.setRoleWriteAccess( Moderators , true);\nwallPost.setACL(postACL);\nwallPost.save();", 
            "title": "其他对象的安全性"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_71", 
            "text": "就像上面所描述的一样，一个角色可能包含其他的角色，表示两个角色之间的父-子关系，这样做的结果就是任何被授予一个角色的权限都会被隐式地授予这个角 色的所有子角色。  这样的关系很经常会在有用户管理内容的程序之中看到，比如论坛，有一个很少量的用户称为管理员，有最高的权限，比如程序设定、创建新的论坛、设定所有人能看到的内容等等。另一类有一部分类似于\"版主\" 的用户，这些人有责任保持用户创建的内容是合适的，任何一个\"版主\"有的权限\"管理员\"都应该有。为了启用这种关系，你应该使\"管理员\"成为\"版主\"的一个子角色。  var administrators = /* Your  Administrators  role */;\nvar moderators = /* Your  Moderators  role */;\nmoderators.getRoles().add(administrators);\nmoderators.save();", 
            "title": "角色继承"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_72", 
            "text": "", 
            "title": "地理位置"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_73", 
            "text": "地理位置对象的创建需要用到 Bmob.GeoPoint 类，如创建一个地理位置在纬度40度，经度在-30度的点的示例代码如下：  var point = new Bmob.GeoPoint({latitude: 40.0, longitude: -30.0});", 
            "title": "创建地理位置对象"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_74", 
            "text": "现在你可以有一系列的对象可以做空间坐标查询了，如果能轻松地发现有哪些对象离一个点最近就好了。这样可以通过在 Bmob.Query 中加入一个 near 来做查询，为了获得离用户最近的10个地点列表，可以这样：  // location对应Web后台的一个字段名称\nvar userGeoPoint = userObject.get( location );\n// 创建查询\nvar query = new Bmob.Query(PlaceObject);\n// location附近的位置\nquery.near( location , userGeoPoint);\n// 返回10个地点数据\nquery.limit(10);\n// 查询\nquery.find({\n  success: function(placesObjects) {\n  }\n});  在这时 placeObjects 会返回一个按离 userGeoPoint 的距离排序的列表，注意如果一个 ascending()/descending() 给了查询的话，会取代按距离排序这项特性。  为了按距离限制返回的结果，你可以使用 withinMiles 、 withinKilometers 和 withinRadians 。  同样，查询在特定地域的Object是可以的。为了找到用矩形表示的一块地域中的对象，加入 withinGeoBox 来在 Bmob.Query 中加入约束。  var southwestOfSF = new Bmob.GeoPoint(37.708813, -122.526398);\nvar northeastOfSF = new Bmob.GeoPoint(37.822802, -122.373962);\n\nvar query = new Bmob.Query(PizzaPlaceObject);\nquery.withinGeoBox( location , southwestOfSF, northeastOfSF);\nquery.find({\n  success: function(pizzaPlacesInSF) {\n    ...\n  }\n});", 
            "title": "查询地理位置对象"
        }, 
        {
            "location": "/data/javascript/develop_doc/#_75", 
            "text": "错误码列表", 
            "title": "错误代码详细说明"
        }, 
        {
            "location": "/data/javascript/example/", 
            "text": "JS快速入门相关源码:\nhttp://www.bmob.cn/static/bmob_jssdk_quickstart.zip\n\n\n聊天室：\nhttp://chatroom.bmob.cn\n （采用实时数据同步SDK开发，右击可直接查看源码）", 
            "title": "示例/功能"
        }, 
        {
            "location": "/data/php/", 
            "text": "准备工作\n\n\n本文档是Bmob官方提供的PHP SDK，方便PHP开发人员快速使用Bmob进行后端开发。\n\n\n【注】运行PHP需要相关运行环境，推荐在5.*以上环境上使用。PHP官方下载地址为：\nhttp://php.net/\n 。\n\n\nSDK下载\n\n\n请到以下的Github地址clone我们的SDK最新代码：\nhttps://github.com/bmob/bmob-php-sdk\n\n\n安装和配置\n\n\n打开\nlib/BmobConfig.class.php\n，填写\nAPPID\n（后台获取“应用密钥”中的Application ID）和\nRESTKEY\n（后台获取“应用密钥”中的REST API Key）相应的值。如下所示：\n\n\nclass BmobConfig{\n    const APPID = '';       //替换后台\n应用密钥\n中的Application ID\n    const RESTKEY = '';     //后台\n应用密钥\n中的REST API Key\n    const BMOBURL = 'https://api.bmob.cn/1/';   //保持不变\n\n}\n\n\n\n\n运行效果\n\n\n打开项目中的\ntest.php\n文件，可以看到如何使用PHP SDK相关的方法。\n\n\n?php\ninclude_once 'lib/BmobObject.class.php';\ninclude_once 'lib/BmobUser.class.php';\ntry {\n    /*\n     *  BmobObject 的例子\n    */  \n    $bmobObj = new BmobObject(\nGameScore\n);\n    $res=$bmobObj-\ncreate(array(\nscore\n=\n80,\nplayerName\n=\ngame\n)); //添加对象\n    $res=$bmobObj-\nget(\nbd89c6bce9\n); // 获取id为bd89c6bce9的对象\n    $res=$bmobObj-\nget(); //获取所有对象\n    //更新对象bd89c6bce9, 任何您未指定的key都不会更改,所以您可以只更新对象数据的一个子集\n    $res=$bmobObj-\nupdate(\nbd89c6bce9\n, array(\nscore\n=\n60,\nplayerName\n=\ngame\n));  \n    $res=$bmobObj-\ndelete(\nbd89c6bce9\n); //删除对象bd89c6bce9\n    //对象的查询,这里是表示查找playerName为\ngame\n的对象，只返回２个结果\n    $res=$bmobObj-\nget(\n,array('where={\nplayerName\n:\ngame\n}','limit=2')); \n    //id为bd89c6bce9的field score数值减2\n    $res=$bmobObj-\nincrement(\nbd89c6bce9\n,\nscore\n,array(-2)); \n    //id为bd89c6bce9的field score数值加2\n    $res=$bmobObj-\nincrement(\nbd89c6bce9\n,\nscore\n,array(2)); \n\n    /*\n     *  BmobUser 的例子\n     */ \n    $bmobUser = new BmobUser();\n    //用户注册, 其中username和password为必填字段\n    $res = $bmobUser-\nregister(array(\nusername\n=\ncooldude117\n, \npassword\n=\np_n7!-e8\n, \nphone\n=\n415-392-0202\n, \nemail\n=\nbmobtest111@126.com\n)); \n    //用户登录, 第一个参数为用户名,第二个参数为密码\n    $res = $bmobUser-\nlogin(\ncooldude117\n,\np_n7!-e8\n); \n    // 获取id为415b8fe99a用户的信息\n    $res = $bmobUser-\nget(\n415b8fe99a\n); \n    $res = $bmobUser-\nget(); // 获取所有用户的信息\n    $res = $bmobUser-\nupdate(\n415b8fe99a\n, \n050391db407114d9801c8f2788c6b25a\n, array(\nphone\n=\n02011111\n)); // 更新用户的信息\n    // 请求重设密码,前提是用户将email与他们的账户关联起来\n    $res = $bmobUser-\nrequestPasswordReset(\nbmobtest111@126.com\n);\n    // 删除id为415b8fe99a的用户, 第一参数是用户id, 第二个参数为sessiontoken,在用户登录或注册后获取, 必填\n    $res = $bmobUser-\ndelete(\n415b8fe99a\n, \n050391db407114d9801c8f2788c6b25a\n); \n\n    /*\n     *  BmobCloudCode 的例子\n     */ \n    //调用名字为getMsgCode的云端代码\n    $cloudCode = new BmobCloudCode('getMsgCode');\n    //传入参数name，其值为bmob\n    $res = $cloudCode-\nget(array(\nname\n=\nbmob\n));\n\n\n    var_dump($res);\n\n} catch (Exception $e) {\n    echo $e;\n}\n\n\n\n\n类库说明\n\n\n\n\nBmobConfig\n\n\n\n\nBmob配置类，使用的时候需要修改里面的配置信息\n\n\n\n\nBmobUser\n\n\n\n\nBmob用户表处理类，负责处理与_User表相关的事情\n\n\n\n\nBmobObject\n\n\n\n\nBmob对象处理类，负责处理云端各种表的数据操作\n\n\n\n\nBmobRestClient\n\n\n\n\nBmob基础类，用于完成REST API请求\n\n\n\n\nBmobException\n\n\n\n\nBmob异常处理类\n\n\n\n\nBmobCloudCode\n\n\n\n\nBmob云端代码调用类\n\n\nBmob官方信息\n\n\n官方网址：\nhttp://www.bmob.cn\n\n\n问答社区：\nhttp://wenda.bmob.cn\n\n\n技术邮箱：support@bmob.cn", 
            "title": "快速入门"
        }, 
        {
            "location": "/data/php/#_1", 
            "text": "本文档是Bmob官方提供的PHP SDK，方便PHP开发人员快速使用Bmob进行后端开发。  【注】运行PHP需要相关运行环境，推荐在5.*以上环境上使用。PHP官方下载地址为： http://php.net/  。", 
            "title": "准备工作"
        }, 
        {
            "location": "/data/php/#sdk", 
            "text": "请到以下的Github地址clone我们的SDK最新代码： https://github.com/bmob/bmob-php-sdk", 
            "title": "SDK下载"
        }, 
        {
            "location": "/data/php/#_2", 
            "text": "打开 lib/BmobConfig.class.php ，填写 APPID （后台获取“应用密钥”中的Application ID）和 RESTKEY （后台获取“应用密钥”中的REST API Key）相应的值。如下所示：  class BmobConfig{\n    const APPID = '';       //替换后台 应用密钥 中的Application ID\n    const RESTKEY = '';     //后台 应用密钥 中的REST API Key\n    const BMOBURL = 'https://api.bmob.cn/1/';   //保持不变\n\n}", 
            "title": "安装和配置"
        }, 
        {
            "location": "/data/php/#_3", 
            "text": "打开项目中的 test.php 文件，可以看到如何使用PHP SDK相关的方法。  ?php\ninclude_once 'lib/BmobObject.class.php';\ninclude_once 'lib/BmobUser.class.php';\ntry {\n    /*\n     *  BmobObject 的例子\n    */  \n    $bmobObj = new BmobObject( GameScore );\n    $res=$bmobObj- create(array( score = 80, playerName = game )); //添加对象\n    $res=$bmobObj- get( bd89c6bce9 ); // 获取id为bd89c6bce9的对象\n    $res=$bmobObj- get(); //获取所有对象\n    //更新对象bd89c6bce9, 任何您未指定的key都不会更改,所以您可以只更新对象数据的一个子集\n    $res=$bmobObj- update( bd89c6bce9 , array( score = 60, playerName = game ));  \n    $res=$bmobObj- delete( bd89c6bce9 ); //删除对象bd89c6bce9\n    //对象的查询,这里是表示查找playerName为 game 的对象，只返回２个结果\n    $res=$bmobObj- get( ,array('where={ playerName : game }','limit=2')); \n    //id为bd89c6bce9的field score数值减2\n    $res=$bmobObj- increment( bd89c6bce9 , score ,array(-2)); \n    //id为bd89c6bce9的field score数值加2\n    $res=$bmobObj- increment( bd89c6bce9 , score ,array(2)); \n\n    /*\n     *  BmobUser 的例子\n     */ \n    $bmobUser = new BmobUser();\n    //用户注册, 其中username和password为必填字段\n    $res = $bmobUser- register(array( username = cooldude117 ,  password = p_n7!-e8 ,  phone = 415-392-0202 ,  email = bmobtest111@126.com )); \n    //用户登录, 第一个参数为用户名,第二个参数为密码\n    $res = $bmobUser- login( cooldude117 , p_n7!-e8 ); \n    // 获取id为415b8fe99a用户的信息\n    $res = $bmobUser- get( 415b8fe99a ); \n    $res = $bmobUser- get(); // 获取所有用户的信息\n    $res = $bmobUser- update( 415b8fe99a ,  050391db407114d9801c8f2788c6b25a , array( phone = 02011111 )); // 更新用户的信息\n    // 请求重设密码,前提是用户将email与他们的账户关联起来\n    $res = $bmobUser- requestPasswordReset( bmobtest111@126.com );\n    // 删除id为415b8fe99a的用户, 第一参数是用户id, 第二个参数为sessiontoken,在用户登录或注册后获取, 必填\n    $res = $bmobUser- delete( 415b8fe99a ,  050391db407114d9801c8f2788c6b25a ); \n\n    /*\n     *  BmobCloudCode 的例子\n     */ \n    //调用名字为getMsgCode的云端代码\n    $cloudCode = new BmobCloudCode('getMsgCode');\n    //传入参数name，其值为bmob\n    $res = $cloudCode- get(array( name = bmob ));\n\n\n    var_dump($res);\n\n} catch (Exception $e) {\n    echo $e;\n}", 
            "title": "运行效果"
        }, 
        {
            "location": "/data/php/#_4", 
            "text": "BmobConfig   Bmob配置类，使用的时候需要修改里面的配置信息   BmobUser   Bmob用户表处理类，负责处理与_User表相关的事情   BmobObject   Bmob对象处理类，负责处理云端各种表的数据操作   BmobRestClient   Bmob基础类，用于完成REST API请求   BmobException   Bmob异常处理类   BmobCloudCode   Bmob云端代码调用类", 
            "title": "类库说明"
        }, 
        {
            "location": "/data/php/#bmob", 
            "text": "官方网址： http://www.bmob.cn  问答社区： http://wenda.bmob.cn  技术邮箱：support@bmob.cn", 
            "title": "Bmob官方信息"
        }, 
        {
            "location": "/data/php/develop_doc/", 
            "text": "简介\n\n\nBmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。\n\n\n快速入门\n\n\n建议您在阅读本开发文档之前，先阅读我们提供的 \nphp快速入门文档\n，便于您后续的开发。\n\n\n应用程序\n\n\n在Bmob平台注册后，每个账户可创建多个应用程序，创建的每个应用程序有各自的Application ID，应用程序将凭其Application ID使用Bmob SDK。\n\n\n应用安全\n\n\n请大家在使用Bmob开发应用程序之前，仔细阅读“数据与安全”的文档：\nhttp://docs.bmob.cn/other/Other/n_datasafety/doc/index.html\n\n\n数据类型\n\n\n目前为止，我们支持的数据类型有String、Integer、Boolean、ArrayList以及BmobObject对象类型。同时Bmob也支持BmobDate、BmobGeoPoint、BmobFile数据类型。\n\n\nphpsdk相关类的说明\n\n\nlib/BmobObject.class.php:对象操作类\nlib/BmobUser.class.php：用户操作类\nlib/BmobBatch.class.php：批量操作类\nlib/BmobFile.class.php：文件操作类\nlib/BmobImage.class.php：图片操作类\nlib/BmobRole.class.php：权限类\nlib/BmobPush.class.php：推送类\nlib/BmobPay.class.php：支付类\nlib/BmobSms.class.php：短信消息类\nlib/BmobApp.class.php：app操作类\nlib/BmobSchemas.class.php：数据表操作类\nlib/BmobTimestamp.class.php：获取服务器时间类\nlib/BmobCloudCode.class.php：云端代码类\nlib/BmobBql.class.php：bql操作类\n\n\n对象\n\n\n一个数据对象（APP中创建的BmobObject类和子类）对应于Bmob后台的一个数据表。\n\n\n数据对象\n\n\nBmob存储的数据是建立在BmobObject基础上的，所以任何要保存的数据对象必须继承自BmobObject类。BmobObject类本身包含\nobjectId\n、\ncreatedAt\n、\nupdatedAt\n、\nACL\n四个默认的属性，objectId是数据的唯一标示，相当于表的主键，createdAt是数据的创建时间，updatedAt是数据的最后修改时间，ACL是数据的操作权限。\n\n\n如，你的游戏中使用GameScore表来记录玩家的比分信息，其中表的字段有：score（分数）、playerName（玩家名字）属性，那么这个数据对象如下定义：\n\n\n\n$bmobObj = new BmobObject(\nGameScore\n);\n$bmobObj-\ncreate(array(\nplayerName\n=\ngame\n,\nscore\n=\n20)); //添加对象\n\n\n\n\n需要注意的是：\n\n\n\n\nphp不需要对\nobjectId\n、\ncreatedAt\n、\nupdatedAt\n、\nACL\n四个属性进行定义。\n\n\n不少开发者会没有注意到\ncreatedAt\n和\nupdatedAt\n属性中的字母\nd\n，写成createAt和updateAt。\n\n\n\n\n对象格式\n\n\n通过php sdk保存数据，这个数据是无模式化的（Schema Less）,这意味着你不需要提前标注每个对象上有哪些Key，你只需要随意设置key-value对就可以，php sdk后端会存储它的。\n\n\n举个例子，假设你正在记录一局游戏的最高分，一个简单的对象可能包含:\n\n\narray(\n    \nscore\n=\n 1337,\n    \nplayerName\n=\n \nSean Plott\n,\n    \ncheatMode\n=\n false\n)\n\n\n\n\nKey必须是字母和数字组成的字符串,Value可以是任何可以JSON编码的东西.\n\n\n每个对象都有一个类名，你可以通过类名来区分不同的数据，例如，我们可以把游戏得分对象称之为GameScore.我们推荐你使用  \nNameYourClassesLikeThis\n 和 \nnameYourKeysLikeThis\n 这样的格式为你的类名和Key命名，这可以使你的代码看起来很漂亮.\n\n\n当你从\nBmob\n中获取对象时，一些字段会被自动加上: createdAt, updatedAt 和 objectId， 这些字段的名字是保留的，你不能自行设置它们，我们上面设置的对象在获取时应该是下面的样子.\n\n\narray(\n    \nscore\n=\n 1337,\n    \nplayerName\n=\n \nSean Plott\n,\n    \ncheatMode\n=\n false,\n    \ncreatedAt\n=\n \n2011-08-20 02:06:57\n,\n    \nupdatedAt\n=\n \n2011-08-20 02:06:57\n,\n    \nobjectId\n=\n \ne1kXT22L\n\n)\n\n\n\n\ncreatedAt和updatedAt都是UTC时间戳,以ISO 8601标准和毫秒级精度储存:YYYY-MM-DD HH:MM:SS. objectId是一个string,在类中唯一表明了一个对象。\n\n\n数据类型\n\n\n到现在为止我们只使用了可以被标准JSON编码的值，\nBmob\n移动客户端SDK库同样支持日期,地理位置数据和指针数据、关系型数据。在php sdk中，这些值都被编码了，同时有一个\"__type\"字段来标识出它们所属的类型，所以如果你采用正确的编码的话就可以读或者写这些字段了。\n\n\nDate类型包含了一个\"iso\"字段存储了一个UTC时间戳,以ISO 8601格式和毫秒级的精度来存储时间: YYYY-MM-DDTHH:MM:SS.MMMZ，或者 YYYY-MM-DDTHH:MM:SS\n\n\narray(\n    \n__type\n=\nDate\n,\n    \niso\n=\n2011-08-21 18:02:52\n\n)\n\n\n\n\nFile类型是在上传后返回的JSON数据再加一个Key为\"__Type\":\"File\", 用来保存到数据列为文件类型的值：\n\n\narray(\n    \n__type\n=\nFile\n,\n    \ngroup\n=\n \ngroup1\n,\n    \nfilename\n=\n \n1.xml\n,\n    \nurl\n=\n \nM00/01/14/sd2lkds0.xml\n\n)\n\n\n\n\nPointer 类型是在当前对象要指向另一个对象时使用，它包含了 className 和 objectId 两个作为一个指针正确指向的必填值.\n\n\narray(\n  \n__type\n=\n \nPointer\n,\n  \nclassName\n=\n \nGame\n,\n  \nobjectId\n=\n \nDdUOIIIW\n\n)\n\n\n\n\n指向用户对象的 \nPointer\n 的 \nclassName\n 为_User, 前面加一个下划线表示开发者不能定义的类名, 而且所指的类是系统内置的。\n\n\nRelation\n 类型被用在多对多的类型上, 移动端的库将使用 \nBmobRelation\n 作为值, 它有一个 className 字段表示目标对象的类名：\n\n\narray(\n  \n__type\n=\n \nRelation\n,\n  \nclassName\n=\n \nGameScore\n\n)\n\n\n\n\n当使用查询时， \nRelation\n 对象的行为很像是 \nPointer\n 的数组, 任何操作针对于 \nPointer\n 的数组的 (除了 include) 都可以对 \nRelation\n 起作用.\n\n\n当更多的数据类型被加入的时候, 它们都会采用 hashmap \n加上一个 type\n 字段的形式, 所以你不应该使用type作为你自己的JSON对象的Key。\n\n\n添加数据\n\n\n添加数据使用BmobObject对象的\ncreate\n方法，就可以将当前对象的内容保存到Bmob服务端。\n\n\n例如，你现在要保存一条游戏分数的记录，代码如下：\n\n\n\n$bmobObj = new BmobObject(\nGameScore\n);\n$res=$bmobObj-\ncreate(array(\nplayerName\n=\n比目\n,\nscore\n=\n89)); //添加对象\n\n\n\n\n\n运行以上代码，如果添加成功，你可以在Bmob提供的后台的数据浏览中看到类似这样的结果：\n\n\nobjectId: \n0c6db13c\n, score: 89, playerName: \n比目\n,createdAt:\n2013-09-27 10:32:54\n, updatedAt:\n2013-09-27 10:32:54\n\n\n\n\n\n这里需要注意的是：\n\n\n\n\n\n\n如果服务器端不存在GameScore表，那么系统将自动建表，并插入数据。\n\n\n\n\n\n\n如果服务器端已经存在GameScore表，和相应的score、playerName字段，那么你此时添加的数据和数据类型也应该和服务器端的表结构一致，否则会保存数据失败。\n\n\n\n\n\n\n每个BmobObject对象都有几个默认的键(数据列)是不需要开发者指定的，\nobjectId\n是每个保存成功数据的唯一标识符。\ncreatedAt\n和\nupdatedAt\n代表每个对象(每条数据)在服务器上创建和最后修改的时间。这些键(数据列)的创建和数据内容是由服务器端自主来完成的。\n因此，使用create和update方法时,如果保存了objectId对象，否则会出现提示：“It is a reserved field: objectId(105)”--表明objectId为系统保留字段，不允许修改。\n。\n\n\n\n\n\n\n查询数据\n\n\n数据的查询可能是每个应用都会频繁使用到的，可以使用BmobObject类，它提供了多样的方法来实现不同条件的查询，同时它的使用也是非常的简单和方便的。\n\n\n查询所有数据\n\n\n查询某个数据表中的所有数据是非常简单的查询操作，例如：查询GameScore表中playerName为“比目”的50条数据记录。\n\n\n$res=$bmobObj-\nget(\n,array('where={\nplayerName\n:\n比目\n}','limit=50'));\n\n\n\n\n查询的结果不需要进行任何处理，BmobSDK已经为你封装成相应的php集合了，你直接使用即可。\n\n\n查询单条数据\n\n\n当我们知道某条数据的\nobjectId\n时，就可以根据\nobjectId\n直接获取单条数据对象。例如：查询\nobjectId\n为\na203eba875\n的人员信息。\n\n\n\n$res=$bmobObj-\nget(\na203eba875\n); \n\n\n\n\n\n查询条件\n\n\n在查询的使用过程中，基于不同条件的查询是非常常见的，BmobQuery同样也支持不同条件的查询。\n\n\n比如需要查询playerName不等于“Barbie”的数据时可以这样写：\n\n\n$res=$bmobObj-\nget(\n,array('where={\nplayerName\n:{\n$ne\n:\nBarbie\n}}'));\n\n\n\n\n当然，你可以在你的查询操作中添加多个约束条件，来查询符合要求的数据。例如，下面的例子是查询playerName不等于“Barbie”，score大于90的数据\n\n\n$res=$bmobObj-\nget(\n,array('where={\nplayerName\n:{\n$ne\n:\nBarbie\n},\nscore\n:{\n$gt\n:90}}'));\n\n\n\n\n如果你想查询匹配几个不同值的数据，如：要查询“Barbie”,“Joe”,“Julia”三个人的成绩时，你可以使用下面的方法来实现。\n\n\n$res=$bmobObj-\nget(\n,array('where={\nplayerName\n:{\n$in\n:[\nBarbie\n,\nJoe\n,\n“Julia\n]}}'));\n\n\n\n\n相反，如果你想查询排除“Barbie”,“Joe”,“Julia”这三个人的其他同学的信息，你可以使用\n$nin\n来实现。\n\n\n$res=$bmobObj-\nget(\n,array('where={\nplayerName\n:{\n$nin\n:[\nBarbie\n,\nJoe\n,\n“Julia\n]}}'));\n\n\n\n\n为了获得score得分包括数组中所有的值，如score是[1,3, 5]就满足，是[1, 5,10]就不满足:\n\n\n$res=$bmobObj-\nget(\n,array('where={\nscore\n:{\n$all\n:[1,3,5]}}'));\n\n\n\n\n为了获取playerName不在列表中的GameScore对象们，我们可以:\n\n\n$res=$bmobObj-\nget(\n,array('where={\nplayerName\n:{\n$nin\n:[\nJonathan Walsh\n,\nDario Wunsch\n,\nShawn Simon\n]}}'));\n\n\n\n\n为了获取有分数的对象，我们应该用::\n\n\n$res=$bmobObj-\nget(\n,array('where={\nscore\n:{\n$exists\n:true}}'));\n\n\n\n\n为了获取没有分数的对象，用:\n\n\n$res=$bmobObj-\nget(\n,array('where={\nscore\n:{\n$exists\n:false}}'));\n\n\n\n\n你还可以使用模糊查询，支持PCRE正则表达式：\n\n\n$res=$bmobObj-\nget(\n,array('where={\nplayerName\n:{\n$regex\n:\nsmile.*\n}}'));\n\n\n\n\n注:模糊查询只对付费用户开放，付费后可直接使用。\n\n\n如果您的查询条件某个列值要匹配另一个查询的返回值，举例有一个队伍(Team)保存了每个城市的得分情况且用户表中有一列为用户家乡(hometown), 您可以创建一个查询来寻找用户的家乡是得分大于0.5的城市的所有运动员， 就像这样查询:\n\n\n$res=$bmobObj-\nget(\n,array('where={\nhometown\n:{\n$select\n:{\nquery\n:{\nclassName\n:\nTeam\n,\nwhere\n:{\nwinPct\n:{\n$gt\n:0.5}}},\nkey\n:\ncity\n}}}'));\n\n\n\n\n反之查询Team中得分小于等于0.5的城市的所有运动员，构造查询如下：\n\n\n$res=$bmobObj-\nget(\n,array('where={\nhometown\n:{\n$dontSelect\n:{\nquery\n:{\nclassName\n:\nTeam\n,\nwhere\n:{\nwinPct\n:{\n$gt\n:0.5}}},\nkey\n:\ncity\n}}}'));\n\n\n\n\n下面是查询时支持的参数：\n\n\n\n\n\n\n\n\nKey\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n$lt\n\n\n小于\n\n\n\n\n\n\n$lte\n\n\n小于等于\n\n\n\n\n\n\n$gt\n\n\n大于\n\n\n\n\n\n\n$gte\n\n\n大于等于\n\n\n\n\n\n\n$ne\n\n\n不等于\n\n\n\n\n\n\n$in\n\n\n包含在数组中\n\n\n\n\n\n\n$nin\n\n\n不包含在数组中\n\n\n\n\n\n\n$exists\n\n\n这个 Key 有值\n\n\n\n\n\n\n$select\n\n\n匹配另一个查询的返回值\n\n\n\n\n\n\n$dontSelect\n\n\n排除另一个查询的返回\n\n\n\n\n\n\n$all\n\n\n包括所有给定的值\n\n\n\n\n\n\n$regex\n\n\n匹配PCRE表达式\n\n\n\n\n\n\n\n\n分页查询\n\n\n你可以用limit和skip来做分页，limit的默认值是100，但是任何1到1000的值都是可选的，就是说，为了获取在400到600之间的对象:\n\n\n$res=$bmobObj-\nget(\n,array('where={\nplayerName\n:\ngame\n}','limit=200','skip=400'));\n\n\n\n\n结果排序\n\n\n你可以用order参数指定一个字段来排序，前面加一个负号的前缀表示降序，这样返回的对象会以score升序排列:\n\n\n$res=$bmobObj-\nget(\n,array('where={\nplayerName\n:\ngame\n}','order=score'));\n\n\n\n\n而以下这样返回的对象会以score降序排列:\n\n\n$res=$bmobObj-\nget(\n,array('where={\nplayerName\n:\ngame\n}','order=-score'));\n\n\n\n\n你可以用多个字段进行排序，只要用一个逗号隔开列表就可以，为了获取GameScore，以score的升序和name的降序进行排序:\n\n\n$res=$bmobObj-\nget(\n,array('where={\nplayerName\n:\ngame\n}','order=score,-name'));\n\n\n\n\n统计对象数量\n\n\n如果你在使用limit，或者如果返回的结果很多，你可能想要知道到底有多少对象应该返回，而不用把它们全部获得以后再计数，此时你可以使用count参数。举个例子，如果你仅仅是关心一个特定的玩家玩过的游戏数量：\n\n\n$res=$bmobObj-\nget(\n,array('where={\nplayerName\n:\ngame\n}','limit=0','count=1'));\n\n\n\n\n因为请求了count而且把limit设为了0，返回的值里面只有计数，results为空数组集。\n\n\n{ [\ncount\n]=\n int(6) [\nresults\n]=\n array(0) { } }\n\n\n\n\n复合查询\n\n\n\n\n\n\n\n\nKey\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n$or\n\n\n复合查询中的或查询\n\n\n\n\n\n\n$and\n\n\n复合查询中的与查询\n\n\n\n\n\n\n\n\n如果你想查询对象符合几种查询之一，你可以使用$or或$and操作符，带一个JSON数组作为它的值。例如，如果你想找到player赢了很多或者赢了很少，你可以用如下的方式:\n\n\n$res=$bmobObj-\nget(\n,array('where={\n$or\n:[{\nwins\n:{\n$gt\n:150}},{\nwins\n:{\n$lt\n:5}}]}'));\n\n\n\n\n查询今天内的数据，方式如下:\n\n\n$res=$bmobObj-\nget(\n,array('where={\n$and\n:[{\ncreatedAt\n:{\n$gte\n:{\n__type\n: \nDate\n, \niso\n: \n2014-07-15 00:00:00\n}}},{\ncreatedAt\n:{\n$lte\n:{\n__type\n: \nDate\n, \niso\n: \n2014-07-15 23:59:59\n}}}]}'));\n\n\n\n\n因为createdAt updatedAt服务器自动生成的时间，在服务器保存的是精确到微秒值的时间，所以基于时间类型比较的值要加1秒。\n\n\n任何在查询上的其他的约束都会对返回的对象生效，所以你可以用$or对其他的查询添加约束。\n\n\n注意我们不会在 \n组合查询的子查询\n 中支持非过滤型的约束(例如:limit skip sort include)，但最外层的查询中是支持非过滤型约束的。\n\n\n查询指定列\n\n\n你可以限定返回的字段，通过传入keys参数，值为用一个逗号分隔的字段名称列表，为了获取对象只包含score和playerName字段(还有特殊的内置字段比如objectId,createdAt和updatedAt)，请求如下：\n\n\n$res=$bmobObj-\nget(\n,array('$res=$bmobObj-\nget(\n,array(\nkeys=score,playerName\n))'));\n\n\n\n\n使用 BQL 查询\n\n\n我们还提供类 SQL 语法的 BQL 查询语言来查询数据，例如：\n\n\n     $bmobBql = new BmobBql();\n     $res = $bmobBql-\nquery(array('bql=select * from GameScore where name=? limit ?,? order by name'));  \n\n\n\n\n更多请参考 \nBQL 详细指南\n 。\n\n\nBQL 还支持占位符查询，where 和 limit 子句的条件参数可以使用问号替换，然后通过 \nvalues\n 数组传入：\n\n\n    $bmobBql = new BmobBql();\n     $res = $bmobBql-\nquery(array('bql=select * from GameScore where name=? limit ?,? order by name','values=[\ndennis\n, 0, 100]'));  \n\n\n\n\n\n修改数据\n\n\n为了更改一个对象上已经有的数据，你可以发送一个PUT请求到对象相应的URL上，只有你指定的Key的值才会变更为新值，任何你未指定的Key的值都不会更改，所以你可以只更新对象数据的一个子集。例如，我们来更改我们对象的一个score的字段:\n\n\n$res=$bmobObj-\nupdate(\n16d846f51c\n, array(\nscore\n=\n60));\n\n\n\n\n返回的JSON对象只会包含一个updatedAt字段，表明更新发生的时间：\n\n\n{ [\nupdatedAt\n]=\n string(19) \n2015-10-26 16:33:51\n }\n\n\n\n\n删除数据\n\n\n为了在\nBmob\n上删除一个对象，可以发送一个DELETE请求到指定的对象的URL，比如:\n\n\n$res=$bmobObj-\ndelete(\nbd89c6bce9\n); //删除对象bd89c6bce9\n\n\n\n\n删除字段\n\n\n你可以在一个对象中删除一个字段，通过Delete操作:\n\n\n $res=$bmobObj-\ndeleteField(\nZS5wHHHV\n,\nscore\n); //在一个对象中删除一个字段\n\n\n\n\n数组\n\n\n为了存储数组型数据，\nBmob\n提供了3种操作来原子性地更改一个数组字段:\n\n\nAdd\n 在一个数组字段的后面添加一些指定的对象(包装在一个数组内)\n\n\nAddUnique\n 只会在原本数组字段中没有这些对象的情形下才会添加入数组，插入数组的位置不固定的\n\n\nRemove\n 从一个数组字段的值内移除指定的数组中的所有对象\n\n\n添加数组数据\n\n\n添加一行记录时创建一个普通的数组类型字段，可以使用以下方法添加：\n\n\n $res=$bmobObj-\naddArray(\nlist\n,array(\nperson1\n,\nperson2\n));\n\n\n\n\n更新数组数据\n\n\n每一种方法都会有一个objects，即包含了这些方法将被添加或删除的对象列表，举个例子，技能skills是一个类似于集合的数组类型，那么我们可以在skills中加入一些对象，只有在skills原来的对象中不包含这些值的情况下才会被加入:\n\n\n $res=$bmobObj-\nupdateArray(\nZS5wHHHV\n,\nskills\n,array(\nflying\n,\nkungfu\n)); \n\n\n\n\n查询数组数据\n\n\n对于Key的类型是数组的情况，可以查找Key的数组值中包含有2的对象:\n\n\n$res=$bmobObj-\nget(\n,array('where={\narrayKey\n:2}'));\n\n\n\n\n你同样可以使用\"$all\"操作符来找到类型为数组的Key的值中包含有2,3和4的对象:\n\n\n$res=$bmobObj-\nget(\n,array('where={\narrayKey\n:{\n$all\n:[2,3,4]}}'));\n\n\n\n\n删除数组数据\n\n\n同理我们可以使用Remove这个操作在把这些对象从skills中移除：\n\n\n$res=$bmobObj-\ndeleteArray(\nZS5wHHHV\n,\nskills\n,array(\nflying\n,\nkungfu\n)); \n\n\n\n\n使用索引和对象key修改数组中的对象\n\n\n比如你当前行有一列叫用户的工作经验projectExperiences，是一个Array数组列，里面包含了多个对象值：[{\"name\":\"项目名称\",\"descr\":\"项目描述\"，\"startTime\":\"开始时间\"，\"endTime\":\"结束时间\"}, ...]\n\n\n那么我们要修改projectExperiences数组中第一个对象的name值：\n\n\n$bmobUser = new BmobUser();\n$res=$bmobUser-\nupdate(\n16d846f51c\n, array(\nprojectExperiences.0.name\n=\n项目名称2\n));\n\n\n\n\n修改对象的某个值\n\n\n比如你当前行有一列叫userAttibute,保存的是一个JSON 对象，比如是: {\"name\":\"John\", \"gender\":\"男\"}\n\n\n那么我们要修改这个对象的某个Key的值：\n\n\n$res=$bmobObj-\nupdate(\n16d846f51c\n, array(\nuserAttibute.gender\n=\n女\n)); \n\n\n\n\n数据关联\n\n\n关联关系描述\n\n\n在程序设计中，不同类型的数据之间可能存在某种关系。\n\n\n比如：帖子和作者的关系，一篇帖子只属于某个用户，这是\n一对一的关系\n,\n\n\n比如：帖子和评论的关系，一条评论只属于某一篇帖子，而一篇帖子对应有很多条评论，这是\n一对多的关系\n,\n\n\n比如：学生和课程的关系，一个学生可以选择很多课程，一个课程也可以被很多学生所选择，这是\n多对多的关系\n。\n\n\nBmob提供了\nPointer（一对一、一对多）\n和\nRelation（多对多）\n两种数据类型来解决这种业务需求。\n\n\n本案例的场景描述\n\n\n由于关联关系讲解起来比较复杂，以下用一个简单的案例来说明在Bmob中是如何使用关联关系的。\n\n\n场景：\n用户发表帖子，同时又可对帖子进行评论留言。\n\n\n在这个场景中涉及到三个表：用户表（\n_User\n）、帖子表（\nPost\n）、评论表（\nComment\n）,以下是各个表的字段：\n\n\n_User\n字段如下：\n\n\n\n\n 字段 \n类型\n  含义\n\n\n objectId \n  String\n  用户ID\n\n\n username \n  String\n  用户名(可以既发帖子又发评论)\n\n\n age \n  Integer\n  年龄\n\n\n\n\n\n\n\nPost\n字段如下：\n\n\n\n\n 字段 \n  含义\n  类型\n\n\n objectId \n  String\n 帖子ID \n\n\n title \n  String\n 帖子标题 \n\n\n content \n  String\n 帖子内容 \n\n\n author \n  Pointer\n<\n_User>\n 帖子作者 \n\n\n likes \n  Relation\n<\n_User>\n 喜欢帖子的读者 \n\n\n\n\n\n\n\nComment\n字段如下：\n\n\n\n\n 字段 \n  含义\n  类型\n\n\n objectId \n  String\n 评论ID \n\n\n content \n  String\n 评论内容 \n\n\n post \n   Pointer\n<\n Post>\n 评论对应的帖子 \n\n\n author \n  Pointer\n<\n_User>\n 评论该帖子的人 \n\n\n\n\n\n\n\nWeb端创建关联字段\n\n\n如果你需要在Web端创建上述表的话，那么当选择的字段类型为\nPointer或Relation\n时，会提示你选择该字段所指向或关联的数据表。\n\n\n如下图所示：\n\n\n\n\n以下举例均假定A用户已注册并登陆\n\n\n\n\n一对一关系\n\n\n用户发表帖子，一篇帖子也只能属于某个用户，那么帖子和用户之间的关系是\n一对一关系\n，建议使用\nPointer\n类型来表示。\n\n\nPointer\n本质上可以看成是我们将一个指向某条记录的指针记录下来，我们查询时可以通过该指针来获得其指向的关联对象。\n\n\n用户A（该ObjectId为“0290813a89”）写了一篇帖子，需要在\nPost\n表中生成一条记录，并将该帖子关联到用户A这条记录，表明该帖子是A所发表的。\n\n\n示例如下：\n\n\n    $post = new BmobObject(\nPost\n);\n    $res=$post-\naddRelPointer(\nauthor\n,\n_User\n,\n0290813a89\n);\n    $res=$post-\nupdate($res-\nobjectId, array(\ncontent\n=\n帖子内容\n));\n\n\n\n\n添加成功后，在后台的\nPost\n表中，你就会看到有一条记录生成，并且该帖子的\nauthor\n字段的值指向了\n_User\n表中的\n用户A\n这条记录。\n\n\n\n\n查询一对一关联\n\n\n如果想查询用户A（该ObjectId为“0290813a89”）所发表的所有帖子，那么可以这样：\n\n\n    $post = new BmobObject(\nPost\n);\n    $res=$post-\naddRelPointer(array(array(\nauthor\n,\n_User\n,\n0290813a89\n)));\n    $res=$post-\nupdate($res-\nobjectId, array(\ncontent\n=\n帖子内容\n));\n\n\n\n\n修改一对一关联\n\n\n如果希望将\n83ce274594\n这条帖子的作者修改成\n用户B\n,示例：\n\n\n    $res=$post-\nupdateRelPointer(\n83ce274594\n, \nauthor\n, \n_User\n, \n7f00a95bdf\n);\n\n\n\n\n修改成功后，在后台可查看到\n83ce274594\n这个帖子的作者已经变更为用户B\n\n\n\n\n删除一对一关联\n\n\n如果你想和\n83ce274594\n这个帖子解除关联关系，可以这样：\n\n\n    $res=$post-\ndeleteField(\n83ce274594\n,\nauthor\n);\n\n\n\n\n删除成功后，在后台的\nPost\n表中，你就会看到\n83ce274594\n这个帖子的\nauthor\n字段的值已经被置空了。\n\n\n\n\n一对多关系\n\n\n一篇评论只能属于某一篇帖子，一篇帖子可以有很多用户对其进行评论，那么帖子和评论之间的关系就是\n一对多关系\n，推荐使用\npointer\n类型来表示\n。\n\n\n因为使用方法和上面的一对一关联基本相同，只是查询一对多关联的时候有些区别，故只举添加和查询两个例子：\n\n\n添加一对多关联\n\n\n将评论和微博进行关联，并同时和当前用户进行关联，表明是当前用户对该帖子进行评论，示例如下：\n\n\n    $comment = new BmobObject(\nComment\n);\n    $res=$comment-\naddRelPointer(array(array(\nauthor\n,\n_User\n,\n0290813a89\n),array(\npost\n,\nPost\n,\n81108a33c8\n)));\n\n\n\n\n查询一对多关联\n\n\n我想\n查询出某个帖子（objectId为81108a33c8）的所有评论,同时将该评论的作者的信息也查询出来\n，那么可以使用下面的方法：\n\n\n    $res=$comment-\nget(\n,array('where={\npost\n:{\n__type\n:\nPointer\n,\nclassName\n:\nPost\n,\nobjectId\n:\n81108a33c8\n}}','include=author'));\n\n\n\n\n多对多关系\n\n\n一个帖子可以被很多用户所喜欢，一个用户也可能会喜欢很多帖子，那么可以使用\nRelation\n类型来表示这种\n多对多关联关系\n。\n\n\nRelation\n本质上可以理解为其存储的是一个对象，而这个对象中存储的是多个指向其它记录的指针。\n\n\n添加多对多关联\n\n\n    $res=$post-\nupdateRelRelation(\n83ce274594\n, \nlikes\n, array(array(\n_User\n,\nfocb9e3d60\n)));\n\n\n\n\n添加成功后，在后台的\nPost\n表中就能查看到\nlikes\n字段已经生成并对应到了\n_User\n\n\n\n\n点击红框中的\n关联关系\n按钮展开后，可查看刚才所添加的喜欢该帖子的用户A：\n\n\n\n\n查询多对多关联\n\n\n如果希望\n查询喜欢该帖子（objectId为83ce274594）的所有用户\n，那么可以使用下面的方法：\n\n\n示例代码：\n\n\n    $res = $bmobUser-\nget(0,array('where={\n$relatedTo\n:{\nobject\n:{\n__type\n:\nPointer\n,\nclassName\n:\nPost\n,\nobjectId\n:\n83ce274594\n},\nkey\n:\nlikes\n}}')); \n\n\n\n\n修改多对多关联\n\n\n如果\n用户B也喜欢该帖子（objectId为83ce274594）\n，此时需要为该帖子(Post)的\nlikes\n字段多添加一个用户,示例如下：\n\n\n$res=$post-\nupdateRelRelation(\n83ce274594\n, \nlikes\n, array(array(\n_User\n,\n83ce274594\n)));\n\n\n\n\n修改成功后，你在点击该帖子的\nlikes\n字段下面的\n关联关系\n按钮展开后，可查看刚才所添加的喜欢该帖子的用户B：\n\n\n\n\n删除多对多关联\n\n\n如果\n想对该帖子进行取消喜欢的操作\n，此时，需要删除之前的多对多关联，具体代码：\n\n\n$res=$post-\ndeleteRelation(\n81108a33c8\n, \nlikes\n, array(array(\n_User\n,\neb3e34f23b\n)));\n\n\n\n\ninclude用法\n\n\n在某些情况下，你想在一个查询内获取\nPointer\n类型的关联对象。\n\n\n比如上述示例中，如果希望在查询帖子信息的同时也把该帖子的作者的信息查询出来，可以使用\ninclude\n方法\n\n\n$res=$post-\nget(\n,array('include=author'));\n\n\n\n\n你可以使用\n,\n号(逗号)操作符来\ninclude并列查询\n两个对象\n\n\n比如，查询评论表的同时将该评论用户的信息和所评论的帖子信息也一并查询出来（因为Comment表有两个\nPointer类型\n的字段），那么可以这样做：\n\n\n$res=$comment-\nget(\n,array('include=author,post'));\n\n\n\n\n你同时还可以使用 \n.\n号（英语句号）操作符来进行\ninclude中的内嵌对象查询\n\n\n比如，你想在查询评论信息的同时将该评论\nComment\n对应的帖子\npost\n以及该帖子的作者信息\nauthor\n一并查询出来，你可以这样做：\n\n\n$res=$comment-\nget(\n,array('include=post.author'));\n\n\n\n\n注：include的查询对象只能为BmobPointer类型，而不能是BmobRelation类型。\n\n\n批量数据操作\n\n\n为了减少因为网络通讯次数太多而带来的时间浪费, 你可以使用下面的批量(batch)操作，在一个请求中对多个普通对象进行添加(create)、更新(update)、删除(delete) 操作，上限为50个。\n\n\n在一个批量(batch)请求中每一个操作都有自己对应的方法、路径和主体, 这些参数可以代替你通常使用的HTTP方法. 这些操作会以发送过去的顺序来执行, 比如我们要创建一系列的 GameScore 的对象:\n\n\n    $bmobBatch = new BmobBatch();\n    $data=array(\n        array(\n            \nmethod\n=\nPOST\n,\n            \npath\n=\n/1/classes/GameScore\n,\n            \nbody\n=\narray(\n                        \nscore\n=\n1337,\n                        \nplayerName\n=\nSean Plott\n,\n                    ),\n        ),\n        array(\n            \nmethod\n=\nPOST\n,\n            \npath\n=\n/1/classes/GameScore\n,\n            \nbody\n=\narray(\n                        \nscore\n=\n1338,\n                        \nplayerName\n=\nZeroCool\n,\n                    ),\n        ),\n    );\n    $res=$bmobBatch-\nbatch($data);\n\n\n\n\n批量操作的响应会是一个列表, 列表的返回值个数与给定的requests请求个数是相等的。列表中每个返回项都有一个字段是 \n\"success\"\n 或者 \n\"error\"\n， \n\"success\"\n 的值通常和你进行其他REST操作成功时返回的值是一样的:\n\n\nArray\n(\n    [0] =\n stdClass Object\n        (\n            [success] =\n stdClass Object\n                (\n                    [createdAt] =\n 2015-10-30 10:51:52\n                    [objectId] =\n 495ac937b8\n                )\n\n        )\n\n    [1] =\n stdClass Object\n        (\n            [success] =\n stdClass Object\n                (\n                    [createdAt] =\n 2015-10-30 10:51:52\n                    [objectId] =\n e8597579be\n                )\n\n        )\n\n)\n\n\n\n\n\n\"error\"\n 的值是有返回码和错误信息字符串的一个对象:\n\n\n[error] =\n stdClass Object\n    (\n        [code] =\n 101\n        [error] =\n \nobject not found for delete\n\n    )\n\n\n\n\n在 batch 操作中更新(update)和删除(delete)同样是有效的，如果相应记录有ACL规则，则必须传入该用户的Token才能进行更新或删除:\n\n\n    $bmobBatch = new BmobBatch();\n    $data=array(\n        array(\n            \nmethod\n=\nPUT\n,\n            \ntoken\n=\npnktnjyb996sj4p156gjtp4im\n,\n            \npath\n=\n/1/users/51e3a334e4b0b3eb44adbe1a\n,\n            \nbody\n=\narray(\n                        \nscore\n=\n1337,\n                    ),\n        ),\n        array(\n            \nmethod\n=\nDELETE\n,\n            \ntoken\n=\npnktnjyb996sj4p156gjtp4im\n,\n            \npath\n=\n/1/users/51a8a4d9e4b0d034f6159a35\n,\n        ),\n    );\n    $res=$bmobBatch-\nbatch($data);\n\n\n\n\n原子计数器\n\n\n很多应用可能会有需要计数器的功能，比如某条信息被点赞多少次等。Bmob提供了非常便捷的方式来保证原子性的修改某一数值字段的值。\n\n\n$bmobObj = new BmobObject(\nGameScore\n);\n$res=$bmobObj-\nincrement(\nbd89c6bce9\n,\nscore\n,array(2)); //id为bd89c6bce9的field score数值加2\n\n\n\n\n\n同理可以让score像下面一样减少一个固定的值：\n\n\n$res=$bmobObj-\nincrement(\nbd89c6bce9\n,\nscore\n,array(-2)); //id为bd89c6bce9的field score数值减2\n\n\n\n\n文件\n\n\nBmob的文件上传有整个文件上传和分片上传两种方式，可以分别实现小文件上传和大文件的上传。\n\n\n整个文件上传\n\n\n上传整个文件到bmob，发送一个POST请求到file路径，参数是：文件名，。\n上传一个 hello.txt 文件实现方法如下：\n\n\n$bmobFile = new BmobFile();\n//第一个参数是文件的名称,第二个参数是文件的url(可以是本地路径,最终是通过file_get_contents获取文件内容)\n$res=$bmobFile-\nuploadFile(\nheelo.txt\n,\nhttp://file.bmob.cn/M02/17/99/oYYBAFYfXS6AKB96AAAABNsGNwg872.txt\n);\n\n\n\n\n返回的主体是一个JSON对象，包含：文件名（filename）、分组（group）、文件地址（url）。 http://file.bmob.cn/ + url 就是文件上传成功后的完整地址，返回的Http Headers中的Location会包含该完整地址:\n\n\n[filename] =\n heelo.txt [group] =\n group1 [url] =\n M02/57/6A/oYYBAFYy3amAQI7cAAAAAjP0FTs923.txt\n\n\n\n\n\n然后你需要把上传后的文件对象上传:\n\n\n$fileArray = array(\n__type\n=\nFile\n, \ngroup\n=\n$res-\ngroup,\nfilename\n=\n$res-\nfilename,\nurl\n=\n$res-\nurl);\n$res=$bmobObj-\ncreate(array(\nscore\n=\n11,\nfile\n=\n$fileArray)); \n\n\n\n\n删除文件\n\n\n删除文件，必须要知道文件的url，如下：\n\n\n$res=$bmobFile-\ndelete(\nM02/54/09/oYYBAFYxx4uAbgTcAAAbpS8UHE45961.js\n);\n\n\n\n\n其中M02/54/09/oYYBAFYxx4uAbgTcAAAbpS8UHE45961.js是文件的url。\n\n\n返回结果格式如下：\n\n\n{ $msg =\n \nok\n } \n\n\n\n\n删除文件不会删除文件关联的行记录中的文件列的值，需要自行通过更新行来删除关联。\n\n\n用户\n\n\n很多跨平台和跨系统的应用都有一个统一的登录流程，\nBmob\n通过REST API访问用户的账户让你实现该功能。\n\n\n通常来说，用户这个类的功能与其他的对象是相同的，比如都没有限制模式(Schema Less)，User对象和其他对象不同的是一个用户必须有用户名(username)和密码(password)，密码会被自动地加密和存储。\nBmob\n强制你username和email这两个Key的值必须是不重复的。\n\n\n属性\n\n\nBmob\n默认会有几个特定的属性：\nusername: 用户的用户名\n（必需）\n。\npassword: 用户的密码\n（必需）\n。\nemail: 用户的电子邮件地址\n（可选）\n。\n\n\n注册用户\n\n\n注册一个新用户与创建一个新的普通对象之间的不同点在于其username和password字段都是必要的，password字段会以与其他的字段不一样的方式处理，它在保存时会被加密而且永远不会被返回给任何来自客户端的请求。\n\n\n在你的应用设置页面中，你可以向\nBmob\n来请求认证邮件地址，这项设置启用了的话，所有用户在注册时填写email这个Key的值，并且邮箱有效的情况下，就会向这个邮箱地址发出一封邮件，邮件中会包含一个来自\nBmob\n的邮箱验证的链接，当你的用户查收邮件并点击这个链接后，这个用户emailVerified的Key的值会置为True，你可以在emailVerified字段上查看用户的email是否已经通过验证了。\n\n\n为了注册一个新的用户，需要向user路径发送一个POST请求，你可以加入一个甚至多个新的字段，例如，创建一个有家庭电话字段的新用户:\n\n\n$bmobUser = new BmobUser();\n$res = $bmobUser-\nregister(array(\nusername\n=\ncooldude117\n, \npassword\n=\np_n7!-e8\n, \nphone\n=\n415-392-0202\n, \nemail\n=\nbmobtest111@126.com\n)); \n\n\n\n\n当创建成功时,HTTP响应头的状态码返回为201 Created，Http响应头的Location值包含了该新用户的URL:\n\n\nStatus: 201 Created\nLocation: https://api.bmob.cn/1/users/Kc3M222J\n\n\n\n\n返回的主体是包含objectId，表示唯一的用户, createdAt时间戳表示用户注册时间, sessionToken可以被用来认证更新或删除这名用户信息的请求。\n\n\n[createdAt] =\n 2011-11-07 20:58:34, [objectId] =\n Kc3M222J, [sessionToken] =\n pnktnjyb996sj4p156gjtp4im, \n\n\n\n\n这里需要注意一点的是，有些时候你可能需要在用户注册时发送一封验证邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在应用设置-\n邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在注册时自动发动一封验证邮件给用户。\n\n\n\n设置邮箱验证功能\n\n\n使用手机号码一键注册或登陆\n\n\nBmob\n 支持让用户直接输入手机号码进行注册，如果手机号码存在则自动登陆：\n\n\n $res = $bmobUser-\nregister(array(\nmobilePhoneNumber\n=\n131xxxxxxxx\n, \nsmsCode\n=\n502845\n));\n\n\n\n\n其中 \nmobilePhoneNumber\n 就是手机号码，而 \nsmsCode\n 是使用 \n请求短信验证码方法\n发送到用户手机上的 6位验证码字符串。如果是新用户且不传入 username，默认用户名将是手机号码。\n\n\n注册或者登陆成功后，返回的应答跟登陆接口类似：\n\n\n  \nusername\n =\n185xxxxxxxx\n,\n  \nmobilePhoneNumber\n =\n \n185xxxxxxxx\n,\n  \nmobilePhoneVerified\n =\n true,\n  \ncreatedAt\n =\n \n2011-11-07 20:58:34\n,\n  \nupdatedAt\n =\n \n2011-11-07 20:58:34\n,\n  \nobjectId\n =\n \nKc3M222J\n,\n  \nsessionToken\n =\n \npnktnjyb996sj4p156gjtp4im\n\n  ……其他属性\n\n\n\n\n\n如果是第一次注册，将默认设置_User表的 \nmobilePhoneVerified\n 属性为 true。\n\n\n登录用户\n\n\n你的用户注册之后，你需要让他们用自己的用户名和密码登录，为了做到这一点，发送一个HTTP GET请求到 \n/1/login\n ，加上username和password作为URL编码后的参数：\n\n\n$res = $bmobUser-\nlogin(\ntest111@qq.com\n,\n111111\n);\n\n\n\n\nusername 支持传入_User表的username或email或mobilePhoneNumber字段的值，作为登录的扩展功能，以实现邮箱和密码、手机号和密码登录功能。\n\n\n除了有用户名或邮箱或手机号码和密码登录的功能，\nBmob\n 还支持使用手机号码和验证码一键快速登录的功能，而 \nsmsCode\n 是使用\n请求短信验证码方法\n发送到用户手机上的 6位验证码字符串：\n\n\n$res = $bmobUser-\nloginByMobile(\n131xxxxxxxx\n,\n745399\n);\n\n\n\n\n返回的主体是一个JSON对象，包括所有除了password以外的自定义字段，它同样包含了createdAt,updateAt,objectId和sessionToken字段：\n\n\n    \nusername\n=\ncooldude6\n,\n    \nphone\n=\n415-392-0202\n,\n    \ncreatedAt\n=\n \n2011-11-07 20:58:34\n,\n    \nupdatedAt\n=\n2011-11-07 20:58:34\n,\n    \nobjectId\n=\nKc3M222J\n,\n    \nsessionToken\n=\npnktnjyb996sj4p156gjtp4im\n\n\n\n\n\n获取当前用户\n\n\n当注册一个用户后，你可以通过发送一个HTTP GET请求到用户注册成功时返回的HTTP请求头中的Location的URL获取用户的信息。比如，为了获取上面注册成功的用户：\n\n\n$res = $bmobUser-\nget(\n415b8fe99a\n); // 获取id为415b8fe99a用户的信息\n\n\n\n\n返回的对象包含所有用户提供的字段,除了密码以外.也包括了createdAt,updatedAt和objectId字段.\n\n\n\n    \nusername\n=\ncooldude6\n,\n    \nphone\n=\n \n415-392-0202\n,\n    \ncreatedAt\n=\n \n2011-11-07 20:58:34\n,\n    \nupdatedAt\n=\n \n2011-11-07 20:58:34\n,\n    \nobjectId\n=\n \n415b8fe99a\n\n\n\n\n\n\n更新用户\n\n\n在通常的情况下，我们都不希望用户去修改自己的数据，但可以通过认证让用户去做这件事，修改的用户的数据必须要传入sessionToken，这个sessionToken在注册和登录时都会返回。\n\n\n为了改动一个用户已经有的数据，需要对这个用户的URL发送一个HTTP PUT请求，任何你没有指定的key会保持不变，所以你可以只改动用户信息中的一部分，username和password可以更改，但是新的username不能重复。\n\n\n比如，如果我们想对 cooldude6 的电话做出一些改动：\n\n\n$res = $bmobUser-\nupdate(\n415b8fe99a\n, \n050391db407114d9801c8f2788c6b25a\n, array(\nphone\n=\n02011111\n)); \n\n\n\n\n上面的050391db407114d9801c8f2788c6b25a是sessionToken\n\n\n返回只有一个updatedAt字段表明更新发生的时间.\n\n\n{\n    \nupdatedAt\n=\n2011-11-07 21:25:10\n\n}\n\n\n\n\n在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发动一封验证邮件给用户。\n\n\n删除用户\n\n\n为了在\nBmob\n上删除一个用户，可以向用户的URL上发送一个DELETE请求，前提是你必须填入sessiontoken以便认证授权，例子：\n\n\n$res = $bmobUser-\ndelete(\n415b8fe99a\n, \n050391db407114d9801c8f2788c6b25a\n); // 删除id为415b8fe99a的用户, 第一参数是用户id, 第二个参数为sessiontoken,在用户登录或注册后获取, 必填\n\n\n\n\n查询用户\n\n\n你可以一次获取多个用户，只要向用户的根URL发送一个GET请求，没有任何URL参数的话，可以简单地列出所有用户：\n\n\n $res = $bmobUser-\nget(); // 获取所有用户的信息\n\n\n\n\n返回的值是一个JSON对象包括一个results字段, 值是包含了所有对象的一个JSON数组.\n\n\n    [results] =\n Array\n        (\n            [0] =\n stdClass Object\n                (\n                    [age] =\n 11\n                    [createdAt] =\n 2015-10-19 15:45:17\n                    [email] =\n test111@qq.com\n                    [emailVerified] =\n \n                    [objectId] =\n WXHsFFFd\n                    [updatedAt] =\n 2015-10-27 18:03:42\n                    [username] =\n b\n                )\n\n            [1] =\n stdClass Object\n                (\n                    [createdAt] =\n 2015-10-22 10:24:49\n                    [mobilePhoneNumber] =\n 13168399536\n                    [mobilePhoneNumberVerified] =\n 1\n                    [objectId] =\n 0290813a89\n                    [updatedAt] =\n 2015-10-26 17:47:00\n                    [username] =\n a\n                )\n\n            [2] =\n stdClass Object\n                (\n                    [createdAt] =\n 2015-10-30 14:44:18\n                    [email] =\n bmobtest111@126.com\n                    [emailVerified] =\n \n                    [objectId] =\n eb3e34f23b\n                    [phone] =\n 415-392-0202\n                    [updatedAt] =\n 2015-10-30 14:44:18\n                    [username] =\n cooldude117\n                )\n\n        )\n\n\n\n\n浏览器中查看用户表\n\n\nUser表是一个特殊的表，专门存储BmobUser对象。在浏览器端，你会看到一个User表旁边有一个小人的图标。\n\n\n\n\n密码重置\n\n\n你可以使用这项功能，前提是用户将email与他们的账户关联起来.\n\n\n $res = $bmobUser-\nrequestPasswordReset(\nbmobxxx@126.com\n);\n\n\n\n\n如果成功的话,返回的值是一个JSON对象。\n密码重置流程如下：\n\n\n\n\n用户输入他们的电子邮件，请求重置自己的密码。\n\n\nBmob向他们的邮箱发送一封包含特殊的密码重置连接的电子邮件，此邮件的模板可在Bmob后台中修改。\n\n\n用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，输入一个新的密码。\n\n\n用户的密码已被重置为新输入的密码。\n\n\n\n\n使用短信验证码进行密码重置\n\n\n如果用户有绑定了手机号码，就可以通过手机验证码短信来实现使用手机号码找回密码的功能，先调用发送验证码 $bmobSms-\nsendSms 会将验证码发送到用户手机上，用户收到验证码并输入后，调用resetPasswordBySmsCode 来为用户设置新的密码：\n\n\n$res = $bmobUser-\nresetPasswordBySmsCode(\n111111\n, \n134554\n); // 使用短信验证码进行密码重置\n\n\n\n\n如果成功的话,返回如下:\n\n\nmsg\n: \nok\n\n\n\n\n\n这时，用户就可以用新密码登陆了。\n\n\n提供旧密码方式安全修改用户密码\n\n\n很多开发者希望让用户输入一次旧密码做一次校验，旧密码正确才可以修改为新密码，因此我们提供了一个单独的方法updateUserPassword来安全地修改用户密码：\n\n\n$res = $bmobUser-\nupdateUserPassword(\nWXHsFFFd\n, \nd365d5834061d9f6805047131893ae13\n , \n123456\n, \n111111\n); //用户输入一次旧密码做一次校验，旧密码正确才可以修改为新密码\n\n\n\n\nWXHsFFFd：为当前登录用户的objectId。\nd365d5834061d9f6805047131893ae13：sessionToken\n\n\n注意：仍然需要传入 sessionToken，也就是登录用户才可以修改自己的密码。\n\n\n邮箱验证\n\n\n设置邮件验证是一个可选的应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会默认被设为false，如果应用设置中开启了邮箱认证功能，\nBmob\n会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.\n\n\nemailVerified 字段有 3 种状态可以考虑：\n\n\ntrue\n : 用户可以点击邮件中的链接通过\nBmob\n来验证地址，一个用户永远不会在新创建这个值的时候出现emailVerified为true。\n\n\nfalse\n : 用户(User)对象最后一次被刷新的时候, 用户并没有确认过他的邮箱地址, 如果你看到emailVerified为false的话，你可以考虑刷新 用户(User)对象。\n\n\nmissing\n : 用户(User)对象已经被创建，但应用设置并没有开启邮件验证功能； 或者用户(User)对象没有email邮箱。\n\n\n请求验证Email\n\n\n发送到用户邮箱验证的邮件会在一周内失效，可以通过调用 \nrequestEmailVerifyy\n 来强制重新发送：\n\n\n$res = $bmobUser-\nrequestEmailVerify(\nh622222225@126.com\n); //请求验证Email\n\n\n\n\n用户账户连接\n\n\nBmob允许你连接你的用户到第三方账户服务系统，比如新浪微博和QQ，这样就允许您的用户用已经存在的第三方账户直接登录您的App。通过注册或者更新的用户信息的功能，使用 \nauthData\n 字段来保存第三方服务的授权信息就可以做到。一旦用户关联了某个第三方账户，\nauthData\n 将被存储到您的Bmob的用户信息里，并通过登录即可重新获取到。\n\n\nauthData\n 是一个普通的 JSON 对象，它所要求的key根据第三方账户服务不同而不同，具体要求见下面。每种情况下，你都需要自己负责完成整个授权过程 (一般是通过 OAuth 协议，1.0 或者 2.0) 通过连接的API来获取授权信息。\n\n\n新浪微博的 \nauthData\n 内容:\n\n\narray(\n    \nauthData\n=\n\n        array(\nweibo\n=\narray(\n            \nuid\n=\n123456789\n,\n            \naccess_token\n=\n2.00ed6eMCV9DWcBcb79e8108f8m1HdE\n,\n            \nexpires_in\n=\n1564469423540,\n    ))\n)\n\n\n\n\n\n腾讯QQ的 \nauthData\n 内容:\n\n\narray(\n    \nauthData\n=\n\n        array(\nweibo\n=\narray(\n            \nopenid\n=\n2345CA18A5CD6255E5BA185E7BECD222\n,\n            \naccess_token\n=\n12345678-SM3m2avZxh5cjJmIrAfx4ZYyamdofM7IjU\n,\n            \nexpires_in\n=\n1382686496,\n    ))\n)\n\n\n\n\n\n匿名用户 (Anonymous user) 的 authData 内容:\n\n\narray(\n    \nauthData\n=\narray(\nid\n=\nrandom UUID with lowercase hexadecimal digits\n)    \n)\n\n\n\n\n\n注册和登录\n\n\n使用一个第三方账户连接服务来注册用户并登录，同样使用POST请求/1/users，只是需要提供authData字段。例如，使用新浪微博账户注册或者登录用户:\n\n\n$data = array(\n    \nauthData\n=\n\n        array(\nweibo\n=\narray(\n            \nuid\n=\n123456789\n,\n            \naccess_token\n=\n2.00ed6eMCV9DWcBcb79e8108f8m1HdE\n,\n            \nexpires_in\n=\n1564469423540,\n    ))\n);\n$res = $bmobUser-\nregister($data);\n\n\n\n\n\nBmob 会校验提供的 authData 是否有效，并检查是否已经有一个用户连接了这个 authData 服务。如果已经有用户存在并连接了同一个 authData，那么Http响应头将返回 200 OK 和详细信息 (包括用户的 sessionToken):\n\n\nStatus: 200 OK\nLocation: https://api.bmob.cn/1/users/Kc3M222J\n\n\n\n\n返回的内容类似\n\n\n\n  \nusername\n=\nBmob\n,\n  \ncreatedAt\n=\n2011-11-07 21:25:10\n,\n  \nupdatedAt\n=\n2011-11-07 21:25:10\n,\n  \nobjectId\n=\nKc3M222J\n,\n  \nsessionToken\n=\npnktnjyb996sj4p156gjtp4im\n,\n  \nauthData\n=\narray(\n    \nweibo\n=\narray(\n      \nuid\n=\n \n123456789\n,\n      \naccess_token\n=\n \n2.00ed6eMCV9DWcBcb79e8108f8m1HdE\n,\n      \nexpires_in\n=\n 1564469423540\n    )\n  )\n\n\n\n\n\n连接\n\n\n连接一个现有的用户到新浪微博或者腾讯QQ帐号，可以通过发送一个 PUT 请求附带 authData 字段到以上Location返回的用户URL做到。例如，连接一个用户到腾讯QQ帐号发起的请求类似这样:\n\n\n\n$data = array(\n    \nauthData\n=\n\n        array(\nweibo\n=\narray(\n            \nopenid\n=\n2345CA18A5CD6255E5BA185E7BECD222\n,\n            \naccess_token\n=\n12345678-SM3m2avZxh5cjJmIrAfx4ZYyamdofM7IjU\n,\n            \nexpires_in\n=\n1382686496,\n    ))\n);\n $res = $bmobUser-\nupdate(\n415b8fe99a\n, \n050391db407114d9801c8f2788c6b25a\n, $data));\n\n\n\n\n\n完成连接后，你可以使用匹配的 authData 来认证他们。\n\n\n断开连接\n\n\n断开一个现有用户到某个服务，可以发送一个 PUT 请求设置 authData 中对应的服务为 null 来做到。例如，取消新浪微博关联:\n\n\n$data = array(\n    \nauthData\n=\n\n        array(\nweibo\n=\nnull\n    ))\n);\n$res = $bmobUser-\nupdate(\n415b8fe99a\n, \n050391db407114d9801c8f2788c6b25a\n, $data));\n\n\n\n\n\nACL和角色\n\n\n数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看\nBmob数据与安全页面\n，了解Bmob如何保护数据安全）。\n\n\n其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。\n\n\n大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：\n\n\n\n\n对于私有数据，读写权限可以只局限于数据的所有者。\n\n\n对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。\n\n\n对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。\n\n\n属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。\n\n\n一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。\n\n\n\n\nACL的格式\n\n\n在Bmob中，ACL是用array来表示的。这个array的key是objectId（用户表某个用户对应的objectId）或者是 *(表示公共的访问权限)，ACL 的值是 \"读和写的权限\", 这个array的key总是权限名, 而这些key的值总是 true。\n\n\n如果您想让一个 id 为 \"Kc3M222k\" 的用户有读和写一条数据的权限, 而且这个数据应该可以被全部人读取的话，这个ACL的表达方式如下：\n\n\narray(\n    \nKc3M222k\n=\narray(\n        \nread\n=\ntrue,\nwrite\n=\ntrue\n        )，\n    \n*\n=\narray(\n        \nread\n=\ntrue\n        )，  \n)\n\n\n\n\n角色和相关操作\n\n\n在很多情况下，你需要定义一些用户具有某种相同的数据操作权限，而另外一群用户具有另外一种相同的数据操作权限，这时你就可以使用到Bmob的角色（对应Bmob在Web提供的Role表、SDK中的BmobRole类）功能，设置不同的用户组不同的操作权限。角色表有三个特殊字段：\n\n\nname\n : 必须字段，表示角色名称,而且只允许被设置一次（命名必须由字母, 空格, 减号或者下划线构成）；\n\n\nusers\n :一个指向一系列用户的关系, 这些用户会继承角色的权限；\n\n\nroles\n : 一个指向一系列子角色的关系, 这些子关系会继承父角色所有的权限。\n\n\n创建角色\n\n\n创建一个新角色的方法如下（固定POST数据到https://api.bmob.cn/1/roles中，且必须提供 \nname\n 字段）：\n\n\n    $bmobRole = new BmobRole();\n    $res = $bmobRole-\ncreateRole(array(\nname\n=\nMo1derators\n, \nACL\n=\narray(\n*\n=\narray(\nread\n=\ntrue,\nwrite\n=\ntrue)))); //创建角色\n\n\n\n\n\n如果你要创建一个包括了“用户和子角色”的角色，实现方式如下：\n\n\n$data = array(\n    \nname\n=\nMo1derators\n,\n     \nACL\n=\narray(\n        \n*\n=\narray(\nread\n=\ntrue,\nwrite\n=\ntrue)\n      )，\n     \nroles\n=\narray(\n         \n__op\n=\nAddRelation\n,\n        \nobjects\n=\n array(\n              \n__type\n=\nPointer\n,\n              \nclassName\n=\n_Role\n,\n              \nobjectId\n=\nFe441wZ5\n\n            )\n      ），\n)\n$res = $bmobRole-\ncreateRole($data);\n\n\n\n\n当创建成功后返回HTTP如下：\n\n\nStatus: 201 Created\nLocation: https://api.bmob.cn/1/roles/51e3812D\n\n\n\n\n获取角色\n\n\n获取角色对象的方法如下：\n\n\n$res = $bmobRole-\ngetRole(\nfff849f7d4\n); //获取角色\n\n\n\n\n响应结果如下：\n\n\n    [ACL] =\n stdClass Object\n        (\n            [*] =\n stdClass Object\n                (\n                    [read] =\n 1\n                    [write] =\n 1\n                )\n\n        )\n\n    [createdAt] =\n 2015-10-23 10:19:06\n    [name] =\n Mo1derators\n    [objectId] =\n dcf9ad7d2e\n    [updatedAt] =\n 2015-10-23 10:19:06\n\n\n\n\n更新角色\n\n\n更新角色时，一个很重要的一点是： \nname\n 字段不可以更改。添加和删除 \nusers\n 和 \nroles\n 可以通过使用 AddRelation 和 RemoveRelation 操作符进行。\n\n\n如给 \"Moderators\" 角色增加 1 个用户，实现如下:\n\n\n    $data=array(\n            array(\n              \n__type\n=\nPointer\n,\n                 \nclassName\n=\n_User\n,\n                 \nobjectId\n=\nWXHsFFFd\n,\n            ),\n        );\n    $res = $bmobRole-\nupdateRole(\nd4642acf90\n, \nusers\n, \nAddRelation\n, $data); \n\n\n\n\n\n删除 \"Moderrators\" 的一个子角色的实现如下：\n\n\n    $data=array(\n            array(\n              \n__type\n=\nPointer\n,\n                 \nclassName\n=\n_User\n,\n                 \nobjectId\n=\nWXHsFFFd\n,\n            ),\n        );\n    $res = $bmobRole-\nupdateRole(\nd4642acf90\n, \nusers\n, \nRemoveRelation\n, $data); \n\n\n\n\n角色的使用\n\n\n设置一条数据的角色权限，需要在ACL中把Key的名字设置为 “\nrole:\n + 角色名称” 。如限制一条数据可以被在 \"Members\" 里的任何人读到, 而且可以被它的创建者（objectId为\nf1766d0b42\n）和任何有 \"Moderators\" 角色的人所修改, 实现方式如下:\n\n\n\n  \nf1766d0b42\n=\narray(\n    \nwrite\n=\ntrue\n  ),\n  \nrole:Members\n=\narray(\n    \nread\n=\ntrue\n  },\n  \nrole:Moderators\n=\narray(\n    \nwrite\n=\ntrue\n  }\n\n\n\n\n\n如果这个用户和 \"Moderators\" 本身就是 \"Members\" 的子角色和用户，那么，您不必为创建的用户和 \"Moderators\" 指定读的权限，因为它们都会继承授予 \"Members\" 的权限。\n\n\n角色的继承\n\n\n一个角色可以包含另一个，可以为 2 个角色建立一个父-子关系。 这个关系的结果就是任何被授予父角色的权限隐含地被授予子角色。\n\n\n这样的关系类型通常在用户管理的内容类的应用上比较常见, 比如在论坛中，有一些少数的用户是 \"管理员（Administartors）\", 有最高的权限，可以调整系统设置、 创建新的论坛等等。 另一类用户是 \"版主（Moderators）\"，他们可以对用户发帖的内容进行管理。可见，任何有管理员权限的人都应该有版主的权限。为建立起这种关系, 您应该把 \"Administartors\" 的角色设置为 \"Moderators\" 的子角色, 具体来说就是把 \"Administrators\" 这个角色加入 \"Moderators\" 对象的 roles 关系之中，实现如下：\n\n\n\n    $data=array(\n            array(\n              \n__type\n=\nPointer\n,\n                 \nclassName\n=\n_Role\n,\n                 \nobjectId\n=\nAdministratorsRoleObjectId\n,\n            ),\n        );\n    $res = $bmobRole-\nupdateRole(\nModeratorsRoleObjectId\n, \nroles\n, \nAddRelation\n, $data); \n\n\n\n\n\n地理位置\n\n\nBmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询。你可以在查询中添加一个GeoPoint的对象查询。你可以实现轻松查找出离当前用户最接近的信息或地点的功能。\n\n\n创建地理位置对象\n\n\n\n$data = array(\nlocation\n=\narray(\n                               \n__type\n=\n \nGeoPoint\n,\n                               \nlatitude\n=\n 50.934755,\n                               \nlongitude\n=\n 24.52065,                  \n                        )\n             );\n\n$res=$bmobObj-\nupdate(\ne1kXT22L\n, $data);\n\n\n\n\n\n查询地理位置信息\n\n\n现在你有一系列的对象对应的地理坐标，如果能发现哪些对象离指定的点近就好了，这可以通过GeoPoint数据类型加上在查询中使用$nearSphere做到。获取离用户最近的10个地点应该看起来像下面这个样子:\n\n\n$res=$bmobObj-\nget(\n,array('where={\n    \nlocation\n: {\n        \n$nearSphere\n: {\n            \n__type\n: \nGeoPoint\n,\n            \nlatitude\n: 30.0,\n            \nlongitude\n: -20.0\n        }\n      }\n    }','limit=200'));\n\n\n\n\n这操作会按离纬度30.0，经度-20.0的距离排序返回一系列的结果，第一个就是最近的对象。(注意如果一个特定的order参数是给定了的话，它会覆盖按距离排序的结果)，例如，查询操作返回的结果：\n\n\n        array(\n        \nlocation\n=\narray(\n             \n__type\n=\n \nGeoPoint\n,\n            \nlatitude\n=\n 40.0,\n            \nlongitude\n=\n -30.0\n        ),\n        \nupdatedAt\n=\n \n2011-12-06 22:36:04\n,\n        \ncreatedAt\n=\n \n2011-12-06 22:36:04\n,\n        \nobjectId\n=\n \ne1kXT22L\n\n        )\n\n\n\n\n为了限定搜索的最大距离范围，需要加入$maxDistanceInMiles(英里)和$maxDistanceInKilometers(公里d)或者$maxDistanceInRadians(弧度)参数来限定，如果不加，则默认是100KM的半径。比如要找的半径在10公里内的话:\n\n\n$res=$bmobObj-\nget(\n,array('where={\n        \nlocation\n: {\n            \n$nearSphere\n: {\n                \n__type\n: \nGeoPoint\n,\n                \nlatitude\n: 30.0,\n                \nlongitude\n: -20.0\n            },\n        \n$maxDistanceInKilometers\n: 10.0\n        }\n    }','limit=200'));\n\n\n\n\n同样作查询寻找在一个特定的范围里面的对象也是可以的，为了找到在一个矩形区域里的对象，按下面的格式加入一个约束 {\"$within\": {\"$box\": [southwestGeoPoint, northeastGeoPoint]}}：\n\n\n$res=$bmobObj-\nget(\n,array('where={\n        \nlocation\n: {\n            \n$within\n: {\n                \n$box\n: [\n                    {\n                        \n__type\n: \nGeoPoint\n,\n                        \nlatitude\n: 37.71,\n                        \nlongitude\n: -122.53\n                    },\n                    {\n                        \n__type\n: \nGeoPoint\n,\n                        \nlatitude\n: 30.82,\n                        \nlongitude\n: -122.37\n                    }\n                ]\n            }\n        }\n    }','limit=200'));\n\n\n\n\n注意事项\n\n\n关于地理位置的有一些问题是值得留意的:\n\n\n\n\n每一个表\n只能\n一个地理位置列，每一个对象\n只能\n有一个索引指向一个GeoPoint对象\n\n\nGeoPoint的点不能超过规定的范围。\n纬度的范围\n应该是在\n-90.0到90.0\n之间。\n经度的范围\n应该是在\n-180.0到180.0\n之间。如果您添加的经纬度超出了以上范围，将导致程序错误。\n\n\n删除文件不会删除文件关联的行记录中的文件列的值，需要自行通过更新行来删除关联。\n\n\n如果不加任何距离范围限制，则默认是100公里的半径范围。\n\n\n\n\n统计相关的查询\n\n\nBmob的统计查询，提供以下关键字或其组合的查询操作：\n\n\n\n\n\n\n\n\nKey\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\ngroupby\n\n\n分组操作\n\n\n\n\n\n\ngroupcount\n\n\n返回每个分组的总记录\n\n\n\n\n\n\nsum\n\n\n计算总和\n\n\n\n\n\n\naverage\n\n\n计算平均值\n\n\n\n\n\n\nmax\n\n\n计算最大值\n\n\n\n\n\n\nmin\n\n\n计算最小值\n\n\n\n\n\n\nhaving\n\n\n分组中的过滤条件\n\n\n\n\n\n\n\n\n为避免和用户创建的列名称冲突，Bmob约定以上统计关键字（sum, max, min)的查询结果值都用 '_(关键字)+首字母大写的列名' 的格式，如计算玩家得分列名称为score总和的操作，则返回的结果集会有一个列名为_sumScore。average返回的列为 '_avg+首字母大写的列名'，有groupcount的情形下则返回_count。\n\n\n以上关键字除了groupcount是传Boolean值true或false，having传的是和where类似的json字符串，但having只应该用于过滤分组查询得到的结果集，即having只应该包含结果集中的列名如{\"_sumScore\":{\"$gt\":100}}，其他关键字必须是字符串而必须是表中包含的列名，多个列名用,分隔。\n\n\n以上关键字可以自由组合并可以与前面查询语句中的where, order, limit, skip等组合使用。\n\n\n比如，GameScore表是游戏玩家的信息和得分表，有playerName(玩家名称)、score(玩家得分)等你自己创建的列，还有Bmob的默认列objectId, createdAt, updatedAt,那么我们现在举例如何使用以上的查询关键字来作这个表的统计。 \n\n\n计算总和\n\n\n我们要计算GameScore表所有玩家的得分总和，sum后面只能拼接Number类型的列名，即要计算哪个列的值的总和，只对Number类型有效，多个Number列用,分隔，则查询如下：\n\n\n $res=$bmobObj-\nget(\n,array('sum=score'));\n\n\n\n\n返回内容如下：\n\n\n   [_sumScore] =\n 11371\n\n\n\n\n\n分组计算总和\n\n\n比如我们以创建时间按天统计所有玩家的得分，并按时间降序, groupby后面只能拼接列名，如果该列是时间类型，则按天分组，其他类型，则按确定值分组:\n\n\n$res=$bmobObj-\nget(\n,array('sum=score','groupby=createdAt'));\n\n\n\n\n返回内容如下：\n\n\n            [0] =\n Array\n                (\n                    [_sumScore] =\n 20\n                    [createdAt] =\n 2015-10-29\n                )\n\n            [1] =\n Array\n                (\n                    [_sumScore] =\n 0\n                    [createdAt] =\n 2014-05-19\n                )                \n\n\n\n\n多个分组并计算多个列的总和\n\n\n比如我们以创建时间按天和按玩家名称分组统计所有玩家的得分1，得分2的总和，并按得分1的总和降序, groupby后面只能拼接列名，如果该列是时间类型，则按天分组，其他类型，则按确定值分组:\n\n\n$res=$bmobObj-\nget(\n,array('sum=score1,score2','groupby=createdAt,playerName','order=-_sumscore1'));\n\n\n\n\n返回内容如下：\n\n\n            [0] =\n Array\n                (\n                    [_sumScore1] =\n 399,\n                    [_sumScore2] =\n 120,    \n                    [playerName] =\n \nJohn\n,\n                    [createdAt] =\n 2015-10-29\n                )\n\n            [1] =\n Array\n                (\n                    [_sumScore1] =\n 299,\n                    [_sumScore2] =\n 250,    \n                    [playerName] =\n \nBily\n,\n                    [createdAt] =\n 2015-10-29\n                )  \n\n\n\n\n分组计算总和并只返回满足条件的部分值\n\n\n比如我们以创建时间按天统计所有玩家的得分，并只返回某天的总得分大于2000的记录，并按时间降序，having是用于过滤部分结果，其中的_sumScore是 '_sum+首字母大写的列名' 的格式表示是计算这个列的总和的值:\n\n\n\n$res=$bmobObj-\nget(\n,array('sum=score','having={\n_sumScore\n:{\n$gt\n: 2000}}','order=-createdAt','groupby=createdAt'));\n\n\n\n\n返回内容如下：\n\n\n            [0] =\n Array\n                (\n                    [_sumScore] =\n 2398\n                    [createdAt] =\n 2015-10-29\n                )\n\n\n\n\n\n\n分组计算总和并返回每个分组的记录数\n\n\n比如我们以创建时间按天统计所有玩家的得分和每一天有多少条玩家的得分记录，并按时间降序:\n\n\n\n$res=$bmobObj-\nget(\n,array('sum=score','groupby=createdAt','groupcount=true','order=-createdAt'));\n\n\n\n\n\n返回内容如下：\n\n\n            [0] =\n Array\n                (\n                    [_sumScore] =\n 2398,\n                    [_count] =\n 10, \n                    [createdAt] =\n 2015-10-29\n                )\n\n            [1] =\n Array\n                (\n                    [_sumScore] =\n 100,\n                    [_count] =\n 2,  \n                    [createdAt] =\n 2015-10-29\n                )   \n\n\n\n\n获取不重复的列值\n\n\n比如我们获取表中所有的唯一的score:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'groupby=score' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n$res=$bmobObj-\nget(\n,array('groupby=score'));\n\n\n\n\n返回内容如下：\n\n\n            [0] =\n Array\n                (\n                    [score] =\n 78\n\n                )\n\n            [1] =\n Array\n                (\n                    [score] =\n 79\n\n                )                 \n\n\n\n\n其他关键字\n\n\naverage(计算平均值)， max(计算最大值)，min(计算最小值)和sum查询语句是类似的，只用把上面的例子中的sum替换为相应的average, max, min就可以了。\n\n\napp服务\n\n\n通过appapi，你可以查看，创建或编辑你的app，在用户管理后台也实现了这样的功能。通过验证你的bmob email账号和密码，你可以获取所有的app信息，创建一个新的app或者修改旧的app的信息。\n\n\n获取app信息\n\n\n获取所有的app信息\n\n\n    $bmobApp = new BmobApp();\n    $res = $bmobApp-\ngetApp(\n611115@126.com\n, \n111111\n); //获取全部app的信息\n\n\n\n\n获取某个特定的app信息\n\n\n$res = $bmobApp-\ngetApp(\n611115@126.com\n, \n111111\n, \n85b5xxxxxxxx9e59a795da547c68e6\n); //获取app id 为\n85b56934cce1129e59a795da547c68e6\n的信息\n\n\n\n\n创建新的app\n\n\n通过使用post 方法，可以在你的账号上创建一个app，创建app时支持如下的参数：\n\n\n\n\n\n\n\n\n参数名\n\n\n参数用途\n\n\n取值范围\n\n\n是否必须要填\n\n\n\n\n\n\n\n\n\n\nappName\n\n\napp的名称\n\n\n少于30个字符\n\n\n是\n\n\n\n\n\n\nstatus\n\n\napp是否可用\n\n\n0：表示禁用，1：表示可用\n\n\n否\n\n\n\n\n\n\nnotAllowedCreateTable\n\n\n是否允许通过api创建表\n\n\n0：表示允许创建表，1：表示不允许创建表\n\n\n否\n\n\n\n\n\n\n\n\n下面是一个创建app的例子\n\n\n$res = $bmobApp-\ncreateApp(\n611115@126.com\n, \n111111\n, array(\nappName\n=\nmyapp111\n)); //创建一个名为\nmyapp111\n的app\n\n\n\n\n修改app信息\n\n\n通过使用PUT 方法，可以修改app的信息，修改app信息时支持如下的参数：\n\n\n\n\n\n\n\n\n参数名\n\n\n参数用途\n\n\n取值范围\n\n\n是否必须要填\n\n\n\n\n\n\n\n\n\n\nappName\n\n\napp的名称\n\n\n少于30个字符\n\n\n否\n\n\n\n\n\n\nstatus\n\n\napp是否可用\n\n\n0：表示禁用，1：表示可用\n\n\n否\n\n\n\n\n\n\nnotAllowedCreateTable\n\n\n是否允许通过api创建表\n\n\n0：表示允许创建表，1：表示不允许创建表\n\n\n否\n\n\n\n\n\n\n\n\n下面是修改app信息的例子\n\n\n$res = $bmobApp-\nupdateApp(\n611115@126.com\n, \n111111\n, \n330xxxxxxxxx578d1f923126547bea5\n, array(\nappName\n=\nmyapp11122\n)); \n\n\n\n\n数据表\n\n\n通过数据表的php sdk，你可以查看，创建或编辑你的表结构，在用户管理后台的数据浏览页面也实现了这样的功能。\n\n\n注意，调用数据表相关的php sdk，必须指定Master Key。\n\n\n获取app表的信息\n\n\n$bmobSchemas = new BmobSchemas();\n$res = $bmobSchemas-\ngetSchemas(\ne09fb5cbb5bxxxxxxxx9504604c0dcff\n); \n\n\n\n\n获取某个特定表的信息\n\n\n$res = $bmobSchemas-\ngetSchemas(\ne09fb5cbb5b825c78989504604c0dcff\n, \nGame\n);\n\n\n\n\n创建字段支持的数据类型\n\n\nString\nNumber\nBool\nDate\nFile\nGeo\nArray\nObject\nPointer\nRelation\n\n\n创建一个表\n\n\n创建表“City”，并添加字段“name”\n\n\n    $data=array(\n            \nclassName\n =\n \nCity\n,\n            \nfields\n =\n array(\n              \nname\n =\n array(\n                \ntype\n=\nString\n,\n              ),\n            ),\n        );\n    $res = $bmobSchemas-\ncreateSchemas(\ne09fb5cbb5bxxxxxxxx9504604c0dcff\n, \nCity\n, $data);\n\n\n\n\n创建一个表\n\n\n创建表“City”，并添加字段“name”\n\n\n    $data=array(\n            \nclassName\n =\n \nCity\n,\n            \nfields\n =\n array(\n              \nname\n =\n array(\n                \ntype\n=\nString\n,\n              ),\n            ),\n        );\n    $res = $bmobSchemas-\ncreateSchemas(\ne09fb5cbb5bxxxxxxxx9504604c0dcff\n, \nCity\n, $data);\n\n\n\n\n如果创建表的字段是Pointer或Relation类型，需要用targetClass指定关联的表，例如：\n\n\n    $data=array(\n            \nclassName\n =\n \nCity\n,\n            \nfields\n =\n array(\n              \nname\n =\n array(\n                \ntype\n=\nPointer\n,\n                \ntargetClass\n=\n_User\n\n              ),\n            ),\n        );\n    $res = $bmobSchemas-\ncreateSchemas(\ne09fb5cbb5bxxxxxxxx9504604c0dcff\n, \nCity\n, $data);\n\n\n\n\n修改表的结构\n\n\n在表“City”中添加字段“name”\n\n\n    $data=array(\n            \nclassName\n =\n \nCity\n,\n            \nfields\n =\n array(\n              \nname\n =\n array(\n                \ntype\n=\nString\n,\n              ),\n            ),\n        );\n    $res = $bmobSchemas-\nupdateSchemas(\ne09fb5cbb5bxxxxxxxx9504604c0dcff\n, \nCity\n, $data); \n\n\n\n\n在表“City”中删除字段“name”\n\n\n    $data=array(\n            \nclassName\n =\n \nCity\n,\n            \nfields\n =\n array(\n              \nname\n =\n array(\n                \ntype\n=\nString\n,\n                \n__op\n=\nDelete\n\n              ),\n            ),\n        );\n    $res = $bmobSchemas-\nupdateSchemas(\ne09fb5cbb5bxxxxxxxx9504604c0dcff\n, \nCity\n, $data);\n\n\n\n\n删除表\n\n\n$res = $bmobSchemas-\ndeleteSchemas(\ne09fb5cbb5bxxxxxxxx9504604c0dcff\n, \nCity\n);\n\n\n\n\n获取服务器的时间\n\n\n有时，app需要获取服务器的时间，可通过下面的api\n\n\n    $bmobTimestamp = new BmobTimestamp();\n    $res = $bmobTimestamp-\ngetTimestamp(); \n\n\n\n\n返回结果如下：\n\n\narray（\n    [\ntimestamp\n]=\n1446522662，\n    [\ndatetime\n]=\n2015-11-03 11:51:02\n\n）", 
            "title": "开发文档"
        }, 
        {
            "location": "/data/php/develop_doc/#_1", 
            "text": "Bmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。", 
            "title": "简介"
        }, 
        {
            "location": "/data/php/develop_doc/#_2", 
            "text": "建议您在阅读本开发文档之前，先阅读我们提供的  php快速入门文档 ，便于您后续的开发。", 
            "title": "快速入门"
        }, 
        {
            "location": "/data/php/develop_doc/#_3", 
            "text": "在Bmob平台注册后，每个账户可创建多个应用程序，创建的每个应用程序有各自的Application ID，应用程序将凭其Application ID使用Bmob SDK。", 
            "title": "应用程序"
        }, 
        {
            "location": "/data/php/develop_doc/#_4", 
            "text": "请大家在使用Bmob开发应用程序之前，仔细阅读“数据与安全”的文档： http://docs.bmob.cn/other/Other/n_datasafety/doc/index.html", 
            "title": "应用安全"
        }, 
        {
            "location": "/data/php/develop_doc/#_5", 
            "text": "目前为止，我们支持的数据类型有String、Integer、Boolean、ArrayList以及BmobObject对象类型。同时Bmob也支持BmobDate、BmobGeoPoint、BmobFile数据类型。", 
            "title": "数据类型"
        }, 
        {
            "location": "/data/php/develop_doc/#phpsdk", 
            "text": "lib/BmobObject.class.php:对象操作类\nlib/BmobUser.class.php：用户操作类\nlib/BmobBatch.class.php：批量操作类\nlib/BmobFile.class.php：文件操作类\nlib/BmobImage.class.php：图片操作类\nlib/BmobRole.class.php：权限类\nlib/BmobPush.class.php：推送类\nlib/BmobPay.class.php：支付类\nlib/BmobSms.class.php：短信消息类\nlib/BmobApp.class.php：app操作类\nlib/BmobSchemas.class.php：数据表操作类\nlib/BmobTimestamp.class.php：获取服务器时间类\nlib/BmobCloudCode.class.php：云端代码类\nlib/BmobBql.class.php：bql操作类", 
            "title": "phpsdk相关类的说明"
        }, 
        {
            "location": "/data/php/develop_doc/#_6", 
            "text": "一个数据对象（APP中创建的BmobObject类和子类）对应于Bmob后台的一个数据表。", 
            "title": "对象"
        }, 
        {
            "location": "/data/php/develop_doc/#_7", 
            "text": "Bmob存储的数据是建立在BmobObject基础上的，所以任何要保存的数据对象必须继承自BmobObject类。BmobObject类本身包含 objectId 、 createdAt 、 updatedAt 、 ACL 四个默认的属性，objectId是数据的唯一标示，相当于表的主键，createdAt是数据的创建时间，updatedAt是数据的最后修改时间，ACL是数据的操作权限。  如，你的游戏中使用GameScore表来记录玩家的比分信息，其中表的字段有：score（分数）、playerName（玩家名字）属性，那么这个数据对象如下定义：  \n$bmobObj = new BmobObject( GameScore );\n$bmobObj- create(array( playerName = game , score = 20)); //添加对象  需要注意的是：   php不需要对 objectId 、 createdAt 、 updatedAt 、 ACL 四个属性进行定义。  不少开发者会没有注意到 createdAt 和 updatedAt 属性中的字母 d ，写成createAt和updateAt。", 
            "title": "数据对象"
        }, 
        {
            "location": "/data/php/develop_doc/#_8", 
            "text": "通过php sdk保存数据，这个数据是无模式化的（Schema Less）,这意味着你不需要提前标注每个对象上有哪些Key，你只需要随意设置key-value对就可以，php sdk后端会存储它的。  举个例子，假设你正在记录一局游戏的最高分，一个简单的对象可能包含:  array(\n     score =  1337,\n     playerName =   Sean Plott ,\n     cheatMode =  false\n)  Key必须是字母和数字组成的字符串,Value可以是任何可以JSON编码的东西.  每个对象都有一个类名，你可以通过类名来区分不同的数据，例如，我们可以把游戏得分对象称之为GameScore.我们推荐你使用   NameYourClassesLikeThis  和  nameYourKeysLikeThis  这样的格式为你的类名和Key命名，这可以使你的代码看起来很漂亮.  当你从 Bmob 中获取对象时，一些字段会被自动加上: createdAt, updatedAt 和 objectId， 这些字段的名字是保留的，你不能自行设置它们，我们上面设置的对象在获取时应该是下面的样子.  array(\n     score =  1337,\n     playerName =   Sean Plott ,\n     cheatMode =  false,\n     createdAt =   2011-08-20 02:06:57 ,\n     updatedAt =   2011-08-20 02:06:57 ,\n     objectId =   e1kXT22L \n)  createdAt和updatedAt都是UTC时间戳,以ISO 8601标准和毫秒级精度储存:YYYY-MM-DD HH:MM:SS. objectId是一个string,在类中唯一表明了一个对象。", 
            "title": "对象格式"
        }, 
        {
            "location": "/data/php/develop_doc/#_9", 
            "text": "到现在为止我们只使用了可以被标准JSON编码的值， Bmob 移动客户端SDK库同样支持日期,地理位置数据和指针数据、关系型数据。在php sdk中，这些值都被编码了，同时有一个\"__type\"字段来标识出它们所属的类型，所以如果你采用正确的编码的话就可以读或者写这些字段了。  Date类型包含了一个\"iso\"字段存储了一个UTC时间戳,以ISO 8601格式和毫秒级的精度来存储时间: YYYY-MM-DDTHH:MM:SS.MMMZ，或者 YYYY-MM-DDTHH:MM:SS  array(\n     __type = Date ,\n     iso = 2011-08-21 18:02:52 \n)  File类型是在上传后返回的JSON数据再加一个Key为\"__Type\":\"File\", 用来保存到数据列为文件类型的值：  array(\n     __type = File ,\n     group =   group1 ,\n     filename =   1.xml ,\n     url =   M00/01/14/sd2lkds0.xml \n)  Pointer 类型是在当前对象要指向另一个对象时使用，它包含了 className 和 objectId 两个作为一个指针正确指向的必填值.  array(\n   __type =   Pointer ,\n   className =   Game ,\n   objectId =   DdUOIIIW \n)  指向用户对象的  Pointer  的  className  为_User, 前面加一个下划线表示开发者不能定义的类名, 而且所指的类是系统内置的。  Relation  类型被用在多对多的类型上, 移动端的库将使用  BmobRelation  作为值, 它有一个 className 字段表示目标对象的类名：  array(\n   __type =   Relation ,\n   className =   GameScore \n)  当使用查询时，  Relation  对象的行为很像是  Pointer  的数组, 任何操作针对于  Pointer  的数组的 (除了 include) 都可以对  Relation  起作用.  当更多的数据类型被加入的时候, 它们都会采用 hashmap  加上一个 type  字段的形式, 所以你不应该使用type作为你自己的JSON对象的Key。", 
            "title": "数据类型"
        }, 
        {
            "location": "/data/php/develop_doc/#_10", 
            "text": "添加数据使用BmobObject对象的 create 方法，就可以将当前对象的内容保存到Bmob服务端。  例如，你现在要保存一条游戏分数的记录，代码如下：  \n$bmobObj = new BmobObject( GameScore );\n$res=$bmobObj- create(array( playerName = 比目 , score = 89)); //添加对象  运行以上代码，如果添加成功，你可以在Bmob提供的后台的数据浏览中看到类似这样的结果：  objectId:  0c6db13c , score: 89, playerName:  比目 ,createdAt: 2013-09-27 10:32:54 , updatedAt: 2013-09-27 10:32:54   这里需要注意的是：    如果服务器端不存在GameScore表，那么系统将自动建表，并插入数据。    如果服务器端已经存在GameScore表，和相应的score、playerName字段，那么你此时添加的数据和数据类型也应该和服务器端的表结构一致，否则会保存数据失败。    每个BmobObject对象都有几个默认的键(数据列)是不需要开发者指定的， objectId 是每个保存成功数据的唯一标识符。 createdAt 和 updatedAt 代表每个对象(每条数据)在服务器上创建和最后修改的时间。这些键(数据列)的创建和数据内容是由服务器端自主来完成的。 因此，使用create和update方法时,如果保存了objectId对象，否则会出现提示：“It is a reserved field: objectId(105)”--表明objectId为系统保留字段，不允许修改。 。", 
            "title": "添加数据"
        }, 
        {
            "location": "/data/php/develop_doc/#_11", 
            "text": "数据的查询可能是每个应用都会频繁使用到的，可以使用BmobObject类，它提供了多样的方法来实现不同条件的查询，同时它的使用也是非常的简单和方便的。", 
            "title": "查询数据"
        }, 
        {
            "location": "/data/php/develop_doc/#_12", 
            "text": "查询某个数据表中的所有数据是非常简单的查询操作，例如：查询GameScore表中playerName为“比目”的50条数据记录。  $res=$bmobObj- get( ,array('where={ playerName : 比目 }','limit=50'));  查询的结果不需要进行任何处理，BmobSDK已经为你封装成相应的php集合了，你直接使用即可。", 
            "title": "查询所有数据"
        }, 
        {
            "location": "/data/php/develop_doc/#_13", 
            "text": "当我们知道某条数据的 objectId 时，就可以根据 objectId 直接获取单条数据对象。例如：查询 objectId 为 a203eba875 的人员信息。  \n$res=$bmobObj- get( a203eba875 );", 
            "title": "查询单条数据"
        }, 
        {
            "location": "/data/php/develop_doc/#_14", 
            "text": "在查询的使用过程中，基于不同条件的查询是非常常见的，BmobQuery同样也支持不同条件的查询。  比如需要查询playerName不等于“Barbie”的数据时可以这样写：  $res=$bmobObj- get( ,array('where={ playerName :{ $ne : Barbie }}'));  当然，你可以在你的查询操作中添加多个约束条件，来查询符合要求的数据。例如，下面的例子是查询playerName不等于“Barbie”，score大于90的数据  $res=$bmobObj- get( ,array('where={ playerName :{ $ne : Barbie }, score :{ $gt :90}}'));  如果你想查询匹配几个不同值的数据，如：要查询“Barbie”,“Joe”,“Julia”三个人的成绩时，你可以使用下面的方法来实现。  $res=$bmobObj- get( ,array('where={ playerName :{ $in :[ Barbie , Joe , “Julia ]}}'));  相反，如果你想查询排除“Barbie”,“Joe”,“Julia”这三个人的其他同学的信息，你可以使用 $nin 来实现。  $res=$bmobObj- get( ,array('where={ playerName :{ $nin :[ Barbie , Joe , “Julia ]}}'));  为了获得score得分包括数组中所有的值，如score是[1,3, 5]就满足，是[1, 5,10]就不满足:  $res=$bmobObj- get( ,array('where={ score :{ $all :[1,3,5]}}'));  为了获取playerName不在列表中的GameScore对象们，我们可以:  $res=$bmobObj- get( ,array('where={ playerName :{ $nin :[ Jonathan Walsh , Dario Wunsch , Shawn Simon ]}}'));  为了获取有分数的对象，我们应该用::  $res=$bmobObj- get( ,array('where={ score :{ $exists :true}}'));  为了获取没有分数的对象，用:  $res=$bmobObj- get( ,array('where={ score :{ $exists :false}}'));  你还可以使用模糊查询，支持PCRE正则表达式：  $res=$bmobObj- get( ,array('where={ playerName :{ $regex : smile.* }}'));  注:模糊查询只对付费用户开放，付费后可直接使用。  如果您的查询条件某个列值要匹配另一个查询的返回值，举例有一个队伍(Team)保存了每个城市的得分情况且用户表中有一列为用户家乡(hometown), 您可以创建一个查询来寻找用户的家乡是得分大于0.5的城市的所有运动员， 就像这样查询:  $res=$bmobObj- get( ,array('where={ hometown :{ $select :{ query :{ className : Team , where :{ winPct :{ $gt :0.5}}}, key : city }}}'));  反之查询Team中得分小于等于0.5的城市的所有运动员，构造查询如下：  $res=$bmobObj- get( ,array('where={ hometown :{ $dontSelect :{ query :{ className : Team , where :{ winPct :{ $gt :0.5}}}, key : city }}}'));  下面是查询时支持的参数：     Key  Operation      $lt  小于    $lte  小于等于    $gt  大于    $gte  大于等于    $ne  不等于    $in  包含在数组中    $nin  不包含在数组中    $exists  这个 Key 有值    $select  匹配另一个查询的返回值    $dontSelect  排除另一个查询的返回    $all  包括所有给定的值    $regex  匹配PCRE表达式", 
            "title": "查询条件"
        }, 
        {
            "location": "/data/php/develop_doc/#_15", 
            "text": "你可以用limit和skip来做分页，limit的默认值是100，但是任何1到1000的值都是可选的，就是说，为了获取在400到600之间的对象:  $res=$bmobObj- get( ,array('where={ playerName : game }','limit=200','skip=400'));", 
            "title": "分页查询"
        }, 
        {
            "location": "/data/php/develop_doc/#_16", 
            "text": "你可以用order参数指定一个字段来排序，前面加一个负号的前缀表示降序，这样返回的对象会以score升序排列:  $res=$bmobObj- get( ,array('where={ playerName : game }','order=score'));  而以下这样返回的对象会以score降序排列:  $res=$bmobObj- get( ,array('where={ playerName : game }','order=-score'));  你可以用多个字段进行排序，只要用一个逗号隔开列表就可以，为了获取GameScore，以score的升序和name的降序进行排序:  $res=$bmobObj- get( ,array('where={ playerName : game }','order=score,-name'));", 
            "title": "结果排序"
        }, 
        {
            "location": "/data/php/develop_doc/#_17", 
            "text": "如果你在使用limit，或者如果返回的结果很多，你可能想要知道到底有多少对象应该返回，而不用把它们全部获得以后再计数，此时你可以使用count参数。举个例子，如果你仅仅是关心一个特定的玩家玩过的游戏数量：  $res=$bmobObj- get( ,array('where={ playerName : game }','limit=0','count=1'));  因为请求了count而且把limit设为了0，返回的值里面只有计数，results为空数组集。  { [ count ]=  int(6) [ results ]=  array(0) { } }", 
            "title": "统计对象数量"
        }, 
        {
            "location": "/data/php/develop_doc/#_18", 
            "text": "Key  Operation      $or  复合查询中的或查询    $and  复合查询中的与查询     如果你想查询对象符合几种查询之一，你可以使用$or或$and操作符，带一个JSON数组作为它的值。例如，如果你想找到player赢了很多或者赢了很少，你可以用如下的方式:  $res=$bmobObj- get( ,array('where={ $or :[{ wins :{ $gt :150}},{ wins :{ $lt :5}}]}'));  查询今天内的数据，方式如下:  $res=$bmobObj- get( ,array('where={ $and :[{ createdAt :{ $gte :{ __type :  Date ,  iso :  2014-07-15 00:00:00 }}},{ createdAt :{ $lte :{ __type :  Date ,  iso :  2014-07-15 23:59:59 }}}]}'));  因为createdAt updatedAt服务器自动生成的时间，在服务器保存的是精确到微秒值的时间，所以基于时间类型比较的值要加1秒。  任何在查询上的其他的约束都会对返回的对象生效，所以你可以用$or对其他的查询添加约束。  注意我们不会在  组合查询的子查询  中支持非过滤型的约束(例如:limit skip sort include)，但最外层的查询中是支持非过滤型约束的。", 
            "title": "复合查询"
        }, 
        {
            "location": "/data/php/develop_doc/#_19", 
            "text": "你可以限定返回的字段，通过传入keys参数，值为用一个逗号分隔的字段名称列表，为了获取对象只包含score和playerName字段(还有特殊的内置字段比如objectId,createdAt和updatedAt)，请求如下：  $res=$bmobObj- get( ,array('$res=$bmobObj- get( ,array( keys=score,playerName ))'));", 
            "title": "查询指定列"
        }, 
        {
            "location": "/data/php/develop_doc/#bql", 
            "text": "我们还提供类 SQL 语法的 BQL 查询语言来查询数据，例如：       $bmobBql = new BmobBql();\n     $res = $bmobBql- query(array('bql=select * from GameScore where name=? limit ?,? order by name'));    更多请参考  BQL 详细指南  。  BQL 还支持占位符查询，where 和 limit 子句的条件参数可以使用问号替换，然后通过  values  数组传入：      $bmobBql = new BmobBql();\n     $res = $bmobBql- query(array('bql=select * from GameScore where name=? limit ?,? order by name','values=[ dennis , 0, 100]'));", 
            "title": "使用 BQL 查询"
        }, 
        {
            "location": "/data/php/develop_doc/#_20", 
            "text": "为了更改一个对象上已经有的数据，你可以发送一个PUT请求到对象相应的URL上，只有你指定的Key的值才会变更为新值，任何你未指定的Key的值都不会更改，所以你可以只更新对象数据的一个子集。例如，我们来更改我们对象的一个score的字段:  $res=$bmobObj- update( 16d846f51c , array( score = 60));  返回的JSON对象只会包含一个updatedAt字段，表明更新发生的时间：  { [ updatedAt ]=  string(19)  2015-10-26 16:33:51  }", 
            "title": "修改数据"
        }, 
        {
            "location": "/data/php/develop_doc/#_21", 
            "text": "为了在 Bmob 上删除一个对象，可以发送一个DELETE请求到指定的对象的URL，比如:  $res=$bmobObj- delete( bd89c6bce9 ); //删除对象bd89c6bce9", 
            "title": "删除数据"
        }, 
        {
            "location": "/data/php/develop_doc/#_22", 
            "text": "你可以在一个对象中删除一个字段，通过Delete操作:   $res=$bmobObj- deleteField( ZS5wHHHV , score ); //在一个对象中删除一个字段", 
            "title": "删除字段"
        }, 
        {
            "location": "/data/php/develop_doc/#_23", 
            "text": "为了存储数组型数据， Bmob 提供了3种操作来原子性地更改一个数组字段:  Add  在一个数组字段的后面添加一些指定的对象(包装在一个数组内)  AddUnique  只会在原本数组字段中没有这些对象的情形下才会添加入数组，插入数组的位置不固定的  Remove  从一个数组字段的值内移除指定的数组中的所有对象", 
            "title": "数组"
        }, 
        {
            "location": "/data/php/develop_doc/#_24", 
            "text": "添加一行记录时创建一个普通的数组类型字段，可以使用以下方法添加：   $res=$bmobObj- addArray( list ,array( person1 , person2 ));", 
            "title": "添加数组数据"
        }, 
        {
            "location": "/data/php/develop_doc/#_25", 
            "text": "每一种方法都会有一个objects，即包含了这些方法将被添加或删除的对象列表，举个例子，技能skills是一个类似于集合的数组类型，那么我们可以在skills中加入一些对象，只有在skills原来的对象中不包含这些值的情况下才会被加入:   $res=$bmobObj- updateArray( ZS5wHHHV , skills ,array( flying , kungfu ));", 
            "title": "更新数组数据"
        }, 
        {
            "location": "/data/php/develop_doc/#_26", 
            "text": "对于Key的类型是数组的情况，可以查找Key的数组值中包含有2的对象:  $res=$bmobObj- get( ,array('where={ arrayKey :2}'));  你同样可以使用\"$all\"操作符来找到类型为数组的Key的值中包含有2,3和4的对象:  $res=$bmobObj- get( ,array('where={ arrayKey :{ $all :[2,3,4]}}'));", 
            "title": "查询数组数据"
        }, 
        {
            "location": "/data/php/develop_doc/#_27", 
            "text": "同理我们可以使用Remove这个操作在把这些对象从skills中移除：  $res=$bmobObj- deleteArray( ZS5wHHHV , skills ,array( flying , kungfu ));", 
            "title": "删除数组数据"
        }, 
        {
            "location": "/data/php/develop_doc/#key", 
            "text": "比如你当前行有一列叫用户的工作经验projectExperiences，是一个Array数组列，里面包含了多个对象值：[{\"name\":\"项目名称\",\"descr\":\"项目描述\"，\"startTime\":\"开始时间\"，\"endTime\":\"结束时间\"}, ...]  那么我们要修改projectExperiences数组中第一个对象的name值：  $bmobUser = new BmobUser();\n$res=$bmobUser- update( 16d846f51c , array( projectExperiences.0.name = 项目名称2 ));", 
            "title": "使用索引和对象key修改数组中的对象"
        }, 
        {
            "location": "/data/php/develop_doc/#_28", 
            "text": "比如你当前行有一列叫userAttibute,保存的是一个JSON 对象，比如是: {\"name\":\"John\", \"gender\":\"男\"}  那么我们要修改这个对象的某个Key的值：  $res=$bmobObj- update( 16d846f51c , array( userAttibute.gender = 女 ));", 
            "title": "修改对象的某个值"
        }, 
        {
            "location": "/data/php/develop_doc/#_29", 
            "text": "", 
            "title": "数据关联"
        }, 
        {
            "location": "/data/php/develop_doc/#_30", 
            "text": "在程序设计中，不同类型的数据之间可能存在某种关系。  比如：帖子和作者的关系，一篇帖子只属于某个用户，这是 一对一的关系 ,  比如：帖子和评论的关系，一条评论只属于某一篇帖子，而一篇帖子对应有很多条评论，这是 一对多的关系 ,  比如：学生和课程的关系，一个学生可以选择很多课程，一个课程也可以被很多学生所选择，这是 多对多的关系 。  Bmob提供了 Pointer（一对一、一对多） 和 Relation（多对多） 两种数据类型来解决这种业务需求。", 
            "title": "关联关系描述"
        }, 
        {
            "location": "/data/php/develop_doc/#_31", 
            "text": "由于关联关系讲解起来比较复杂，以下用一个简单的案例来说明在Bmob中是如何使用关联关系的。  场景： 用户发表帖子，同时又可对帖子进行评论留言。  在这个场景中涉及到三个表：用户表（ _User ）、帖子表（ Post ）、评论表（ Comment ）,以下是各个表的字段：  _User 字段如下：    字段  类型   含义   objectId    String   用户ID   username    String   用户名(可以既发帖子又发评论)   age    Integer   年龄    Post 字段如下：    字段    含义   类型   objectId    String  帖子ID    title    String  帖子标题    content    String  帖子内容    author    Pointer < _User>  帖子作者    likes    Relation < _User>  喜欢帖子的读者     Comment 字段如下：    字段    含义   类型   objectId    String  评论ID    content    String  评论内容    post     Pointer <  Post>  评论对应的帖子    author    Pointer < _User>  评论该帖子的人", 
            "title": "本案例的场景描述"
        }, 
        {
            "location": "/data/php/develop_doc/#web", 
            "text": "如果你需要在Web端创建上述表的话，那么当选择的字段类型为 Pointer或Relation 时，会提示你选择该字段所指向或关联的数据表。  如下图所示：   以下举例均假定A用户已注册并登陆", 
            "title": "Web端创建关联字段"
        }, 
        {
            "location": "/data/php/develop_doc/#_32", 
            "text": "用户发表帖子，一篇帖子也只能属于某个用户，那么帖子和用户之间的关系是 一对一关系 ，建议使用 Pointer 类型来表示。  Pointer 本质上可以看成是我们将一个指向某条记录的指针记录下来，我们查询时可以通过该指针来获得其指向的关联对象。  用户A（该ObjectId为“0290813a89”）写了一篇帖子，需要在 Post 表中生成一条记录，并将该帖子关联到用户A这条记录，表明该帖子是A所发表的。  示例如下：      $post = new BmobObject( Post );\n    $res=$post- addRelPointer( author , _User , 0290813a89 );\n    $res=$post- update($res- objectId, array( content = 帖子内容 ));  添加成功后，在后台的 Post 表中，你就会看到有一条记录生成，并且该帖子的 author 字段的值指向了 _User 表中的 用户A 这条记录。", 
            "title": "一对一关系"
        }, 
        {
            "location": "/data/php/develop_doc/#_33", 
            "text": "如果想查询用户A（该ObjectId为“0290813a89”）所发表的所有帖子，那么可以这样：      $post = new BmobObject( Post );\n    $res=$post- addRelPointer(array(array( author , _User , 0290813a89 )));\n    $res=$post- update($res- objectId, array( content = 帖子内容 ));", 
            "title": "查询一对一关联"
        }, 
        {
            "location": "/data/php/develop_doc/#_34", 
            "text": "如果希望将 83ce274594 这条帖子的作者修改成 用户B ,示例：      $res=$post- updateRelPointer( 83ce274594 ,  author ,  _User ,  7f00a95bdf );  修改成功后，在后台可查看到 83ce274594 这个帖子的作者已经变更为用户B", 
            "title": "修改一对一关联"
        }, 
        {
            "location": "/data/php/develop_doc/#_35", 
            "text": "如果你想和 83ce274594 这个帖子解除关联关系，可以这样：      $res=$post- deleteField( 83ce274594 , author );  删除成功后，在后台的 Post 表中，你就会看到 83ce274594 这个帖子的 author 字段的值已经被置空了。", 
            "title": "删除一对一关联"
        }, 
        {
            "location": "/data/php/develop_doc/#_36", 
            "text": "一篇评论只能属于某一篇帖子，一篇帖子可以有很多用户对其进行评论，那么帖子和评论之间的关系就是 一对多关系 ，推荐使用 pointer 类型来表示 。  因为使用方法和上面的一对一关联基本相同，只是查询一对多关联的时候有些区别，故只举添加和查询两个例子：", 
            "title": "一对多关系"
        }, 
        {
            "location": "/data/php/develop_doc/#_37", 
            "text": "将评论和微博进行关联，并同时和当前用户进行关联，表明是当前用户对该帖子进行评论，示例如下：      $comment = new BmobObject( Comment );\n    $res=$comment- addRelPointer(array(array( author , _User , 0290813a89 ),array( post , Post , 81108a33c8 )));", 
            "title": "添加一对多关联"
        }, 
        {
            "location": "/data/php/develop_doc/#_38", 
            "text": "我想 查询出某个帖子（objectId为81108a33c8）的所有评论,同时将该评论的作者的信息也查询出来 ，那么可以使用下面的方法：      $res=$comment- get( ,array('where={ post :{ __type : Pointer , className : Post , objectId : 81108a33c8 }}','include=author'));", 
            "title": "查询一对多关联"
        }, 
        {
            "location": "/data/php/develop_doc/#_39", 
            "text": "一个帖子可以被很多用户所喜欢，一个用户也可能会喜欢很多帖子，那么可以使用 Relation 类型来表示这种 多对多关联关系 。  Relation 本质上可以理解为其存储的是一个对象，而这个对象中存储的是多个指向其它记录的指针。", 
            "title": "多对多关系"
        }, 
        {
            "location": "/data/php/develop_doc/#_40", 
            "text": "$res=$post- updateRelRelation( 83ce274594 ,  likes , array(array( _User , focb9e3d60 )));  添加成功后，在后台的 Post 表中就能查看到 likes 字段已经生成并对应到了 _User   点击红框中的 关联关系 按钮展开后，可查看刚才所添加的喜欢该帖子的用户A：", 
            "title": "添加多对多关联"
        }, 
        {
            "location": "/data/php/develop_doc/#_41", 
            "text": "如果希望 查询喜欢该帖子（objectId为83ce274594）的所有用户 ，那么可以使用下面的方法：  示例代码：      $res = $bmobUser- get(0,array('where={ $relatedTo :{ object :{ __type : Pointer , className : Post , objectId : 83ce274594 }, key : likes }}'));", 
            "title": "查询多对多关联"
        }, 
        {
            "location": "/data/php/develop_doc/#_42", 
            "text": "如果 用户B也喜欢该帖子（objectId为83ce274594） ，此时需要为该帖子(Post)的 likes 字段多添加一个用户,示例如下：  $res=$post- updateRelRelation( 83ce274594 ,  likes , array(array( _User , 83ce274594 )));  修改成功后，你在点击该帖子的 likes 字段下面的 关联关系 按钮展开后，可查看刚才所添加的喜欢该帖子的用户B：", 
            "title": "修改多对多关联"
        }, 
        {
            "location": "/data/php/develop_doc/#_43", 
            "text": "如果 想对该帖子进行取消喜欢的操作 ，此时，需要删除之前的多对多关联，具体代码：  $res=$post- deleteRelation( 81108a33c8 ,  likes , array(array( _User , eb3e34f23b )));", 
            "title": "删除多对多关联"
        }, 
        {
            "location": "/data/php/develop_doc/#include", 
            "text": "在某些情况下，你想在一个查询内获取 Pointer 类型的关联对象。  比如上述示例中，如果希望在查询帖子信息的同时也把该帖子的作者的信息查询出来，可以使用 include 方法  $res=$post- get( ,array('include=author'));  你可以使用 , 号(逗号)操作符来 include并列查询 两个对象  比如，查询评论表的同时将该评论用户的信息和所评论的帖子信息也一并查询出来（因为Comment表有两个 Pointer类型 的字段），那么可以这样做：  $res=$comment- get( ,array('include=author,post'));  你同时还可以使用  . 号（英语句号）操作符来进行 include中的内嵌对象查询  比如，你想在查询评论信息的同时将该评论 Comment 对应的帖子 post 以及该帖子的作者信息 author 一并查询出来，你可以这样做：  $res=$comment- get( ,array('include=post.author'));  注：include的查询对象只能为BmobPointer类型，而不能是BmobRelation类型。", 
            "title": "include用法"
        }, 
        {
            "location": "/data/php/develop_doc/#_44", 
            "text": "为了减少因为网络通讯次数太多而带来的时间浪费, 你可以使用下面的批量(batch)操作，在一个请求中对多个普通对象进行添加(create)、更新(update)、删除(delete) 操作，上限为50个。  在一个批量(batch)请求中每一个操作都有自己对应的方法、路径和主体, 这些参数可以代替你通常使用的HTTP方法. 这些操作会以发送过去的顺序来执行, 比如我们要创建一系列的 GameScore 的对象:      $bmobBatch = new BmobBatch();\n    $data=array(\n        array(\n             method = POST ,\n             path = /1/classes/GameScore ,\n             body = array(\n                         score = 1337,\n                         playerName = Sean Plott ,\n                    ),\n        ),\n        array(\n             method = POST ,\n             path = /1/classes/GameScore ,\n             body = array(\n                         score = 1338,\n                         playerName = ZeroCool ,\n                    ),\n        ),\n    );\n    $res=$bmobBatch- batch($data);  批量操作的响应会是一个列表, 列表的返回值个数与给定的requests请求个数是相等的。列表中每个返回项都有一个字段是  \"success\"  或者  \"error\" ，  \"success\"  的值通常和你进行其他REST操作成功时返回的值是一样的:  Array\n(\n    [0] =  stdClass Object\n        (\n            [success] =  stdClass Object\n                (\n                    [createdAt] =  2015-10-30 10:51:52\n                    [objectId] =  495ac937b8\n                )\n\n        )\n\n    [1] =  stdClass Object\n        (\n            [success] =  stdClass Object\n                (\n                    [createdAt] =  2015-10-30 10:51:52\n                    [objectId] =  e8597579be\n                )\n\n        )\n\n)  \"error\"  的值是有返回码和错误信息字符串的一个对象:  [error] =  stdClass Object\n    (\n        [code] =  101\n        [error] =   object not found for delete \n    )  在 batch 操作中更新(update)和删除(delete)同样是有效的，如果相应记录有ACL规则，则必须传入该用户的Token才能进行更新或删除:      $bmobBatch = new BmobBatch();\n    $data=array(\n        array(\n             method = PUT ,\n             token = pnktnjyb996sj4p156gjtp4im ,\n             path = /1/users/51e3a334e4b0b3eb44adbe1a ,\n             body = array(\n                         score = 1337,\n                    ),\n        ),\n        array(\n             method = DELETE ,\n             token = pnktnjyb996sj4p156gjtp4im ,\n             path = /1/users/51a8a4d9e4b0d034f6159a35 ,\n        ),\n    );\n    $res=$bmobBatch- batch($data);", 
            "title": "批量数据操作"
        }, 
        {
            "location": "/data/php/develop_doc/#_45", 
            "text": "很多应用可能会有需要计数器的功能，比如某条信息被点赞多少次等。Bmob提供了非常便捷的方式来保证原子性的修改某一数值字段的值。  $bmobObj = new BmobObject( GameScore );\n$res=$bmobObj- increment( bd89c6bce9 , score ,array(2)); //id为bd89c6bce9的field score数值加2  同理可以让score像下面一样减少一个固定的值：  $res=$bmobObj- increment( bd89c6bce9 , score ,array(-2)); //id为bd89c6bce9的field score数值减2", 
            "title": "原子计数器"
        }, 
        {
            "location": "/data/php/develop_doc/#_46", 
            "text": "Bmob的文件上传有整个文件上传和分片上传两种方式，可以分别实现小文件上传和大文件的上传。", 
            "title": "文件"
        }, 
        {
            "location": "/data/php/develop_doc/#_47", 
            "text": "上传整个文件到bmob，发送一个POST请求到file路径，参数是：文件名，。\n上传一个 hello.txt 文件实现方法如下：  $bmobFile = new BmobFile();\n//第一个参数是文件的名称,第二个参数是文件的url(可以是本地路径,最终是通过file_get_contents获取文件内容)\n$res=$bmobFile- uploadFile( heelo.txt , http://file.bmob.cn/M02/17/99/oYYBAFYfXS6AKB96AAAABNsGNwg872.txt );  返回的主体是一个JSON对象，包含：文件名（filename）、分组（group）、文件地址（url）。 http://file.bmob.cn/ + url 就是文件上传成功后的完整地址，返回的Http Headers中的Location会包含该完整地址:  [filename] =  heelo.txt [group] =  group1 [url] =  M02/57/6A/oYYBAFYy3amAQI7cAAAAAjP0FTs923.txt  然后你需要把上传后的文件对象上传:  $fileArray = array( __type = File ,  group = $res- group, filename = $res- filename, url = $res- url);\n$res=$bmobObj- create(array( score = 11, file = $fileArray));", 
            "title": "整个文件上传"
        }, 
        {
            "location": "/data/php/develop_doc/#_48", 
            "text": "删除文件，必须要知道文件的url，如下：  $res=$bmobFile- delete( M02/54/09/oYYBAFYxx4uAbgTcAAAbpS8UHE45961.js );  其中M02/54/09/oYYBAFYxx4uAbgTcAAAbpS8UHE45961.js是文件的url。  返回结果格式如下：  { $msg =   ok  }   删除文件不会删除文件关联的行记录中的文件列的值，需要自行通过更新行来删除关联。", 
            "title": "删除文件"
        }, 
        {
            "location": "/data/php/develop_doc/#_49", 
            "text": "很多跨平台和跨系统的应用都有一个统一的登录流程， Bmob 通过REST API访问用户的账户让你实现该功能。  通常来说，用户这个类的功能与其他的对象是相同的，比如都没有限制模式(Schema Less)，User对象和其他对象不同的是一个用户必须有用户名(username)和密码(password)，密码会被自动地加密和存储。 Bmob 强制你username和email这两个Key的值必须是不重复的。", 
            "title": "用户"
        }, 
        {
            "location": "/data/php/develop_doc/#_50", 
            "text": "Bmob 默认会有几个特定的属性：\nusername: 用户的用户名 （必需） 。\npassword: 用户的密码 （必需） 。\nemail: 用户的电子邮件地址 （可选） 。", 
            "title": "属性"
        }, 
        {
            "location": "/data/php/develop_doc/#_51", 
            "text": "注册一个新用户与创建一个新的普通对象之间的不同点在于其username和password字段都是必要的，password字段会以与其他的字段不一样的方式处理，它在保存时会被加密而且永远不会被返回给任何来自客户端的请求。  在你的应用设置页面中，你可以向 Bmob 来请求认证邮件地址，这项设置启用了的话，所有用户在注册时填写email这个Key的值，并且邮箱有效的情况下，就会向这个邮箱地址发出一封邮件，邮件中会包含一个来自 Bmob 的邮箱验证的链接，当你的用户查收邮件并点击这个链接后，这个用户emailVerified的Key的值会置为True，你可以在emailVerified字段上查看用户的email是否已经通过验证了。  为了注册一个新的用户，需要向user路径发送一个POST请求，你可以加入一个甚至多个新的字段，例如，创建一个有家庭电话字段的新用户:  $bmobUser = new BmobUser();\n$res = $bmobUser- register(array( username = cooldude117 ,  password = p_n7!-e8 ,  phone = 415-392-0202 ,  email = bmobtest111@126.com ));   当创建成功时,HTTP响应头的状态码返回为201 Created，Http响应头的Location值包含了该新用户的URL:  Status: 201 Created\nLocation: https://api.bmob.cn/1/users/Kc3M222J  返回的主体是包含objectId，表示唯一的用户, createdAt时间戳表示用户注册时间, sessionToken可以被用来认证更新或删除这名用户信息的请求。  [createdAt] =  2011-11-07 20:58:34, [objectId] =  Kc3M222J, [sessionToken] =  pnktnjyb996sj4p156gjtp4im,   这里需要注意一点的是，有些时候你可能需要在用户注册时发送一封验证邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在应用设置- 邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在注册时自动发动一封验证邮件给用户。  \n设置邮箱验证功能", 
            "title": "注册用户"
        }, 
        {
            "location": "/data/php/develop_doc/#_52", 
            "text": "Bmob  支持让用户直接输入手机号码进行注册，如果手机号码存在则自动登陆：   $res = $bmobUser- register(array( mobilePhoneNumber = 131xxxxxxxx ,  smsCode = 502845 ));  其中  mobilePhoneNumber  就是手机号码，而  smsCode  是使用  请求短信验证码方法 发送到用户手机上的 6位验证码字符串。如果是新用户且不传入 username，默认用户名将是手机号码。  注册或者登陆成功后，返回的应答跟登陆接口类似：     username  = 185xxxxxxxx ,\n   mobilePhoneNumber  =   185xxxxxxxx ,\n   mobilePhoneVerified  =  true,\n   createdAt  =   2011-11-07 20:58:34 ,\n   updatedAt  =   2011-11-07 20:58:34 ,\n   objectId  =   Kc3M222J ,\n   sessionToken  =   pnktnjyb996sj4p156gjtp4im \n  ……其他属性  如果是第一次注册，将默认设置_User表的  mobilePhoneVerified  属性为 true。", 
            "title": "使用手机号码一键注册或登陆"
        }, 
        {
            "location": "/data/php/develop_doc/#_53", 
            "text": "你的用户注册之后，你需要让他们用自己的用户名和密码登录，为了做到这一点，发送一个HTTP GET请求到  /1/login  ，加上username和password作为URL编码后的参数：  $res = $bmobUser- login( test111@qq.com , 111111 );  username 支持传入_User表的username或email或mobilePhoneNumber字段的值，作为登录的扩展功能，以实现邮箱和密码、手机号和密码登录功能。  除了有用户名或邮箱或手机号码和密码登录的功能， Bmob  还支持使用手机号码和验证码一键快速登录的功能，而  smsCode  是使用 请求短信验证码方法 发送到用户手机上的 6位验证码字符串：  $res = $bmobUser- loginByMobile( 131xxxxxxxx , 745399 );  返回的主体是一个JSON对象，包括所有除了password以外的自定义字段，它同样包含了createdAt,updateAt,objectId和sessionToken字段：       username = cooldude6 ,\n     phone = 415-392-0202 ,\n     createdAt =   2011-11-07 20:58:34 ,\n     updatedAt = 2011-11-07 20:58:34 ,\n     objectId = Kc3M222J ,\n     sessionToken = pnktnjyb996sj4p156gjtp4im", 
            "title": "登录用户"
        }, 
        {
            "location": "/data/php/develop_doc/#_54", 
            "text": "当注册一个用户后，你可以通过发送一个HTTP GET请求到用户注册成功时返回的HTTP请求头中的Location的URL获取用户的信息。比如，为了获取上面注册成功的用户：  $res = $bmobUser- get( 415b8fe99a ); // 获取id为415b8fe99a用户的信息  返回的对象包含所有用户提供的字段,除了密码以外.也包括了createdAt,updatedAt和objectId字段.  \n     username = cooldude6 ,\n     phone =   415-392-0202 ,\n     createdAt =   2011-11-07 20:58:34 ,\n     updatedAt =   2011-11-07 20:58:34 ,\n     objectId =   415b8fe99a", 
            "title": "获取当前用户"
        }, 
        {
            "location": "/data/php/develop_doc/#_55", 
            "text": "在通常的情况下，我们都不希望用户去修改自己的数据，但可以通过认证让用户去做这件事，修改的用户的数据必须要传入sessionToken，这个sessionToken在注册和登录时都会返回。  为了改动一个用户已经有的数据，需要对这个用户的URL发送一个HTTP PUT请求，任何你没有指定的key会保持不变，所以你可以只改动用户信息中的一部分，username和password可以更改，但是新的username不能重复。  比如，如果我们想对 cooldude6 的电话做出一些改动：  $res = $bmobUser- update( 415b8fe99a ,  050391db407114d9801c8f2788c6b25a , array( phone = 02011111 ));   上面的050391db407114d9801c8f2788c6b25a是sessionToken  返回只有一个updatedAt字段表明更新发生的时间.  {\n     updatedAt = 2011-11-07 21:25:10 \n}  在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发动一封验证邮件给用户。", 
            "title": "更新用户"
        }, 
        {
            "location": "/data/php/develop_doc/#_56", 
            "text": "为了在 Bmob 上删除一个用户，可以向用户的URL上发送一个DELETE请求，前提是你必须填入sessiontoken以便认证授权，例子：  $res = $bmobUser- delete( 415b8fe99a ,  050391db407114d9801c8f2788c6b25a ); // 删除id为415b8fe99a的用户, 第一参数是用户id, 第二个参数为sessiontoken,在用户登录或注册后获取, 必填", 
            "title": "删除用户"
        }, 
        {
            "location": "/data/php/develop_doc/#_57", 
            "text": "你可以一次获取多个用户，只要向用户的根URL发送一个GET请求，没有任何URL参数的话，可以简单地列出所有用户：   $res = $bmobUser- get(); // 获取所有用户的信息  返回的值是一个JSON对象包括一个results字段, 值是包含了所有对象的一个JSON数组.      [results] =  Array\n        (\n            [0] =  stdClass Object\n                (\n                    [age] =  11\n                    [createdAt] =  2015-10-19 15:45:17\n                    [email] =  test111@qq.com\n                    [emailVerified] =  \n                    [objectId] =  WXHsFFFd\n                    [updatedAt] =  2015-10-27 18:03:42\n                    [username] =  b\n                )\n\n            [1] =  stdClass Object\n                (\n                    [createdAt] =  2015-10-22 10:24:49\n                    [mobilePhoneNumber] =  13168399536\n                    [mobilePhoneNumberVerified] =  1\n                    [objectId] =  0290813a89\n                    [updatedAt] =  2015-10-26 17:47:00\n                    [username] =  a\n                )\n\n            [2] =  stdClass Object\n                (\n                    [createdAt] =  2015-10-30 14:44:18\n                    [email] =  bmobtest111@126.com\n                    [emailVerified] =  \n                    [objectId] =  eb3e34f23b\n                    [phone] =  415-392-0202\n                    [updatedAt] =  2015-10-30 14:44:18\n                    [username] =  cooldude117\n                )\n\n        )  浏览器中查看用户表  User表是一个特殊的表，专门存储BmobUser对象。在浏览器端，你会看到一个User表旁边有一个小人的图标。", 
            "title": "查询用户"
        }, 
        {
            "location": "/data/php/develop_doc/#_58", 
            "text": "你可以使用这项功能，前提是用户将email与他们的账户关联起来.   $res = $bmobUser- requestPasswordReset( bmobxxx@126.com );  如果成功的话,返回的值是一个JSON对象。\n密码重置流程如下：   用户输入他们的电子邮件，请求重置自己的密码。  Bmob向他们的邮箱发送一封包含特殊的密码重置连接的电子邮件，此邮件的模板可在Bmob后台中修改。  用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，输入一个新的密码。  用户的密码已被重置为新输入的密码。", 
            "title": "密码重置"
        }, 
        {
            "location": "/data/php/develop_doc/#_59", 
            "text": "如果用户有绑定了手机号码，就可以通过手机验证码短信来实现使用手机号码找回密码的功能，先调用发送验证码 $bmobSms- sendSms 会将验证码发送到用户手机上，用户收到验证码并输入后，调用resetPasswordBySmsCode 来为用户设置新的密码：  $res = $bmobUser- resetPasswordBySmsCode( 111111 ,  134554 ); // 使用短信验证码进行密码重置  如果成功的话,返回如下:  msg :  ok   这时，用户就可以用新密码登陆了。", 
            "title": "使用短信验证码进行密码重置"
        }, 
        {
            "location": "/data/php/develop_doc/#_60", 
            "text": "很多开发者希望让用户输入一次旧密码做一次校验，旧密码正确才可以修改为新密码，因此我们提供了一个单独的方法updateUserPassword来安全地修改用户密码：  $res = $bmobUser- updateUserPassword( WXHsFFFd ,  d365d5834061d9f6805047131893ae13  ,  123456 ,  111111 ); //用户输入一次旧密码做一次校验，旧密码正确才可以修改为新密码  WXHsFFFd：为当前登录用户的objectId。\nd365d5834061d9f6805047131893ae13：sessionToken  注意：仍然需要传入 sessionToken，也就是登录用户才可以修改自己的密码。", 
            "title": "提供旧密码方式安全修改用户密码"
        }, 
        {
            "location": "/data/php/develop_doc/#_61", 
            "text": "设置邮件验证是一个可选的应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会默认被设为false，如果应用设置中开启了邮箱认证功能， Bmob 会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.  emailVerified 字段有 3 种状态可以考虑：  true  : 用户可以点击邮件中的链接通过 Bmob 来验证地址，一个用户永远不会在新创建这个值的时候出现emailVerified为true。  false  : 用户(User)对象最后一次被刷新的时候, 用户并没有确认过他的邮箱地址, 如果你看到emailVerified为false的话，你可以考虑刷新 用户(User)对象。  missing  : 用户(User)对象已经被创建，但应用设置并没有开启邮件验证功能； 或者用户(User)对象没有email邮箱。", 
            "title": "邮箱验证"
        }, 
        {
            "location": "/data/php/develop_doc/#email", 
            "text": "发送到用户邮箱验证的邮件会在一周内失效，可以通过调用  requestEmailVerifyy  来强制重新发送：  $res = $bmobUser- requestEmailVerify( h622222225@126.com ); //请求验证Email", 
            "title": "请求验证Email"
        }, 
        {
            "location": "/data/php/develop_doc/#_62", 
            "text": "Bmob允许你连接你的用户到第三方账户服务系统，比如新浪微博和QQ，这样就允许您的用户用已经存在的第三方账户直接登录您的App。通过注册或者更新的用户信息的功能，使用  authData  字段来保存第三方服务的授权信息就可以做到。一旦用户关联了某个第三方账户， authData  将被存储到您的Bmob的用户信息里，并通过登录即可重新获取到。  authData  是一个普通的 JSON 对象，它所要求的key根据第三方账户服务不同而不同，具体要求见下面。每种情况下，你都需要自己负责完成整个授权过程 (一般是通过 OAuth 协议，1.0 或者 2.0) 通过连接的API来获取授权信息。  新浪微博的  authData  内容:  array(\n     authData = \n        array( weibo = array(\n             uid = 123456789 ,\n             access_token = 2.00ed6eMCV9DWcBcb79e8108f8m1HdE ,\n             expires_in = 1564469423540,\n    ))\n)  腾讯QQ的  authData  内容:  array(\n     authData = \n        array( weibo = array(\n             openid = 2345CA18A5CD6255E5BA185E7BECD222 ,\n             access_token = 12345678-SM3m2avZxh5cjJmIrAfx4ZYyamdofM7IjU ,\n             expires_in = 1382686496,\n    ))\n)  匿名用户 (Anonymous user) 的 authData 内容:  array(\n     authData = array( id = random UUID with lowercase hexadecimal digits )    \n)", 
            "title": "用户账户连接"
        }, 
        {
            "location": "/data/php/develop_doc/#_63", 
            "text": "使用一个第三方账户连接服务来注册用户并登录，同样使用POST请求/1/users，只是需要提供authData字段。例如，使用新浪微博账户注册或者登录用户:  $data = array(\n     authData = \n        array( weibo = array(\n             uid = 123456789 ,\n             access_token = 2.00ed6eMCV9DWcBcb79e8108f8m1HdE ,\n             expires_in = 1564469423540,\n    ))\n);\n$res = $bmobUser- register($data);  Bmob 会校验提供的 authData 是否有效，并检查是否已经有一个用户连接了这个 authData 服务。如果已经有用户存在并连接了同一个 authData，那么Http响应头将返回 200 OK 和详细信息 (包括用户的 sessionToken):  Status: 200 OK\nLocation: https://api.bmob.cn/1/users/Kc3M222J  返回的内容类似  \n   username = Bmob ,\n   createdAt = 2011-11-07 21:25:10 ,\n   updatedAt = 2011-11-07 21:25:10 ,\n   objectId = Kc3M222J ,\n   sessionToken = pnktnjyb996sj4p156gjtp4im ,\n   authData = array(\n     weibo = array(\n       uid =   123456789 ,\n       access_token =   2.00ed6eMCV9DWcBcb79e8108f8m1HdE ,\n       expires_in =  1564469423540\n    )\n  )", 
            "title": "注册和登录"
        }, 
        {
            "location": "/data/php/develop_doc/#_64", 
            "text": "连接一个现有的用户到新浪微博或者腾讯QQ帐号，可以通过发送一个 PUT 请求附带 authData 字段到以上Location返回的用户URL做到。例如，连接一个用户到腾讯QQ帐号发起的请求类似这样:  \n$data = array(\n     authData = \n        array( weibo = array(\n             openid = 2345CA18A5CD6255E5BA185E7BECD222 ,\n             access_token = 12345678-SM3m2avZxh5cjJmIrAfx4ZYyamdofM7IjU ,\n             expires_in = 1382686496,\n    ))\n);\n $res = $bmobUser- update( 415b8fe99a ,  050391db407114d9801c8f2788c6b25a , $data));  完成连接后，你可以使用匹配的 authData 来认证他们。", 
            "title": "连接"
        }, 
        {
            "location": "/data/php/develop_doc/#_65", 
            "text": "断开一个现有用户到某个服务，可以发送一个 PUT 请求设置 authData 中对应的服务为 null 来做到。例如，取消新浪微博关联:  $data = array(\n     authData = \n        array( weibo = null\n    ))\n);\n$res = $bmobUser- update( 415b8fe99a ,  050391db407114d9801c8f2788c6b25a , $data));", 
            "title": "断开连接"
        }, 
        {
            "location": "/data/php/develop_doc/#acl", 
            "text": "数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看 Bmob数据与安全页面 ，了解Bmob如何保护数据安全）。  其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。  大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：   对于私有数据，读写权限可以只局限于数据的所有者。  对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。  对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。  属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。  一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。", 
            "title": "ACL和角色"
        }, 
        {
            "location": "/data/php/develop_doc/#acl_1", 
            "text": "在Bmob中，ACL是用array来表示的。这个array的key是objectId（用户表某个用户对应的objectId）或者是 *(表示公共的访问权限)，ACL 的值是 \"读和写的权限\", 这个array的key总是权限名, 而这些key的值总是 true。  如果您想让一个 id 为 \"Kc3M222k\" 的用户有读和写一条数据的权限, 而且这个数据应该可以被全部人读取的话，这个ACL的表达方式如下：  array(\n     Kc3M222k = array(\n         read = true, write = true\n        )，\n     * = array(\n         read = true\n        )，  \n)", 
            "title": "ACL的格式"
        }, 
        {
            "location": "/data/php/develop_doc/#_66", 
            "text": "在很多情况下，你需要定义一些用户具有某种相同的数据操作权限，而另外一群用户具有另外一种相同的数据操作权限，这时你就可以使用到Bmob的角色（对应Bmob在Web提供的Role表、SDK中的BmobRole类）功能，设置不同的用户组不同的操作权限。角色表有三个特殊字段：  name  : 必须字段，表示角色名称,而且只允许被设置一次（命名必须由字母, 空格, 减号或者下划线构成）；  users  :一个指向一系列用户的关系, 这些用户会继承角色的权限；  roles  : 一个指向一系列子角色的关系, 这些子关系会继承父角色所有的权限。", 
            "title": "角色和相关操作"
        }, 
        {
            "location": "/data/php/develop_doc/#_67", 
            "text": "创建一个新角色的方法如下（固定POST数据到https://api.bmob.cn/1/roles中，且必须提供  name  字段）：      $bmobRole = new BmobRole();\n    $res = $bmobRole- createRole(array( name = Mo1derators ,  ACL = array( * = array( read = true, write = true)))); //创建角色  如果你要创建一个包括了“用户和子角色”的角色，实现方式如下：  $data = array(\n     name = Mo1derators ,\n      ACL = array(\n         * = array( read = true, write = true)\n      )，\n      roles = array(\n          __op = AddRelation ,\n         objects =  array(\n               __type = Pointer ,\n               className = _Role ,\n               objectId = Fe441wZ5 \n            )\n      ），\n)\n$res = $bmobRole- createRole($data);  当创建成功后返回HTTP如下：  Status: 201 Created\nLocation: https://api.bmob.cn/1/roles/51e3812D", 
            "title": "创建角色"
        }, 
        {
            "location": "/data/php/develop_doc/#_68", 
            "text": "获取角色对象的方法如下：  $res = $bmobRole- getRole( fff849f7d4 ); //获取角色  响应结果如下：      [ACL] =  stdClass Object\n        (\n            [*] =  stdClass Object\n                (\n                    [read] =  1\n                    [write] =  1\n                )\n\n        )\n\n    [createdAt] =  2015-10-23 10:19:06\n    [name] =  Mo1derators\n    [objectId] =  dcf9ad7d2e\n    [updatedAt] =  2015-10-23 10:19:06", 
            "title": "获取角色"
        }, 
        {
            "location": "/data/php/develop_doc/#_69", 
            "text": "更新角色时，一个很重要的一点是：  name  字段不可以更改。添加和删除  users  和  roles  可以通过使用 AddRelation 和 RemoveRelation 操作符进行。  如给 \"Moderators\" 角色增加 1 个用户，实现如下:      $data=array(\n            array(\n               __type = Pointer ,\n                  className = _User ,\n                  objectId = WXHsFFFd ,\n            ),\n        );\n    $res = $bmobRole- updateRole( d4642acf90 ,  users ,  AddRelation , $data);   删除 \"Moderrators\" 的一个子角色的实现如下：      $data=array(\n            array(\n               __type = Pointer ,\n                  className = _User ,\n                  objectId = WXHsFFFd ,\n            ),\n        );\n    $res = $bmobRole- updateRole( d4642acf90 ,  users ,  RemoveRelation , $data);", 
            "title": "更新角色"
        }, 
        {
            "location": "/data/php/develop_doc/#_70", 
            "text": "设置一条数据的角色权限，需要在ACL中把Key的名字设置为 “ role:  + 角色名称” 。如限制一条数据可以被在 \"Members\" 里的任何人读到, 而且可以被它的创建者（objectId为 f1766d0b42 ）和任何有 \"Moderators\" 角色的人所修改, 实现方式如下:  \n   f1766d0b42 = array(\n     write = true\n  ),\n   role:Members = array(\n     read = true\n  },\n   role:Moderators = array(\n     write = true\n  }  如果这个用户和 \"Moderators\" 本身就是 \"Members\" 的子角色和用户，那么，您不必为创建的用户和 \"Moderators\" 指定读的权限，因为它们都会继承授予 \"Members\" 的权限。", 
            "title": "角色的使用"
        }, 
        {
            "location": "/data/php/develop_doc/#_71", 
            "text": "一个角色可以包含另一个，可以为 2 个角色建立一个父-子关系。 这个关系的结果就是任何被授予父角色的权限隐含地被授予子角色。  这样的关系类型通常在用户管理的内容类的应用上比较常见, 比如在论坛中，有一些少数的用户是 \"管理员（Administartors）\", 有最高的权限，可以调整系统设置、 创建新的论坛等等。 另一类用户是 \"版主（Moderators）\"，他们可以对用户发帖的内容进行管理。可见，任何有管理员权限的人都应该有版主的权限。为建立起这种关系, 您应该把 \"Administartors\" 的角色设置为 \"Moderators\" 的子角色, 具体来说就是把 \"Administrators\" 这个角色加入 \"Moderators\" 对象的 roles 关系之中，实现如下：  \n    $data=array(\n            array(\n               __type = Pointer ,\n                  className = _Role ,\n                  objectId = AdministratorsRoleObjectId ,\n            ),\n        );\n    $res = $bmobRole- updateRole( ModeratorsRoleObjectId ,  roles ,  AddRelation , $data);", 
            "title": "角色的继承"
        }, 
        {
            "location": "/data/php/develop_doc/#_72", 
            "text": "Bmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询。你可以在查询中添加一个GeoPoint的对象查询。你可以实现轻松查找出离当前用户最接近的信息或地点的功能。", 
            "title": "地理位置"
        }, 
        {
            "location": "/data/php/develop_doc/#_73", 
            "text": "$data = array( location = array(\n                                __type =   GeoPoint ,\n                                latitude =  50.934755,\n                                longitude =  24.52065,                  \n                        )\n             );\n\n$res=$bmobObj- update( e1kXT22L , $data);", 
            "title": "创建地理位置对象"
        }, 
        {
            "location": "/data/php/develop_doc/#_74", 
            "text": "现在你有一系列的对象对应的地理坐标，如果能发现哪些对象离指定的点近就好了，这可以通过GeoPoint数据类型加上在查询中使用$nearSphere做到。获取离用户最近的10个地点应该看起来像下面这个样子:  $res=$bmobObj- get( ,array('where={\n     location : {\n         $nearSphere : {\n             __type :  GeoPoint ,\n             latitude : 30.0,\n             longitude : -20.0\n        }\n      }\n    }','limit=200'));  这操作会按离纬度30.0，经度-20.0的距离排序返回一系列的结果，第一个就是最近的对象。(注意如果一个特定的order参数是给定了的话，它会覆盖按距离排序的结果)，例如，查询操作返回的结果：          array(\n         location = array(\n              __type =   GeoPoint ,\n             latitude =  40.0,\n             longitude =  -30.0\n        ),\n         updatedAt =   2011-12-06 22:36:04 ,\n         createdAt =   2011-12-06 22:36:04 ,\n         objectId =   e1kXT22L \n        )  为了限定搜索的最大距离范围，需要加入$maxDistanceInMiles(英里)和$maxDistanceInKilometers(公里d)或者$maxDistanceInRadians(弧度)参数来限定，如果不加，则默认是100KM的半径。比如要找的半径在10公里内的话:  $res=$bmobObj- get( ,array('where={\n         location : {\n             $nearSphere : {\n                 __type :  GeoPoint ,\n                 latitude : 30.0,\n                 longitude : -20.0\n            },\n         $maxDistanceInKilometers : 10.0\n        }\n    }','limit=200'));  同样作查询寻找在一个特定的范围里面的对象也是可以的，为了找到在一个矩形区域里的对象，按下面的格式加入一个约束 {\"$within\": {\"$box\": [southwestGeoPoint, northeastGeoPoint]}}：  $res=$bmobObj- get( ,array('where={\n         location : {\n             $within : {\n                 $box : [\n                    {\n                         __type :  GeoPoint ,\n                         latitude : 37.71,\n                         longitude : -122.53\n                    },\n                    {\n                         __type :  GeoPoint ,\n                         latitude : 30.82,\n                         longitude : -122.37\n                    }\n                ]\n            }\n        }\n    }','limit=200'));  注意事项  关于地理位置的有一些问题是值得留意的:   每一个表 只能 一个地理位置列，每一个对象 只能 有一个索引指向一个GeoPoint对象  GeoPoint的点不能超过规定的范围。 纬度的范围 应该是在 -90.0到90.0 之间。 经度的范围 应该是在 -180.0到180.0 之间。如果您添加的经纬度超出了以上范围，将导致程序错误。  删除文件不会删除文件关联的行记录中的文件列的值，需要自行通过更新行来删除关联。  如果不加任何距离范围限制，则默认是100公里的半径范围。", 
            "title": "查询地理位置信息"
        }, 
        {
            "location": "/data/php/develop_doc/#_75", 
            "text": "Bmob的统计查询，提供以下关键字或其组合的查询操作：     Key  Operation      groupby  分组操作    groupcount  返回每个分组的总记录    sum  计算总和    average  计算平均值    max  计算最大值    min  计算最小值    having  分组中的过滤条件     为避免和用户创建的列名称冲突，Bmob约定以上统计关键字（sum, max, min)的查询结果值都用 '_(关键字)+首字母大写的列名' 的格式，如计算玩家得分列名称为score总和的操作，则返回的结果集会有一个列名为_sumScore。average返回的列为 '_avg+首字母大写的列名'，有groupcount的情形下则返回_count。  以上关键字除了groupcount是传Boolean值true或false，having传的是和where类似的json字符串，但having只应该用于过滤分组查询得到的结果集，即having只应该包含结果集中的列名如{\"_sumScore\":{\"$gt\":100}}，其他关键字必须是字符串而必须是表中包含的列名，多个列名用,分隔。  以上关键字可以自由组合并可以与前面查询语句中的where, order, limit, skip等组合使用。  比如，GameScore表是游戏玩家的信息和得分表，有playerName(玩家名称)、score(玩家得分)等你自己创建的列，还有Bmob的默认列objectId, createdAt, updatedAt,那么我们现在举例如何使用以上的查询关键字来作这个表的统计。", 
            "title": "统计相关的查询"
        }, 
        {
            "location": "/data/php/develop_doc/#_76", 
            "text": "我们要计算GameScore表所有玩家的得分总和，sum后面只能拼接Number类型的列名，即要计算哪个列的值的总和，只对Number类型有效，多个Number列用,分隔，则查询如下：   $res=$bmobObj- get( ,array('sum=score'));  返回内容如下：     [_sumScore] =  11371", 
            "title": "计算总和"
        }, 
        {
            "location": "/data/php/develop_doc/#_77", 
            "text": "比如我们以创建时间按天统计所有玩家的得分，并按时间降序, groupby后面只能拼接列名，如果该列是时间类型，则按天分组，其他类型，则按确定值分组:  $res=$bmobObj- get( ,array('sum=score','groupby=createdAt'));  返回内容如下：              [0] =  Array\n                (\n                    [_sumScore] =  20\n                    [createdAt] =  2015-10-29\n                )\n\n            [1] =  Array\n                (\n                    [_sumScore] =  0\n                    [createdAt] =  2014-05-19\n                )", 
            "title": "分组计算总和"
        }, 
        {
            "location": "/data/php/develop_doc/#_78", 
            "text": "比如我们以创建时间按天和按玩家名称分组统计所有玩家的得分1，得分2的总和，并按得分1的总和降序, groupby后面只能拼接列名，如果该列是时间类型，则按天分组，其他类型，则按确定值分组:  $res=$bmobObj- get( ,array('sum=score1,score2','groupby=createdAt,playerName','order=-_sumscore1'));  返回内容如下：              [0] =  Array\n                (\n                    [_sumScore1] =  399,\n                    [_sumScore2] =  120,    \n                    [playerName] =   John ,\n                    [createdAt] =  2015-10-29\n                )\n\n            [1] =  Array\n                (\n                    [_sumScore1] =  299,\n                    [_sumScore2] =  250,    \n                    [playerName] =   Bily ,\n                    [createdAt] =  2015-10-29\n                )", 
            "title": "多个分组并计算多个列的总和"
        }, 
        {
            "location": "/data/php/develop_doc/#_79", 
            "text": "比如我们以创建时间按天统计所有玩家的得分，并只返回某天的总得分大于2000的记录，并按时间降序，having是用于过滤部分结果，其中的_sumScore是 '_sum+首字母大写的列名' 的格式表示是计算这个列的总和的值:  \n$res=$bmobObj- get( ,array('sum=score','having={ _sumScore :{ $gt : 2000}}','order=-createdAt','groupby=createdAt'));  返回内容如下：              [0] =  Array\n                (\n                    [_sumScore] =  2398\n                    [createdAt] =  2015-10-29\n                )", 
            "title": "分组计算总和并只返回满足条件的部分值"
        }, 
        {
            "location": "/data/php/develop_doc/#_80", 
            "text": "比如我们以创建时间按天统计所有玩家的得分和每一天有多少条玩家的得分记录，并按时间降序:  \n$res=$bmobObj- get( ,array('sum=score','groupby=createdAt','groupcount=true','order=-createdAt'));  返回内容如下：              [0] =  Array\n                (\n                    [_sumScore] =  2398,\n                    [_count] =  10, \n                    [createdAt] =  2015-10-29\n                )\n\n            [1] =  Array\n                (\n                    [_sumScore] =  100,\n                    [_count] =  2,  \n                    [createdAt] =  2015-10-29\n                )", 
            "title": "分组计算总和并返回每个分组的记录数"
        }, 
        {
            "location": "/data/php/develop_doc/#_81", 
            "text": "比如我们获取表中所有的唯一的score:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'groupby=score' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n$res=$bmobObj- get( ,array('groupby=score'));  返回内容如下：              [0] =  Array\n                (\n                    [score] =  78\n\n                )\n\n            [1] =  Array\n                (\n                    [score] =  79\n\n                )", 
            "title": "获取不重复的列值"
        }, 
        {
            "location": "/data/php/develop_doc/#_82", 
            "text": "average(计算平均值)， max(计算最大值)，min(计算最小值)和sum查询语句是类似的，只用把上面的例子中的sum替换为相应的average, max, min就可以了。", 
            "title": "其他关键字"
        }, 
        {
            "location": "/data/php/develop_doc/#app", 
            "text": "通过appapi，你可以查看，创建或编辑你的app，在用户管理后台也实现了这样的功能。通过验证你的bmob email账号和密码，你可以获取所有的app信息，创建一个新的app或者修改旧的app的信息。", 
            "title": "app服务"
        }, 
        {
            "location": "/data/php/develop_doc/#app_1", 
            "text": "获取所有的app信息      $bmobApp = new BmobApp();\n    $res = $bmobApp- getApp( 611115@126.com ,  111111 ); //获取全部app的信息  获取某个特定的app信息  $res = $bmobApp- getApp( 611115@126.com ,  111111 ,  85b5xxxxxxxx9e59a795da547c68e6 ); //获取app id 为 85b56934cce1129e59a795da547c68e6 的信息", 
            "title": "获取app信息"
        }, 
        {
            "location": "/data/php/develop_doc/#app_2", 
            "text": "通过使用post 方法，可以在你的账号上创建一个app，创建app时支持如下的参数：     参数名  参数用途  取值范围  是否必须要填      appName  app的名称  少于30个字符  是    status  app是否可用  0：表示禁用，1：表示可用  否    notAllowedCreateTable  是否允许通过api创建表  0：表示允许创建表，1：表示不允许创建表  否     下面是一个创建app的例子  $res = $bmobApp- createApp( 611115@126.com ,  111111 , array( appName = myapp111 )); //创建一个名为 myapp111 的app", 
            "title": "创建新的app"
        }, 
        {
            "location": "/data/php/develop_doc/#app_3", 
            "text": "通过使用PUT 方法，可以修改app的信息，修改app信息时支持如下的参数：     参数名  参数用途  取值范围  是否必须要填      appName  app的名称  少于30个字符  否    status  app是否可用  0：表示禁用，1：表示可用  否    notAllowedCreateTable  是否允许通过api创建表  0：表示允许创建表，1：表示不允许创建表  否     下面是修改app信息的例子  $res = $bmobApp- updateApp( 611115@126.com ,  111111 ,  330xxxxxxxxx578d1f923126547bea5 , array( appName = myapp11122 ));", 
            "title": "修改app信息"
        }, 
        {
            "location": "/data/php/develop_doc/#_83", 
            "text": "通过数据表的php sdk，你可以查看，创建或编辑你的表结构，在用户管理后台的数据浏览页面也实现了这样的功能。  注意，调用数据表相关的php sdk，必须指定Master Key。", 
            "title": "数据表"
        }, 
        {
            "location": "/data/php/develop_doc/#app_4", 
            "text": "$bmobSchemas = new BmobSchemas();\n$res = $bmobSchemas- getSchemas( e09fb5cbb5bxxxxxxxx9504604c0dcff );   获取某个特定表的信息  $res = $bmobSchemas- getSchemas( e09fb5cbb5b825c78989504604c0dcff ,  Game );", 
            "title": "获取app表的信息"
        }, 
        {
            "location": "/data/php/develop_doc/#_84", 
            "text": "String\nNumber\nBool\nDate\nFile\nGeo\nArray\nObject\nPointer\nRelation", 
            "title": "创建字段支持的数据类型"
        }, 
        {
            "location": "/data/php/develop_doc/#_85", 
            "text": "创建表“City”，并添加字段“name”      $data=array(\n             className  =   City ,\n             fields  =  array(\n               name  =  array(\n                 type = String ,\n              ),\n            ),\n        );\n    $res = $bmobSchemas- createSchemas( e09fb5cbb5bxxxxxxxx9504604c0dcff ,  City , $data);", 
            "title": "创建一个表"
        }, 
        {
            "location": "/data/php/develop_doc/#_86", 
            "text": "创建表“City”，并添加字段“name”      $data=array(\n             className  =   City ,\n             fields  =  array(\n               name  =  array(\n                 type = String ,\n              ),\n            ),\n        );\n    $res = $bmobSchemas- createSchemas( e09fb5cbb5bxxxxxxxx9504604c0dcff ,  City , $data);  如果创建表的字段是Pointer或Relation类型，需要用targetClass指定关联的表，例如：      $data=array(\n             className  =   City ,\n             fields  =  array(\n               name  =  array(\n                 type = Pointer ,\n                 targetClass = _User \n              ),\n            ),\n        );\n    $res = $bmobSchemas- createSchemas( e09fb5cbb5bxxxxxxxx9504604c0dcff ,  City , $data);", 
            "title": "创建一个表"
        }, 
        {
            "location": "/data/php/develop_doc/#_87", 
            "text": "在表“City”中添加字段“name”      $data=array(\n             className  =   City ,\n             fields  =  array(\n               name  =  array(\n                 type = String ,\n              ),\n            ),\n        );\n    $res = $bmobSchemas- updateSchemas( e09fb5cbb5bxxxxxxxx9504604c0dcff ,  City , $data);   在表“City”中删除字段“name”      $data=array(\n             className  =   City ,\n             fields  =  array(\n               name  =  array(\n                 type = String ,\n                 __op = Delete \n              ),\n            ),\n        );\n    $res = $bmobSchemas- updateSchemas( e09fb5cbb5bxxxxxxxx9504604c0dcff ,  City , $data);", 
            "title": "修改表的结构"
        }, 
        {
            "location": "/data/php/develop_doc/#_88", 
            "text": "$res = $bmobSchemas- deleteSchemas( e09fb5cbb5bxxxxxxxx9504604c0dcff ,  City );", 
            "title": "删除表"
        }, 
        {
            "location": "/data/php/develop_doc/#_89", 
            "text": "有时，app需要获取服务器的时间，可通过下面的api      $bmobTimestamp = new BmobTimestamp();\n    $res = $bmobTimestamp- getTimestamp();   返回结果如下：  array（\n    [ timestamp ]= 1446522662，\n    [ datetime ]= 2015-11-03 11:51:02 \n）", 
            "title": "获取服务器的时间"
        }, 
        {
            "location": "/data/restful/", 
            "text": "注册Bmob帐号\n\n\n在网址栏输入www.bmob.cn或者在百度输入Bmob搜索，打开\nBmob官网\n后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活\nBmob\n账户，你就可以用Bmob轻松开发应用了。\n\n\n\n网站后台创建应用\n\n\n登录账号进入bmob后台后，点击后台界面左上角“创建应用“，在弹出框输入你应用的名称后确认，你就拥有了一个等待开发的应用。\n\n\n\n\n获取应用密钥\n\n\n选择你要开发的应用，进入该应用\n\n\n\n\n在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID以及REST API Key\n\n\n\n\n获取Application ID和REST API Key后，这两个Key将在后面用于REST API请求中作为HTTP头部的X-Bmob-Application-Id 和\nX-Bmob-REST-API-Key的值传到接口。\n\n\n添加一行数据\n\n\ncurl -X POST \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nscore\n:1337,\nplayerName\n:\nSean Plott\n,\ncheatMode\n:false}' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\nRestAPI调试工具\n\n\n这里给大家介绍一个简单的工具chrome浏览器的插件\npostman\n，方便调试Restful。操作界面如下所示：\n\n\n\n\n注意：建议大家用postman插件或者在linux系统环境下调试，curl在windows环境下请求存在数据格式转换的问题。\n\n\n获取一行数据\n\n\n查找GameScore表里面id为e1kXT22L的数据\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\n\n修改一行数据\n\n\n更新GameScore表里面id为e1kXT22L的数据，score内容更新为73453\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nscore\n:73453}' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\n删除一行数据\n\n\ncurl -X DELETE \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L", 
            "title": "快速入门"
        }, 
        {
            "location": "/data/restful/#bmob", 
            "text": "在网址栏输入www.bmob.cn或者在百度输入Bmob搜索，打开 Bmob官网 后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活 Bmob 账户，你就可以用Bmob轻松开发应用了。", 
            "title": "注册Bmob帐号"
        }, 
        {
            "location": "/data/restful/#_1", 
            "text": "登录账号进入bmob后台后，点击后台界面左上角“创建应用“，在弹出框输入你应用的名称后确认，你就拥有了一个等待开发的应用。", 
            "title": "网站后台创建应用"
        }, 
        {
            "location": "/data/restful/#_2", 
            "text": "选择你要开发的应用，进入该应用   在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID以及REST API Key   获取Application ID和REST API Key后，这两个Key将在后面用于REST API请求中作为HTTP头部的X-Bmob-Application-Id 和\nX-Bmob-REST-API-Key的值传到接口。", 
            "title": "获取应用密钥"
        }, 
        {
            "location": "/data/restful/#_3", 
            "text": "curl -X POST \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ score :1337, playerName : Sean Plott , cheatMode :false}' \\\n    https://api.bmob.cn/1/classes/GameScore", 
            "title": "添加一行数据"
        }, 
        {
            "location": "/data/restful/#restapi", 
            "text": "这里给大家介绍一个简单的工具chrome浏览器的插件 postman ，方便调试Restful。操作界面如下所示：   注意：建议大家用postman插件或者在linux系统环境下调试，curl在windows环境下请求存在数据格式转换的问题。", 
            "title": "RestAPI调试工具"
        }, 
        {
            "location": "/data/restful/#_4", 
            "text": "查找GameScore表里面id为e1kXT22L的数据  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L", 
            "title": "获取一行数据"
        }, 
        {
            "location": "/data/restful/#_5", 
            "text": "更新GameScore表里面id为e1kXT22L的数据，score内容更新为73453  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ score :73453}' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L", 
            "title": "修改一行数据"
        }, 
        {
            "location": "/data/restful/#_6", 
            "text": "curl -X DELETE \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L", 
            "title": "删除一行数据"
        }, 
        {
            "location": "/data/restful/develop_doc/", 
            "text": "简介\n\n\n只要你的设备，你使用的语言能够发送HTTP请求，那么就可以用来和\nBmob\n进行数据交互，你可以使用REST API做很多事情,比如:\n\n\n\n\n一个移动网站可以通过C、Java、Python、PHP、C#等甚至任何语言来获取\nBmob\n上的数据。\n\n\n一个网站可以展示来自\nBmob\n的数据。\n\n\n你可以上传大量的数据，随后可以被一个移动App读取。\n\n\n你可以下载最近的数据来进行你自定义的分析统计。\n\n\n使用任何语言写的程序都可以操作\nBmob\n上的数据。\n\n\n如果你不再需要使用\nBmob\n，你可以导出你所有的数据。\n\n\n\n\n案例源码\n\n\n这里提供一些开发者写的其他语言调用RestApi的源码或者核心代码。\n\n\nJAVA访问RestApi：\nhttp://wenda.bmob.cn//?/question/51\n\n\nPHP访问RestApi：\nhttp://docs.bmob.cn/data/PHP/a_faststart/doc/index.html\n\n\nAS3.0访问RestApi：\nhttp://wenda.bmob.cn//?/question/193\n\n\n请求格式\n\n\n对于POST和PUT请求，请求的主体必须是JSON格式,而且HTTP请求头的 \nContent-Type\n 需要设置为 \napplication/json\n 。\n\n\n用户验证是通过HTTP请求头来进行的, \nX-Bmob-Application-Id\n 头表明你正在访问的是哪个App程序, 而 \nX-Bmob-REST-API-Key\n 头是用来授权的。在下面的例子中，你必须使用正确的key替换Your Application ID和Your REST API Key才能正常地发出Curl请求。\n\n\n响应格式\n\n\n对于所有REST API请求的响应内容体都是一个JSON对象.\n\n\n一个请求是否成功是由HTTP状态码表明的， 一个2XX的状态码表示成功，而一个4XX表示请求失败。当一个请求失败时响应的主体仍然是一个JSON对象，但是总会包含code和error这两个字段，你可以用它们来进行调试。举个例子，如果保存一个对象的时候，尝试用不允许的Key，比如包含下划线的_name的话，就会得到如下请求失败的响应信息:\n\n\n{\n    \ncode\n: 105,\n    \nerror\n: \ninvalid field name: bl!ng\n\n}\n\n\n\n\n快速参考\n\n\nAPI 访问需要在 https://api.bmob.cn 域名下，相对路径前缀 /1/ 表明现在使用的是第 1 版的 API。\n\n\n对象快速参考\n\n\n\n\n\n\n\n\nURL\n\n\nHTTP\n\n\n功能\n\n\n\n\n\n\n\n\n\n\n/1/classes/TableName\n\n\nPOST\n\n\n添加数据\n\n\n\n\n\n\n/1/classes/TableName/objectId\n\n\nPUT\n\n\n更新数据\n\n\n\n\n\n\n/1/classes/TableName/objectId\n\n\nDELETE\n\n\n删除数据\n\n\n\n\n\n\n/1/batch\n\n\nPOST\n\n\n批量操作数据\n\n\n\n\n\n\n/1/classes/TableName/objectId\n\n\nGET\n\n\n查询数据\n\n\n\n\n\n\n/1/cloudQuery\n\n\nGET\n\n\n使用BQL查询\n\n\n\n\n\n\n\n\n用户快速参考\n\n\n\n\n\n\n\n\nURL\n\n\nHTTP\n\n\n功能\n\n\n\n\n\n\n\n\n\n\n/1/users\n\n\nPOST\n\n\n用户注册、使用手机号注册登录、第三方注册登录\n\n\n\n\n\n\n/1/login\n\n\nGET\n\n\n登录\n\n\n\n\n\n\n/1/users/objectId\n\n\nGET\n\n\n获取当前用户、查询用户\n\n\n\n\n\n\n/1/users/objectId\n\n\nPUT\n\n\n更新用户、第三方连接及断开连接\n\n\n\n\n\n\n/1/users/objectId\n\n\nDELETE\n\n\n删除用户\n\n\n\n\n\n\n/1/requestPasswordReset\n\n\nPOST\n\n\n密码重置\n\n\n\n\n\n\n/1/resetPasswordBySmsCode/smsCode\n\n\nPUT\n\n\n短信密码重置\n\n\n\n\n\n\n/1/updateUserPassword/objectId\n\n\nPOST\n\n\n旧密码更新密码\n\n\n\n\n\n\n/1/requestEmailVerify\n\n\nPOST\n\n\n邮箱验证\n\n\n\n\n\n\n\n\n文件管理快速参考\n\n\n\n\n\n\n\n\nURL\n\n\nHTTP\n\n\n功能\n\n\n\n\n\n\n\n\n\n\n/2/files/fileName\n\n\nPOST\n\n\n文件上传\n\n\n\n\n\n\n/2/files/cdnName/url\n\n\nDELETE\n\n\n删除文件\n\n\n\n\n\n\n/2/cdnBatchDelete\n\n\nPOST\n\n\n批量删除CDN文件\n\n\n\n\n\n\n\n\nACL和角色管理快速参考\n\n\n\n\n\n\n\n\nURL\n\n\nHTTP\n\n\n功能\n\n\n\n\n\n\n\n\n\n\n/1/roles\n\n\nPOST\n\n\n创建角色\n\n\n\n\n\n\n/1/roles/objectId\n\n\nGET\n\n\n获取角色\n\n\n\n\n\n\n/1/roles/objectId\n\n\nPUT\n\n\n更新角色\n\n\n\n\n\n\n\n\napp服务快速参考\n\n\n\n\n\n\n\n\nURL\n\n\nHTTP\n\n\n功能\n\n\n\n\n\n\n\n\n\n\n/1/apps\n\n\nGET\n\n\n获取所有app信息\n\n\n\n\n\n\n/1/apps/appId\n\n\nGET\n\n\n获取特定app信息\n\n\n\n\n\n\n/1/apps\n\n\nPOST\n\n\n创建新app\n\n\n\n\n\n\n/1/apps/appId\n\n\nPUT\n\n\n修改app信息\n\n\n\n\n\n\n\n\n数据表快速参考\n\n\n\n\n\n\n\n\nURL\n\n\nHTTP\n\n\n功能\n\n\n\n\n\n\n\n\n\n\n/1/schemas\n\n\nGET\n\n\n获取所有表信息\n\n\n\n\n\n\n/1/schemas/TableName\n\n\nGET\n\n\n获取特定表信息\n\n\n\n\n\n\n/1/schemas/TableName\n\n\nPOST\n\n\n创建表\n\n\n\n\n\n\n/1/schemas/TableName\n\n\nPUT\n\n\n修改表\n\n\n\n\n\n\n/1/schemas/TableName\n\n\nDELETE\n\n\n删除表\n\n\n\n\n\n\n\n\n其它功能快速参考\n\n\n\n\n\n\n\n\nURL\n\n\nHTTP\n\n\n功能\n\n\n\n\n\n\n\n\n\n\n/1/timestamp\n\n\nGET\n\n\n获取服务器时间\n\n\n\n\n\n\n\n\n对象\n\n\n对象格式\n\n\n通过REST API保存数据需要将对象的数据通过JSON来编码，这个数据是无模式化的（Schema Less）,这意味着你不需要提前标注每个对象上有哪些Key，你只需要随意设置key-value对就可以，Rest API后端会存储它的。\n\n\n举个例子，假设你正在记录一局游戏的最高分，一个简单的对象可能包含:\n\n\n{\n    \nscore\n: 1337,\n    \nplayerName\n: \nSean Plott\n,\n    \ncheatMode\n: false\n}\n\n\n\n\nKey必须是字母和数字组成的字符串,Value可以是任何可以JSON编码的东西.\n\n\n每个对象都有一个类名，你可以通过类名来区分不同的数据，例如，我们可以把游戏得分对象称之为GameScore.我们推荐你使用  \nNameYourClassesLikeThis\n 和 \nnameYourKeysLikeThis\n 这样的格式为你的类名和Key命名，这可以使你的代码看起来很漂亮.\n\n\n当你从\nBmob\n中获取对象时，一些字段会被自动加上: createdAt, updatedAt 和 objectId， 这些字段的名字是保留的，你不能自行设置它们，我们上面设置的对象在获取时应该是下面的样子.\n\n\n{\n    \nscore\n: 1337,\n    \nplayerName\n: \nSean Plott\n,\n    \ncheatMode\n: false,\n    \ncreatedAt\n: \n2011-08-20 02:06:57\n,\n    \nupdatedAt\n: \n2011-08-20 02:06:57\n,\n    \nobjectId\n: \ne1kXT22L\n\n}\n\n\n\n\ncreatedAt和updatedAt都是UTC时间戳,以ISO 8601标准和毫秒级精度储存:YYYY-mm-dd HH:ii:ss. objectId是一个string,在类中唯一表明了一个对象。\n\n\n在REST API中class级的在一个资源上的操作只能根据类名来进行，例如，如果类名是GameScore，那么class的URL就是\n\n\nhttps://api.bmob.cn/1/classes/GameScore\n\n\n\n\n用户有一个特殊的类级的url:\n\n\nhttps://api.bmob.cn/1/users\n\n\n\n\n针对于一个特定对象的操作可以通过组织一个URL来做，例如，对GameScore中的一个objectId为e1kXT22L的对象的操作应使用如下URL:\n\n\nhttps://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\n数据类型\n\n\n到现在为止我们只使用了可以被标准JSON编码的值，\nBmob\n移动客户端SDK库同样支持日期,地理位置数据和指针数据、关系型数据。在REST API中，这些值都被编码了，同时有一个\"__type\"字段来标识出它们所属的类型，所以如果你采用正确的编码的话就可以读或者写这些字段了。\n\n\nDate类型包含了一个\"iso\"字段存储了一个UTC时间戳,以ISO 8601格式和毫秒级的精度来存储时间: YYYY-MM-DDTHH:MM:SS.MMMZ，或者 YYYY-MM-DDTHH:MM:SS\n\n\n{\n    \n__type\n: \nDate\n,\n    \niso\n: \n2011-08-21 18:02:52\n\n}\n\n\n\n\nDate 与内置的 \ncreatedAt\n 字段和 \nupdatedAt\n 字段相结合的时候特别有用，举个例子：为了找到在一个特殊时间创建的对象，只需要将Date编码在一个查询的where条件中:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\ncreatedAt\n:{\n$gte\n:{\n__type\n:\nDate\n,\niso\n:\n2011-08-21 18:02:52\n}}}' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\nFile类型是在上传后返回的JSON数据再加一个Key为\"__Type\":\"File\", 用来保存到数据列为文件类型的值：\n\n\n{\n    \n__type\n: \nFile\n,\n    \ngroup\n: \ngroup1\n,\n    \nfilename\n: \n1.xml\n,\n    \nurl\n: \nM00/01/14/sd2lkds0.xml\n\n}\n\n\n\n\n更新对象时可以为该对象保存上传后返回的文件信息：\n\n\ncurl -X PUT \n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nscore\n:1337,\nplayerName\n:\nSean Plott\n,\nfile\n:{\n__type\n:\nFile\n,\ngroup\n:\ngroup1\n,\nfilename\n:\n1.xml\n,\nurl\n:\nM00/01/14/sd2lkds0.xml\n\n}}' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\nPointer 类型是在当前对象要指向另一个对象时使用，它包含了 className 和 objectId 两个作为一个指针正确指向的必填值.\n\n\n{\n  \n__type\n: \nPointer\n,\n  \nclassName\n: \nGame\n,\n  \nobjectId\n: \nDdUOIIIW\n\n}\n\n\n\n\n指向用户对象的 \nPointer\n 的 \nclassName\n 为_User, 前面加一个下划线表示开发者不能定义的类名, 而且所指的类是系统内置的。\n\n\nRelation\n 类型被用在多对多的类型上, 移动端的库将使用 \nBmobRelation\n 作为值, 它有一个 className 字段表示目标对象的类名：\n\n\n{\n  \n__type\n: \nRelation\n,\n  \nclassName\n: \nGameScore\n\n}\n\n\n\n\n当使用查询时， \nRelation\n 对象的行为很像是 \nPointer\n 的数组, 任何操作针对于 \nPointer\n 的数组的 (除了 include) 都可以对 \nRelation\n 起作用.\n\n\n当更多的数据类型被加入的时候, 它们都会采用 hashmap \n加上一个 type\n 字段的形式, 所以你不应该使用type作为你自己的JSON对象的Key。\n\n\n添加数据\n\n\n请求描述\n\n\n为了在\nBmob\n上创建一个新的对象，应该向class的URL发送一个POST请求，其中内容体应该是包含对象本身的JSON格式。\n\n\n请求\n\n\n\n\nurl ：https://api.bmob.cn/1/classes/TableName\n\n\nmethod ：POST\n\n\nheader:\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  key1 : value1,\n  key2 : value2,\n  ...\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 201 Created\n\n\n\n\n\n\nlocation: https://api.bmob.cn/1/classes/TableName/objectId\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n    \ncreatedAt\n: create date,\n    \nobjectId\n: objectId\n}\n\n\n\n\n例子\n\n\n例如，要创建如上例子中说的对象:\n\n\ncurl -X POST \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nscore\n:1337,\nplayerName\n:\nSean Plott\n,\ncheatMode\n:false}' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n当创建成功时，响应的HTTP状态码的返回值是201 Created，而响应的HTTP头部中Location的值是表示刚创建的该对象的URL:\n\n\nStatus: 201 Created\nLocation: https://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\n响应的主体是一个JSON对象,包含新对象的objectId和createdAt时间戳：\n\n\n{\n    \ncreatedAt\n: \n2011-08-20 02:06:57\n,\n    \nobjectId\n: \ne1kXT22L\n\n}\n\n\n\n\n更新数据\n\n\n普通更新\n\n\n请求描述\n\n\n为了更改一个对象上已经有的数据，你可以发送一个PUT请求到对象相应的URL上，只有你指定的Key的值才会变更为新值，任何你未指定的Key的值都不会更改，所以你可以只更新对象数据的一个子集。\n\n\n请求\n\n\n\n\nurl ：https://api.bmob.cn/1/classes/\n\n\n\n\nTableName/objectId\n\n\n\n\n\n\nmethod ：PUT\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  key1 : value1,\n  key2 : value2,\n  ...\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nupdatedAt\n: \nYYYY-mm-dd HH:ii:ss\n\n}\n\n\n\n\n例子\n\n\n我们来更改我们对象的一个score的字段:\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nscore\n:73453}' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\n返回的JSON对象只会包含一个updatedAt字段，表明更新发生的时间：\n\n\n{\n    \nupdatedAt\n: \n2011-08-21 18:02:52\n\n}\n\n\n\n\n修改对象的某个值\n\n\n如果存储的是JSON对象还可以通过以下形式，只修改JSON对象的特定键值，其body为：\n\n\n{\n  key1.keyOfJson : value1,\n  key2.keyOfJson : value2,\n  ...\n}\n\n\n\n\n如果你当前行有一列叫userAttibute,保存的是一个JSON 对象，比如是: {\"name\":\"John\", \"gender\":\"男\"}，那么我们要修改这个对象的gender值就可以通过以下方式实现：\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nuserAttibute.gender\n:\n女\n}' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\n原子计算器\n\n\n另外，很多应用可能会有需要计数器的功能，比如某条信息被点赞多少次等。Bmob提供了非常便捷的方式来保证原子性的修改某一数值字段的值，body如下，其中value的正负均可。\n\n\n其中请求的body为：\n\n\n{\n    key1:{\n__op\n:\nIncrement\n,\namount\n:value}\n    ...\n}\n\n\n\n\n例如，如果需要让score每次增加1，而并不需要知道其当前的值，可以使用以下请求：\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nscore\n:{\n__op\n:\nIncrement\n,\namount\n:1}}' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\n删除数据\n\n\n请求描述\n\n\n为了在\nBmob\n上删除一个对象，可以发送一个DELETE请求到指定的对象的URL。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/classes/TableName/objectId\n\n\n\n\n\n\nmethod ：DELETE\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus:200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nmsg\n: \nok\n\n}\n\n\n\n\n例子\n\n\n删除GameScore下objectId为e1kXT22L的方法如下：\n\n\ncurl -X DELETE \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\n删除字段的值\n\n\n请求描述\n\n\n可以在一个对象中删除一个字段，通过接口自定义的Delete操作\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/classes/TableName/objectId\n\n\n\n\n\n\nmethod ：PUT\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  key1:{\n__op\n:\nDelete\n},\n  key2:{\n__op\n:\nDelete\n},\n  ...\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nupdatedAt\n: \nYYYY-mm-dd HH:ii:ss\n\n}\n\n\n\n\n例子\n\n\n如果要删除GameScore中objectId为e1kXT22L记录的playerName，可进行如下请求。\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nplayerName\n:{\n__op\n:\nDelete\n}}' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\n批量数据操作\n\n\n请求描述\n\n\n为了减少因为网络通讯次数太多而带来的时间浪费, Bmob提供批量(batch)操作，在一个请求中对多个普通对象进行添加(create)、更新(update)、删除(delete) 操作，上限为50个。在一个批量(batch)请求中每一个操作都有自己对应的方法、路径和主体, 这些参数可以代替你通常使用的HTTP方法. 这些操作会以发送过去的顺序来执行。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/batch\n\n\n\n\n\n\nmethod ：POST\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  \nrequests\n: [\n          {\n            \nmethod\n: \nPOST\n,\n            \npath\n: \n/1/classes/TableName\n,\n            \nbody\n: {\n              key1: value1,\n              key2: value2,\n              ...\n            }\n          },\n          {\n            \nmethod\n: \nPUT\n,\n            \ntoken\n: \ntokenValue\n(具有ACL规则时),\n            \npath\n: \n/1/classes/TableName/objectId\n,\n            \nbody\n: {\n              key1: value1,\n              ...\n            }\n          },\n          {\n            \nmethod\n: \nDELETE\n,\n            \ntoken\n: \ntokenValue\n(具有ACL规则时),\n            \npath\n: \n/1/classes/TableName/objectId\n\n          },\n\n          ...\n\n          ]\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n[\n(添加对象返回的信息)\n  {\n    \nsuccess\n: {\n      \ncreatedAt\n: YYYY-mm-dd HH:ii:ss,\n      \nobjectId\n: \nd746635d0b\n\n    }\n  },\n  (修改对象返回的信息)\n  {\n    \nsuccess\n: {\n      \nupdatedAt\n: YYYY-mm-dd HH:ii:ss\n    }\n  },\n  (删除对象返回的信息)\n  {\n    \nsuccess\n: {\n      \nmsg\n: \nok\n\n    }\n  }\n]\n\n\n\n\n例子\n\n\n比如我们要创建一系列的 GameScore 的对象:\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nrequests\n: [\n          {\n            \nmethod\n: \nPOST\n,\n            \npath\n: \n/1/classes/GameScore\n,\n            \nbody\n: {\n              \nscore\n: 1337,\n              \nplayerName\n: \nSean Plott\n\n            }\n          },\n          {\n            \nmethod\n: \nPOST\n,\n            \npath\n: \n/1/classes/GameScore\n,\n            \nbody\n: {\n              \nscore\n: 1338,\n              \nplayerName\n: \nZeroCool\n\n            }\n          }\n        ]\n      }' \n  https://api.bmob.cn/1/batch\n\n\n\n\n如果我们要修改用户表的某条记录或者删除某条记录，则用以下方法。\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nrequests\n: [\n          {\n            \nmethod\n: \nPUT\n,\n            \ntoken\n: \npnktnjyb996sj4p156gjtp4im\n,\n            \npath\n: \n/1/users/51e3a334e4b0b3eb44adbe1a\n,\n            \nbody\n: {\n              \nscore\n: 999999\n            }\n          },\n          {\n            \nmethod\n: \nDELETE\n,\n            \ntoken\n: \npnktnjyb996sj4p156gjtp4im\n,\n            \npath\n: \n/1/users/51a8a4d9e4b0d034f6159a35\n\n          }\n        ]\n      }' \\\n  https://api.bmob.cn/1/batch\n\n\n\n\n查询\n\n\n数据的查询可能是每个应用都会频繁使用的，它提供了多样的方法来实现不同条件的查询，同时它的使用也是非常的简单和方便。\n\n\n查询单条数据\n\n\n请求描述\n\n\n当你创建了一个对象时，你可以通过发送一个HTTP GET请求到创建对象成功时返回的HTTP请求头中的Location的URL获取它的内容。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/classes/TableName/objectId，可以加上include值，具体形式为：https://api.bmob.cn/1/classes/TableName/objectId?include=game\n\n\n\n\n\n\nmethod ：GET\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  key1 : value1,\n  key2 : value2,\n  ...\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n    key1:value1,\n    key2:value2,\n    ...\n}\n\n\n\n\n例子\n\n\n为了得到我们上面创建的对象:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\n返回的主体是一个JSON对象，它包含所有用户提供的field，并且加上系统保留的createdAt,updatedAt和objectId三个Key的值：\n\n\n{\n    \nscore\n: 1337,\n    \nplayerName\n: \nSean Plott\n,\n    \ncheatMode\n: false,\n    \nskills\n: [\n        \npwnage\n,\n        \nflying\n\n    ],\n    \ncreatedAt\n: \n2011-08-20 02:06:57\n,\n    \nupdatedAt\n: \n2011-08-20 02:06:57\n,\n    \nobjectId\n: \ne1kXT22L\n\n}\n\n\n\n\n当获取的对象有指向其子对象的Pointer类型指针Key时，你可以加入inclue选项来获取指针指向的子对象。按上面的实例，如果GameScore对象有一个game的Key为Pointer类型，并指向了Game游戏对象，那么可以通过GameScore的game这个Key来获取指向的一个Game对象:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'include=game' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\n返回的主体是一个JSON对象包含GameScore的所有Key，并有game这个Pointer的Key被扩展为一个Game对象:\n\n\n{\n    \nscore\n: 1337,\n    \nplayerName\n: \nSean Plott\n,\n    \ncheatMode\n: false,\n    \nskills\n: [\n        \npwnage\n,\n        \nflying\n\n    ],\n    \ngame\n: {\n        \ntype\n: \nObject\n,\n        \nclassName\n: \nGame\n,\n        \nname\n: \n愤怒的小鸡\n,\n    }\n    \ncreatedAt\n: \n2011-08-20 02:06:57\n,\n    \nupdatedAt\n: \n2011-08-20 02:06:57\n,\n    \nobjectId\n: \ne1kXT22L\n\n}\n\n\n\n\n查询多条数据\n\n\n请求描述\n\n为了一次获取多个对象，你可以通过发送一个GET请求到类的URL上，不需要任何URL参数。具体如下。\n\n\n请求\n\n\n\n\nurl ：https://api.bmob.cn/1/classes/TableName\n\n\nmethod ：GET\n\n\nheader:\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n成功时响应\n\n\n\n\nstatus: 200 OK\n\n\nbody: \n\n\n\n\n{\n  \nresults\n: [\n    {\n      key1:value1,\n      key2:value2,\n      ...\n    },\n    {\n      key1:value1,\n      key2:value2,\n      ...\n    },\n    ...\n\n\n\n\n例子\n\n\n下面就是简单地获取所有在GameScore类之中的对象:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n返回的值就是一个JSON对象包含了results字段,它的值就是对象的列表:\n\n\n{\n    \nresults\n: [\n    {\n        \nplayerName\n: \nJang Min Chul\n,\n        \nupdatedAt\n: \n2011-08-19 02:24:17\n,\n        \ncheatMode\n: false,\n        \ncreatedAt\n: \n2011-08-19 02:24:17\n,\n        \nobjectId\n: \n51c3ba67e4b0f0e851c16221\n,\n        \nscore\n: 80075\n    },\n    {\n        \nplayerName\n: \nSean Plott\n,\n        \nupdatedAt\n: \n2011-08-21 18:02:52\n,\n        \ncheatMode\n: false,\n        \ncreatedAt\n: \n2011-08-20 02:06:57\n,\n        \nobjectId\n: \ne1kXT22L\n,\n        \nscore\n: 73453\n    }\n    ]\n}\n\n\n\n\n怎么样，是不是很简单，而且查询的结果不需要任何处理，你直接使用即可。\n\n\n条件查询\n\n\n条件查询就是在查询所有数据的请求上通过where参数的形式对查询对象做出约束，只返回我们功期望返回的值。\n\n\nwhere参数的值应该是JSON编码过的，就是说，如果你查看真正被发出的URL请求，它应该是先被JSON编码过，然后又被URL编码过。\n\n\n使用where参数最简单的方式就是包含应有的key的值。举例说,如果我们想要得到Lily的记录，那该请求的URL为：\n\n\nhttps://api.bmob.cn/1/classes/GameScore?where={\nname\n:\nLily\n}\n\n\n\n\n这是未经编码前我们看到的url，我们需要对URL进行URL编码，编码的的结果为：\n\n\nhttps://api.bmob.cn/1/classes/GameScore?where=%7B%22name%22:%22Lily%22%7D\n\n\n\n\n不同的语言开发环境有不同的URL编码接口，如果是使用如Postman这类工具来进行测试的，可以使用一些在线的url编解码工具进行编码后再发送请求，这里推荐一个\nhttp://web.chacuo.net/charseturlencode\n\n\nwhere的参数值除了上面的准确匹配外，还支持比较运算符的方式，除了给定一个确定值的方式，还可以提供一个hash中包含有key用于比较，where参数支持下面一些选项:\n\n\n\n\n\n\n\n\nKey\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n$lt\n\n\n小于\n\n\n\n\n\n\n$lte\n\n\n小于等于\n\n\n\n\n\n\n$gt\n\n\n大于\n\n\n\n\n\n\n$gte\n\n\n大于等于\n\n\n\n\n\n\n$ne\n\n\n不等于\n\n\n\n\n\n\n$in\n\n\n包含在数组中\n\n\n\n\n\n\n$nin\n\n\n不包含在数组中\n\n\n\n\n\n\n$exists\n\n\n这个 Key 有值\n\n\n\n\n\n\n$select\n\n\n匹配另一个查询的返回值\n\n\n\n\n\n\n$dontSelect\n\n\n排除另一个查询的返回\n\n\n\n\n\n\n$all\n\n\n包括所有给定的值\n\n\n\n\n\n\n$regex\n\n\n匹配PCRE表达式\n\n\n\n\n\n\n\n\n作为示例，为了获取score得分在[1000,3000]之间的对象，我们需要这样做:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\nscore\n:{\n$gte\n:1000,\n$lte\n:3000}}' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n为了获得score得分在10以下并且是一个奇数，我们需要这样做:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\nscore\n:{\n$in\n:[1,3,5,7,9]}}' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n为了获得scoreArray得分包括数组中所有的值，如scoreArray是[1,3, 5, 7]就满足，是[1, 5,10]就不满足:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\nscoreArray\n:{\n$all\n:[1,3,5]}}' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n为了获取playerName不在列表中的GameScore对象们，我们可以:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\nplayerName\n:{\n$nin\n:[\nJonathan Walsh\n,\nDario Wunsch\n,\nShawn Simon\n]}}' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n为了获取有分数的对象，我们应该用:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\nscore\n:{\n$exists\n:true}}' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n为了获取没有分数的对象，用:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\nscore\n:{\n$exists\n:false}}' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n你还可以使用模糊查询，支持PCRE正则表达式：\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\nplayerName\n:{\n$regex\n:\nsmile.*\n}}' \\\n    https://api.bmob.cn/1/classes/GameScore \n\n\n\n\n注:模糊查询只对付费用户开放，付费后可直接使用。\n\n\n如果您的查询条件某个列值要匹配另一个查询的返回值，举例有一个队伍(Team)保存了每个城市的得分情况且用户表中有一列为用户家乡(hometown), 您可以创建一个查询来寻找用户的家乡是得分大于0.5的城市的所有运动员， 就像这样查询:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\nhometown\n:{\n$select\n:{\nquery\n:{\nclassName\n:\nTeam\n,\nwhere\n:{\nwinPct\n:{\n$gt\n:0.5}}},\nkey\n:\ncity\n}}}' \\\n    https://api.bmob.cn/1/users\n\n\n\n\n反之查询Team中得分小于等于0.5的城市的所有运动员，构造查询如下：\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\nhometown\n:{\n$dontSelect\n:{\nquery\n:{\nclassName\n:\nTeam\n,\nwhere\n:{\nwinPct\n:{\n$gt\n:0.5}}},\nkey\n:\ncity\n}}}' \\\n    https://api.bmob.cn/1/users\n\n\n\n\n分页查询\n\n\n你可以用limit和skip来做分页，limit的默认值是100，但是任何1到1000的值都是可选的，就是说，为了获取在400到600之间的对象:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'limit=200' \\\n    --data-urlencode 'skip=400' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n排序\n\n\n你可以用order参数指定一个字段来排序，前面加一个负号的前缀表示降序，这样返回的对象会以score升序排列:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'order=score' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n而以下这样返回的对象会以score降序排列:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'order=-score' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n你可以用多个字段进行排序，只要用一个逗号隔开列表就可以，为了获取GameScore，以score的升序和name的降序进行排序:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'order=score,-name' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n复合查询\n\n\n\n\n\n\n\n\nKey\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n$or\n\n\n复合查询中的或查询\n\n\n\n\n\n\n$and\n\n\n复合查询中的与查询\n\n\n\n\n\n\n\n\n如果你想查询对象符合几种查询之一，你可以使用$or或$and操作符，带一个JSON数组作为它的值。例如，如果你想找到player赢了很多或者赢了很少，你可以用如下的方式:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\n$or\n:[{\nwins\n:{\n$gt\n:150}},{\nwins\n:{\n$lt\n:5}}]}' \\\n    https://api.bmob.cn/1/classes/Player\n\n\n\n\n查询今天内的数据，方式如下:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\n$and\n:[{\ncreatedAt\n:{\n$gte\n:{\n__type\n: \nDate\n, \niso\n: \n2014-07-15 00:00:00\n}}},\\\n    {\ncreatedAt\n:{\n$lte\n:{\n__type\n: \nDate\n, \niso\n: \n2014-07-15 23:59:59\n}}}]}' \\\n    https://api.bmob.cn/1/classes/Player\n\n\n\n\n因为createdAt updatedAt服务器自动生成的时间，在服务器保存的是精确到微秒值的时间，所以基于时间类型比较的值要加1秒。\n\n\n任何在查询上的其他的约束都会对返回的对象生效，所以你可以用$or对其他的查询添加约束。\n\n\n注意我们不会在 \n组合查询的子查询\n 中支持非过滤型的约束(例如:limit skip sort include)，但最外层的查询中是支持非过滤型约束的。\n\n\n查询结果计数\n\n\n如果你在使用limit，或者如果返回的结果很多，你可能想要知道到底有多少对象应该返回，而不用把它们全部获得以后再计数，此时你可以使用count参数。举个例子，如果你仅仅是关心一个特定的玩家玩过的游戏数量：\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\nplayerName\n:\nJonathan Walsh\n}' \\\n    --data-urlencode 'count=1' \\\n    --data-urlencode 'limit=0' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n因为请求了count而且把limit设为了0，返回的值里面只有计数，results为空数组集。\n\n\n{\n    \nresults\n: [\n\n    ],\n    \ncount\n: 1337\n}\n\n\n\n\n如果有一个非0的limit的话，既会返回正确的results也会返回count的值。\n\n\n查询指定列\n\n\n你可以限定返回的字段，通过传入keys参数，值为用一个逗号分隔的字段名称列表，为了获取对象只包含score和playerName字段(还有特殊的内置字段比如objectId,createdAt和updatedAt)，请求如下：\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'keys=score,playerName' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n统计相关的查询\n\n\nBmob的统计查询，提供以下关键字或其组合的查询操作：\n\n\n\n\n\n\n\n\nKey\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\ngroupby\n\n\n分组操作\n\n\n\n\n\n\ngroupcount\n\n\n返回每个分组的总记录\n\n\n\n\n\n\nsum\n\n\n计算总和\n\n\n\n\n\n\naverage\n\n\n计算平均值\n\n\n\n\n\n\nmax\n\n\n计算最大值\n\n\n\n\n\n\nmin\n\n\n计算最小值\n\n\n\n\n\n\nhaving\n\n\n分组中的过滤条件\n\n\n\n\n\n\n\n\n为避免和用户创建的列名称冲突，Bmob约定以上统计关键字（sum, max, min)的查询结果值都用 \n_(关键字)+首字母大写的列名\n 的格式，如计算玩家得分列名称为score总和的操作，则返回的结果集会有一个列名为_sumScore。average返回的列为 \n_avg+首字母大写的列名\n ，有groupcount的情形下则返回_count。\n\n\n以上关键字除了groupcount是传Boolean值true或false，having传的是和where类似的json字符串，但having只应该用于过滤分组查询得到的结果集，即having只应该包含结果集中的列名如 \n{\"_sumScore\":{\"$gt\":100}}\n ，其他关键字必须是字符串而必须是表中包含的列名，多个列名用,分隔。\n\n\n以上关键字可以自由组合并可以与前面查询语句中的where, order, limit, skip等组合使用。\n\n\n比如，GameScore表是游戏玩家的信息和得分表，有playerName(玩家名称)、score(玩家得分)等你自己创建的列，还有Bmob的默认列objectId, createdAt, updatedAt,那么我们现在举例如何使用以上的查询关键字来作这个表的统计。 \n\n\n计算总和\n\n\n我们要计算GameScore表所有玩家的得分总和，sum后面只能拼接Number类型的列名，即要计算哪个列的值的总和，只对Number类型有效，多个Number列用,分隔，则查询如下：\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'sum=score' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n返回内容如下：\n\n\n[\n    {\n        \n_sumScore\n: 2398\n    }   \n]\n\n\n\n\n\n分组计算总和\n\n\n比如我们以创建时间按天统计所有玩家的得分，并按时间降序, groupby后面只能拼接列名，如果该列是时间类型，则按天分组，其他类型，则按确定值分组:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'sum=score\ngroupby=createdAt\norder=-createdAt' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n返回内容如下：\n\n\n[\n    {\n        \n_sumScore\n: 2398,\n        \ncreatedAt\n: \n2014-02-05\n\n    },\n    {\n        \n_sumScore\n: 1208,\n        \ncreatedAt\n: \n2014-01-01\n\n    },\n]                 \n\n\n\n\n多个分组并计算多个列的总和\n\n\n比如我们以创建时间按天和按玩家名称分组统计所有玩家的得分1，得分2的总和，并按得分1的总和降序, groupby后面只能拼接列名，如果该列是时间类型，则按天分组，其他类型，则按确定值分组:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'sum=score1,score2\ngroupby=createdAt,playerName\norder=-_sumscore1' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n返回内容如下：\n\n\n[\n    {\n        \n_sumScore1\n: 399,\n        \n_sumScore2\n: 120,\n        \nplayerName\n: \nJohn\n\n        \ncreatedAt\n: \n2014-02-05\n\n    },\n    {\n        \n_sumScore1\n: 299,\n        \n_sumScore2\n: 250,\n        \nplayerName\n: \nBily\n\n        \ncreatedAt\n: \n2014-02-05\n\n    },\n    {\n        \n_sumScore1\n: 99,\n        \n_sumScore2\n: 450,\n        \nplayerName\n: \nJohn\n\n        \ncreatedAt\n: \n2014-02-01\n\n    },\n]                 \n\n\n\n\n分组计算总和并只返回满足条件的部分值\n\n\n比如我们以创建时间按天统计所有玩家的得分，并只返回某天的总得分大于2000的记录，并按时间降序，having是用于过滤部分结果，其中的_sumScore是 \n_sum+首字母大写的列名\n 的格式表示是计算这个列的总和的值:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'sum=score\nhaving={\n_sumScore\n:{\n$gt\n: 2000}}\ngroupby=createdAt\norder=-createdAt' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n返回内容如下：\n\n\n[\n    {\n        \n_sumScore\n: 2398,\n        \ncreatedAt\n: \n2014-02-05\n\n    },\n]                 \n\n\n\n\n分组计算总和并返回每个分组的记录数\n\n\n比如我们以创建时间按天统计所有玩家的得分和每一天有多少条玩家的得分记录，并按时间降序:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'sum=score\ngroupby=createdAt\ngroupcount=true\norder=-createdAt' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n返回内容如下：\n\n\n[\n    {\n        \n_sumScore\n: 2398,\n        \n_count\n: 10,\n        \ncreatedAt\n: \n2014-02-05\n\n    },\n    {\n        \n_sumScore\n: 100,\n        \n_count\n: 2,\n        \ncreatedAt\n: \n2014-01-01\n\n    },\n]                 \n\n\n\n\n获取不重复的列值\n\n\n比如我们获取表中所有的唯一的score:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'groupby=score' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n返回内容如下：\n\n\n[\n    {\n        \nscore\n: 78\n    },\n    {\n        \nscore\n: 89\n    }\n]                 \n\n\n\n\n其他关键字\n\n\naverage(计算平均值)， max(计算最大值)，min(计算最小值)和sum查询语句是类似的，只用把上面的例子中的sum替换为相应的average, max, min就可以了。\n\n\nBQL查询\n\n\n我们还提供类 SQL 语法的 BQL 查询语言来查询数据，例如：\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -G \\\n  --data-urlencode 'bql=select * from Player limit 0,100 order by name' \\\n  https://api.bmob.cn/1/cloudQuery\n\n\n\n\n更多请参考 \nBQL 详细指南\n 。\n\n\nBQL 还支持占位符查询，where 和 limit 子句的条件参数可以使用问号替换，然后通过 \nvalues\n 数组传入：\n\n\ncurl -X GET \\\n   -H \nX-Bmob-Application-Id: Your Application ID\n \\\n   -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -G \\\n  --data-urlencode 'bql=select * from Player where name=? limit ?,? order by name' \\\n  --data-urlencode 'values=[\ndennis\n, 0, 100]'\n  https://api.bmob.cn/1/cloudQuery\n\n\n\n\n数组\n\n\n为了存储数组型数据，\nBmob\n提供了3种操作来原子性地更改一个数组字段:\n\n\nAdd\n 在一个数组字段的后面添加一些指定的对象(包装在一个数组内)\n\n\nAddUnique\n 只会在原本数组字段中没有这些对象的情形下才会添加入数组，插入数组的位置不固定的\n\n\nRemove\n 从一个数组字段的值内移除指定的数组中的所有对象\n\n\n添加数组数据\n\n\n请求描述\n\n\n添加数据时添加一个数据字段。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/classes/TableName\n\n\n\n\n\n\nmethod ：POST\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  key1:{\n__op\n:\nAdd\n,\nobjects\n:[value1,value2...]},\n\n  ...\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \"createdAt\": \"YYYY-mm-dd HH:ii:ss\",\n  \"objectId\": objectId\n}\n\n\n例子\n\n\n给GameScore添加一条记录其中一个字体为数组，包含一些技能，可进行如下请求:\n\n\ncurl -X POST \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nskill\n:{\n__op\n:\nAdd\n,\nobjects\n:[\nskill1\n,\nskill2\n]}}' \\\n    https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n更新数组数据\n\n\n普通更新\n\n\n请求描述\n\n\n数组对象生成后，还可以对其进行更新，往数组里面添加内容。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/classes/TableName/objectId\n\n\n\n\n\n\nmethod ：PUT\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n   key1:{\n__op\n:\nAddUnique\n,\nobjects\n:[value1,value2...]},\n  ...\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nupdatedAt\n: \nYYYY-mm-dd HH:ii:ss\n\n}\n\n\n\n\n例子\n\n\n如在GameScore的e1kXT22L再添加两个技能，并且只有在这两个技能不存在时才加入，则可以使用以下请求：\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nskills\n:{\n__op\n:\nAddUnique\n,\nobjects\n:[\nflying\n,\nkungfu\n]}}' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\n使用索引和对象key修改数组中的对象\n\n\n请求描述\n\n\n当数组中存储的是JSON对象时，可以使用该请求单独修改JSON对象中的某个值。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/classes/TableName/objectId\n\n\n\n\n\n\nmethod ：PUT\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  key1.number.keyOfJson : value1,\n  key2.number.keyOfJson : value2,\n  ...\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nupdatedAt\n: \nYYYY-mm-dd HH:ii:ss\n\n}\n\n\n\n\n例子\n\n\n比如你当前行有一列叫用户的工作经验projectExperiences，是一个Array数组列，里面包含了多个对象值：[{\"name\":\"项目名称\",\"descr\":\"项目描述\"，\"startTime\":\"开始时间\"，\"endTime\":\"结束时间\"}, ...]\n\n\n那么我们要修改projectExperiences数组中第一个对象的name值：\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nprojectExperiences.0.name\n:\n项目名称2\n}' \\\n    https://api.bmob.cn/1/users/e1kXT22L\n\n\n\n\n删除数组数据\n\n\n请求描述\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/classes/TableName/objectId\n\n\n\n\n\n\nmethod ：PUT\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n   key1:{\n__op\n:\nRemove\n,\nobjects\n:[value1,value2...]},\n  ...\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nupdatedAt\n: \nYYYY-mm-dd HH:ii:ss\n\n}\n\n\n\n\n例子\n\n\n把GameScore里objectId为e1kXT22L对象的技能移除。\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nskills\n:{\n__op\n:\nRemove\n,\nobjects\n:[\nflying\n,\nkungfu\n]}}' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\n查询数组数据\n\n\n请求描述\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/classes/TableName\n\n\n\n\n\n\nmethod ：GET\n\n\n\n\n\n\nparams:\n\n\n\n\n\n\n//查找数组中含有特定值\nwhere={arraykey1:value1,arraykey2:value2,...}\n\nor\n\n//查找数据组同时含有若干个值\nwhere={\narrayKey\n:{\n$all\n:[value1,value2,...]}}\n\n\n\n\n\n\nheader:\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody: \n\n\n\n\n\n\n{\n  \nresults\n: [\n    {\n      key1:value1,\n      key2:value2,\n      ...\n    },\n    {\n      key1:value1,\n      key2:value2,\n      ...\n    },\n    ...\n\n\n\n\n例子\n\n\n例如，可以查找Key的数组值中包含有2的对象:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\narrayKey\n:2}' \\\n    https://api.bmob.cn/1/classes/RandomObject\n\n\n\n\n还同样可以使用\"$all\"操作符来找到类型为数组的Key的值中包含有2,3和4的对象:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\narrayKey\n:{\n$all\n:[2,3,4]}}' \\\n    https://api.bmob.cn/1/classes/RandomObject\n\n\n\n\n数据关联\n\n\n关联对象\n\n\n在程序设计中，不同类型的数据之间可能存在某种关系。分别是以下三种：\n1. 一对一，比如车队给司机分车，1个司机对应1台车；\n2. 一对多，比如1个作者会对应多篇贴子；\n3. 多对多，比如1篇帖子会有多个喜欢的读者，而每个读者也会有多篇喜欢的帖子。\n前面的两种关系我们提供Pointer类型来表示，而最后一种关系我们使用Relation类型来表示\n\n\n在下面的讲解中我们可能会使用到以下的两张表，其表结构如下：\n\n\n_User\n\n\n\n\n\n\n\n\n字段\n\n\n类型\n\n\n含义\n\n\n\n\n\n\n\n\n\n\nobjectId\n\n\nstring\n\n\n\n\n\n\n\n\nusername\n\n\nstring\n\n\n用户名，用户可以是作者发帖子，也可以是读者发评论\n\n\n\n\n\n\n\n\nPost\n\n\n\n\n\n\n\n\n字段\n\n\n类型\n\n\n含义\n\n\n\n\n\n\n\n\n\n\nobjectId\n\n\nstring\n\n\n\n\n\n\n\n\ntitle\n\n\nstring\n\n\n帖子标题\n\n\n\n\n\n\ncontent\n\n\nstring\n\n\n帖子内容\n\n\n\n\n\n\nauthor\n\n\nPointer(_User)\n\n\n作者\n\n\n\n\n\n\nlikes\n\n\nRelation(_User)\n\n\n喜欢帖子的读者\n\n\n\n\n\n\n\n\nPointer的使用\n\n\nPointer可用于表示一对一及一对多的关系。\n\n\nPointer本质类似于指针，使用 \nclassName\n 和 \nobjectId\n 来定位具体的对象。具体的操作如下。\n\n\n添加Pointer\n\n\n添加Pointer其实与普通的添加对象是一样的，使用的请求也是添加对象的接口，只是其中的 key-value对中的value的格式为\n\n\n{\n    \n__type\n:\nPointer\n,\n    \nclassName\n:tableName,\n    \nobjectId\n:objectId\n}\n\n\n\n\n例如，如果我们需要添加一篇帖子，并关联至其作者，可以采用以下请求：\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{ \\\n            \ntitle\n: \nhow to user pointer\n, \\           \nuser\n : { \\\n            \n__type\n:\nPointer\n, \\\n            \nclassName\n:\n_User\n, \\\n            \nobjectId\n:\nDdUOIIIW\n \\\n            } \\\n         }' \\\n  https://api.bmob.cn/1/classes/GameScore\n\n\n\n\n删除Pointer\n\n\n与删除普通列值一样，例如要删除帖子(Post)的作者，如下\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nauthor\n:{\n__op\n:\nDelete\n}}' \\\n    https://api.bmob.cn/1/classes/Post/e1kXT22L\n\n\n\n\n修改Pointer\n\n\n与修改普通列值一样，只是新的值需要满足Pointer的格式，如下\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{ \\\n                \ntitle\n: \nhow to user pointer\n, \\               \nuser\n : { \\\n                \n__type\n:\nPointer\n, \\\n                \nclassName\n:\n_User\n, \\\n                \nobjectId\n:\nobjectId\n \\ (新关联作者的objectId)\n                } \\\n         }' \n    https://api.bmob.cn/1/classes/Post/e1kXT22L\n\n\n\n\n查询Pointer\n\n\n在某些情况之下，你可能需要在一个查询之中返回关联对象的所有值，你可以通过传入字段名称到include参数中，多个字段名称用,间隔。比如，在查询Post时还想将其相关联的user对象取出来，如下\n\n\ncurl -X GET \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -G \\\n  --data-urlencode 'include=author' \\\n  https://api.bmob.cn/1/classes/Post\n\n\n\n\n返回的user字段的值如下：\n\n\n{\n  \n__type\n: \nObject\n,\n  \nclassName\n: \n_User\n,\n  \nobjectId\n: \n51e3a359e4b015ead4d95ddc\n,\n  \ncreatedAt\n: \n2011-12-06T20:59:34.428Z\n,\n  \nupdatedAt\n: \n2011-12-06T20:59:34.428Z\n,\n  \notherFields\n: \nwillAlsoBeIncluded\n\n}\n\n\n\n\n而没有使用include时，返回的user字段值则是如下形式：\n\n\n{\n  \n__type\n: \nPointer\n,\n  \nclassName\n: \n_User\n,\n  \nobjectId\n: \n51e3a359e4b015ead4d95ddc\n\n}\n\n\n\n\n你可以同样做多层的include, 这时要使用 \".\" 号. 如果你要include一条评论(Comment)对应的帖子(Post)的作者(author)：\n\n\ncurl -X GET \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -G \\\n  --data-urlencode 'order=-createdAt' \\\n  --data-urlencode 'limit=10' \\\n  --data-urlencode 'include=post.author' \\\n  https://api.bmob.cn/1/classes/Comment\n\n\n\n\n如果你要构建一个查询, 这个查询要include多个 \nPointer\n 类型的Key, 此时用逗号分隔Key名称列表即可。\n\n\n另外，include 还可以只返回指定的keys，即 Pointer 类型的字段指向的表只返回指定的字段，举例如下：\n\n\n建议大家使用以下方式，只返回需要的值，性能更好，流量更少\n\n\ncurl -X GET \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -G \\\n  --data-urlencode 'include=post[likes].author[username|email],user[username]' \\\n  https://api.bmob.cn/1/classes/Comment\n\n\n\n\npost 指向的帖子表只返回likes字段，而author指向的用户表只返回username和email字段，user指向的用户表只返回username字段。\n\n\n约束Pointer值查询\n\n\n在查询当中，我们可以对字符串、数组、数字等进行约束，比如查询Post表时，我们可以指定只返回title以“a”开头的Post对象。那么Pointer能不能也进行约束呢？如下：\n\n\n1.如果约束的是某个特定对象，即知道该对象的objectId，您可以用一个 \nwhere\n 参数查询, 自己使用 \n__type\n 构造一个 \nPointer\n, 就像你构造其他数据类型一样。举例说, 如果每一条评论(Comment对象)有一个Key叫post，类型是Pointer，并且指向了一个具体的帖子(Post对象，用objectId表示一个帖子)，那么您可以使用下面的请求获取一个帖子的所有评论\n\n\ncurl -X GET \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -G \\\n  --data-urlencode 'where={\npost\n:{\n__type\n:\nPointer\n,\nclassName\n:\nPost\n,\nobjectId\n:\n1dafb9ed9b\n}}' \\\n  https://api.bmob.cn/1/classes/Comment\n\n\n\n\n2.如果想要约束关联对象除objectId外的其它值，比如我想要返回所有指向的author指向的对象，其username都为Lily的Post对象，该如何做呢？我们可以使用 \"$inQuery\" 来完成，具体如下：\n\n\ncurl -X GET \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -G \\\n  --data-urlencode 'where= { \\\n                                \nauthor\n: { \\\n                                    \n$inQuery\n: { \\\n                                    \nwhere\n: { \\\n                                          \nusername\n: \nLily\n \\\n                                    }, \\\n                                    \nclassName\n: \n_User\n \\\n                                } \\\n                                 } \\\n                            }' \\\n  https://api.bmob.cn/1/classes/Post\n\n\n\n\n如果需求是不匹配查询条件的，比较要找username不是Lily的Post对象，只需要将 \n$inQuery\n 替换成 \n$notInQuery\n 即可。\n\n\nRelation的使用\n\n\nRelation可用于表示多对多的关系。其本质是一个Pointer的数组。具体的操作介绍如下。\n\n\n添加Relation\n\n\n添加 \nRelation\n 返回使用的也是添加对象的接口，对应的 \nkey-value\n 对中的 \nvalue\n 需要满足以下格式\n\n\n{\n  key: {\n    \n__op\n: \nAddRelation\n,\n    \nobjects\n: [\n      {\n        \n__type\n: \nPointer\n,\n        \nclassName\n: className,\n        \nobjectId\n: objectId\n      },\n      {\n        \n__type\n: \nPointer\n,\n        \nclassName\n: className,\n        \nobjectId\n: objectId\n      }\n    ]\n  }\n}\n\n\n\n\n如需要给一个 \nPost\n 对象添加两个喜欢该 \nPost\n 的读者，可以使用以下方法。\n\n\ncurl -X PUT \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{ \nlikes\n: { \\\n          \n__op\n: \nAddRelation\n, \\\n          \nobjects\n: [ \\\n            { \\\n             \n__type\n: \nPointer\n, \\\n             \nclassName\n: \n_User\n, \\\n             \nobjectId\n: \nz0lOxp1X\n \\\n            }, \\\n            { \\\n             \n__type\n: \nPointer\n, \\\n             \nclassName\n: \n_User\n, \\\n             \nobjectId\n: \nMTzXDDDG\n \\\n            } \\\n           ] \\\n        } \\\n      }' \\\n  https://api.bmob.cn/1/classes/Post/z0lOxp12\n\n\n\n\n删除Relation\n\n\n与普通的更新对象接口一样，只是需要使用特定的格式，具体如下：\n\n\n{\n  key: {\n    \n__op\n: \nRemoveRelation\n,\n    \nobjects\n: [\n      {\n        \n__type\n: \nPointer\n,\n        \nclassName\n: className,\n        \nobjectId\n: objectId\n      },\n      {\n        \n__type\n: \nPointer\n,\n        \nclassName\n: className,\n        \nobjectId\n: objectId\n      }\n    ]\n  }\n}\n\n\n\n\n如有读者取消了对某篇帖子的收藏，可以进行如下操作:\n\n\ncurl -X PUT \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{ \nlikes\n: { \\\n          \n__op\n: \nRemoveRelation\n, \\\n          \nobjects\n: [ \\\n            { \\\n             \n__type\n: \nPointer\n, \\\n             \nclassName\n: \n_User\n, \\\n             \nobjectId\n: \nz0lOxp1X\n \\\n            }\n      }' \\\n  https://api.bmob.cn/1/classes/Post/z0lOxp2a\n\n\n\n\n查询Relation\n\n\n如果我们需要查询喜欢某篇帖子的所有作者，那么可以使用 \n$relatedTo\n，可以使用以下请求，与Pointer不同的是，此处我们直接查询的是_User表，\n$relatedTo\n 跟的是帖子的具体记录。\n\n\ncurl -X GET \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -G \\\n  --data-urlencode 'where={\n$relatedTo\n:{\nobject\n:{\n__type\n:\nPointer\n,\nclassName\n:\nPost\n,\nobjectId\n:\n1dafb9ed9b\n},\nkey\n:\nlikes\n}}' \\\n  https://api.bmob.cn/1/users\n\n\n\n\n约束Relation进行查询\n\n\n跟Pointer一样，我们同样可以使用 \n$inQuery\n 和 \n$notInQuery\n 对Relation的指向的对象的某些属性进行约束。例如，如果需要找到 \nLily\n 喜欢的所有帖子，可以使用以下请求：\n\n\ncurl -X GET \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -G \\\n  --data-urlencode 'where= { \\\n                                \nlikes\n: { \\\n                                    \n$inQuery\n: { \\\n                                    \nwhere\n: { \\\n                                          \nusername\n: \nLily\n \\\n                                    }, \\\n                                    \nclassName\n: \n_User\n \\\n                                } \\\n                                 } \\\n                            }' \\\n  https://api.bmob.cn/1/classes/Post\n\n\n\n\n用户管理\n\n\n很多跨平台和跨系统的应用都有一个统一的登录流程，\nBmob\n通过REST API访问用户的账户让你实现该功能。\n\n\n通常来说，用户这个类的功能与其他的对象是相同的，比如都没有限制模式(Schema Less)，User对象和其他对象不同的是一个用户必须有用户名(username)和密码(password)，密码会被自动地加密和存储。\nBmob\n强制你username和email这两个Key的值必须是不重复的。\n\n\n属性\n\n\nBmob\n默认会有几个特定的属性：\nusername: 用户的用户名\n（必需）\n。\npassword: 用户的密码\n（必需）\n。\nemail: 用户的电子邮件地址\n（可选）\n。\n\n\n注册用户\n\n\n请求描述\n\n\n注册一个新用户与创建一个新的普通对象之间的不同点在于其username和password字段都是必要的，password字段会以与其他的字段不一样的方式处理，它在保存时会被加密而且永远不会被返回给任何来自客户端的请求。\n\n\n在你的应用设置页面中，你可以向\nBmob\n来请求认证邮件地址，这项设置启用了的话，所有用户在注册时填写email这个Key的值，并且邮箱有效的情况下，就会向这个邮箱地址发出一封邮件，邮件中会包含一个来自\nBmob\n的邮箱验证的链接，当你的用户查收邮件并点击这个链接后，这个用户emailVerified的Key的值会置为True，你可以在emailVerified字段上查看用户的email是否已经通过验证了。\n\n\n为了注册一个新的用户，需要向user路径发送一个POST请求，你可以加入一个甚至多个新的字段。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/users\n\n\n\n\n\n\nmethod ：POST\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  \nusername\n : username,\n  \npassword\n : password,\n  key1:value1,\n  key2:value2,\n  ...\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 201 Created\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n返回的主体是一个JSON对象，包含objectId，表示唯一的用户, createdAt时间戳表示用户注册时间, sessionToken可以被用来认证更新或删除这名用户信息的请求。\n\n\n{\n    \ncreatedAt\n: YYYY-mm-dd HH:ii:ss,\n    \nobjectId\n: objectId,\n    \nsessionToken\n: sessionToken\n}\n\n\n\n\n例子\n\n\n例如，创建一个有家庭电话字段的新用户:\n\n\ncurl -X POST \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nusername\n:\ncooldude6\n,\npassword\n:\nb_m7!-o8\n,\nphone\n:\n415-392-0202\n}' \\\n    https://api.bmob.cn/1/users\n\n\n\n\n其返回值如下：\n\n\n{\n    \ncreatedAt\n: \n2011-11-07 20:58:34\n,\n    \nobjectId\n: \nKc3M222J\n,\n    \nsessionToken\n: \npnktnjyb996sj4p156gjtp4im\n\n}\n\n\n\n\n这里需要注意一点的是，有些时候你可能需要在用户注册时发送一封验证邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在设置-\n邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在注册时自动发动一封验证邮件给用户。\n\n\n\n\n使用手机号码一键注册或登陆\n\n\n请求描述\n\n\nBmob\n 支持让用户直接输入手机号码进行注册，如果手机号码存在则自动登陆。\n\n\n请求\n\n\n\n\n\n\nurl ： https://api.bmob.cn/1/users\n\n\n\n\n\n\nmethod ：POST\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  mobilePhoneNumber:phoneNumber,\n  smsCode:smsCode\n  key1 : value1,\n  key2 : value2,\n  ...\n}\n\n\n\n\n其中 \nmobilePhoneNumber\n 就是手机号码，而 \nsmsCode\n 是使用 \n请求短信验证码API\n发送到用户手机上的 6位验证码字符串。如果是新用户且不传入 username，默认用户名将是手机号码。\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nusername\n: username,\n  \nmobilePhoneNumber\n: mobilePhoneNumber,\n  \nmobilePhoneVerified\n: boolValue,\n  \ncreatedAt\n: YYYY-mm-dd HH:ii:ss,\n  \nupdatedAt\n: YYYY-mm-dd HH:ii:ss,\n  \nobjectId\n: objectId,\n  \nsessionToken\n: sessionToekn,\n  key1:value1,\n  key2:value2,\n  ...\n}\n\n\n\n\n如果是第一次注册，将默认设置_User表的 \nmobilePhoneVerified\n 属性为 true。\n\n\n例子\n\n\n创建一个用户如下：\n\n\ncurl -X POST \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nmobilePhoneNumber\n:\n185xxxxxxxx\n,\nsmsCode\n:\n6位短信验证码\n}' \\\n    https://api.bmob.cn/1/users\n\n\n\n\n返回值\n\n\n{\n  \nusername\n: \n185xxxxxxxx\n,\n  \nmobilePhoneNumber\n: \n185xxxxxxxx\n,\n  \nmobilePhoneVerified\n: true,\n  \ncreatedAt\n: \n2011-11-07 20:58:34\n,\n  \nupdatedAt\n: \n2011-11-07 20:58:34\n,\n  \nobjectId\n: \nKc3M222J\n,\n  \nsessionToken\n: \npnktnjyb996sj4p156gjtp4im\n\n}\n\n\n\n\n登录用户\n\n\n请求描述\n\n\n你的用户注册之后，你需要让他们用自己的用户名和密码登录，为了做到这一点，发送一个HTTP GET请求到 \n/1/login\n ，加上username和password作为URL编码后的参数。\n\n\n另外，username 支持传入_User表的username或email或mobilePhoneNumber字段的值，作为登录的扩展功能，以实现邮箱和密码、手机号和密码登录功能。\n\n\n除了有用户名或邮箱或手机号码和密码登录的功能，\nBmob\n 还支持使用手机号码和验证码一键快速登录的功能，而 \nsmsCode\n 是使用 \n请求短信验证码API\n发送到用户手机上的 6位验证码字符串：\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/login\n\n\n\n\n\n\nparams:\n\n\n\n\n\n\n用户名密码登陆\n\nusername\n=username(也可以使用email或者mobilePhoneNumber)\n\npassword\n=password\n\n手机号验证码\n\nmobilePhoneNumber\n=phoneNumber\n\nsmsCode\n:smsCode\n\n\n\n\n\n\n\n\nmethod ：GET\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nusername\n: username,\n  \nmobilePhoneNumber\n: mobilePhoneNumber,\n  \nmobilePhoneVerified\n: boolValue,\n  \ncreatedAt\n: YYYY-mm-dd HH:ii:ss,\n  \nupdatedAt\n: YYYY-mm-dd HH:ii:ss,\n  \nobjectId\n: objectId,\n  \nsessionToken\n: sessionToekn,\n  key1:value1,\n  key2:value2,\n  ...\n}\n\n\n\n\n例子\n\n\n使用用户名加密码登陆\n\n\ncurl -X GET\n    \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'username=cooldude6' \\\n    --data-urlencode 'password=b_m7!-o8' \\\n    https://api.bmob.cn/1/login\n\n\n\n\n使用手机号加验证码登陆\n\n\ncurl -X GET\n    \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'mobilePhoneNumber=185xxxxxxxx' \\\n    --data-urlencode 'smsCode=6位短信验证码' \\\n    https://api.bmob.cn/1/login\n\n\n\n\n获取当前用户\n\n\n请求描述\n\n\n当注册一个用户后，你可以通过发送一个HTTP GET请求到用户注册成功时返回的HTTP请求头中的Location的URL获取用户的信息。比如，为了获取上面注册成功的用户\n\n\n请求\n\n\n\n\n\n\nurl ： https://api.bmob.cn/1/users/objectID\n\n\n\n\n\n\nmethod ：GET\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n    \nusername\n: username,\n    \ncreatedAt\n: YYYY-mm-dd HH:ii:ss,\n    \nupdatedAt\n: YYYY-mm-dd HH:ii:ss,\n    \nobjectId\n: objectId\n}\n\n\n\n\n例子\n\n\n获取objectId为Kc3M222J的用户可以使用以下请求。\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    https://api.bmob.cn/1/users/Kc3M222J\n\n\n\n\n更新用户\n\n\n请求描述\n\n\n在通常的情况下，我们都不希望用户去修改自己的数据，但可以通过认证让用户去做这件事，用户必须加入一个 \nX-Bmob-Session-Token\n 头部来请求这个更新操作，这个sessionToken在注册和登录时都会返回。该值的有效期为1年。\n\n\n为了改动一个用户已经有的数据，需要对这个用户的URL发送一个HTTP PUT请求，任何你没有指定的key会保持不变，所以你可以只改动用户信息中的一部分，username和password可以更改，但是新的username不能重复。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/users/objectId\n\n\n\n\n\n\nmethod ：PUT\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\nX-Bmob-Session-Token: sessionToken\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  key1 : value1,\n  key2 : value2,\n  ...\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n    \nupdatedAt\n: YYYY-mm-dd HH:ii:ss\n}\n\n\n\n\n例子\n\n\n比如，如果我们想对 cooldude6 的电话做出一些改动，可以采用如下请求，\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nX-Bmob-Session-Token: pnktnjyb996sj4p156gjtp4im\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nphone\n:\n415-369-6201\n}' \\\n    https://api.bmob.cn/1/users/Kc3M222J\n\n\n\n\n在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发动一封验证邮件给用户。\n\n\n删除用户\n\n\n请求描述\n\n为了在\nBmob\n上删除一个用户，可以向用户的URL上发送一个DELETE请求，前提是你必须提供一个X-Bmob-Session-Token在Http请求头以便认证授权。\n\n\n当然了，你也可以直接把MasterKey传入到X-Bmob-Master-Key中, 这个就可以实现在不需要提供SessionToken的情形下更新和删除用户了，但希望只在开发环境下使用，不要把MasterKey发布出去。\n\n\n请求\n\n\n\n\n\n\nurl ： https://api.bmob.cn/1/users/objectId\n\n\n\n\n\n\nmethod ：DELETE\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\nX-Bmob-Session-Token: sessionToken\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nmsg\n: \nok\n\n}\n\n\n\n\n例子\n\n\n删除objectId为g7y9tkhB7O的用户。\n\n\ncurl -X DELETE \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nX-Bmob-Session-Token: pnktnjyb996sj4p156gjtp4im\n \\\n    https://api.bmob.cn/1/users/g7y9tkhB7O\n\n\n\n\n查询用户\n\n\n请求描述\n\n\n你可以一次获取多个用户，只要向用户的根URL发送一个GET请求，没有任何URL参数的话，可以简单地列出所有用户。\n\n\n所有的对普通对象的查询选项都适用于对用户对象的查询，所以可以查看 \n查询\n 部分来获取详细信息。\n\n\nUser表是一个特殊的表，专门用于存储用户对象。在浏览器端，你会看到一个User表旁边有一个小人的图标。\n\n\n请求\n\n\n\n\n\n\nurl ： https://api.bmob.cn/1/users\n\n\n\n\n\n\nmethod ：GET\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  {\n    \nresults\n: [\n        {\n            \nusername\n: username,\n            \ncreatedAt\n: YYYY-mm-dd HH:ii:ss,\n            \nupdatedAt\n: YYYY-mm-dd HH:ii:ss,\n            \nobjectId\n: objectId,\n            key1:value1,\n            ...\n        },\n        {\n            \nusername\n: username,\n            \ncreatedAt\n: YYYY-mm-dd HH:ii:ss,\n            \nupdatedAt\n: YYYY-mm-dd HH:ii:ss,\n            \nobjectId\n: objectId,\n            key1:value1,\n            ...\n        },\n        ...\n    ]\n}\n}\n\n\n\n\n例子\n\n\n获取当前用户表的所有用户信息。\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    https://api.bmob.cn/1/users\n\n\n\n\n密码重置\n\n\n共提供了3种方法，分别是email重置、短信验证码重置、旧密码重置。\n\n\nEamil重置\n\n\n请求描述\n\n\n你可以使用这项功能，前提是用户将email与他们的账户关联起来，如果要重设密码，发送一个POST请求到 \n/1/requestPasswordReset\n, 同时在request的body部分带上email字段。\n\n\n密码重置流程如下：\n\n\n\n\n用户输入他们的电子邮件，请求重置自己的密码。\n\n\nBmob向他们的邮箱发送一封包含特殊的密码重置连接的电子邮件，此邮件的模板可在Bmob后台中修改。\n\n\n用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，输入一个新的密码。\n\n\n用户的密码已被重置为新输入的密码。\n\n\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/requestPasswordReset\n\n\n\n\n\n\nmethod ：POST\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n    \nemail\n:emailAdress\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nmsg\n: \nok\n\n}\n\n\n\n\n例子\n\n\n重置用户邮箱为coolguy@iloveapps.com的用户密码。\n\n\ncurl -X POST \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nemail\n:\ncoolguy@iloveapps.com\n}' \\\n    https://api.bmob.cn/1/requestPasswordReset\n\n\n\n\n使用短信验证码进行密码重置\n\n\n请求描述\n\n\n如果用户有绑定了手机号码，就可以通过手机验证码短信来实现使用手机号码找回密码的功能，先调用 \n请求短信验证码API\n会将验证码发送到用户手机上，用户收到验证码并输入后，调用PUT /1/resetPasswordBySmsCode/smsCode 来为用户设置新的密码。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/resetPasswordBySmsCode/smsCode\n\n\n\n\n\n\nmethod ：PUT\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  \npassword\n: \nnew password\n\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n    {\nmsg\n: \nok\n}\n\n\n\n\n例子\n\n\n以下为短信验证码重置样例。\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\npassword\n: \ntestPass\n}' \\\n    https://api.bmob.cn/1/resetPasswordBySmsCode/123987\n\n\n\n\n提供旧密码方式安全修改用户密码\n\n\n请求描述\n\n\n很多开发者希望让用户输入一次旧密码做一次校验，旧密码正确才可以修改为新密码，因此我们提供了一个单独的 API \nPUT /1/updatePassword\n 来安全地修改用户密码。\n\n\n注意：仍然需要传入 X-Bmob-Session-Token，也就是登录用户才可以修改自己的密码。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/updateUserPassword/objectId\n\n\n\n\n\n\nmethod ：PUT\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\nX-Bmob-Session-Token: sessionToken\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  \noldPassword\n: \n用户的老密码\n,\n  \nnewPassword\n: \n用户的新密码\n\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nmsg\n: \nok\n\n}\n\n\n\n\n例子\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nX-Bmob-Session-Token: pnktnjyb996sj4p156gjtp4im\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\noldPassword\n: \n123\n,\nnewPassword\n: \n456\n}' \\\n    https://api.bmob.cn/1/updateUserPassword/g7y9tkhB7O\n\n\n\n\ng7y9tkhB7O：为当前登录用户的objectId。\npnktnjyb996sj4p156gjtp4im:用户sessionToken\n\n\n邮箱验证\n\n\n设置邮件验证是一个可选的应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会默认被设为false，如果应用设置中开启了邮箱认证功能，\nBmob\n会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.\n\n\nemailVerified 字段有 3 种状态可以考虑：\n\n\ntrue\n : 用户可以点击邮件中的链接通过\nBmob\n来验证地址，一个用户永远不会在新创建这个值的时候出现emailVerified为true。\n\n\nfalse\n : 用户(User)对象最后一次被刷新的时候, 用户并没有确认过他的邮箱地址, 如果你看到emailVerified为false的话，你可以考虑刷新 用户(User)对象。\n\n\nmissing\n : 用户(User)对象已经被创建，但应用设置并没有开启邮件验证功能； 或者用户(User)对象没有email邮箱。\n\n\n请求描述\n\n\n发送到用户邮箱验证的邮件会在一周内失效，可以通过调用 \n/1/requestEmailVerify\n 来强制重新发送。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/requestEmailVerify\n\n\n\n\n\n\nmethod ：POST\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  \nemail\n:emailAddress\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nmsg\n: \nok\n\n}\n\n\n\n\n例子\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\nemail\n:\ncoolguy@iloveapps.com\n}' \\\n  https://api.bmob.cn/1/requestEmailVerify\n\n\n\n\n用户账户连接\n\n\nBmob允许你连接你的用户到第三方账户服务系统，比如新浪微博和QQ，这样就允许您的用户用已经存在的第三方账户直接登录您的App。通过注册或者更新的用户信息的功能，使用 \nauthData\n 字段来保存第三方服务的授权信息就可以做到。一旦用户关联了某个第三方账户，\nauthData\n 将被存储到您的Bmob的用户信息里，并通过登录即可重新获取到。\n\n\nauthData\n 是一个普通的 JSON 对象，它所要求的key根据第三方账户服务不同而不同，具体要求见下面。每种情况下，你都需要自己负责完成整个授权过程 (一般是通过 OAuth 协议，1.0 或者 2.0) 通过连接的API来获取授权信息。\n\n\n新浪微博的 \nauthData\n 内容:\n\n\n{\n  \nauthData\n: {\n    \nweibo\n: {\n      \nuid\n: \n123456789\n,\n      \naccess_token\n: \n2.00ed6eMCV9DWcBcb79e8108f8m1HdE\n,\n      \nexpires_in\n: 1564469423540\n    }\n  }\n}\n\n\n\n\n腾讯QQ的 \nauthData\n 内容:\n\n\n{\n  \nauthData\n: {\n    \nqq\n: {\n      \nopenid\n: \n2345CA18A5CD6255E5BA185E7BECD222\n,\n      \naccess_token\n: \n12345678-SM3m2avZxh5cjJmIrAfx4ZYyamdofM7IjU\n,\n      \nexpires_in\n: 1382686496\n    }\n  }\n}\n\n\n\n\n匿名用户 (Anonymous user) 的 authData 内容:\n\n\n{\n  \nanonymous\n: {\n    \nid\n: \nrandom UUID with lowercase hexadecimal digits\n\n  }\n}\n\n\n\n\n注册和登录\n\n\n请求描述\n\n\n使用一个第三方账户连接服务来注册用户并登录，同样使用POST请求/1/users，只是需要提供authData字段。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/users\n\n\n\n\n\n\nmethod ：POST\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n   \nauthData\n: {\n       platform: {\n          \nuid\n: uid,\n          \naccess_token\n: accessToken,\n          \nexpires_in\n: expiresIn\n        }\n    }\n }\n\n\n\n\n成功时响应\n\n\nBmob 会校验提供的 authData 是否有效，并检查是否已经有一个用户连接了这个 authData 服务。如果已经有用户存在并连接了同一个 authData，那么Http响应头将返回 200 OK 和详细信息 (包括用户的 sessionToken):\n\n\nStatus: 200 OK\nLocation: https://api.bmob.cn/1/users/objectId\n\n\n\n\n应答的 body 类似:\n\n\n{\n  \nusername\n: username,\n  \ncreatedAt\n: YYYY-mm-dd HH:ii:ss,\n  \nupdatedAt\n: YYYY-mm-dd HH:ii:ss,\n  \nobjectId\n: objectId,\n  \nsessionToken\n: sessionToken,\n  \nauthData\n: {\n       platform: {\n          \nuid\n: uid,\n          \naccess_token\n: accessToken,\n          \nexpires_in\n: expiresIn\n        }\n    }\n  }\n}\n\n\n\n\n如果用户还没有连接到这个帐号，则你会收到 201 Created 的应答状态码，标识新的用户已经被创建:\n\n\nStatus: 201 Created\nLocation: https://api.bmob.cn/1/users/objectId\n\n\n\n\n应答内容包括 objectId,createdAt,sessionToken 以及一个自动生成的随机 username\n\n\n{\n  \nusername\n: username,\n  \ncreatedAt\n: YYYY-mm-dd HH:ii:ss,\n  \nobjectId\n: objectId,\n  \nsessionToken\n: sessionToken,\n}\n\n\n\n\n例子\n\n\n例如，使用新浪微博账户注册或者登录用户:\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n     \nauthData\n: {\n       \nweibo\n: {\n          \nuid\n: \n123456789\n,\n          \naccess_token\n: \n2.00ed6eMCV9DWcBcb79e8108f8m1HdE\n,\n          \nexpires_in\n: 1564469423540\n        }\n      }\n    }' \\\n  https://api.bmob.cn/1/users\n\n\n\n\n连接\n\n\n请求描述\n\n\n连接一个现有的用户到新浪微博或者腾讯QQ帐号，可以通过发送一个 PUT 请求附带 authData 字段到以上Location返回的用户URL做到。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/users/objectId\n\n\n\n\n\n\nmethod ：PUT\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\nX-Bmob-Session-Token: sessionToken\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n   \nauthData\n: {\n       platform: {\n          \nuid\n: uid,\n          \naccess_token\n: accessToken,\n          \nexpires_in\n: expiresIn\n        }\n    }\n }\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nusername\n: username,\n  \ncreatedAt\n: YYYY-mm-dd HH:ii:ss,\n  \nupdatedAt\n: YYYY-mm-dd HH:ii:ss,\n  \nobjectId\n: objectId,\n  \nsessionToken\n: sessionToken,\n  \nauthData\n: {\n       platform: {\n          \nuid\n: uid,\n          \naccess_token\n: accessToken,\n          \nexpires_in\n: expiresIn\n        }\n    }\n  }\n}\n\n\n\n\n例子\n\n\n例如，连接一个用户到腾讯QQ帐号发起的请求类似这样:\n\n\ncurl -X PUT \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nX-Bmob-Session-Token: pnktnjyb996sj4p156gjtp4im\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nauthData\n: {\n           \nqq\n: {\n              \nopenid\n: \n2345CA18A5CD6255E5BA185E7BECD222\n,\n              \naccess_token\n: \n12345678-SM3m2avZxh5cjJmIrAfx4ZYyamdofM7IjU\n,\n              \nexpires_in\n: 1382686496\n            }\n        }\n      }' \\\n  https://api.bmob.cn/1/users/Kc3M222J\n\n\n\n\n完成连接后，你可以使用匹配的 authData 来认证他们。\n\n\n断开连接\n\n\n请求描述\n\n\n断开一个现有用户到某个服务，可以发送一个 PUT 请求设置 authData 中对应的服务为 null 来做到。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/users/objectId\n\n\n\n\n\n\nmethod ：PUT\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\nX-Bmob-Session-Token: sessionToken\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n    \nauthData\n: {\n          platform:null\n    }\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nusername\n: username,\n  \ncreatedAt\n: YYYY-mm-dd HH:ii:ss,\n  \nupdatedAt\n: YYYY-mm-dd HH:ii:ss,\n  \nobjectId\n: objectId,\n  \nsessionToken\n: sessionToken,\n  \nauthData\n: {\n       platform: NULL\n    }\n  }\n}\n\n\n\n\n例子\n\n\n例如，取消新浪微博关联:\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nX-Bmob-Session-Token: pnktnjyb996sj4p156gjtp4im\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nauthData\n: {\n          \nweibo\n : null\n        }\n      }' \\\n  https://api.bmob.cn/1/users/Kc3M222J\n\n\n\n\n文件管理\n\n\nBmob的新版文件采用了cdn。\n\n\n整个文件上传\n\n\n请求描述\n\n\n请求\n\n\n\n\n\n\nurl ： https://api.bmob.cn/2/files/fileName，可以选择BASE64加密\n\n\n\n\n\n\nmethod ：POST\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nContent-Type 不同类型文件使用不同的值，可以参考：\nhttp://tool.oschina.net/commons\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: content-Type\n\n\n\n\n\n\nbody:\n\n\n\n\n相应的文本或者二进制流\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n返回的主体是一个JSON对象，包含：文件名（filename）、cdn信息（cdnname）、文件地址（url）。\n\n\n{\n  \nfilename\n: filename,\n  \nurl\n: url,\n  \ncdn\n:cdnname\n}\n\n\n\n\n例子\n\n\n上传一个 hello.txt 文件实现方法如下（-d的值是文件内容）：\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: text/plain\n \\\n  -d 'Hello, World!' \\\n  https://api.bmob.cn/2/files/hello.txt\n\n\n\n\n上传当前文件夹下的图片 myPicture.jpg 实现方法如下（--data-binary的值是文件二进制内容）：\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: image/jpeg\n \\\n  --data-binary '@myPicture.jpg' \\\n  https://api.bmob.cn/2/files/myPicture.jpg\n\n\n\n\n返回的内容，此时使用http://bmob-cdn-24.b0.upaiyun.com/2016/04/14/9306f2e74090d668801eac8814b3f56f.jpg 即可访问。\n\n\n{\n  \nfilename\n: \nmyPicture.jpg\n,\n  \nurl\n: \nhttp://bmob-cdn-24.b0.upaiyun.com/2016/04/14/9306f2e74090d668801eac8814b3f56f.jpg\n,\n  \ncdn\n:\nupyun\n\n}\n\n\n\n\n上传完成后，你还可以把上传后的文件对象关联到某行记录中，相应的body格式为：\n\n\n{\n    keyOfFile:{\n    \n__type\n: \nFile\n,\n        \ngroup\n: \nupyun\n,\n        \nfilename\n: fileName,\n        url: url\n    }\n}\n\n\n\n\n例子如下：\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nscore\n:73453, \nfile\n:{\n        \n__type\n: \nFile\n,\n        \ngroup\n: \ngroup1\n,\n        \nfilename\n: \nmyPicture.jpg\n,\n        url: \nhttp://bmob-cdn-24.b0.upaiyun.com/2016/04/14/9306f2e74090d668801eac8814b3f56f.jpg\n\n    }}' \\\nhttps://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\n删除文件\n\n\n请求描述\n\n\n该接口可删除已经上传的文件。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/2/files/cdnName/url ，其中cdnName是指上传文件后再body返回的cdnname,其中URL指的是上传文件后在body中返回的url除去域名之后的字符串。\n\n\n\n\n\n\nmethod ：DELETE\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nmsg\n: \nok\n\n}\n\n\n\n\n例子\n\n\n如下为删除上传例子中的jpg文件\n\n\ncurl -X DELETE \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  https://api.bmob.cn/2/files/upyun/2016/04/14/9306f2e74090d668801eac8814b3f56f.jpg\n\n\n\n\n其中2016/04/14/9306f2e74090d668801eac8814b3f56f.jpg是文件上传时返回的url除去域名之后的字符串，upyun是上传时返回的cdn。\n\n\n删除文件不会删除文件关联的行记录中的文件列的值，需要自行通过更新行来删除关联。\n\n\n批量删除文件\n\n\n请求描述\n\n该接口可批量删除已经上传的文件。此操作不可逆，已经删除成功的文件不可恢复。\n\n\n请求\n\n\n\n\nurl :https://api.bmob.cn/2/cdnBatchDelete\n\n\nmethod : POST\n\n\nheader:\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody\ncdnname为上传文件是返回的cdnname，url1，url2为上传时返回的url除去域名后的字符串。\n\n\n\n\n{\n  \ncdnname\n:[\nurl1\n,\nurl2\n]\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nmsg\n: \nok\n\n}\n\n\n\n\n失败时响应\n\ncdnname为删除失败的cdn名称，url1，url2为删除失败的url地址。\n\n\n{\n  \ncode\n: 154,\n  \nerror\n: \nerror info\n,\n  \nfail\n: {\n    \ncdnname\n: [\n      \nurl1\n,\n      \nurl2\n\n    ]\n  }\n}\n\n\n\n\n例子\n\n\n如下为删除上传例子中的jpg文件\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n   {\n    \nupyun\n:[\n2016/04/14/9306f2e74090d668801eac8814b3f56f.jpg\n,\n2016/04/14/ycf2f2e74090d668801eac88145523f.jpg\n],\n}\n}'\\\n  https://api.bmob.cn/2/cdnBatchDelete\n\n\n\n\n删除文件不会删除文件关联的行记录中的文件列的值，需要自行通过更新行来删除关联。\n\n\nACL和角色\n\n\n数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看\nBmob数据与安全页面\n，了解Bmob如何保护数据安全）。\n\n\n其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。\n\n\n大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：\n\n\n\n\n对于私有数据，读写权限可以只局限于数据的所有者。\n\n\n对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。\n\n\n对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。\n\n\n属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。\n\n\n一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。\n\n\n\n\nACL的格式\n\n\n在Bmob中，ACL是按JSON对象格式（key-value）来表示的。这个JSON对象的key是objectId（用户表某个用户对应的objectId）或者是 *(表示公共的访问权限)，ACL 的值是 \"读和写的权限\", 这个JSON对象的key总是权限名, 而这些key的值总是 true。\n\n\n如果您想让一个 id 为 \"Kc3M222k\" 的用户有读和写一条数据的权限, 而且这个数据应该可以被全部人读取的话，这个ACL的表达方式如下，只要将该值设置到对应数据的ACL字段中即可：\n\n\n{\n  \nKc3M222k\n: {\n    \nread\n: true,\n    \nwrite\n: true\n  },\n  \n*\n: {\n    \nread\n: true\n  }\n}\n\n\n\n\n角色和相关操作\n\n\n在很多情况下，你需要定义一些用户具有某种相同的数据操作权限，而另外一群用户具有另外一种相同的数据操作权限，这时你就可以使用到Bmob的角色（对应Bmob在Web提供的Role表、SDK中的BmobRole类）功能，设置不同的用户组不同的操作权限。角色表有三个特殊字段：\n\n\nname\n : 必须字段，表示角色名称,而且只允许被设置一次（命名必须由字母, 空格, 减号或者下划线构成）；\n\n\nusers\n :一个指向一系列用户的关系, 这些用户会继承角色的权限；\n\n\nroles\n : 一个指向一系列子角色的关系, 这些子关系会继承父角色所有的权限。\n\n\n而创建角色、更新角色、删除角色本质就是对_Role表进行操作，因为该表是固定的，所以我们将请求的URL设置为https://api.bmob.cn/1/roles，具体操作如下。_Role表中含 \nusers\n和 \nroles\n字段，其中 \nusers\n 字段指向的是 \n_User\n 表，在该字段下的用户记录具备该角色的读写权限，而 \nroles\n 字段指向的是 \n_Role\n 表，在该字段下的角色记录都将继承该角色的权限。\n\n\n创建角色\n\n\n创建一个新角色的方法如下（固定POST数据到https://api.bmob.cn/1/roles中，且必须提供 \nname\n 字段）：\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nname\n: \nModerators\n,\n        \nACL\n: {\n          \n*\n: {\n            \nread\n: true\n          }\n        }\n      }' \\\n  https://api.bmob.cn/1/roles\n\n\n\n\n如果你要创建一个包括了“用户和子角色”的角色，实现方式如下：\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nname\n: \nModerators\n,\n        \nACL\n: {\n          \n*\n: {\n            \nread\n: true\n          }\n        },\n        \nroles\n: {\n          \n__op\n: \nAddRelation\n,\n          \nobjects\n: [\n            {\n              \n__type\n: \nPointer\n,\n              \nclassName\n: \n_Role\n,\n              \nobjectId\n: \nFe441wZ5\n\n            }\n          ]\n        },\n        \nusers\n: {\n          \n__op\n: \nAddRelation\n,\n          \nobjects\n: [\n            {\n              \n__type\n: \nPointer\n,\n              \nclassName\n: \n_User\n,\n              \nobjectId\n: \nKc3M222k\n\n            }\n          ]\n        }\n      }' \\\n  https://api.bmob.cn/1/roles\n\n\n\n\n当创建成功后返回HTTP如下：\n\n\nStatus: 201 Created\nLocation: https://api.bmob.cn/1/roles/51e3812D\n\n\n\n\n获取角色\n\n\n获取角色对象的方法如下：\n\n\ncurl -X GET \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  https://api.bmob.cn/1/roles/51e3812D\n\n\n\n\n响应结果如下：\n\n\n{\n  \ncreatedAt\n: \n2012-04-28 17:41:09\n,\n  \nobjectId\n: \n51e3812D\n,\n  \nupdatedAt\n: \n2012-04-28 17:41:09\n,\n  \nACL\n: {\n    \n*\n: {\n      \nread\n: true\n    },\n    \nrole:Administrators\n: {\n      \nwrite\n: true\n    }\n  },\n  \nname\n: \nModerators\n\n}\n\n\n\n\n注意 users 和 roles 关系无法在 JSON 结果中看到, 您需要使用 $relatedTo 操作符来查询。\n\n\n更新角色\n\n\n更新角色时，一个很重要的一点是： \nname\n 字段不可以更改。添加和删除 \nusers\n 和 \nroles\n 可以通过使用 AddRelation 和 RemoveRelation 操作符进行。\n\n\n如给 \"Moderators\" 角色增加 2 个用户，实现如下:\n\n\ncurl -X PUT \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nusers\n: {\n          \n__op\n: \nAddRelation\n,\n          \nobjects\n: [\n            {\n              \n__type\n: \nPointer\n,\n              \nclassName\n: \n_User\n,\n              \nobjectId\n: \neba635d9\n\n            },\n            {\n              \n__type\n: \nPointer\n,\n              \nclassName\n: \n_User\n,\n              \nobjectId\n: \n51dfb8bd\n\n            }\n          ]\n        }\n      }' \\\n  https://api.bmob.cn/1/roles/51e3812D\n\n\n\n\n删除 \"Moderrators\" 的一个子角色的实现如下：\n\n\ncurl -X PUT \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nroles\n: {\n          \n__op\n: \nRemoveRelation\n,\n          \nobjects\n: [\n            {\n              \n__type\n: \nPointer\n,\n              \nclassName\n: \n_Role\n,\n              \nobjectId\n: \neba635d9\n\n            }\n          ]\n        }\n      }' \\\n  https://api.bmob.cn/1/roles/51e3812D\n\n\n\n\n删除角色\n\n\n删除角色这里有一个需要注意的是：需要传入 X-Bmob-Session-Token ，即对这条数据有操作权限的用户SessionToken。实现如下：\n\n\ncurl -X DELETE \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nX-Bmob-Session-Token: pnktnjyb996sj4p156gjtp4im\n \\\n  https://api.bmob.cn/1/roles/51e3812D\n\n\n\n\n角色的使用\n\n\n设置一条数据的角色权限，需要在ACL中把Key的名字设置为 “\nrole:\n + 角色名称” 。如限制一条数据可以被在 \"Members\" 里的任何人读到, 而且可以被它的创建者（objectId为\nf1766d0b42\n）和任何有 \"Moderators\" 角色的人所修改, 实现方式如下:\n\n\n{\n  \nf1766d0b42\n: {\n    \nwrite\n: true\n  },\n  \nrole:Members\n: {\n    \nread\n: true\n  },\n  \nrole:Moderators\n: {\n    \nwrite\n: true\n  }\n}\n\n\n\n\n如果这个用户和 \"Moderators\" 本身就是 \"Members\" 的子角色和用户，那么，您不必为创建的用户和 \"Moderators\" 指定读的权限，因为它们都会继承授予 \"Members\" 的权限。\n\n\n角色的继承\n\n\n一个角色可以包含另一个，可以为 2 个角色建立一个父-子关系。 这个关系的结果就是任何被授予父角色的权限隐含地被授予子角色。\n\n\n这样的关系类型通常在用户管理的内容类的应用上比较常见, 比如在论坛中，有一些少数的用户是 \"管理员（Administartors）\", 有最高的权限，可以调整系统设置、 创建新的论坛等等。 另一类用户是 \"版主（Moderators）\"，他们可以对用户发帖的内容进行管理。可见，任何有管理员权限的人都应该有版主的权限。为建立起这种关系, 您应该把 \"Administartors\" 的角色设置为 \"Moderators\" 的子角色, 具体来说就是把 \"Administrators\" 这个角色加入 \"Moderators\" 对象的 roles 关系之中，实现如下：\n\n\n\ncurl -X PUT \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nroles\n: {\n          \n__op\n: \nAddRelation\n,\n          \nobjects\n: [\n            {\n              \n__type\n: \nPointer\n,\n              \nclassName\n: \n_Role\n,\n              \nobjectId\n: \nAdministratorsRoleObjectId\n\n            }\n          ]\n        }\n      }' \\\n  https://api.bmob.cn/1/roles/\nModeratorsRoleObjectId\n\n\n\n\n\n地理位置\n\n\nBmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询。你可以在查询中添加一个GeoPoint的对象查询。你可以实现轻松查找出离当前用户最接近的信息或地点的功能。\n\n\n创建地理位置对象\n\n\n在表中添加一个地理位置的列，只需要在对应列值满足以下格式即可。\n\n\n{\n  key : {\n    \n__type\n: \nGeoPoint\n,\n    \nlatitude\n: latitudeValue,\n    \nlongitude\n: longitude\n  }\n}\n\n\n\n\n例如，如果需要在 \nGameScore\n 的特定对象中加上地理位置，其请求如下：\n\n\ncurl -X PUT \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\nlocation\n:{            \n            \n__type\n: \nGeoPoint\n,\n            \nlatitude\n: 50.934755,\n            \nlongitude\n: 24.52065\n        }}' \\\n  https://api.bmob.cn/1/classes/GameScore/e1kXT22L\n\n\n\n\n查询地理位置信息\n\n\n现在你有一系列的对象对应的地理坐标，如果能发现哪些对象离指定的点近就好了，这可以通过GeoPoint数据类型加上在查询中使用$nearSphere做到。查询的 \nwhere\n 参数值格式如下。\n\n\n{\n  key: {\n    \n$nearSphere\n: {\n      \n__type\n: \nGeoPoint\n,\n      \nlatitude\n: latitudeValue,\n      \nlongitude\n: longitudeValue\n    }\n  }\n}\n\n\n\n\n例如，获取离用户最近的10个地点应该看起来像下面这个样子\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'limit=10' \\\n    --data-urlencode 'where={\n    \nlocation\n: {\n        \n$nearSphere\n: {\n            \n__type\n: \nGeoPoint\n,\n            \nlatitude\n: 30.0,\n            \nlongitude\n: -20.0\n        }\n      }\n    }' \\\n    https://api.bmob.cn/1/classes/PlaceObject\n\n\n\n\n这操作会按离纬度30.0，经度-20.0的距离排序返回一系列的结果，第一个就是最近的对象。(注意如果一个特定的order参数是给定了的话，它会覆盖按距离排序的结果)，例如，下面是两个上面的查询操作返回的结果：\n\n\n{\n    \nresults\n: [\n    {\n        \nlocation\n: {\n             \n__type\n: \nGeoPoint\n,\n            \nlatitude\n: 40.0,\n            \nlongitude\n: -30.0\n        },\n        \nupdatedAt\n: \n2011-12-06 22:36:04\n,\n        \ncreatedAt\n: \n2011-12-06 22:36:04\n,\n        \nobjectId\n: \ne1kXT22L\n\n        },\n        {\n        \nlocation\n: {\n             \n__type\n: \nGeoPoint\n,\n            \nlatitude\n: 60.0,\n            \nlongitude\n: -20.0\n        },\n        \nupdatedAt\n: \n2011-12-06 22:36:26\n,\n        \ncreatedAt\n: \n2011-12-06 22:36:26\n,\n        \nobjectId\n: \n51e3a2a8e4b015ead4d95dd9\n\n        }\n    ]\n}\n\n\n\n\n为了限定搜索的最大距离范围，需要加入 \n$maxDistanceInMiles(英里)\n 和 \n$maxDistanceInKilometers(公里d)\n或者 \n$maxDistanceInRadians(弧度)\n 参数来限定，如果不加，则默认是100KM的半径。比如要找的半径在10公里内的话:\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\n        \nlocation\n: {\n            \n$nearSphere\n: {\n                \n__type\n: \nGeoPoint\n,\n                \nlatitude\n: 30.0,\n                \nlongitude\n: -20.0\n            },\n        \n$maxDistanceInKilometers\n: 10.0\n        }\n    }' \\\n    https://api.bmob.cn/1/classes/PlaceObject\n\n\n\n\n同样作查询寻找在一个特定的范围里面的对象也是可以的，为了找到在一个矩形区域里的对象，按下面的格式加入一个约束 \n{\"$within\": {\"$box\": [southwestGeoPoint, northeastGeoPoint]}}\n：\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n    -G \\\n    --data-urlencode 'where={\n        \nlocation\n: {\n            \n$within\n: {\n                \n$box\n: [\n                    {\n                        \n__type\n: \nGeoPoint\n,\n                        \nlatitude\n: 37.71,\n                        \nlongitude\n: -122.53\n                    },\n                    {\n                        \n__type\n: \nGeoPoint\n,\n                        \nlatitude\n: 30.82,\n                        \nlongitude\n: -122.37\n                    }\n                ]\n            }\n        }\n    }' \\\n    https://api.bmob.cn/1/classes/PizzaPlaceObject\n\n\n\n\n注意事项\n\n\n关于地理位置的有一些问题是值得留意的:\n\n\n\n\n每一个表\n只能\n一个地理位置列，每一个对象\n只能\n有一个索引指向一个GeoPoint对象\n\n\nGeoPoint的点不能超过规定的范围。\n纬度的范围\n应该是在\n-90.0到90.0\n之间。\n经度的范围\n应该是在\n-180.0到180.0\n之间。如果您添加的经纬度超出了以上范围，将导致程序错误。\n\n\n删除文件不会删除文件关联的行记录中的文件列的值，需要自行通过更新行来删除关联。\n\n\n如果不加任何距离范围限制，则默认是100公里的半径范围。\n\n\n\n\napp服务\n\n\n通过app restful api，你可以查看，创建或编辑你的app，在用户管理后台也实现了这样的功能。通过验证你的bmob email账号和密码，你可以获取所有的app信息，创建一个新的app或者修改旧的app的信息。\n\n\napp restful api的验证流程和其它restful api有点不一样。在验证的时候，不是验证你的app key，而是验证账号的登录信息。头部 \nX-Bmob-Email\n 代表登录用的email，头部 \nX-Bmob-Password\n 代表登录用的密码。\n\n\n获取app信息\n\n\n请求描述\n\n\n可以获取一个账号下所有app的信息或者某个app的信息，如下。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/apps （获取所有app信息） https://api.bmob.cn/1/apps/Your Application ID（获取特定app信息）\n\n\n\n\n\n\nmethod ：GET\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Email: Your Account Email\nX-Bmob-Password: Your Account Password\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n请求所有应用信息的body结构如下：\n\n\n{\n  \nresults\n: [\n        {\n          \nappName\n: appName,\n          \napplicationId\n: app Id,\n          \nrestKey\n: $estful Key,\n          \nmasterKey\n: master Key,\n          \naccessKey\n: access Key,\n          \nsecretKey\n: secret Key,\n          \nstatus\n: status (app 是否可用，0表示不可用，1表示可用),\n          \nnotAllowedCreateTable\n: isAllowedCreateTable(是否允许通过api建表，0表示允许，1表示不允许)\n        }, \n        {\n              \nappName\n: appName,\n              \napplicationId\n: app Id,\n              \nrestKey\n: $estful Key,\n              \nmasterKey\n: master Key,\n              \naccessKey\n: access Key,\n              \nsecretKey\n: secret Key,\n              \nstatus\n: status (app 是否可用，0表示不可用，1表示可用),\n              \nnotAllowedCreateTable\n: isAllowedCreateTable(是否允许通过api建表，0表示允许，1表示不允许)\n         },\n         ...\n  ]\n}\n\n\n\n\n请求单个应用信息的body结构如下：\n\n\n{\n  \nappName\n: appName,\n  \napplicationId\n: app Id,\n  \nrestKey\n: $estful Key,\n  \nmasterKey\n: master Key,\n  \naccessKey\n: access Key,\n  \nsecretKey\n: secret Key,\n  \nstatus\n: status (app 是否可用，0表示不可用，1表示可用),\n  \nnotAllowedCreateTable\n: isAllowedCreateTable(是否允许通过api建表，0表示允许，1表示不允许)\n}\n\n\n\n\n创建新的app\n\n\n请求描述\n\n\n该请求接口可以动态创建一个应用。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/apps\n\n\n\n\n\n\nmethod ：POST\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Email: Your Account Email\nX-Bmob-Password: Your Account Password\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  \nappName\n : appName,\n  \nstatus\n: status,\n  \nnotAllowedCreateTable\n: value\n}\n\n\n\n\n\n\n\n\n\n\n参数名\n\n\n参数用途\n\n\n取值范围\n\n\n是否必须要填\n\n\n\n\n\n\n\n\n\n\nappName\n\n\napp的名称\n\n\n少于30个字符\n\n\n是\n\n\n\n\n\n\nstatus\n\n\napp是否可用\n\n\n0：表示禁用，1：表示可用\n\n\n否\n\n\n\n\n\n\nnotAllowedCreateTable\n\n\n是否允许通过api创建表\n\n\n0：表示允许创建表，1：表示不允许创建表\n\n\n否\n\n\n\n\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nappName\n: appName,\n  \napplicationId\n: app Id,\n  \nrestKey\n: $estful Key,\n  \nmasterKey\n: master Key,\n  \naccessKey\n: access Key,\n  \nsecretKey\n: secret Key,\n  \nstatus\n: status (app 是否可用，0表示不可用，1表示可用),\n  \nnotAllowedCreateTable\n: isAllowedCreateTable(是否允许通过api建表，0表示允许，1表示不允许)\n}\n\n\n\n\n例子\n\n\n下面是一个创建app的例子\n\n\ncurl -X POST \\\n    -H \nX-Bmob-Email: Your Account Email\n \\\n    -H \nX-Bmob-Password: Your Account Password\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nappName\n:\nmyapp\n,\nstatus\n:1,\nnotAllowedCreateTable\n:0}' \\\n    https://api.bmob.cn/1/apps\n\n\n\n\n修改app信息\n\n\n修改app信息与添加app相似，只是请求URL修改为 https://api.bmob.cn/1/apps/appId，并且使用 PUT方法即可，其中body里为需要修改的信息，参见下表：\n\n\n通过使用PUT 方法，可以修改app的信息，修改app信息时支持如下的参数：\n\n\n\n\n\n\n\n\n参数名\n\n\n参数用途\n\n\n取值范围\n\n\n是否必须要填\n\n\n\n\n\n\n\n\n\n\nappName\n\n\napp的名称\n\n\n少于30个字符\n\n\n否\n\n\n\n\n\n\nstatus\n\n\napp是否可用\n\n\n0：表示禁用，1：表示可用\n\n\n否\n\n\n\n\n\n\nnotAllowedCreateTable\n\n\n是否允许通过api创建表\n\n\n0：表示允许创建表，1：表示不允许创建表\n\n\n否\n\n\n\n\n\n\n\n\n下面是修改app信息的例子\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Email: Your Account Email\n \\\n    -H \nX-Bmob-Password: Your Account Password\n \\\n    -H \nContent-Type: application/json\n \\\n    -d '{\nappName\n:\nmyapp\n,\nstatus\n:1,\nnotAllowedCreateTable\n:0}' \\\n    https://api.bmob.cn/1/apps/f6fe8d5ab8a7909a3c6f6a7a0adb9550\n\n\n\n\n数据表\n\n\n通过数据表的restful api，你可以查看，创建或编辑你的表结构，在用户管理后台的数据浏览页面也实现了这样的功能。\n\n\n注意，调用数据表相关的api，必须指定Master Key。\n\n\n获取app表的信息\n\n\n请求描述\n\n\n可获取所有表的结构或者是特定某张表的结构\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/schemas 或者 https://api.bmob.cn/1/schemas/tableName(获取特定表)\n\n\n\n\n\n\nmethod ：GET\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-Master-Key: Your Master Key\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody: \n\n\n\n\n\n\n获取所有表结构：\n\n\n{\n  \nresults\n: [\n          {\n          \nclassName\n: tableName1,\n          \nfields\n: {\n            key1: {\n              \ntype\n: typeOfKey1\n              \ntargetClass\n:tableName（Pointer及Relation类型）\n            },\n            key2: {\n              \ntype\n: typeOfKey2\n              \ntargetClass\n:tableName（Pointer及Relation类型）\n            },\n            ...\n            }\n          }\n        },\n        {\n          \nclassName\n: tableName2,\n          \nfields\n: {\n            key1: {\n              \ntype\n: typeOfKey1\n              \ntargetClass\n:tableName（Pointer及Relation类型）\n            },\n            key2: {\n              \ntype\n: typeOfKey2\n              \ntargetClass\n:tableName（Pointer及Relation类型）\n            },\n            ...\n            }\n          }\n        },\n        ...\n    ]\n}\n\n\n\n\n获取特定表结构\n\n\n{\n  \nclassName\n: tableName,\n  \nfields\n: {\n    key1: {\n      \ntype\n: typeOfKey1\n      \ntargetClass\n:tableName（Pointer及Relation类型）\n    },\n    key2: {\n      \ntype\n: typeOfKey2\n      \ntargetClass\n:tableName（Pointer及Relation类型）\n    },\n    ...\n    }\n  }\n}\n\n\n\n\n例子\n\n\n例如，想要获取 \nGameScore\n 的表结构可使用以下请求。\n\n\ncurl -X GET \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-Master-Key: Your Master Key\n \\\n    https://api.bmob.cn/1/schemas/GameScore\n\n\n\n\n返回的body如下：\n\n\n{\n  \nclassName\n: \nGameScore\n,\n  \nfields\n: {\n    \nACL\n: {\n      \ntype\n: \nObject\n\n    },\n    \ncreatedAt\n: {\n      \ntype\n: \nDate\n\n    },\n    \nlocation\n: {\n      \ntype\n: \nGeo\n\n    },\n    \nname\n: {\n      \ntype\n: \nString\n\n    },\n    \nobjectId\n: {\n      \ntype\n: \nString\n\n    },\n    \nupdatedAt\n: {\n      \ntype\n: \nDate\n\n    }\n  }\n}\n\n\n\n\n表支持的数据类型\n\n\nBmob的表含有String、Number、Bool、Date、File、Geo、Array、Object、Pointer以及Relation类型。\n\n\n创建一个表\n\n\n请求描述\n\n\n可通过该接口创建一个表\n\n\n请求\n\n\n\n\n\n\nurl ： https://api.bmob.cn/1/schemas/TableName\n\n\n\n\n\n\nmethod ：POST\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-Master-Key: Your Master Key\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  \nclassName\n: tableName,\n  \nfields\n: {\n    key1: {\n      \ntype\n: typeOfKey1\n      \ntargetClass\n:tableName（Pointer及Relation类型需要填）\n    },\n    key2: {\n      \ntype\n: typeOfKey2\n      \ntargetClass\n:tableName（Pointer及Relation类型需要填）\n    },\n    ...\n    }\n  }\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nclassName\n: tableName,\n  \nfields\n: {\n    key1: {\n      \ntype\n: typeOfKey1\n      \ntargetClass\n:tableName（Pointer及Relation类型）\n    },\n    key2: {\n      \ntype\n: typeOfKey2\n      \ntargetClass\n:tableName（Pointer及Relation类型）\n    },\n    ...\n    }\n  }\n}\n\n\n\n\n例子\n\n\n如创建表“City”，并添加字段 \nname\n 和 \nvisiter\n （指向_User）\n\n\ncurl -X POST \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-Master-Key: Your Master Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d ' \n        {\n          \nclassName\n: \nCity\n,\n          \nfields\n: {\n                \nname\n: {\n                  \ntype\n: \nString\n\n                },\n                \nvisiter\n: {\n                  \ntype\n: \nPointer\n,\n                  \ntargetClass\n:\n_User\n\n                }\n          }\n        }' \\\n  https://api.bmob.cn/1/schemas/City\n\n\n\n\n修改表的结构\n\n\n请求描述\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/schemas/tableName\n\n\n\n\n\n\nmethod ：PUT\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-Master-Key: Your Master Key\n\n\n\n\n\n\nbody:\n\n\n\n\n  {\n      \nclassName\n: tableName,\n      \nfields\n: {\n        key1: {\n          \ntype\n: \nString\n(添加字段)\n        },\n        key2: {\n          \ntype\n: \nString\n,\n          \n__op\n: \nDelete\n (删除字段)\n        }\n      }\n }\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n返回的是修改后的表结构\n\n\n{\n  \nclassName\n: tableName,\n  \nfields\n: {\n    key1: {\n      \ntype\n: typeOfKey1\n      \ntargetClass\n:tableName（Pointer及Relation类型）\n    },\n    key2: {\n      \ntype\n: typeOfKey2\n      \ntargetClass\n:tableName（Pointer及Relation类型）\n    },\n    ...\n    }\n  }\n}\n\n\n\n\n例子\n\n\n在表“City”中添加字段“name”\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-Master-Key: Your Master Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d ' \n    {\n      \nclassName\n: \nCity\n,\n      \nfields\n: {\n        \nname\n: {\n          \ntype\n: \nString\n\n        }\n      }\n    }' \\\n  https://api.bmob.cn/1/schemas/City\n\n\n\n\n\n在表“City”中删除字段“name”\n\n\ncurl -X PUT \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-Master-Key: Your Master Key\n \\\n    -H \nContent-Type: application/json\n \\\n    -d ' \n    {\n      \nclassName\n: \nCity\n,\n      \nfields\n: {\n        \nname\n: {\n          \ntype\n: \nString\n,\n          \n__op\n: \nDelete\n  \n        }\n      }\n    }' \\\n  https://api.bmob.cn/1/schemas/City\n\n\n\n\n删除表\n\n\n请求描述\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/schemas/tableName\n\n\n\n\n\n\nmethod ：DELETE\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-Master-Key: Your Master Key\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nmsg\n: \nok\n\n}\n\n\n\n\n例子\n\n\n删除City表\n\n\ncurl -X DELETE \\\n    -H \nX-Bmob-Application-Id: Your Application ID\n \\\n    -H \nX-Bmob-Master-Key: Your Master Key\n \\\n  https://api.bmob.cn/1/schemas/City\n\n\n\n\n获取服务器时间\n\n\n请求描述\n\n\n有时，app需要获取服务器的时间，可使用该请求。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/timestamp\n\n\n\n\n\n\nmethod ：GET\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \ntimestamp\n: timestamp,\n  \ndatetime\n: YYYY-mm-dd HH:ii:ss(北京时间)\n}\n\n\n\n\n例子\n\n\n以下是一个请求样例，\n\n\ncurl -X GET \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  https://api.bmob.cn/1/timestamp\n\n\n\n\n返回参数如下：\n\n\n{\ntimestamp\n:1437531770,\ndatetime\n:\n2015-07-22 10:22:50\n}\n\n\n\n\ntimestamp为时间戳，datetime为格式化的日期。\n\n\n错误码\n\n\n参照\n所有平台错误码列表\n 中的Restful部分。", 
            "title": "开发文档"
        }, 
        {
            "location": "/data/restful/develop_doc/#_1", 
            "text": "只要你的设备，你使用的语言能够发送HTTP请求，那么就可以用来和 Bmob 进行数据交互，你可以使用REST API做很多事情,比如:   一个移动网站可以通过C、Java、Python、PHP、C#等甚至任何语言来获取 Bmob 上的数据。  一个网站可以展示来自 Bmob 的数据。  你可以上传大量的数据，随后可以被一个移动App读取。  你可以下载最近的数据来进行你自定义的分析统计。  使用任何语言写的程序都可以操作 Bmob 上的数据。  如果你不再需要使用 Bmob ，你可以导出你所有的数据。", 
            "title": "简介"
        }, 
        {
            "location": "/data/restful/develop_doc/#_2", 
            "text": "这里提供一些开发者写的其他语言调用RestApi的源码或者核心代码。  JAVA访问RestApi： http://wenda.bmob.cn//?/question/51  PHP访问RestApi： http://docs.bmob.cn/data/PHP/a_faststart/doc/index.html  AS3.0访问RestApi： http://wenda.bmob.cn//?/question/193", 
            "title": "案例源码"
        }, 
        {
            "location": "/data/restful/develop_doc/#_3", 
            "text": "对于POST和PUT请求，请求的主体必须是JSON格式,而且HTTP请求头的  Content-Type  需要设置为  application/json  。  用户验证是通过HTTP请求头来进行的,  X-Bmob-Application-Id  头表明你正在访问的是哪个App程序, 而  X-Bmob-REST-API-Key  头是用来授权的。在下面的例子中，你必须使用正确的key替换Your Application ID和Your REST API Key才能正常地发出Curl请求。", 
            "title": "请求格式"
        }, 
        {
            "location": "/data/restful/develop_doc/#_4", 
            "text": "对于所有REST API请求的响应内容体都是一个JSON对象.  一个请求是否成功是由HTTP状态码表明的， 一个2XX的状态码表示成功，而一个4XX表示请求失败。当一个请求失败时响应的主体仍然是一个JSON对象，但是总会包含code和error这两个字段，你可以用它们来进行调试。举个例子，如果保存一个对象的时候，尝试用不允许的Key，比如包含下划线的_name的话，就会得到如下请求失败的响应信息:  {\n     code : 105,\n     error :  invalid field name: bl!ng \n}", 
            "title": "响应格式"
        }, 
        {
            "location": "/data/restful/develop_doc/#_5", 
            "text": "API 访问需要在 https://api.bmob.cn 域名下，相对路径前缀 /1/ 表明现在使用的是第 1 版的 API。", 
            "title": "快速参考"
        }, 
        {
            "location": "/data/restful/develop_doc/#_6", 
            "text": "URL  HTTP  功能      /1/classes/TableName  POST  添加数据    /1/classes/TableName/objectId  PUT  更新数据    /1/classes/TableName/objectId  DELETE  删除数据    /1/batch  POST  批量操作数据    /1/classes/TableName/objectId  GET  查询数据    /1/cloudQuery  GET  使用BQL查询", 
            "title": "对象快速参考"
        }, 
        {
            "location": "/data/restful/develop_doc/#_7", 
            "text": "URL  HTTP  功能      /1/users  POST  用户注册、使用手机号注册登录、第三方注册登录    /1/login  GET  登录    /1/users/objectId  GET  获取当前用户、查询用户    /1/users/objectId  PUT  更新用户、第三方连接及断开连接    /1/users/objectId  DELETE  删除用户    /1/requestPasswordReset  POST  密码重置    /1/resetPasswordBySmsCode/smsCode  PUT  短信密码重置    /1/updateUserPassword/objectId  POST  旧密码更新密码    /1/requestEmailVerify  POST  邮箱验证", 
            "title": "用户快速参考"
        }, 
        {
            "location": "/data/restful/develop_doc/#_8", 
            "text": "URL  HTTP  功能      /2/files/fileName  POST  文件上传    /2/files/cdnName/url  DELETE  删除文件    /2/cdnBatchDelete  POST  批量删除CDN文件", 
            "title": "文件管理快速参考"
        }, 
        {
            "location": "/data/restful/develop_doc/#acl", 
            "text": "URL  HTTP  功能      /1/roles  POST  创建角色    /1/roles/objectId  GET  获取角色    /1/roles/objectId  PUT  更新角色", 
            "title": "ACL和角色管理快速参考"
        }, 
        {
            "location": "/data/restful/develop_doc/#app", 
            "text": "URL  HTTP  功能      /1/apps  GET  获取所有app信息    /1/apps/appId  GET  获取特定app信息    /1/apps  POST  创建新app    /1/apps/appId  PUT  修改app信息", 
            "title": "app服务快速参考"
        }, 
        {
            "location": "/data/restful/develop_doc/#_9", 
            "text": "URL  HTTP  功能      /1/schemas  GET  获取所有表信息    /1/schemas/TableName  GET  获取特定表信息    /1/schemas/TableName  POST  创建表    /1/schemas/TableName  PUT  修改表    /1/schemas/TableName  DELETE  删除表", 
            "title": "数据表快速参考"
        }, 
        {
            "location": "/data/restful/develop_doc/#_10", 
            "text": "URL  HTTP  功能      /1/timestamp  GET  获取服务器时间", 
            "title": "其它功能快速参考"
        }, 
        {
            "location": "/data/restful/develop_doc/#_11", 
            "text": "", 
            "title": "对象"
        }, 
        {
            "location": "/data/restful/develop_doc/#_12", 
            "text": "通过REST API保存数据需要将对象的数据通过JSON来编码，这个数据是无模式化的（Schema Less）,这意味着你不需要提前标注每个对象上有哪些Key，你只需要随意设置key-value对就可以，Rest API后端会存储它的。  举个例子，假设你正在记录一局游戏的最高分，一个简单的对象可能包含:  {\n     score : 1337,\n     playerName :  Sean Plott ,\n     cheatMode : false\n}  Key必须是字母和数字组成的字符串,Value可以是任何可以JSON编码的东西.  每个对象都有一个类名，你可以通过类名来区分不同的数据，例如，我们可以把游戏得分对象称之为GameScore.我们推荐你使用   NameYourClassesLikeThis  和  nameYourKeysLikeThis  这样的格式为你的类名和Key命名，这可以使你的代码看起来很漂亮.  当你从 Bmob 中获取对象时，一些字段会被自动加上: createdAt, updatedAt 和 objectId， 这些字段的名字是保留的，你不能自行设置它们，我们上面设置的对象在获取时应该是下面的样子.  {\n     score : 1337,\n     playerName :  Sean Plott ,\n     cheatMode : false,\n     createdAt :  2011-08-20 02:06:57 ,\n     updatedAt :  2011-08-20 02:06:57 ,\n     objectId :  e1kXT22L \n}  createdAt和updatedAt都是UTC时间戳,以ISO 8601标准和毫秒级精度储存:YYYY-mm-dd HH:ii:ss. objectId是一个string,在类中唯一表明了一个对象。  在REST API中class级的在一个资源上的操作只能根据类名来进行，例如，如果类名是GameScore，那么class的URL就是  https://api.bmob.cn/1/classes/GameScore  用户有一个特殊的类级的url:  https://api.bmob.cn/1/users  针对于一个特定对象的操作可以通过组织一个URL来做，例如，对GameScore中的一个objectId为e1kXT22L的对象的操作应使用如下URL:  https://api.bmob.cn/1/classes/GameScore/e1kXT22L", 
            "title": "对象格式"
        }, 
        {
            "location": "/data/restful/develop_doc/#_13", 
            "text": "到现在为止我们只使用了可以被标准JSON编码的值， Bmob 移动客户端SDK库同样支持日期,地理位置数据和指针数据、关系型数据。在REST API中，这些值都被编码了，同时有一个\"__type\"字段来标识出它们所属的类型，所以如果你采用正确的编码的话就可以读或者写这些字段了。  Date类型包含了一个\"iso\"字段存储了一个UTC时间戳,以ISO 8601格式和毫秒级的精度来存储时间: YYYY-MM-DDTHH:MM:SS.MMMZ，或者 YYYY-MM-DDTHH:MM:SS  {\n     __type :  Date ,\n     iso :  2011-08-21 18:02:52 \n}  Date 与内置的  createdAt  字段和  updatedAt  字段相结合的时候特别有用，举个例子：为了找到在一个特殊时间创建的对象，只需要将Date编码在一个查询的where条件中:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ createdAt :{ $gte :{ __type : Date , iso : 2011-08-21 18:02:52 }}}' \\\n    https://api.bmob.cn/1/classes/GameScore  File类型是在上传后返回的JSON数据再加一个Key为\"__Type\":\"File\", 用来保存到数据列为文件类型的值：  {\n     __type :  File ,\n     group :  group1 ,\n     filename :  1.xml ,\n     url :  M00/01/14/sd2lkds0.xml \n}  更新对象时可以为该对象保存上传后返回的文件信息：  curl -X PUT \n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ score :1337, playerName : Sean Plott , file :{ __type : File , group : group1 , filename : 1.xml , url : M00/01/14/sd2lkds0.xml \n}}' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L  Pointer 类型是在当前对象要指向另一个对象时使用，它包含了 className 和 objectId 两个作为一个指针正确指向的必填值.  {\n   __type :  Pointer ,\n   className :  Game ,\n   objectId :  DdUOIIIW \n}  指向用户对象的  Pointer  的  className  为_User, 前面加一个下划线表示开发者不能定义的类名, 而且所指的类是系统内置的。  Relation  类型被用在多对多的类型上, 移动端的库将使用  BmobRelation  作为值, 它有一个 className 字段表示目标对象的类名：  {\n   __type :  Relation ,\n   className :  GameScore \n}  当使用查询时，  Relation  对象的行为很像是  Pointer  的数组, 任何操作针对于  Pointer  的数组的 (除了 include) 都可以对  Relation  起作用.  当更多的数据类型被加入的时候, 它们都会采用 hashmap  加上一个 type  字段的形式, 所以你不应该使用type作为你自己的JSON对象的Key。", 
            "title": "数据类型"
        }, 
        {
            "location": "/data/restful/develop_doc/#_14", 
            "text": "请求描述  为了在 Bmob 上创建一个新的对象，应该向class的URL发送一个POST请求，其中内容体应该是包含对象本身的JSON格式。  请求   url ：https://api.bmob.cn/1/classes/TableName  method ：POST  header:   X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n  key1 : value1,\n  key2 : value2,\n  ...\n}  成功时响应    status: 201 Created    location: https://api.bmob.cn/1/classes/TableName/objectId    body:    {\n     createdAt : create date,\n     objectId : objectId\n}  例子  例如，要创建如上例子中说的对象:  curl -X POST \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ score :1337, playerName : Sean Plott , cheatMode :false}' \\\n    https://api.bmob.cn/1/classes/GameScore  当创建成功时，响应的HTTP状态码的返回值是201 Created，而响应的HTTP头部中Location的值是表示刚创建的该对象的URL:  Status: 201 Created\nLocation: https://api.bmob.cn/1/classes/GameScore/e1kXT22L  响应的主体是一个JSON对象,包含新对象的objectId和createdAt时间戳：  {\n     createdAt :  2011-08-20 02:06:57 ,\n     objectId :  e1kXT22L \n}", 
            "title": "添加数据"
        }, 
        {
            "location": "/data/restful/develop_doc/#_15", 
            "text": "", 
            "title": "更新数据"
        }, 
        {
            "location": "/data/restful/develop_doc/#_16", 
            "text": "请求描述  为了更改一个对象上已经有的数据，你可以发送一个PUT请求到对象相应的URL上，只有你指定的Key的值才会变更为新值，任何你未指定的Key的值都不会更改，所以你可以只更新对象数据的一个子集。  请求   url ：https://api.bmob.cn/1/classes/   TableName/objectId    method ：PUT    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n  key1 : value1,\n  key2 : value2,\n  ...\n}  成功时响应    status: 200 OK    body:    {\n   updatedAt :  YYYY-mm-dd HH:ii:ss \n}  例子  我们来更改我们对象的一个score的字段:  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ score :73453}' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L  返回的JSON对象只会包含一个updatedAt字段，表明更新发生的时间：  {\n     updatedAt :  2011-08-21 18:02:52 \n}", 
            "title": "普通更新"
        }, 
        {
            "location": "/data/restful/develop_doc/#_17", 
            "text": "如果存储的是JSON对象还可以通过以下形式，只修改JSON对象的特定键值，其body为：  {\n  key1.keyOfJson : value1,\n  key2.keyOfJson : value2,\n  ...\n}  如果你当前行有一列叫userAttibute,保存的是一个JSON 对象，比如是: {\"name\":\"John\", \"gender\":\"男\"}，那么我们要修改这个对象的gender值就可以通过以下方式实现：  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ userAttibute.gender : 女 }' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L", 
            "title": "修改对象的某个值"
        }, 
        {
            "location": "/data/restful/develop_doc/#_18", 
            "text": "另外，很多应用可能会有需要计数器的功能，比如某条信息被点赞多少次等。Bmob提供了非常便捷的方式来保证原子性的修改某一数值字段的值，body如下，其中value的正负均可。  其中请求的body为：  {\n    key1:{ __op : Increment , amount :value}\n    ...\n}  例如，如果需要让score每次增加1，而并不需要知道其当前的值，可以使用以下请求：  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ score :{ __op : Increment , amount :1}}' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L", 
            "title": "原子计算器"
        }, 
        {
            "location": "/data/restful/develop_doc/#_19", 
            "text": "请求描述  为了在 Bmob 上删除一个对象，可以发送一个DELETE请求到指定的对象的URL。  请求    url ：https://api.bmob.cn/1/classes/TableName/objectId    method ：DELETE    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json  成功时响应    status:200 OK    body:    {\n   msg :  ok \n}  例子  删除GameScore下objectId为e1kXT22L的方法如下：  curl -X DELETE \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L", 
            "title": "删除数据"
        }, 
        {
            "location": "/data/restful/develop_doc/#_20", 
            "text": "请求描述  可以在一个对象中删除一个字段，通过接口自定义的Delete操作  请求    url ：https://api.bmob.cn/1/classes/TableName/objectId    method ：PUT    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n  key1:{ __op : Delete },\n  key2:{ __op : Delete },\n  ...\n}  成功时响应    status: 200 OK    body:    {\n   updatedAt :  YYYY-mm-dd HH:ii:ss \n}  例子  如果要删除GameScore中objectId为e1kXT22L记录的playerName，可进行如下请求。  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ playerName :{ __op : Delete }}' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L", 
            "title": "删除字段的值"
        }, 
        {
            "location": "/data/restful/develop_doc/#_21", 
            "text": "请求描述  为了减少因为网络通讯次数太多而带来的时间浪费, Bmob提供批量(batch)操作，在一个请求中对多个普通对象进行添加(create)、更新(update)、删除(delete) 操作，上限为50个。在一个批量(batch)请求中每一个操作都有自己对应的方法、路径和主体, 这些参数可以代替你通常使用的HTTP方法. 这些操作会以发送过去的顺序来执行。  请求    url ：https://api.bmob.cn/1/batch    method ：POST    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n   requests : [\n          {\n             method :  POST ,\n             path :  /1/classes/TableName ,\n             body : {\n              key1: value1,\n              key2: value2,\n              ...\n            }\n          },\n          {\n             method :  PUT ,\n             token :  tokenValue (具有ACL规则时),\n             path :  /1/classes/TableName/objectId ,\n             body : {\n              key1: value1,\n              ...\n            }\n          },\n          {\n             method :  DELETE ,\n             token :  tokenValue (具有ACL规则时),\n             path :  /1/classes/TableName/objectId \n          },\n\n          ...\n\n          ]\n}  成功时响应    status: 200 OK    body:    [\n(添加对象返回的信息)\n  {\n     success : {\n       createdAt : YYYY-mm-dd HH:ii:ss,\n       objectId :  d746635d0b \n    }\n  },\n  (修改对象返回的信息)\n  {\n     success : {\n       updatedAt : YYYY-mm-dd HH:ii:ss\n    }\n  },\n  (删除对象返回的信息)\n  {\n     success : {\n       msg :  ok \n    }\n  }\n]  例子  比如我们要创建一系列的 GameScore 的对象:  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         requests : [\n          {\n             method :  POST ,\n             path :  /1/classes/GameScore ,\n             body : {\n               score : 1337,\n               playerName :  Sean Plott \n            }\n          },\n          {\n             method :  POST ,\n             path :  /1/classes/GameScore ,\n             body : {\n               score : 1338,\n               playerName :  ZeroCool \n            }\n          }\n        ]\n      }' \n  https://api.bmob.cn/1/batch  如果我们要修改用户表的某条记录或者删除某条记录，则用以下方法。  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         requests : [\n          {\n             method :  PUT ,\n             token :  pnktnjyb996sj4p156gjtp4im ,\n             path :  /1/users/51e3a334e4b0b3eb44adbe1a ,\n             body : {\n               score : 999999\n            }\n          },\n          {\n             method :  DELETE ,\n             token :  pnktnjyb996sj4p156gjtp4im ,\n             path :  /1/users/51a8a4d9e4b0d034f6159a35 \n          }\n        ]\n      }' \\\n  https://api.bmob.cn/1/batch", 
            "title": "批量数据操作"
        }, 
        {
            "location": "/data/restful/develop_doc/#_22", 
            "text": "数据的查询可能是每个应用都会频繁使用的，它提供了多样的方法来实现不同条件的查询，同时它的使用也是非常的简单和方便。", 
            "title": "查询"
        }, 
        {
            "location": "/data/restful/develop_doc/#_23", 
            "text": "请求描述  当你创建了一个对象时，你可以通过发送一个HTTP GET请求到创建对象成功时返回的HTTP请求头中的Location的URL获取它的内容。  请求    url ：https://api.bmob.cn/1/classes/TableName/objectId，可以加上include值，具体形式为：https://api.bmob.cn/1/classes/TableName/objectId?include=game    method ：GET    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n  key1 : value1,\n  key2 : value2,\n  ...\n}  成功时响应    status: 200 OK    body:    {\n    key1:value1,\n    key2:value2,\n    ...\n}  例子  为了得到我们上面创建的对象:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L  返回的主体是一个JSON对象，它包含所有用户提供的field，并且加上系统保留的createdAt,updatedAt和objectId三个Key的值：  {\n     score : 1337,\n     playerName :  Sean Plott ,\n     cheatMode : false,\n     skills : [\n         pwnage ,\n         flying \n    ],\n     createdAt :  2011-08-20 02:06:57 ,\n     updatedAt :  2011-08-20 02:06:57 ,\n     objectId :  e1kXT22L \n}  当获取的对象有指向其子对象的Pointer类型指针Key时，你可以加入inclue选项来获取指针指向的子对象。按上面的实例，如果GameScore对象有一个game的Key为Pointer类型，并指向了Game游戏对象，那么可以通过GameScore的game这个Key来获取指向的一个Game对象:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'include=game' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L  返回的主体是一个JSON对象包含GameScore的所有Key，并有game这个Pointer的Key被扩展为一个Game对象:  {\n     score : 1337,\n     playerName :  Sean Plott ,\n     cheatMode : false,\n     skills : [\n         pwnage ,\n         flying \n    ],\n     game : {\n         type :  Object ,\n         className :  Game ,\n         name :  愤怒的小鸡 ,\n    }\n     createdAt :  2011-08-20 02:06:57 ,\n     updatedAt :  2011-08-20 02:06:57 ,\n     objectId :  e1kXT22L \n}", 
            "title": "查询单条数据"
        }, 
        {
            "location": "/data/restful/develop_doc/#_24", 
            "text": "请求描述 \n为了一次获取多个对象，你可以通过发送一个GET请求到类的URL上，不需要任何URL参数。具体如下。  请求   url ：https://api.bmob.cn/1/classes/TableName  method ：GET  header:   X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json  成功时响应   status: 200 OK  body:    {\n   results : [\n    {\n      key1:value1,\n      key2:value2,\n      ...\n    },\n    {\n      key1:value1,\n      key2:value2,\n      ...\n    },\n    ...  例子  下面就是简单地获取所有在GameScore类之中的对象:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    https://api.bmob.cn/1/classes/GameScore  返回的值就是一个JSON对象包含了results字段,它的值就是对象的列表:  {\n     results : [\n    {\n         playerName :  Jang Min Chul ,\n         updatedAt :  2011-08-19 02:24:17 ,\n         cheatMode : false,\n         createdAt :  2011-08-19 02:24:17 ,\n         objectId :  51c3ba67e4b0f0e851c16221 ,\n         score : 80075\n    },\n    {\n         playerName :  Sean Plott ,\n         updatedAt :  2011-08-21 18:02:52 ,\n         cheatMode : false,\n         createdAt :  2011-08-20 02:06:57 ,\n         objectId :  e1kXT22L ,\n         score : 73453\n    }\n    ]\n}  怎么样，是不是很简单，而且查询的结果不需要任何处理，你直接使用即可。", 
            "title": "查询多条数据"
        }, 
        {
            "location": "/data/restful/develop_doc/#_25", 
            "text": "条件查询就是在查询所有数据的请求上通过where参数的形式对查询对象做出约束，只返回我们功期望返回的值。  where参数的值应该是JSON编码过的，就是说，如果你查看真正被发出的URL请求，它应该是先被JSON编码过，然后又被URL编码过。  使用where参数最简单的方式就是包含应有的key的值。举例说,如果我们想要得到Lily的记录，那该请求的URL为：  https://api.bmob.cn/1/classes/GameScore?where={ name : Lily }  这是未经编码前我们看到的url，我们需要对URL进行URL编码，编码的的结果为：  https://api.bmob.cn/1/classes/GameScore?where=%7B%22name%22:%22Lily%22%7D  不同的语言开发环境有不同的URL编码接口，如果是使用如Postman这类工具来进行测试的，可以使用一些在线的url编解码工具进行编码后再发送请求，这里推荐一个 http://web.chacuo.net/charseturlencode  where的参数值除了上面的准确匹配外，还支持比较运算符的方式，除了给定一个确定值的方式，还可以提供一个hash中包含有key用于比较，where参数支持下面一些选项:     Key  Operation      $lt  小于    $lte  小于等于    $gt  大于    $gte  大于等于    $ne  不等于    $in  包含在数组中    $nin  不包含在数组中    $exists  这个 Key 有值    $select  匹配另一个查询的返回值    $dontSelect  排除另一个查询的返回    $all  包括所有给定的值    $regex  匹配PCRE表达式     作为示例，为了获取score得分在[1000,3000]之间的对象，我们需要这样做:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ score :{ $gte :1000, $lte :3000}}' \\\n    https://api.bmob.cn/1/classes/GameScore  为了获得score得分在10以下并且是一个奇数，我们需要这样做:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ score :{ $in :[1,3,5,7,9]}}' \\\n    https://api.bmob.cn/1/classes/GameScore  为了获得scoreArray得分包括数组中所有的值，如scoreArray是[1,3, 5, 7]就满足，是[1, 5,10]就不满足:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ scoreArray :{ $all :[1,3,5]}}' \\\n    https://api.bmob.cn/1/classes/GameScore  为了获取playerName不在列表中的GameScore对象们，我们可以:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ playerName :{ $nin :[ Jonathan Walsh , Dario Wunsch , Shawn Simon ]}}' \\\n    https://api.bmob.cn/1/classes/GameScore  为了获取有分数的对象，我们应该用:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ score :{ $exists :true}}' \\\n    https://api.bmob.cn/1/classes/GameScore  为了获取没有分数的对象，用:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ score :{ $exists :false}}' \\\n    https://api.bmob.cn/1/classes/GameScore  你还可以使用模糊查询，支持PCRE正则表达式：  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ playerName :{ $regex : smile.* }}' \\\n    https://api.bmob.cn/1/classes/GameScore   注:模糊查询只对付费用户开放，付费后可直接使用。  如果您的查询条件某个列值要匹配另一个查询的返回值，举例有一个队伍(Team)保存了每个城市的得分情况且用户表中有一列为用户家乡(hometown), 您可以创建一个查询来寻找用户的家乡是得分大于0.5的城市的所有运动员， 就像这样查询:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ hometown :{ $select :{ query :{ className : Team , where :{ winPct :{ $gt :0.5}}}, key : city }}}' \\\n    https://api.bmob.cn/1/users  反之查询Team中得分小于等于0.5的城市的所有运动员，构造查询如下：  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ hometown :{ $dontSelect :{ query :{ className : Team , where :{ winPct :{ $gt :0.5}}}, key : city }}}' \\\n    https://api.bmob.cn/1/users", 
            "title": "条件查询"
        }, 
        {
            "location": "/data/restful/develop_doc/#_26", 
            "text": "你可以用limit和skip来做分页，limit的默认值是100，但是任何1到1000的值都是可选的，就是说，为了获取在400到600之间的对象:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'limit=200' \\\n    --data-urlencode 'skip=400' \\\n    https://api.bmob.cn/1/classes/GameScore", 
            "title": "分页查询"
        }, 
        {
            "location": "/data/restful/develop_doc/#_27", 
            "text": "你可以用order参数指定一个字段来排序，前面加一个负号的前缀表示降序，这样返回的对象会以score升序排列:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'order=score' \\\n    https://api.bmob.cn/1/classes/GameScore  而以下这样返回的对象会以score降序排列:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'order=-score' \\\n    https://api.bmob.cn/1/classes/GameScore  你可以用多个字段进行排序，只要用一个逗号隔开列表就可以，为了获取GameScore，以score的升序和name的降序进行排序:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'order=score,-name' \\\n    https://api.bmob.cn/1/classes/GameScore", 
            "title": "排序"
        }, 
        {
            "location": "/data/restful/develop_doc/#_28", 
            "text": "Key  Operation      $or  复合查询中的或查询    $and  复合查询中的与查询     如果你想查询对象符合几种查询之一，你可以使用$or或$and操作符，带一个JSON数组作为它的值。例如，如果你想找到player赢了很多或者赢了很少，你可以用如下的方式:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ $or :[{ wins :{ $gt :150}},{ wins :{ $lt :5}}]}' \\\n    https://api.bmob.cn/1/classes/Player  查询今天内的数据，方式如下:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ $and :[{ createdAt :{ $gte :{ __type :  Date ,  iso :  2014-07-15 00:00:00 }}},\\\n    { createdAt :{ $lte :{ __type :  Date ,  iso :  2014-07-15 23:59:59 }}}]}' \\\n    https://api.bmob.cn/1/classes/Player  因为createdAt updatedAt服务器自动生成的时间，在服务器保存的是精确到微秒值的时间，所以基于时间类型比较的值要加1秒。  任何在查询上的其他的约束都会对返回的对象生效，所以你可以用$or对其他的查询添加约束。  注意我们不会在  组合查询的子查询  中支持非过滤型的约束(例如:limit skip sort include)，但最外层的查询中是支持非过滤型约束的。", 
            "title": "复合查询"
        }, 
        {
            "location": "/data/restful/develop_doc/#_29", 
            "text": "如果你在使用limit，或者如果返回的结果很多，你可能想要知道到底有多少对象应该返回，而不用把它们全部获得以后再计数，此时你可以使用count参数。举个例子，如果你仅仅是关心一个特定的玩家玩过的游戏数量：  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ playerName : Jonathan Walsh }' \\\n    --data-urlencode 'count=1' \\\n    --data-urlencode 'limit=0' \\\n    https://api.bmob.cn/1/classes/GameScore  因为请求了count而且把limit设为了0，返回的值里面只有计数，results为空数组集。  {\n     results : [\n\n    ],\n     count : 1337\n}  如果有一个非0的limit的话，既会返回正确的results也会返回count的值。", 
            "title": "查询结果计数"
        }, 
        {
            "location": "/data/restful/develop_doc/#_30", 
            "text": "你可以限定返回的字段，通过传入keys参数，值为用一个逗号分隔的字段名称列表，为了获取对象只包含score和playerName字段(还有特殊的内置字段比如objectId,createdAt和updatedAt)，请求如下：  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'keys=score,playerName' \\\n    https://api.bmob.cn/1/classes/GameScore", 
            "title": "查询指定列"
        }, 
        {
            "location": "/data/restful/develop_doc/#_31", 
            "text": "Bmob的统计查询，提供以下关键字或其组合的查询操作：     Key  Operation      groupby  分组操作    groupcount  返回每个分组的总记录    sum  计算总和    average  计算平均值    max  计算最大值    min  计算最小值    having  分组中的过滤条件     为避免和用户创建的列名称冲突，Bmob约定以上统计关键字（sum, max, min)的查询结果值都用  _(关键字)+首字母大写的列名  的格式，如计算玩家得分列名称为score总和的操作，则返回的结果集会有一个列名为_sumScore。average返回的列为  _avg+首字母大写的列名  ，有groupcount的情形下则返回_count。  以上关键字除了groupcount是传Boolean值true或false，having传的是和where类似的json字符串，但having只应该用于过滤分组查询得到的结果集，即having只应该包含结果集中的列名如  {\"_sumScore\":{\"$gt\":100}}  ，其他关键字必须是字符串而必须是表中包含的列名，多个列名用,分隔。  以上关键字可以自由组合并可以与前面查询语句中的where, order, limit, skip等组合使用。  比如，GameScore表是游戏玩家的信息和得分表，有playerName(玩家名称)、score(玩家得分)等你自己创建的列，还有Bmob的默认列objectId, createdAt, updatedAt,那么我们现在举例如何使用以上的查询关键字来作这个表的统计。", 
            "title": "统计相关的查询"
        }, 
        {
            "location": "/data/restful/develop_doc/#_32", 
            "text": "我们要计算GameScore表所有玩家的得分总和，sum后面只能拼接Number类型的列名，即要计算哪个列的值的总和，只对Number类型有效，多个Number列用,分隔，则查询如下：  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'sum=score' \\\n    https://api.bmob.cn/1/classes/GameScore  返回内容如下：  [\n    {\n         _sumScore : 2398\n    }   \n]", 
            "title": "计算总和"
        }, 
        {
            "location": "/data/restful/develop_doc/#_33", 
            "text": "比如我们以创建时间按天统计所有玩家的得分，并按时间降序, groupby后面只能拼接列名，如果该列是时间类型，则按天分组，其他类型，则按确定值分组:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'sum=score groupby=createdAt order=-createdAt' \\\n    https://api.bmob.cn/1/classes/GameScore  返回内容如下：  [\n    {\n         _sumScore : 2398,\n         createdAt :  2014-02-05 \n    },\n    {\n         _sumScore : 1208,\n         createdAt :  2014-01-01 \n    },\n]", 
            "title": "分组计算总和"
        }, 
        {
            "location": "/data/restful/develop_doc/#_34", 
            "text": "比如我们以创建时间按天和按玩家名称分组统计所有玩家的得分1，得分2的总和，并按得分1的总和降序, groupby后面只能拼接列名，如果该列是时间类型，则按天分组，其他类型，则按确定值分组:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'sum=score1,score2 groupby=createdAt,playerName order=-_sumscore1' \\\n    https://api.bmob.cn/1/classes/GameScore  返回内容如下：  [\n    {\n         _sumScore1 : 399,\n         _sumScore2 : 120,\n         playerName :  John \n         createdAt :  2014-02-05 \n    },\n    {\n         _sumScore1 : 299,\n         _sumScore2 : 250,\n         playerName :  Bily \n         createdAt :  2014-02-05 \n    },\n    {\n         _sumScore1 : 99,\n         _sumScore2 : 450,\n         playerName :  John \n         createdAt :  2014-02-01 \n    },\n]", 
            "title": "多个分组并计算多个列的总和"
        }, 
        {
            "location": "/data/restful/develop_doc/#_35", 
            "text": "比如我们以创建时间按天统计所有玩家的得分，并只返回某天的总得分大于2000的记录，并按时间降序，having是用于过滤部分结果，其中的_sumScore是  _sum+首字母大写的列名  的格式表示是计算这个列的总和的值:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'sum=score having={ _sumScore :{ $gt : 2000}} groupby=createdAt order=-createdAt' \\\n    https://api.bmob.cn/1/classes/GameScore  返回内容如下：  [\n    {\n         _sumScore : 2398,\n         createdAt :  2014-02-05 \n    },\n]", 
            "title": "分组计算总和并只返回满足条件的部分值"
        }, 
        {
            "location": "/data/restful/develop_doc/#_36", 
            "text": "比如我们以创建时间按天统计所有玩家的得分和每一天有多少条玩家的得分记录，并按时间降序:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'sum=score groupby=createdAt groupcount=true order=-createdAt' \\\n    https://api.bmob.cn/1/classes/GameScore  返回内容如下：  [\n    {\n         _sumScore : 2398,\n         _count : 10,\n         createdAt :  2014-02-05 \n    },\n    {\n         _sumScore : 100,\n         _count : 2,\n         createdAt :  2014-01-01 \n    },\n]", 
            "title": "分组计算总和并返回每个分组的记录数"
        }, 
        {
            "location": "/data/restful/develop_doc/#_37", 
            "text": "比如我们获取表中所有的唯一的score:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'groupby=score' \\\n    https://api.bmob.cn/1/classes/GameScore  返回内容如下：  [\n    {\n         score : 78\n    },\n    {\n         score : 89\n    }\n]", 
            "title": "获取不重复的列值"
        }, 
        {
            "location": "/data/restful/develop_doc/#_38", 
            "text": "average(计算平均值)， max(计算最大值)，min(计算最小值)和sum查询语句是类似的，只用把上面的例子中的sum替换为相应的average, max, min就可以了。", 
            "title": "其他关键字"
        }, 
        {
            "location": "/data/restful/develop_doc/#bql", 
            "text": "我们还提供类 SQL 语法的 BQL 查询语言来查询数据，例如：  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -G \\\n  --data-urlencode 'bql=select * from Player limit 0,100 order by name' \\\n  https://api.bmob.cn/1/cloudQuery  更多请参考  BQL 详细指南  。  BQL 还支持占位符查询，where 和 limit 子句的条件参数可以使用问号替换，然后通过  values  数组传入：  curl -X GET \\\n   -H  X-Bmob-Application-Id: Your Application ID  \\\n   -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -G \\\n  --data-urlencode 'bql=select * from Player where name=? limit ?,? order by name' \\\n  --data-urlencode 'values=[ dennis , 0, 100]'\n  https://api.bmob.cn/1/cloudQuery", 
            "title": "BQL查询"
        }, 
        {
            "location": "/data/restful/develop_doc/#_39", 
            "text": "为了存储数组型数据， Bmob 提供了3种操作来原子性地更改一个数组字段:  Add  在一个数组字段的后面添加一些指定的对象(包装在一个数组内)  AddUnique  只会在原本数组字段中没有这些对象的情形下才会添加入数组，插入数组的位置不固定的  Remove  从一个数组字段的值内移除指定的数组中的所有对象", 
            "title": "数组"
        }, 
        {
            "location": "/data/restful/develop_doc/#_40", 
            "text": "请求描述  添加数据时添加一个数据字段。  请求    url ：https://api.bmob.cn/1/classes/TableName    method ：POST    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n  key1:{ __op : Add , objects :[value1,value2...]},\n\n  ...\n}  成功时响应    status: 200 OK    body:    {\n  \"createdAt\": \"YYYY-mm-dd HH:ii:ss\",\n  \"objectId\": objectId\n}  例子  给GameScore添加一条记录其中一个字体为数组，包含一些技能，可进行如下请求:  curl -X POST \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ skill :{ __op : Add , objects :[ skill1 , skill2 ]}}' \\\n    https://api.bmob.cn/1/classes/GameScore", 
            "title": "添加数组数据"
        }, 
        {
            "location": "/data/restful/develop_doc/#_41", 
            "text": "", 
            "title": "更新数组数据"
        }, 
        {
            "location": "/data/restful/develop_doc/#_42", 
            "text": "请求描述  数组对象生成后，还可以对其进行更新，往数组里面添加内容。  请求    url ：https://api.bmob.cn/1/classes/TableName/objectId    method ：PUT    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n   key1:{ __op : AddUnique , objects :[value1,value2...]},\n  ...\n}  成功时响应    status: 200 OK    body:    {\n   updatedAt :  YYYY-mm-dd HH:ii:ss \n}  例子  如在GameScore的e1kXT22L再添加两个技能，并且只有在这两个技能不存在时才加入，则可以使用以下请求：  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ skills :{ __op : AddUnique , objects :[ flying , kungfu ]}}' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L", 
            "title": "普通更新"
        }, 
        {
            "location": "/data/restful/develop_doc/#key", 
            "text": "请求描述  当数组中存储的是JSON对象时，可以使用该请求单独修改JSON对象中的某个值。  请求    url ：https://api.bmob.cn/1/classes/TableName/objectId    method ：PUT    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n  key1.number.keyOfJson : value1,\n  key2.number.keyOfJson : value2,\n  ...\n}  成功时响应    status: 200 OK    body:    {\n   updatedAt :  YYYY-mm-dd HH:ii:ss \n}  例子  比如你当前行有一列叫用户的工作经验projectExperiences，是一个Array数组列，里面包含了多个对象值：[{\"name\":\"项目名称\",\"descr\":\"项目描述\"，\"startTime\":\"开始时间\"，\"endTime\":\"结束时间\"}, ...]  那么我们要修改projectExperiences数组中第一个对象的name值：  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ projectExperiences.0.name : 项目名称2 }' \\\n    https://api.bmob.cn/1/users/e1kXT22L", 
            "title": "使用索引和对象key修改数组中的对象"
        }, 
        {
            "location": "/data/restful/develop_doc/#_43", 
            "text": "请求描述  请求    url ：https://api.bmob.cn/1/classes/TableName/objectId    method ：PUT    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n   key1:{ __op : Remove , objects :[value1,value2...]},\n  ...\n}  成功时响应    status: 200 OK    body:    {\n   updatedAt :  YYYY-mm-dd HH:ii:ss \n}  例子  把GameScore里objectId为e1kXT22L对象的技能移除。  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ skills :{ __op : Remove , objects :[ flying , kungfu ]}}' \\\n    https://api.bmob.cn/1/classes/GameScore/e1kXT22L", 
            "title": "删除数组数据"
        }, 
        {
            "location": "/data/restful/develop_doc/#_44", 
            "text": "请求描述  请求    url ：https://api.bmob.cn/1/classes/TableName    method ：GET    params:    //查找数组中含有特定值\nwhere={arraykey1:value1,arraykey2:value2,...}\n\nor\n\n//查找数据组同时含有若干个值\nwhere={ arrayKey :{ $all :[value1,value2,...]}}   header:   X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key  成功时响应    status: 200 OK    body:     {\n   results : [\n    {\n      key1:value1,\n      key2:value2,\n      ...\n    },\n    {\n      key1:value1,\n      key2:value2,\n      ...\n    },\n    ...  例子  例如，可以查找Key的数组值中包含有2的对象:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ arrayKey :2}' \\\n    https://api.bmob.cn/1/classes/RandomObject  还同样可以使用\"$all\"操作符来找到类型为数组的Key的值中包含有2,3和4的对象:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={ arrayKey :{ $all :[2,3,4]}}' \\\n    https://api.bmob.cn/1/classes/RandomObject", 
            "title": "查询数组数据"
        }, 
        {
            "location": "/data/restful/develop_doc/#_45", 
            "text": "", 
            "title": "数据关联"
        }, 
        {
            "location": "/data/restful/develop_doc/#_46", 
            "text": "在程序设计中，不同类型的数据之间可能存在某种关系。分别是以下三种：\n1. 一对一，比如车队给司机分车，1个司机对应1台车；\n2. 一对多，比如1个作者会对应多篇贴子；\n3. 多对多，比如1篇帖子会有多个喜欢的读者，而每个读者也会有多篇喜欢的帖子。\n前面的两种关系我们提供Pointer类型来表示，而最后一种关系我们使用Relation类型来表示  在下面的讲解中我们可能会使用到以下的两张表，其表结构如下：  _User     字段  类型  含义      objectId  string     username  string  用户名，用户可以是作者发帖子，也可以是读者发评论     Post     字段  类型  含义      objectId  string     title  string  帖子标题    content  string  帖子内容    author  Pointer(_User)  作者    likes  Relation(_User)  喜欢帖子的读者", 
            "title": "关联对象"
        }, 
        {
            "location": "/data/restful/develop_doc/#pointer", 
            "text": "Pointer可用于表示一对一及一对多的关系。  Pointer本质类似于指针，使用  className  和  objectId  来定位具体的对象。具体的操作如下。", 
            "title": "Pointer的使用"
        }, 
        {
            "location": "/data/restful/develop_doc/#pointer_1", 
            "text": "添加Pointer其实与普通的添加对象是一样的，使用的请求也是添加对象的接口，只是其中的 key-value对中的value的格式为  {\n     __type : Pointer ,\n     className :tableName,\n     objectId :objectId\n}  例如，如果我们需要添加一篇帖子，并关联至其作者，可以采用以下请求：  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{ \\\n             title :  how to user pointer , \\            user  : { \\\n             __type : Pointer , \\\n             className : _User , \\\n             objectId : DdUOIIIW  \\\n            } \\\n         }' \\\n  https://api.bmob.cn/1/classes/GameScore", 
            "title": "添加Pointer"
        }, 
        {
            "location": "/data/restful/develop_doc/#pointer_2", 
            "text": "与删除普通列值一样，例如要删除帖子(Post)的作者，如下  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ author :{ __op : Delete }}' \\\n    https://api.bmob.cn/1/classes/Post/e1kXT22L", 
            "title": "删除Pointer"
        }, 
        {
            "location": "/data/restful/develop_doc/#pointer_3", 
            "text": "与修改普通列值一样，只是新的值需要满足Pointer的格式，如下  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ \\\n                 title :  how to user pointer , \\                user  : { \\\n                 __type : Pointer , \\\n                 className : _User , \\\n                 objectId : objectId  \\ (新关联作者的objectId)\n                } \\\n         }' \n    https://api.bmob.cn/1/classes/Post/e1kXT22L", 
            "title": "修改Pointer"
        }, 
        {
            "location": "/data/restful/develop_doc/#pointer_4", 
            "text": "在某些情况之下，你可能需要在一个查询之中返回关联对象的所有值，你可以通过传入字段名称到include参数中，多个字段名称用,间隔。比如，在查询Post时还想将其相关联的user对象取出来，如下  curl -X GET \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -G \\\n  --data-urlencode 'include=author' \\\n  https://api.bmob.cn/1/classes/Post  返回的user字段的值如下：  {\n   __type :  Object ,\n   className :  _User ,\n   objectId :  51e3a359e4b015ead4d95ddc ,\n   createdAt :  2011-12-06T20:59:34.428Z ,\n   updatedAt :  2011-12-06T20:59:34.428Z ,\n   otherFields :  willAlsoBeIncluded \n}  而没有使用include时，返回的user字段值则是如下形式：  {\n   __type :  Pointer ,\n   className :  _User ,\n   objectId :  51e3a359e4b015ead4d95ddc \n}  你可以同样做多层的include, 这时要使用 \".\" 号. 如果你要include一条评论(Comment)对应的帖子(Post)的作者(author)：  curl -X GET \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -G \\\n  --data-urlencode 'order=-createdAt' \\\n  --data-urlencode 'limit=10' \\\n  --data-urlencode 'include=post.author' \\\n  https://api.bmob.cn/1/classes/Comment  如果你要构建一个查询, 这个查询要include多个  Pointer  类型的Key, 此时用逗号分隔Key名称列表即可。  另外，include 还可以只返回指定的keys，即 Pointer 类型的字段指向的表只返回指定的字段，举例如下：  建议大家使用以下方式，只返回需要的值，性能更好，流量更少  curl -X GET \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -G \\\n  --data-urlencode 'include=post[likes].author[username|email],user[username]' \\\n  https://api.bmob.cn/1/classes/Comment  post 指向的帖子表只返回likes字段，而author指向的用户表只返回username和email字段，user指向的用户表只返回username字段。", 
            "title": "查询Pointer"
        }, 
        {
            "location": "/data/restful/develop_doc/#pointer_5", 
            "text": "在查询当中，我们可以对字符串、数组、数字等进行约束，比如查询Post表时，我们可以指定只返回title以“a”开头的Post对象。那么Pointer能不能也进行约束呢？如下：  1.如果约束的是某个特定对象，即知道该对象的objectId，您可以用一个  where  参数查询, 自己使用  __type  构造一个  Pointer , 就像你构造其他数据类型一样。举例说, 如果每一条评论(Comment对象)有一个Key叫post，类型是Pointer，并且指向了一个具体的帖子(Post对象，用objectId表示一个帖子)，那么您可以使用下面的请求获取一个帖子的所有评论  curl -X GET \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -G \\\n  --data-urlencode 'where={ post :{ __type : Pointer , className : Post , objectId : 1dafb9ed9b }}' \\\n  https://api.bmob.cn/1/classes/Comment  2.如果想要约束关联对象除objectId外的其它值，比如我想要返回所有指向的author指向的对象，其username都为Lily的Post对象，该如何做呢？我们可以使用 \"$inQuery\" 来完成，具体如下：  curl -X GET \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -G \\\n  --data-urlencode 'where= { \\\n                                 author : { \\\n                                     $inQuery : { \\\n                                     where : { \\\n                                           username :  Lily  \\\n                                    }, \\\n                                     className :  _User  \\\n                                } \\\n                                 } \\\n                            }' \\\n  https://api.bmob.cn/1/classes/Post  如果需求是不匹配查询条件的，比较要找username不是Lily的Post对象，只需要将  $inQuery  替换成  $notInQuery  即可。", 
            "title": "约束Pointer值查询"
        }, 
        {
            "location": "/data/restful/develop_doc/#relation", 
            "text": "Relation可用于表示多对多的关系。其本质是一个Pointer的数组。具体的操作介绍如下。", 
            "title": "Relation的使用"
        }, 
        {
            "location": "/data/restful/develop_doc/#relation_1", 
            "text": "添加  Relation  返回使用的也是添加对象的接口，对应的  key-value  对中的  value  需要满足以下格式  {\n  key: {\n     __op :  AddRelation ,\n     objects : [\n      {\n         __type :  Pointer ,\n         className : className,\n         objectId : objectId\n      },\n      {\n         __type :  Pointer ,\n         className : className,\n         objectId : objectId\n      }\n    ]\n  }\n}  如需要给一个  Post  对象添加两个喜欢该  Post  的读者，可以使用以下方法。  curl -X PUT \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{  likes : { \\\n           __op :  AddRelation , \\\n           objects : [ \\\n            { \\\n              __type :  Pointer , \\\n              className :  _User , \\\n              objectId :  z0lOxp1X  \\\n            }, \\\n            { \\\n              __type :  Pointer , \\\n              className :  _User , \\\n              objectId :  MTzXDDDG  \\\n            } \\\n           ] \\\n        } \\\n      }' \\\n  https://api.bmob.cn/1/classes/Post/z0lOxp12", 
            "title": "添加Relation"
        }, 
        {
            "location": "/data/restful/develop_doc/#relation_2", 
            "text": "与普通的更新对象接口一样，只是需要使用特定的格式，具体如下：  {\n  key: {\n     __op :  RemoveRelation ,\n     objects : [\n      {\n         __type :  Pointer ,\n         className : className,\n         objectId : objectId\n      },\n      {\n         __type :  Pointer ,\n         className : className,\n         objectId : objectId\n      }\n    ]\n  }\n}  如有读者取消了对某篇帖子的收藏，可以进行如下操作:  curl -X PUT \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{  likes : { \\\n           __op :  RemoveRelation , \\\n           objects : [ \\\n            { \\\n              __type :  Pointer , \\\n              className :  _User , \\\n              objectId :  z0lOxp1X  \\\n            }\n      }' \\\n  https://api.bmob.cn/1/classes/Post/z0lOxp2a", 
            "title": "删除Relation"
        }, 
        {
            "location": "/data/restful/develop_doc/#relation_3", 
            "text": "如果我们需要查询喜欢某篇帖子的所有作者，那么可以使用  $relatedTo ，可以使用以下请求，与Pointer不同的是，此处我们直接查询的是_User表， $relatedTo  跟的是帖子的具体记录。  curl -X GET \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -G \\\n  --data-urlencode 'where={ $relatedTo :{ object :{ __type : Pointer , className : Post , objectId : 1dafb9ed9b }, key : likes }}' \\\n  https://api.bmob.cn/1/users", 
            "title": "查询Relation"
        }, 
        {
            "location": "/data/restful/develop_doc/#relation_4", 
            "text": "跟Pointer一样，我们同样可以使用  $inQuery  和  $notInQuery  对Relation的指向的对象的某些属性进行约束。例如，如果需要找到  Lily  喜欢的所有帖子，可以使用以下请求：  curl -X GET \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -G \\\n  --data-urlencode 'where= { \\\n                                 likes : { \\\n                                     $inQuery : { \\\n                                     where : { \\\n                                           username :  Lily  \\\n                                    }, \\\n                                     className :  _User  \\\n                                } \\\n                                 } \\\n                            }' \\\n  https://api.bmob.cn/1/classes/Post", 
            "title": "约束Relation进行查询"
        }, 
        {
            "location": "/data/restful/develop_doc/#_47", 
            "text": "很多跨平台和跨系统的应用都有一个统一的登录流程， Bmob 通过REST API访问用户的账户让你实现该功能。  通常来说，用户这个类的功能与其他的对象是相同的，比如都没有限制模式(Schema Less)，User对象和其他对象不同的是一个用户必须有用户名(username)和密码(password)，密码会被自动地加密和存储。 Bmob 强制你username和email这两个Key的值必须是不重复的。", 
            "title": "用户管理"
        }, 
        {
            "location": "/data/restful/develop_doc/#_48", 
            "text": "Bmob 默认会有几个特定的属性：\nusername: 用户的用户名 （必需） 。\npassword: 用户的密码 （必需） 。\nemail: 用户的电子邮件地址 （可选） 。", 
            "title": "属性"
        }, 
        {
            "location": "/data/restful/develop_doc/#_49", 
            "text": "请求描述  注册一个新用户与创建一个新的普通对象之间的不同点在于其username和password字段都是必要的，password字段会以与其他的字段不一样的方式处理，它在保存时会被加密而且永远不会被返回给任何来自客户端的请求。  在你的应用设置页面中，你可以向 Bmob 来请求认证邮件地址，这项设置启用了的话，所有用户在注册时填写email这个Key的值，并且邮箱有效的情况下，就会向这个邮箱地址发出一封邮件，邮件中会包含一个来自 Bmob 的邮箱验证的链接，当你的用户查收邮件并点击这个链接后，这个用户emailVerified的Key的值会置为True，你可以在emailVerified字段上查看用户的email是否已经通过验证了。  为了注册一个新的用户，需要向user路径发送一个POST请求，你可以加入一个甚至多个新的字段。  请求    url ：https://api.bmob.cn/1/users    method ：POST    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n   username  : username,\n   password  : password,\n  key1:value1,\n  key2:value2,\n  ...\n}  成功时响应    status: 201 Created    body:    返回的主体是一个JSON对象，包含objectId，表示唯一的用户, createdAt时间戳表示用户注册时间, sessionToken可以被用来认证更新或删除这名用户信息的请求。  {\n     createdAt : YYYY-mm-dd HH:ii:ss,\n     objectId : objectId,\n     sessionToken : sessionToken\n}  例子  例如，创建一个有家庭电话字段的新用户:  curl -X POST \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ username : cooldude6 , password : b_m7!-o8 , phone : 415-392-0202 }' \\\n    https://api.bmob.cn/1/users  其返回值如下：  {\n     createdAt :  2011-11-07 20:58:34 ,\n     objectId :  Kc3M222J ,\n     sessionToken :  pnktnjyb996sj4p156gjtp4im \n}  这里需要注意一点的是，有些时候你可能需要在用户注册时发送一封验证邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在设置- 邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在注册时自动发动一封验证邮件给用户。", 
            "title": "注册用户"
        }, 
        {
            "location": "/data/restful/develop_doc/#_50", 
            "text": "请求描述  Bmob  支持让用户直接输入手机号码进行注册，如果手机号码存在则自动登陆。  请求    url ： https://api.bmob.cn/1/users    method ：POST    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n  mobilePhoneNumber:phoneNumber,\n  smsCode:smsCode\n  key1 : value1,\n  key2 : value2,\n  ...\n}  其中  mobilePhoneNumber  就是手机号码，而  smsCode  是使用  请求短信验证码API 发送到用户手机上的 6位验证码字符串。如果是新用户且不传入 username，默认用户名将是手机号码。  成功时响应    status: 200 OK    body:    {\n   username : username,\n   mobilePhoneNumber : mobilePhoneNumber,\n   mobilePhoneVerified : boolValue,\n   createdAt : YYYY-mm-dd HH:ii:ss,\n   updatedAt : YYYY-mm-dd HH:ii:ss,\n   objectId : objectId,\n   sessionToken : sessionToekn,\n  key1:value1,\n  key2:value2,\n  ...\n}  如果是第一次注册，将默认设置_User表的  mobilePhoneVerified  属性为 true。  例子  创建一个用户如下：  curl -X POST \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ mobilePhoneNumber : 185xxxxxxxx , smsCode : 6位短信验证码 }' \\\n    https://api.bmob.cn/1/users  返回值  {\n   username :  185xxxxxxxx ,\n   mobilePhoneNumber :  185xxxxxxxx ,\n   mobilePhoneVerified : true,\n   createdAt :  2011-11-07 20:58:34 ,\n   updatedAt :  2011-11-07 20:58:34 ,\n   objectId :  Kc3M222J ,\n   sessionToken :  pnktnjyb996sj4p156gjtp4im \n}", 
            "title": "使用手机号码一键注册或登陆"
        }, 
        {
            "location": "/data/restful/develop_doc/#_51", 
            "text": "请求描述  你的用户注册之后，你需要让他们用自己的用户名和密码登录，为了做到这一点，发送一个HTTP GET请求到  /1/login  ，加上username和password作为URL编码后的参数。  另外，username 支持传入_User表的username或email或mobilePhoneNumber字段的值，作为登录的扩展功能，以实现邮箱和密码、手机号和密码登录功能。  除了有用户名或邮箱或手机号码和密码登录的功能， Bmob  还支持使用手机号码和验证码一键快速登录的功能，而  smsCode  是使用  请求短信验证码API 发送到用户手机上的 6位验证码字符串：  请求    url ：https://api.bmob.cn/1/login    params:    用户名密码登陆 username =username(也可以使用email或者mobilePhoneNumber) password =password\n\n手机号验证码 mobilePhoneNumber =phoneNumber smsCode :smsCode    method ：GET    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json  成功时响应    status: 200 OK    body:    {\n   username : username,\n   mobilePhoneNumber : mobilePhoneNumber,\n   mobilePhoneVerified : boolValue,\n   createdAt : YYYY-mm-dd HH:ii:ss,\n   updatedAt : YYYY-mm-dd HH:ii:ss,\n   objectId : objectId,\n   sessionToken : sessionToekn,\n  key1:value1,\n  key2:value2,\n  ...\n}  例子  使用用户名加密码登陆  curl -X GET\n    \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'username=cooldude6' \\\n    --data-urlencode 'password=b_m7!-o8' \\\n    https://api.bmob.cn/1/login  使用手机号加验证码登陆  curl -X GET\n    \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'mobilePhoneNumber=185xxxxxxxx' \\\n    --data-urlencode 'smsCode=6位短信验证码' \\\n    https://api.bmob.cn/1/login", 
            "title": "登录用户"
        }, 
        {
            "location": "/data/restful/develop_doc/#_52", 
            "text": "请求描述  当注册一个用户后，你可以通过发送一个HTTP GET请求到用户注册成功时返回的HTTP请求头中的Location的URL获取用户的信息。比如，为了获取上面注册成功的用户  请求    url ： https://api.bmob.cn/1/users/objectID    method ：GET    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json  成功时响应    status: 200 OK    body:    {\n     username : username,\n     createdAt : YYYY-mm-dd HH:ii:ss,\n     updatedAt : YYYY-mm-dd HH:ii:ss,\n     objectId : objectId\n}  例子  获取objectId为Kc3M222J的用户可以使用以下请求。  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    https://api.bmob.cn/1/users/Kc3M222J", 
            "title": "获取当前用户"
        }, 
        {
            "location": "/data/restful/develop_doc/#_53", 
            "text": "请求描述  在通常的情况下，我们都不希望用户去修改自己的数据，但可以通过认证让用户去做这件事，用户必须加入一个  X-Bmob-Session-Token  头部来请求这个更新操作，这个sessionToken在注册和登录时都会返回。该值的有效期为1年。  为了改动一个用户已经有的数据，需要对这个用户的URL发送一个HTTP PUT请求，任何你没有指定的key会保持不变，所以你可以只改动用户信息中的一部分，username和password可以更改，但是新的username不能重复。  请求    url ：https://api.bmob.cn/1/users/objectId    method ：PUT    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\nX-Bmob-Session-Token: sessionToken   body:   {\n  key1 : value1,\n  key2 : value2,\n  ...\n}  成功时响应    status: 200 OK    body:    {\n     updatedAt : YYYY-mm-dd HH:ii:ss\n}  例子  比如，如果我们想对 cooldude6 的电话做出一些改动，可以采用如下请求，  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  X-Bmob-Session-Token: pnktnjyb996sj4p156gjtp4im  \\\n    -H  Content-Type: application/json  \\\n    -d '{ phone : 415-369-6201 }' \\\n    https://api.bmob.cn/1/users/Kc3M222J  在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发动一封验证邮件给用户。", 
            "title": "更新用户"
        }, 
        {
            "location": "/data/restful/develop_doc/#_54", 
            "text": "请求描述 \n为了在 Bmob 上删除一个用户，可以向用户的URL上发送一个DELETE请求，前提是你必须提供一个X-Bmob-Session-Token在Http请求头以便认证授权。  当然了，你也可以直接把MasterKey传入到X-Bmob-Master-Key中, 这个就可以实现在不需要提供SessionToken的情形下更新和删除用户了，但希望只在开发环境下使用，不要把MasterKey发布出去。  请求    url ： https://api.bmob.cn/1/users/objectId    method ：DELETE    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\nX-Bmob-Session-Token: sessionToken  成功时响应    status: 200 OK    body:    {\n   msg :  ok \n}  例子  删除objectId为g7y9tkhB7O的用户。  curl -X DELETE \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  X-Bmob-Session-Token: pnktnjyb996sj4p156gjtp4im  \\\n    https://api.bmob.cn/1/users/g7y9tkhB7O", 
            "title": "删除用户"
        }, 
        {
            "location": "/data/restful/develop_doc/#_55", 
            "text": "请求描述  你可以一次获取多个用户，只要向用户的根URL发送一个GET请求，没有任何URL参数的话，可以简单地列出所有用户。  所有的对普通对象的查询选项都适用于对用户对象的查询，所以可以查看  查询  部分来获取详细信息。  User表是一个特殊的表，专门用于存储用户对象。在浏览器端，你会看到一个User表旁边有一个小人的图标。  请求    url ： https://api.bmob.cn/1/users    method ：GET    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key  成功时响应    status: 200 OK    body:    {\n  {\n     results : [\n        {\n             username : username,\n             createdAt : YYYY-mm-dd HH:ii:ss,\n             updatedAt : YYYY-mm-dd HH:ii:ss,\n             objectId : objectId,\n            key1:value1,\n            ...\n        },\n        {\n             username : username,\n             createdAt : YYYY-mm-dd HH:ii:ss,\n             updatedAt : YYYY-mm-dd HH:ii:ss,\n             objectId : objectId,\n            key1:value1,\n            ...\n        },\n        ...\n    ]\n}\n}  例子  获取当前用户表的所有用户信息。  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    https://api.bmob.cn/1/users", 
            "title": "查询用户"
        }, 
        {
            "location": "/data/restful/develop_doc/#_56", 
            "text": "共提供了3种方法，分别是email重置、短信验证码重置、旧密码重置。", 
            "title": "密码重置"
        }, 
        {
            "location": "/data/restful/develop_doc/#eamil", 
            "text": "请求描述  你可以使用这项功能，前提是用户将email与他们的账户关联起来，如果要重设密码，发送一个POST请求到  /1/requestPasswordReset , 同时在request的body部分带上email字段。  密码重置流程如下：   用户输入他们的电子邮件，请求重置自己的密码。  Bmob向他们的邮箱发送一封包含特殊的密码重置连接的电子邮件，此邮件的模板可在Bmob后台中修改。  用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，输入一个新的密码。  用户的密码已被重置为新输入的密码。   请求    url ：https://api.bmob.cn/1/requestPasswordReset    method ：POST    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n     email :emailAdress\n}  成功时响应    status: 200 OK    body:    {\n   msg :  ok \n}  例子  重置用户邮箱为coolguy@iloveapps.com的用户密码。  curl -X POST \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ email : coolguy@iloveapps.com }' \\\n    https://api.bmob.cn/1/requestPasswordReset", 
            "title": "Eamil重置"
        }, 
        {
            "location": "/data/restful/develop_doc/#_57", 
            "text": "请求描述  如果用户有绑定了手机号码，就可以通过手机验证码短信来实现使用手机号码找回密码的功能，先调用  请求短信验证码API 会将验证码发送到用户手机上，用户收到验证码并输入后，调用PUT /1/resetPasswordBySmsCode/smsCode 来为用户设置新的密码。  请求    url ：https://api.bmob.cn/1/resetPasswordBySmsCode/smsCode    method ：PUT    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n   password :  new password \n}  成功时响应    status: 200 OK    body:        { msg :  ok }  例子  以下为短信验证码重置样例。  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ password :  testPass }' \\\n    https://api.bmob.cn/1/resetPasswordBySmsCode/123987", 
            "title": "使用短信验证码进行密码重置"
        }, 
        {
            "location": "/data/restful/develop_doc/#_58", 
            "text": "请求描述  很多开发者希望让用户输入一次旧密码做一次校验，旧密码正确才可以修改为新密码，因此我们提供了一个单独的 API  PUT /1/updatePassword  来安全地修改用户密码。  注意：仍然需要传入 X-Bmob-Session-Token，也就是登录用户才可以修改自己的密码。  请求    url ：https://api.bmob.cn/1/updateUserPassword/objectId    method ：PUT    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\nX-Bmob-Session-Token: sessionToken   body:   {\n   oldPassword :  用户的老密码 ,\n   newPassword :  用户的新密码 \n}  成功时响应    status: 200 OK    body:    {\n   msg :  ok \n}  例子  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  X-Bmob-Session-Token: pnktnjyb996sj4p156gjtp4im  \\\n    -H  Content-Type: application/json  \\\n    -d '{ oldPassword :  123 , newPassword :  456 }' \\\n    https://api.bmob.cn/1/updateUserPassword/g7y9tkhB7O  g7y9tkhB7O：为当前登录用户的objectId。\npnktnjyb996sj4p156gjtp4im:用户sessionToken", 
            "title": "提供旧密码方式安全修改用户密码"
        }, 
        {
            "location": "/data/restful/develop_doc/#_59", 
            "text": "设置邮件验证是一个可选的应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会默认被设为false，如果应用设置中开启了邮箱认证功能， Bmob 会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.  emailVerified 字段有 3 种状态可以考虑：  true  : 用户可以点击邮件中的链接通过 Bmob 来验证地址，一个用户永远不会在新创建这个值的时候出现emailVerified为true。  false  : 用户(User)对象最后一次被刷新的时候, 用户并没有确认过他的邮箱地址, 如果你看到emailVerified为false的话，你可以考虑刷新 用户(User)对象。  missing  : 用户(User)对象已经被创建，但应用设置并没有开启邮件验证功能； 或者用户(User)对象没有email邮箱。  请求描述  发送到用户邮箱验证的邮件会在一周内失效，可以通过调用  /1/requestEmailVerify  来强制重新发送。  请求    url ：https://api.bmob.cn/1/requestEmailVerify    method ：POST    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n   email :emailAddress\n}  成功时响应    status: 200 OK    body:    {\n   msg :  ok \n}  例子  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{ email : coolguy@iloveapps.com }' \\\n  https://api.bmob.cn/1/requestEmailVerify", 
            "title": "邮箱验证"
        }, 
        {
            "location": "/data/restful/develop_doc/#_60", 
            "text": "Bmob允许你连接你的用户到第三方账户服务系统，比如新浪微博和QQ，这样就允许您的用户用已经存在的第三方账户直接登录您的App。通过注册或者更新的用户信息的功能，使用  authData  字段来保存第三方服务的授权信息就可以做到。一旦用户关联了某个第三方账户， authData  将被存储到您的Bmob的用户信息里，并通过登录即可重新获取到。  authData  是一个普通的 JSON 对象，它所要求的key根据第三方账户服务不同而不同，具体要求见下面。每种情况下，你都需要自己负责完成整个授权过程 (一般是通过 OAuth 协议，1.0 或者 2.0) 通过连接的API来获取授权信息。  新浪微博的  authData  内容:  {\n   authData : {\n     weibo : {\n       uid :  123456789 ,\n       access_token :  2.00ed6eMCV9DWcBcb79e8108f8m1HdE ,\n       expires_in : 1564469423540\n    }\n  }\n}  腾讯QQ的  authData  内容:  {\n   authData : {\n     qq : {\n       openid :  2345CA18A5CD6255E5BA185E7BECD222 ,\n       access_token :  12345678-SM3m2avZxh5cjJmIrAfx4ZYyamdofM7IjU ,\n       expires_in : 1382686496\n    }\n  }\n}  匿名用户 (Anonymous user) 的 authData 内容:  {\n   anonymous : {\n     id :  random UUID with lowercase hexadecimal digits \n  }\n}", 
            "title": "用户账户连接"
        }, 
        {
            "location": "/data/restful/develop_doc/#_61", 
            "text": "请求描述  使用一个第三方账户连接服务来注册用户并登录，同样使用POST请求/1/users，只是需要提供authData字段。  请求    url ：https://api.bmob.cn/1/users    method ：POST    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n    authData : {\n       platform: {\n           uid : uid,\n           access_token : accessToken,\n           expires_in : expiresIn\n        }\n    }\n }  成功时响应  Bmob 会校验提供的 authData 是否有效，并检查是否已经有一个用户连接了这个 authData 服务。如果已经有用户存在并连接了同一个 authData，那么Http响应头将返回 200 OK 和详细信息 (包括用户的 sessionToken):  Status: 200 OK\nLocation: https://api.bmob.cn/1/users/objectId  应答的 body 类似:  {\n   username : username,\n   createdAt : YYYY-mm-dd HH:ii:ss,\n   updatedAt : YYYY-mm-dd HH:ii:ss,\n   objectId : objectId,\n   sessionToken : sessionToken,\n   authData : {\n       platform: {\n           uid : uid,\n           access_token : accessToken,\n           expires_in : expiresIn\n        }\n    }\n  }\n}  如果用户还没有连接到这个帐号，则你会收到 201 Created 的应答状态码，标识新的用户已经被创建:  Status: 201 Created\nLocation: https://api.bmob.cn/1/users/objectId  应答内容包括 objectId,createdAt,sessionToken 以及一个自动生成的随机 username  {\n   username : username,\n   createdAt : YYYY-mm-dd HH:ii:ss,\n   objectId : objectId,\n   sessionToken : sessionToken,\n}  例子  例如，使用新浪微博账户注册或者登录用户:  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n      authData : {\n        weibo : {\n           uid :  123456789 ,\n           access_token :  2.00ed6eMCV9DWcBcb79e8108f8m1HdE ,\n           expires_in : 1564469423540\n        }\n      }\n    }' \\\n  https://api.bmob.cn/1/users", 
            "title": "注册和登录"
        }, 
        {
            "location": "/data/restful/develop_doc/#_62", 
            "text": "请求描述  连接一个现有的用户到新浪微博或者腾讯QQ帐号，可以通过发送一个 PUT 请求附带 authData 字段到以上Location返回的用户URL做到。  请求    url ：https://api.bmob.cn/1/users/objectId    method ：PUT    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\nX-Bmob-Session-Token: sessionToken   body:   {\n    authData : {\n       platform: {\n           uid : uid,\n           access_token : accessToken,\n           expires_in : expiresIn\n        }\n    }\n }  成功时响应    status: 200 OK    body:    {\n   username : username,\n   createdAt : YYYY-mm-dd HH:ii:ss,\n   updatedAt : YYYY-mm-dd HH:ii:ss,\n   objectId : objectId,\n   sessionToken : sessionToken,\n   authData : {\n       platform: {\n           uid : uid,\n           access_token : accessToken,\n           expires_in : expiresIn\n        }\n    }\n  }\n}  例子  例如，连接一个用户到腾讯QQ帐号发起的请求类似这样:  curl -X PUT \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  X-Bmob-Session-Token: pnktnjyb996sj4p156gjtp4im  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         authData : {\n            qq : {\n               openid :  2345CA18A5CD6255E5BA185E7BECD222 ,\n               access_token :  12345678-SM3m2avZxh5cjJmIrAfx4ZYyamdofM7IjU ,\n               expires_in : 1382686496\n            }\n        }\n      }' \\\n  https://api.bmob.cn/1/users/Kc3M222J  完成连接后，你可以使用匹配的 authData 来认证他们。", 
            "title": "连接"
        }, 
        {
            "location": "/data/restful/develop_doc/#_63", 
            "text": "请求描述  断开一个现有用户到某个服务，可以发送一个 PUT 请求设置 authData 中对应的服务为 null 来做到。  请求    url ：https://api.bmob.cn/1/users/objectId    method ：PUT    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\nX-Bmob-Session-Token: sessionToken   body:   {\n     authData : {\n          platform:null\n    }\n}  成功时响应    status: 200 OK    body:    {\n   username : username,\n   createdAt : YYYY-mm-dd HH:ii:ss,\n   updatedAt : YYYY-mm-dd HH:ii:ss,\n   objectId : objectId,\n   sessionToken : sessionToken,\n   authData : {\n       platform: NULL\n    }\n  }\n}  例子  例如，取消新浪微博关联:  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  X-Bmob-Session-Token: pnktnjyb996sj4p156gjtp4im  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         authData : {\n           weibo  : null\n        }\n      }' \\\n  https://api.bmob.cn/1/users/Kc3M222J", 
            "title": "断开连接"
        }, 
        {
            "location": "/data/restful/develop_doc/#_64", 
            "text": "Bmob的新版文件采用了cdn。", 
            "title": "文件管理"
        }, 
        {
            "location": "/data/restful/develop_doc/#_65", 
            "text": "请求描述  请求    url ： https://api.bmob.cn/2/files/fileName，可以选择BASE64加密    method ：POST    header:    Content-Type 不同类型文件使用不同的值，可以参考： http://tool.oschina.net/commons  X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: content-Type   body:   相应的文本或者二进制流  成功时响应    status: 200    body:    返回的主体是一个JSON对象，包含：文件名（filename）、cdn信息（cdnname）、文件地址（url）。  {\n   filename : filename,\n   url : url,\n   cdn :cdnname\n}  例子  上传一个 hello.txt 文件实现方法如下（-d的值是文件内容）：  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: text/plain  \\\n  -d 'Hello, World!' \\\n  https://api.bmob.cn/2/files/hello.txt  上传当前文件夹下的图片 myPicture.jpg 实现方法如下（--data-binary的值是文件二进制内容）：  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: image/jpeg  \\\n  --data-binary '@myPicture.jpg' \\\n  https://api.bmob.cn/2/files/myPicture.jpg  返回的内容，此时使用http://bmob-cdn-24.b0.upaiyun.com/2016/04/14/9306f2e74090d668801eac8814b3f56f.jpg 即可访问。  {\n   filename :  myPicture.jpg ,\n   url :  http://bmob-cdn-24.b0.upaiyun.com/2016/04/14/9306f2e74090d668801eac8814b3f56f.jpg ,\n   cdn : upyun \n}  上传完成后，你还可以把上传后的文件对象关联到某行记录中，相应的body格式为：  {\n    keyOfFile:{\n     __type :  File ,\n         group :  upyun ,\n         filename : fileName,\n        url: url\n    }\n}  例子如下：  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -H  Content-Type: application/json  \\\n    -d '{ score :73453,  file :{\n         __type :  File ,\n         group :  group1 ,\n         filename :  myPicture.jpg ,\n        url:  http://bmob-cdn-24.b0.upaiyun.com/2016/04/14/9306f2e74090d668801eac8814b3f56f.jpg \n    }}' \\\nhttps://api.bmob.cn/1/classes/GameScore/e1kXT22L", 
            "title": "整个文件上传"
        }, 
        {
            "location": "/data/restful/develop_doc/#_66", 
            "text": "请求描述  该接口可删除已经上传的文件。  请求    url ：https://api.bmob.cn/2/files/cdnName/url ，其中cdnName是指上传文件后再body返回的cdnname,其中URL指的是上传文件后在body中返回的url除去域名之后的字符串。    method ：DELETE    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json  成功时响应    status: 200 OK    body:    {\n   msg :  ok \n}  例子  如下为删除上传例子中的jpg文件  curl -X DELETE \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  https://api.bmob.cn/2/files/upyun/2016/04/14/9306f2e74090d668801eac8814b3f56f.jpg  其中2016/04/14/9306f2e74090d668801eac8814b3f56f.jpg是文件上传时返回的url除去域名之后的字符串，upyun是上传时返回的cdn。  删除文件不会删除文件关联的行记录中的文件列的值，需要自行通过更新行来删除关联。", 
            "title": "删除文件"
        }, 
        {
            "location": "/data/restful/develop_doc/#_67", 
            "text": "请求描述 \n该接口可批量删除已经上传的文件。此操作不可逆，已经删除成功的文件不可恢复。  请求   url :https://api.bmob.cn/2/cdnBatchDelete  method : POST  header:   X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body\ncdnname为上传文件是返回的cdnname，url1，url2为上传时返回的url除去域名后的字符串。   {\n   cdnname :[ url1 , url2 ]\n}  成功时响应    status: 200 OK    body:    {\n   msg :  ok \n}  失败时响应 \ncdnname为删除失败的cdn名称，url1，url2为删除失败的url地址。  {\n   code : 154,\n   error :  error info ,\n   fail : {\n     cdnname : [\n       url1 ,\n       url2 \n    ]\n  }\n}  例子  如下为删除上传例子中的jpg文件  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n   {\n     upyun :[ 2016/04/14/9306f2e74090d668801eac8814b3f56f.jpg , 2016/04/14/ycf2f2e74090d668801eac88145523f.jpg ],\n}\n}'\\\n  https://api.bmob.cn/2/cdnBatchDelete  删除文件不会删除文件关联的行记录中的文件列的值，需要自行通过更新行来删除关联。", 
            "title": "批量删除文件"
        }, 
        {
            "location": "/data/restful/develop_doc/#acl_1", 
            "text": "数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看 Bmob数据与安全页面 ，了解Bmob如何保护数据安全）。  其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。  大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：   对于私有数据，读写权限可以只局限于数据的所有者。  对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。  对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。  属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。  一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。", 
            "title": "ACL和角色"
        }, 
        {
            "location": "/data/restful/develop_doc/#acl_2", 
            "text": "在Bmob中，ACL是按JSON对象格式（key-value）来表示的。这个JSON对象的key是objectId（用户表某个用户对应的objectId）或者是 *(表示公共的访问权限)，ACL 的值是 \"读和写的权限\", 这个JSON对象的key总是权限名, 而这些key的值总是 true。  如果您想让一个 id 为 \"Kc3M222k\" 的用户有读和写一条数据的权限, 而且这个数据应该可以被全部人读取的话，这个ACL的表达方式如下，只要将该值设置到对应数据的ACL字段中即可：  {\n   Kc3M222k : {\n     read : true,\n     write : true\n  },\n   * : {\n     read : true\n  }\n}", 
            "title": "ACL的格式"
        }, 
        {
            "location": "/data/restful/develop_doc/#_68", 
            "text": "在很多情况下，你需要定义一些用户具有某种相同的数据操作权限，而另外一群用户具有另外一种相同的数据操作权限，这时你就可以使用到Bmob的角色（对应Bmob在Web提供的Role表、SDK中的BmobRole类）功能，设置不同的用户组不同的操作权限。角色表有三个特殊字段：  name  : 必须字段，表示角色名称,而且只允许被设置一次（命名必须由字母, 空格, 减号或者下划线构成）；  users  :一个指向一系列用户的关系, 这些用户会继承角色的权限；  roles  : 一个指向一系列子角色的关系, 这些子关系会继承父角色所有的权限。  而创建角色、更新角色、删除角色本质就是对_Role表进行操作，因为该表是固定的，所以我们将请求的URL设置为https://api.bmob.cn/1/roles，具体操作如下。_Role表中含  users 和  roles 字段，其中  users  字段指向的是  _User  表，在该字段下的用户记录具备该角色的读写权限，而  roles  字段指向的是  _Role  表，在该字段下的角色记录都将继承该角色的权限。", 
            "title": "角色和相关操作"
        }, 
        {
            "location": "/data/restful/develop_doc/#_69", 
            "text": "创建一个新角色的方法如下（固定POST数据到https://api.bmob.cn/1/roles中，且必须提供  name  字段）：  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         name :  Moderators ,\n         ACL : {\n           * : {\n             read : true\n          }\n        }\n      }' \\\n  https://api.bmob.cn/1/roles  如果你要创建一个包括了“用户和子角色”的角色，实现方式如下：  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         name :  Moderators ,\n         ACL : {\n           * : {\n             read : true\n          }\n        },\n         roles : {\n           __op :  AddRelation ,\n           objects : [\n            {\n               __type :  Pointer ,\n               className :  _Role ,\n               objectId :  Fe441wZ5 \n            }\n          ]\n        },\n         users : {\n           __op :  AddRelation ,\n           objects : [\n            {\n               __type :  Pointer ,\n               className :  _User ,\n               objectId :  Kc3M222k \n            }\n          ]\n        }\n      }' \\\n  https://api.bmob.cn/1/roles  当创建成功后返回HTTP如下：  Status: 201 Created\nLocation: https://api.bmob.cn/1/roles/51e3812D", 
            "title": "创建角色"
        }, 
        {
            "location": "/data/restful/develop_doc/#_70", 
            "text": "获取角色对象的方法如下：  curl -X GET \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  https://api.bmob.cn/1/roles/51e3812D  响应结果如下：  {\n   createdAt :  2012-04-28 17:41:09 ,\n   objectId :  51e3812D ,\n   updatedAt :  2012-04-28 17:41:09 ,\n   ACL : {\n     * : {\n       read : true\n    },\n     role:Administrators : {\n       write : true\n    }\n  },\n   name :  Moderators \n}  注意 users 和 roles 关系无法在 JSON 结果中看到, 您需要使用 $relatedTo 操作符来查询。", 
            "title": "获取角色"
        }, 
        {
            "location": "/data/restful/develop_doc/#_71", 
            "text": "更新角色时，一个很重要的一点是：  name  字段不可以更改。添加和删除  users  和  roles  可以通过使用 AddRelation 和 RemoveRelation 操作符进行。  如给 \"Moderators\" 角色增加 2 个用户，实现如下:  curl -X PUT \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         users : {\n           __op :  AddRelation ,\n           objects : [\n            {\n               __type :  Pointer ,\n               className :  _User ,\n               objectId :  eba635d9 \n            },\n            {\n               __type :  Pointer ,\n               className :  _User ,\n               objectId :  51dfb8bd \n            }\n          ]\n        }\n      }' \\\n  https://api.bmob.cn/1/roles/51e3812D  删除 \"Moderrators\" 的一个子角色的实现如下：  curl -X PUT \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         roles : {\n           __op :  RemoveRelation ,\n           objects : [\n            {\n               __type :  Pointer ,\n               className :  _Role ,\n               objectId :  eba635d9 \n            }\n          ]\n        }\n      }' \\\n  https://api.bmob.cn/1/roles/51e3812D", 
            "title": "更新角色"
        }, 
        {
            "location": "/data/restful/develop_doc/#_72", 
            "text": "删除角色这里有一个需要注意的是：需要传入 X-Bmob-Session-Token ，即对这条数据有操作权限的用户SessionToken。实现如下：  curl -X DELETE \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  X-Bmob-Session-Token: pnktnjyb996sj4p156gjtp4im  \\\n  https://api.bmob.cn/1/roles/51e3812D", 
            "title": "删除角色"
        }, 
        {
            "location": "/data/restful/develop_doc/#_73", 
            "text": "设置一条数据的角色权限，需要在ACL中把Key的名字设置为 “ role:  + 角色名称” 。如限制一条数据可以被在 \"Members\" 里的任何人读到, 而且可以被它的创建者（objectId为 f1766d0b42 ）和任何有 \"Moderators\" 角色的人所修改, 实现方式如下:  {\n   f1766d0b42 : {\n     write : true\n  },\n   role:Members : {\n     read : true\n  },\n   role:Moderators : {\n     write : true\n  }\n}  如果这个用户和 \"Moderators\" 本身就是 \"Members\" 的子角色和用户，那么，您不必为创建的用户和 \"Moderators\" 指定读的权限，因为它们都会继承授予 \"Members\" 的权限。", 
            "title": "角色的使用"
        }, 
        {
            "location": "/data/restful/develop_doc/#_74", 
            "text": "一个角色可以包含另一个，可以为 2 个角色建立一个父-子关系。 这个关系的结果就是任何被授予父角色的权限隐含地被授予子角色。  这样的关系类型通常在用户管理的内容类的应用上比较常见, 比如在论坛中，有一些少数的用户是 \"管理员（Administartors）\", 有最高的权限，可以调整系统设置、 创建新的论坛等等。 另一类用户是 \"版主（Moderators）\"，他们可以对用户发帖的内容进行管理。可见，任何有管理员权限的人都应该有版主的权限。为建立起这种关系, 您应该把 \"Administartors\" 的角色设置为 \"Moderators\" 的子角色, 具体来说就是把 \"Administrators\" 这个角色加入 \"Moderators\" 对象的 roles 关系之中，实现如下：  \ncurl -X PUT \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         roles : {\n           __op :  AddRelation ,\n           objects : [\n            {\n               __type :  Pointer ,\n               className :  _Role ,\n               objectId :  AdministratorsRoleObjectId \n            }\n          ]\n        }\n      }' \\\n  https://api.bmob.cn/1/roles/ ModeratorsRoleObjectId", 
            "title": "角色的继承"
        }, 
        {
            "location": "/data/restful/develop_doc/#_75", 
            "text": "Bmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询。你可以在查询中添加一个GeoPoint的对象查询。你可以实现轻松查找出离当前用户最接近的信息或地点的功能。", 
            "title": "地理位置"
        }, 
        {
            "location": "/data/restful/develop_doc/#_76", 
            "text": "在表中添加一个地理位置的列，只需要在对应列值满足以下格式即可。  {\n  key : {\n     __type :  GeoPoint ,\n     latitude : latitudeValue,\n     longitude : longitude\n  }\n}  例如，如果需要在  GameScore  的特定对象中加上地理位置，其请求如下：  curl -X PUT \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{ location :{            \n             __type :  GeoPoint ,\n             latitude : 50.934755,\n             longitude : 24.52065\n        }}' \\\n  https://api.bmob.cn/1/classes/GameScore/e1kXT22L", 
            "title": "创建地理位置对象"
        }, 
        {
            "location": "/data/restful/develop_doc/#_77", 
            "text": "现在你有一系列的对象对应的地理坐标，如果能发现哪些对象离指定的点近就好了，这可以通过GeoPoint数据类型加上在查询中使用$nearSphere做到。查询的  where  参数值格式如下。  {\n  key: {\n     $nearSphere : {\n       __type :  GeoPoint ,\n       latitude : latitudeValue,\n       longitude : longitudeValue\n    }\n  }\n}  例如，获取离用户最近的10个地点应该看起来像下面这个样子  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'limit=10' \\\n    --data-urlencode 'where={\n     location : {\n         $nearSphere : {\n             __type :  GeoPoint ,\n             latitude : 30.0,\n             longitude : -20.0\n        }\n      }\n    }' \\\n    https://api.bmob.cn/1/classes/PlaceObject  这操作会按离纬度30.0，经度-20.0的距离排序返回一系列的结果，第一个就是最近的对象。(注意如果一个特定的order参数是给定了的话，它会覆盖按距离排序的结果)，例如，下面是两个上面的查询操作返回的结果：  {\n     results : [\n    {\n         location : {\n              __type :  GeoPoint ,\n             latitude : 40.0,\n             longitude : -30.0\n        },\n         updatedAt :  2011-12-06 22:36:04 ,\n         createdAt :  2011-12-06 22:36:04 ,\n         objectId :  e1kXT22L \n        },\n        {\n         location : {\n              __type :  GeoPoint ,\n             latitude : 60.0,\n             longitude : -20.0\n        },\n         updatedAt :  2011-12-06 22:36:26 ,\n         createdAt :  2011-12-06 22:36:26 ,\n         objectId :  51e3a2a8e4b015ead4d95dd9 \n        }\n    ]\n}  为了限定搜索的最大距离范围，需要加入  $maxDistanceInMiles(英里)  和  $maxDistanceInKilometers(公里d) 或者  $maxDistanceInRadians(弧度)  参数来限定，如果不加，则默认是100KM的半径。比如要找的半径在10公里内的话:  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={\n         location : {\n             $nearSphere : {\n                 __type :  GeoPoint ,\n                 latitude : 30.0,\n                 longitude : -20.0\n            },\n         $maxDistanceInKilometers : 10.0\n        }\n    }' \\\n    https://api.bmob.cn/1/classes/PlaceObject  同样作查询寻找在一个特定的范围里面的对象也是可以的，为了找到在一个矩形区域里的对象，按下面的格式加入一个约束  {\"$within\": {\"$box\": [southwestGeoPoint, northeastGeoPoint]}} ：  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n    -G \\\n    --data-urlencode 'where={\n         location : {\n             $within : {\n                 $box : [\n                    {\n                         __type :  GeoPoint ,\n                         latitude : 37.71,\n                         longitude : -122.53\n                    },\n                    {\n                         __type :  GeoPoint ,\n                         latitude : 30.82,\n                         longitude : -122.37\n                    }\n                ]\n            }\n        }\n    }' \\\n    https://api.bmob.cn/1/classes/PizzaPlaceObject  注意事项  关于地理位置的有一些问题是值得留意的:   每一个表 只能 一个地理位置列，每一个对象 只能 有一个索引指向一个GeoPoint对象  GeoPoint的点不能超过规定的范围。 纬度的范围 应该是在 -90.0到90.0 之间。 经度的范围 应该是在 -180.0到180.0 之间。如果您添加的经纬度超出了以上范围，将导致程序错误。  删除文件不会删除文件关联的行记录中的文件列的值，需要自行通过更新行来删除关联。  如果不加任何距离范围限制，则默认是100公里的半径范围。", 
            "title": "查询地理位置信息"
        }, 
        {
            "location": "/data/restful/develop_doc/#app_1", 
            "text": "通过app restful api，你可以查看，创建或编辑你的app，在用户管理后台也实现了这样的功能。通过验证你的bmob email账号和密码，你可以获取所有的app信息，创建一个新的app或者修改旧的app的信息。  app restful api的验证流程和其它restful api有点不一样。在验证的时候，不是验证你的app key，而是验证账号的登录信息。头部  X-Bmob-Email  代表登录用的email，头部  X-Bmob-Password  代表登录用的密码。", 
            "title": "app服务"
        }, 
        {
            "location": "/data/restful/develop_doc/#app_2", 
            "text": "请求描述  可以获取一个账号下所有app的信息或者某个app的信息，如下。  请求    url ：https://api.bmob.cn/1/apps （获取所有app信息） https://api.bmob.cn/1/apps/Your Application ID（获取特定app信息）    method ：GET    header:    X-Bmob-Email: Your Account Email\nX-Bmob-Password: Your Account Password  成功时响应    status: 200 OK    body:    请求所有应用信息的body结构如下：  {\n   results : [\n        {\n           appName : appName,\n           applicationId : app Id,\n           restKey : $estful Key,\n           masterKey : master Key,\n           accessKey : access Key,\n           secretKey : secret Key,\n           status : status (app 是否可用，0表示不可用，1表示可用),\n           notAllowedCreateTable : isAllowedCreateTable(是否允许通过api建表，0表示允许，1表示不允许)\n        }, \n        {\n               appName : appName,\n               applicationId : app Id,\n               restKey : $estful Key,\n               masterKey : master Key,\n               accessKey : access Key,\n               secretKey : secret Key,\n               status : status (app 是否可用，0表示不可用，1表示可用),\n               notAllowedCreateTable : isAllowedCreateTable(是否允许通过api建表，0表示允许，1表示不允许)\n         },\n         ...\n  ]\n}  请求单个应用信息的body结构如下：  {\n   appName : appName,\n   applicationId : app Id,\n   restKey : $estful Key,\n   masterKey : master Key,\n   accessKey : access Key,\n   secretKey : secret Key,\n   status : status (app 是否可用，0表示不可用，1表示可用),\n   notAllowedCreateTable : isAllowedCreateTable(是否允许通过api建表，0表示允许，1表示不允许)\n}", 
            "title": "获取app信息"
        }, 
        {
            "location": "/data/restful/develop_doc/#app_3", 
            "text": "请求描述  该请求接口可以动态创建一个应用。  请求    url ：https://api.bmob.cn/1/apps    method ：POST    header:    X-Bmob-Email: Your Account Email\nX-Bmob-Password: Your Account Password   body:   {\n   appName  : appName,\n   status : status,\n   notAllowedCreateTable : value\n}     参数名  参数用途  取值范围  是否必须要填      appName  app的名称  少于30个字符  是    status  app是否可用  0：表示禁用，1：表示可用  否    notAllowedCreateTable  是否允许通过api创建表  0：表示允许创建表，1：表示不允许创建表  否     成功时响应    status: 200 OK    body:    {\n   appName : appName,\n   applicationId : app Id,\n   restKey : $estful Key,\n   masterKey : master Key,\n   accessKey : access Key,\n   secretKey : secret Key,\n   status : status (app 是否可用，0表示不可用，1表示可用),\n   notAllowedCreateTable : isAllowedCreateTable(是否允许通过api建表，0表示允许，1表示不允许)\n}  例子  下面是一个创建app的例子  curl -X POST \\\n    -H  X-Bmob-Email: Your Account Email  \\\n    -H  X-Bmob-Password: Your Account Password  \\\n    -H  Content-Type: application/json  \\\n    -d '{ appName : myapp , status :1, notAllowedCreateTable :0}' \\\n    https://api.bmob.cn/1/apps", 
            "title": "创建新的app"
        }, 
        {
            "location": "/data/restful/develop_doc/#app_4", 
            "text": "修改app信息与添加app相似，只是请求URL修改为 https://api.bmob.cn/1/apps/appId，并且使用 PUT方法即可，其中body里为需要修改的信息，参见下表：  通过使用PUT 方法，可以修改app的信息，修改app信息时支持如下的参数：     参数名  参数用途  取值范围  是否必须要填      appName  app的名称  少于30个字符  否    status  app是否可用  0：表示禁用，1：表示可用  否    notAllowedCreateTable  是否允许通过api创建表  0：表示允许创建表，1：表示不允许创建表  否     下面是修改app信息的例子  curl -X PUT \\\n    -H  X-Bmob-Email: Your Account Email  \\\n    -H  X-Bmob-Password: Your Account Password  \\\n    -H  Content-Type: application/json  \\\n    -d '{ appName : myapp , status :1, notAllowedCreateTable :0}' \\\n    https://api.bmob.cn/1/apps/f6fe8d5ab8a7909a3c6f6a7a0adb9550", 
            "title": "修改app信息"
        }, 
        {
            "location": "/data/restful/develop_doc/#_78", 
            "text": "通过数据表的restful api，你可以查看，创建或编辑你的表结构，在用户管理后台的数据浏览页面也实现了这样的功能。  注意，调用数据表相关的api，必须指定Master Key。", 
            "title": "数据表"
        }, 
        {
            "location": "/data/restful/develop_doc/#app_5", 
            "text": "请求描述  可获取所有表的结构或者是特定某张表的结构  请求    url ：https://api.bmob.cn/1/schemas 或者 https://api.bmob.cn/1/schemas/tableName(获取特定表)    method ：GET    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-Master-Key: Your Master Key  成功时响应    status: 200 OK    body:     获取所有表结构：  {\n   results : [\n          {\n           className : tableName1,\n           fields : {\n            key1: {\n               type : typeOfKey1\n               targetClass :tableName（Pointer及Relation类型）\n            },\n            key2: {\n               type : typeOfKey2\n               targetClass :tableName（Pointer及Relation类型）\n            },\n            ...\n            }\n          }\n        },\n        {\n           className : tableName2,\n           fields : {\n            key1: {\n               type : typeOfKey1\n               targetClass :tableName（Pointer及Relation类型）\n            },\n            key2: {\n               type : typeOfKey2\n               targetClass :tableName（Pointer及Relation类型）\n            },\n            ...\n            }\n          }\n        },\n        ...\n    ]\n}  获取特定表结构  {\n   className : tableName,\n   fields : {\n    key1: {\n       type : typeOfKey1\n       targetClass :tableName（Pointer及Relation类型）\n    },\n    key2: {\n       type : typeOfKey2\n       targetClass :tableName（Pointer及Relation类型）\n    },\n    ...\n    }\n  }\n}  例子  例如，想要获取  GameScore  的表结构可使用以下请求。  curl -X GET \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-Master-Key: Your Master Key  \\\n    https://api.bmob.cn/1/schemas/GameScore  返回的body如下：  {\n   className :  GameScore ,\n   fields : {\n     ACL : {\n       type :  Object \n    },\n     createdAt : {\n       type :  Date \n    },\n     location : {\n       type :  Geo \n    },\n     name : {\n       type :  String \n    },\n     objectId : {\n       type :  String \n    },\n     updatedAt : {\n       type :  Date \n    }\n  }\n}", 
            "title": "获取app表的信息"
        }, 
        {
            "location": "/data/restful/develop_doc/#_79", 
            "text": "Bmob的表含有String、Number、Bool、Date、File、Geo、Array、Object、Pointer以及Relation类型。", 
            "title": "表支持的数据类型"
        }, 
        {
            "location": "/data/restful/develop_doc/#_80", 
            "text": "请求描述  可通过该接口创建一个表  请求    url ： https://api.bmob.cn/1/schemas/TableName    method ：POST    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-Master-Key: Your Master Key   body:   {\n   className : tableName,\n   fields : {\n    key1: {\n       type : typeOfKey1\n       targetClass :tableName（Pointer及Relation类型需要填）\n    },\n    key2: {\n       type : typeOfKey2\n       targetClass :tableName（Pointer及Relation类型需要填）\n    },\n    ...\n    }\n  }\n}  成功时响应    status: 200 OK    body:    {\n   className : tableName,\n   fields : {\n    key1: {\n       type : typeOfKey1\n       targetClass :tableName（Pointer及Relation类型）\n    },\n    key2: {\n       type : typeOfKey2\n       targetClass :tableName（Pointer及Relation类型）\n    },\n    ...\n    }\n  }\n}  例子  如创建表“City”，并添加字段  name  和  visiter  （指向_User）  curl -X POST \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-Master-Key: Your Master Key  \\\n    -H  Content-Type: application/json  \\\n    -d ' \n        {\n           className :  City ,\n           fields : {\n                 name : {\n                   type :  String \n                },\n                 visiter : {\n                   type :  Pointer ,\n                   targetClass : _User \n                }\n          }\n        }' \\\n  https://api.bmob.cn/1/schemas/City", 
            "title": "创建一个表"
        }, 
        {
            "location": "/data/restful/develop_doc/#_81", 
            "text": "请求描述  请求    url ：https://api.bmob.cn/1/schemas/tableName    method ：PUT    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-Master-Key: Your Master Key   body:     {\n       className : tableName,\n       fields : {\n        key1: {\n           type :  String (添加字段)\n        },\n        key2: {\n           type :  String ,\n           __op :  Delete  (删除字段)\n        }\n      }\n }  成功时响应    status: 200 OK    body:    返回的是修改后的表结构  {\n   className : tableName,\n   fields : {\n    key1: {\n       type : typeOfKey1\n       targetClass :tableName（Pointer及Relation类型）\n    },\n    key2: {\n       type : typeOfKey2\n       targetClass :tableName（Pointer及Relation类型）\n    },\n    ...\n    }\n  }\n}  例子  在表“City”中添加字段“name”  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-Master-Key: Your Master Key  \\\n    -H  Content-Type: application/json  \\\n    -d ' \n    {\n       className :  City ,\n       fields : {\n         name : {\n           type :  String \n        }\n      }\n    }' \\\n  https://api.bmob.cn/1/schemas/City  在表“City”中删除字段“name”  curl -X PUT \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-Master-Key: Your Master Key  \\\n    -H  Content-Type: application/json  \\\n    -d ' \n    {\n       className :  City ,\n       fields : {\n         name : {\n           type :  String ,\n           __op :  Delete   \n        }\n      }\n    }' \\\n  https://api.bmob.cn/1/schemas/City", 
            "title": "修改表的结构"
        }, 
        {
            "location": "/data/restful/develop_doc/#_82", 
            "text": "请求描述  请求    url ：https://api.bmob.cn/1/schemas/tableName    method ：DELETE    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-Master-Key: Your Master Key  成功时响应    status: 200 OK    body:    {\n   msg :  ok \n}  例子  删除City表  curl -X DELETE \\\n    -H  X-Bmob-Application-Id: Your Application ID  \\\n    -H  X-Bmob-Master-Key: Your Master Key  \\\n  https://api.bmob.cn/1/schemas/City", 
            "title": "删除表"
        }, 
        {
            "location": "/data/restful/develop_doc/#_83", 
            "text": "请求描述  有时，app需要获取服务器的时间，可使用该请求。  请求    url ：https://api.bmob.cn/1/timestamp    method ：GET    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key  成功时响应    status: 200 OK    body:    {\n   timestamp : timestamp,\n   datetime : YYYY-mm-dd HH:ii:ss(北京时间)\n}  例子  以下是一个请求样例，  curl -X GET \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  https://api.bmob.cn/1/timestamp  返回参数如下：  { timestamp :1437531770, datetime : 2015-07-22 10:22:50 }  timestamp为时间戳，datetime为格式化的日期。", 
            "title": "获取服务器时间"
        }, 
        {
            "location": "/data/restful/develop_doc/#_84", 
            "text": "参照 所有平台错误码列表  中的Restful部分。", 
            "title": "错误码"
        }, 
        {
            "location": "/cloud_function/android/", 
            "text": "云函数的API集成在BmobSDK中，因此不熟悉的朋友在使用前先可以了解一下BmobSDK的集成\nAndroid 快速入门\n\n\n很多时候，单纯的前端代码是不能完成全部事情的，一些重要和复杂的业务逻辑还是希望能够在服务端中执行。比如：对比较大量的比赛数据进行排序，对某个网站进行资料采集和处理，获取用户的IP信息，等等。Bmob不仅提供了云端存储，还开放了云端的业务逻辑代码功能，也就是云函数。\n\n\n相关云函数的使用，大家可以参考开发文档： \nhttp://docs.bmob.cn/cloudcode/WEB/a_faststart/doc/index.html\n\n\n云函数的执行有多种方法：\n\n\n\n\n定时任务（直接在Web管理后台中设定）； \n\n\nRestApi调用（参考开发文档：\nhttp://docs.bmob.cn/data/Restful/b_developdoc/doc/index.html#0%06Mn\n）； \n\n\nSDK调用。\n\n\n\n\n其中，在SDK中调用云函数的方法如下：\n\n\nAsyncCustomEndpoints ace = new AsyncCustomEndpoints();\n//第一个参数是上下文对象，第二个参数是云函数的方法名称，第三个参数是上传到云函数的参数列表（JSONObject cloudCodeParams），第四个参数是回调类\nace.callEndpoint(context, cloudCodeName, params, new CloudCodeListener() {\n    @Override\n    public void done(Object object, BmobException e) {\n        if (e == null) {\n            String result = object.toString();\n            } else {\n            Log.e(TAG, \n \n + e.getMessage());\n            }\n         }\n});", 
            "title": "开发文档"
        }, 
        {
            "location": "/cloud_function/ios/", 
            "text": "开发文档\n\n\n我们提供了BmobCloud类来调用云函数的功能，有两种方法\n\n\n//同步调用云函数，fuction指的用函数名 parameters为函数需要的参数，同步的方法情在子线程中使用，不然会卡住主线程\n+(id)callFunction:(NSString *)function withParameters:(NSDictionary *)parameters;\n\n\n\n\n例子:\n\n\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        //sayhello 为云函数的函数名，\n        //num 为参数名，@1为 参数值\n\n        id result = [BmobCloud callFunction:@\nsayhello\n withParameters:@{@\nnum\n:@1}];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            NSLog(@\ncloudFunction %@\n,result);\n        });\n    });\n\n\n\n\n//异步调用云函数，fuction指的用函数名 parameters为函数需要的参数\n+ (void)callFunctionInBackground:(NSString *)function withParameters:(NSDictionary *)parameters block:(BmobIdResultBlock)block;\n\n\n\n\n例如，在应用中添加了sayhello的云函数，功能是打印出hello，可以在SDK里这样调用\n\n\n[BmobCloud callFunctionInBackground:@\nsayhello\n withParameters:nil block:^(id object, NSError *error) {\n      if (error) {\n          NSLog(@\nerror %@\n,[error description]);\n      }\n     NSLog(@\nobject      %@\n,object);\n}] ;\n\n\n\n\n注意，为了确保体验，建议使用异步调用的方法。\n\n\n关于云函数的编写，详细参考  \n云函数开发文档", 
            "title": "开发文档"
        }, 
        {
            "location": "/cloud_function/ios/#_1", 
            "text": "我们提供了BmobCloud类来调用云函数的功能，有两种方法  //同步调用云函数，fuction指的用函数名 parameters为函数需要的参数，同步的方法情在子线程中使用，不然会卡住主线程\n+(id)callFunction:(NSString *)function withParameters:(NSDictionary *)parameters;  例子:      dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        //sayhello 为云函数的函数名，\n        //num 为参数名，@1为 参数值\n\n        id result = [BmobCloud callFunction:@ sayhello  withParameters:@{@ num :@1}];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            NSLog(@ cloudFunction %@ ,result);\n        });\n    });  //异步调用云函数，fuction指的用函数名 parameters为函数需要的参数\n+ (void)callFunctionInBackground:(NSString *)function withParameters:(NSDictionary *)parameters block:(BmobIdResultBlock)block;  例如，在应用中添加了sayhello的云函数，功能是打印出hello，可以在SDK里这样调用  [BmobCloud callFunctionInBackground:@ sayhello  withParameters:nil block:^(id object, NSError *error) {\n      if (error) {\n          NSLog(@ error %@ ,[error description]);\n      }\n     NSLog(@ object      %@ ,object);\n}] ;  注意，为了确保体验，建议使用异步调用的方法。  关于云函数的编写，详细参考   云函数开发文档", 
            "title": "开发文档"
        }, 
        {
            "location": "/cloud_function/java/", 
            "text": "云函数是一段部署在服务端的代码片段，采用 java 或 node.js 进行编写，然后部署运行在Bmob服务器\n\n\n通过云函数可以解决很多复杂的业务逻辑，从此无需将要将大量的数据发送到移动设备上做计算处理\n\n\n只需将这些计算都交由服务端运算处理，最后移动客户端仅仅需要接收云函数运算处理返回的数据结果就可以了\n\n\n通过更新云函数代码片段，客户端无需更新，便满足业务改动的需求。这样云函数便有更多的灵活性和自主性\n\n\n\n\n调用方法\n\n\n云函数提供了以下几种方式提供调用：\n\n\n\n\n\n\n\n\n调用方式\n\n\n所需信息\n\n\n优点\n\n\n\n\n\n\n\n\n\n\nSDK\n\n\nAppId\n\n\n交互自带加密,接入快速\n\n\n\n\n\n\nRestApi\n\n\nAppId、RestKey\n\n\n所有平台适用，通用性强\n\n\n\n\n\n\nHttp请求\n\n\nSecret Key\n\n\n所有平台适用，可用浏览器打开\n\n\n\n\n\n\n\n\nAndroid SDK\n\n\niOS SDK\n\n\nC# SDK\n\n\nRestful api\n\n\nHttp请求\n\n\n日志\n\n\n\n\n可在Bmob后台根据时间、日志级别、内容关键字、方法名搜索想要的日志\n\n\n每个应用拥有最大10m的日志空间，循环写入\n\n\n高级用户有实时日志功能\n\n\n\n\n代码规范\n\n\n\n\n\n\njava云函数必须遵循以下格式：\n\n\npublic static void onRequest(final Request request, final Response response, final Modules modules) throws Throwable {\n// 上面这个方法体，不允许任何修改\n// 这里使用Java编写云函数\n// 最后一个字符必须是 }\n}\n\n\n\n\n\n\n\n代码不能包含以下关键字：(保存代码时有错误提醒)\n\n\nClass\nFile\nSystem\n...\n\n\n\n\n\n\n\n需要获取当前毫秒时，可用 \ngetTime()\n 、\nnew java.util.Date().getTime()\n 替代 \nSystem.currentTimeMillis()\n\n\n\n\n如果确实需要用到被禁止使用的关键字，例如查询\"File\"表，可用\"F\"+\"ile\"的形式拼接\n\n\n不可包含\n/**/\n注释，如需注释，请用 \n//\n\n\n仅可写一个Java的方法，不能写多个方法、类变量、静态变量等\n\n\n云函数执行完毕后，必须用response.send方法返回响应数据，否则会被当做超时，多次超时可能会被暂停使用\n\n\n\n\nRequest对象\n\n\nonRequest方法参数中 \nRequest request\n 包含了本次请求的全部信息：\n\n\n\n\n\n\n\n\n名称\n\n\n类型\n\n\n获取方法\n\n\n示例\n\n\n\n\n\n\n\n\n\n\n路径Path\n\n\nString\n\n\nrequest.getPath()\n\n\n/xxxxxxxxxxxxxxxx/test1\n\n\n\n\n\n\n方法Method\n\n\nString\n\n\nrequest.getMethod()\n\n\nPOST\n\n\n\n\n\n\n请求头Headers\n\n\nJSONObject\n\n\nrequest.getHeaders()\n\n\n{\"User-Agent\":[\"Chorme\"]}\n\n\n\n\n\n\n请求体Body\n\n\nbyte[]\n\n\nrequest.getBody()\n\n\n[98, 109, 111, 98]\n\n\n\n\n\n\nGet参数\n\n\nJSONObject\n\n\nrequest.getQueryParams()\n\n\n{\"page\": \"1\"}\n\n\n\n\n\n\nBody内参数\n\n\nJSONObject\n\n\nrequest.getParams()\n\n\n{\"username\": \"zwr\"}\n\n\n\n\n\n\n单个请求头\n\n\nString\n\n\nrequest.getHeader(String key)\n\n\nrequest.getHeader(\"User-Agent\") = \"Chrome\"\n\n\n\n\n\n\n单个Get参数\n\n\nString\n\n\nrequest.getQueryParam(String key)\n\n\nrequest.getQueryParam(\"page\") = \"1\"\n\n\n\n\n\n\n\n\nResponse对象\n\n\n\n\nonRequest方法参数中 \nResponse response\n 用于响应请求，返回数据\n\n\n\n\nResponse对象仅有名为 \nsend\n 的方法，参数不同共有4种重载形式(Overloading):\n\n\n\n\n\n\nsend(Object res)\n\n\n\n\nsend(Object res, int statusCode)\n\n\nsend(Object res, int statusCode, String statusMsg)\n\n\nsend(Object res, int statusCode, String statusMsg, JSONObject headers)\n\n\n\n\n以下是参数说明：\n\n\n\n\n\n\n\n\n名称\n\n\n类型\n\n\n意义\n\n\n\n\n\n\n\n\n\n\nres\n\n\nObject\n\n\n返回的内容：如果为byte[]类型直接返回；否则会返回res.toString(\"UTF-8\")\n\n\n\n\n\n\nstatusCode\n\n\nint\n\n\n返回的Http响应状态码，例如200、404\n\n\n\n\n\n\nstatusMsg\n\n\nString\n\n\n返回的Http响应状态，例如OK、NotFound\n\n\n\n\n\n\nheaders\n\n\nJSONObject\n\n\n返回的头部信息，采用String-String的格式，例如{\"Content-Type\": \"text/plain; charset=UTF-8\"}\n\n\n\n\n\n\n\n\n\n\n示例\n// 1. 直接返回字符串\nresponse.send(\"Hello world--Bmob\");\n// 2. 返回404错误\nresponse.send(\"Error\", 404, \"NotFound\");\n// 3. 返回中文字符串，需要返回包含charset的header\nresponse.send(\n    \"你好，比目\",\n    200,\n    \"OK\",\n    JSON.toJson(\"Content-Type\", \"text/plain; charset=UTF-8\")\n);\n\n\n\n\n\n\n\nModules对象\n\n\n\n\nonRequest方法参数中 \nModules modules\n 提供了几个模块供开发者调用：\n\n\n\n\n\n\n\n\n\n\n模块名\n\n\n获取方式\n\n\n作用\n\n\n\n\n\n\n\n\n\n\nBmob数据库操作对象\n\n\nmodules.oData\n\n\n封装了Bmob的大多数api，以供开发者进行快速的业务逻辑开发，详见下文 \nBmob数据操作\n\n\n\n\n\n\n日志输出对象\n\n\nmodules.oLog\n\n\n提供了几个级别的日志输出，以便调试，详见下文 \n日志输出\n\n\n\n\n\n\n\n\n日志输出\n\n\n    // 设置需要输出的日志级别\n    // Level_All = 0\n    // Level_Debug = 1\n    // Level_Warn = 2\n    // Level_Error = 3\n    modules.oLog.level = modules.oLog.Level_All // 全部都会输出\n    modules.oLog.level = modules.oLog.Level_Warn // 仅输出Warn和Error\n    modules.oLog.level = modules.oLog.Level_Error // 仅Error级别日志\n\n    modules.oLog.d(Object) // 输出Debug级别日志\n    modules.oLog.w(Object) // 输出Warn级别日志\n    modules.oLog.e(Object) // 输出Error级别日志\n    modules.oLog.debug(String,Object...) // 格式化输出Debug级别日志\n    modules.oLog.warn(String,Object...) // 格式化输出Warn级别日志\n    modules.oLog.error(String,Object...) // 格式化输出Error级别日志\n\n\n\nBmob数据操作\n\n\n以下均为 \nmodules.oData\n 的方法：\n\n\n\n\n\n\n\n\n方法体\n\n\n返回值\n\n\n描述\n\n\n\n\n\n\n\n\n\n\nsetDomain(String)\n\n\nthis\n\n\n设置请求的域名，仅迁移用户需要使用\n\n\n\n\n\n\nsetTimeout(int)\n\n\nthis\n\n\n设置超时时间(单位:毫秒)，与云函数超时无关\n\n\n\n\n\n\nsetHeader(String...)\n\n\nthis\n\n\n设置请求头\n\n\n\n\n\n\nsetHeader(JSONObject)\n\n\nthis\n\n\n设置请求头\n\n\n\n\n\n\nsetUserSession(String)\n\n\nthis\n\n\n设置用户的Session Token\n\n\n\n\n\n\nsetMasterKey(String)\n\n\nthis\n\n\n设置应用的Master Key\n\n\n\n\n\n\ninsert(String table,JSONObject data)\n\n\nHttpResponse\n\n\n往数据表中添加一行\n\n\n\n\n\n\nremove(String table,String objectId)\n\n\nHttpResponse\n\n\n删除数据表中的一行\n\n\n\n\n\n\nupdate(String table,String objectId,JSONObject data)\n\n\nHttpResponse\n\n\n更新数据表中的一行\n\n\n\n\n\n\nfind(Querier)\n\n\nHttpResponse\n\n\n使用查询器查询数据\n\n\n\n\n\n\nfindOne(String table,String objectId)\n\n\nHttpResponse\n\n\n查询数据表中的一行\n\n\n\n\n\n\nuploadfile(String fileName,bytes[] bytes)\n\n\nHttpResponse\n\n\n上传一个文件\n\n\n\n\n\n\nuploadfile(String fileName,bytes[] bytes,String contentType)\n\n\nHttpResponse\n\n\n上传一个文件，并指定格式\n\n\n\n\n\n\ndeletefile(String cdnName,String url)\n\n\nHttpResponse\n\n\n删除文件\n\n\n\n\n\n\ndeletefiles(JSONObject)\n\n\nHttpResponse\n\n\n批量删除文件\n\n\n\n\n\n\nbql(String,Object...)\n\n\nHttpResponse\n\n\n使用BQL查询\n\n\n\n\n\n\nuserSignUp(JSONObject)\n\n\nHttpResponse\n\n\n用户注册\n\n\n\n\n\n\nuserLogin(String username,String password\n\n\nHttpResponse\n\n\n用户通过账号、密码登陆\n\n\n\n\n\n\nuserLoginBySMS(String mobile, String smsCode,JSONObject userInfo)\n\n\nHttpResponse\n\n\n用户通过短信验证码一键注册或登录\n\n\n\n\n\n\nuserResetPasswordByEmail(String email)\n\n\nHttpResponse\n\n\n用户请求Email重置密码\n\n\n\n\n\n\nuserResetPasswordBySMS(String smsCode,String password)\n\n\nHttpResponse\n\n\n用户通过短信验证码重置密码\n\n\n\n\n\n\nuserResetPasswordByPWD(String userId,String session, String oldPassword, String newPassword)\n\n\nHttpResponse\n\n\n用户通过旧密码修改新密码\n\n\n\n\n\n\nsendCustomSMS(String mobile, String content)\n\n\nHttpResponse\n\n\n发送自定义短信\n\n\n\n\n\n\nsendSMSCode(String mobile, String template)\n\n\nHttpResponse\n\n\n发送某模版的短信验证码\n\n\n\n\n\n\nverifySMSCode(String mobile, String smsCode)\n\n\nHttpResponse\n\n\n验证短信验证码\n\n\n\n\n\n\npayQuery(String orderId)\n\n\nHttpResponse\n\n\n查询支付订单\n\n\n\n\n\n\ncloudCode(String funcName, JSONObject body)\n\n\nHttpResponse\n\n\n调用云函数\n\n\n\n\n\n\npush(JSONObject body)\n\n\nHttpResponse\n\n\n向客户端推送消息\n\n\n\n\n\n\nroleInsert(JSONObject data)\n\n\nHttpResponse\n\n\nACL:创建角色\n\n\n\n\n\n\nroleFindOne(String roleId)\n\n\nHttpResponse\n\n\nACL:查询角色\n\n\n\n\n\n\nroleUpdate(String roleId, JSONObject data)\n\n\nHttpResponse\n\n\nACL:修改角色\n\n\n\n\n\n\nroleDelete(String roleId)\n\n\nHttpResponse\n\n\nACL:删除角色\n\n\n\n\n\n\ngetDBTime()\n\n\nHttpResponse\n\n\n获取Restful服务器的时间\n\n\n\n\n\n\nbatch(JSONArray requests)\n\n\nHttpResponse\n\n\n批量请求\n\n\n\n\n\n\n\n\n内置类\n\n\nHttpResponse\n\n\n类变量\n:\n\n\n\n\n\n\n\n\n变量名\n\n\n类型\n\n\n描述\n\n\n\n\n\n\n\n\n\n\nerr\n\n\nString\n\n\n错误信息\n\n\n\n\n\n\nres\n\n\nResponseStatus\n\n\n请求状态(见下表)\n\n\n\n\n\n\ndata\n\n\nbyte[]\n\n\n返回的数据\n\n\n\n\n\n\nstringData\n\n\nString\n\n\n返回的数据转String格式\n\n\n\n\n\n\njsonData\n\n\nJSONObject\n\n\n返回的数据转JSON格式\n\n\n\n\n\n\n\n\nResponseStatus\n\n\n类变量\n:\n\n\n\n\n\n\n\n\n变量名\n\n\n类型\n\n\n描述\n\n\n\n\n\n\n\n\n\n\ncode\n\n\nint\n\n\n状态码\n\n\n\n\n\n\nstatus\n\n\nString\n\n\n状态描述\n\n\n\n\n\n\nheaders\n\n\nJSONObject\n\n\n返回的Http头部\n\n\n\n\n\n\n\n\nQuerier\n\n\n类方法\n:\n\n\n\n\n\n\n\n\n方法体\n\n\n描述\n\n\n\n\n\n\n\n\n\n\n\\\ninit>(String table)\n\n\n构造方法，传入表名\n\n\n\n\n\n\nQuerier limit(int)\n\n\n设置最大返回行数\n\n\n\n\n\n\nQuerier skip(int)\n\n\n设置跳过的个数\n\n\n\n\n\n\nQuerier order(String)\n\n\n排序规则\n\n\n\n\n\n\nQuerier keys(String)\n\n\n需要返回的属性\n\n\n\n\n\n\nQuerier include(String)\n\n\n需要返回详细信息的Pointer属性\n\n\n\n\n\n\nQuerier where(JSONObject)\n\n\n设置查询条件\n\n\n\n\n\n\n\n\nBmobUpdater\n\n\n该类的全部静态方法都用于设置insert、update方法的请求内容\n\n\n静态方法\n：\n\n\n\n\n\n\n\n\n方法体\n\n\n描述\n\n\n\n\n\n\n\n\n\n\nJSONObject add(JSONObject data,String key,Object value)\n\n\n往data添加一个键值\n\n\n\n\n\n\nJSONObject increment(JSONObject data,String key,Number number)\n\n\n原子计数\n\n\n\n\n\n\nJSONObject arrayAdd(JSONObject data,String key,Object obj)\n\n\n往Array类型添加一项\n\n\n\n\n\n\nJSONObject arrayAddAll(JSONObject data,String key,JSONArray objects)\n\n\n往Array类型添加多项\n\n\n\n\n\n\nJSONObject arrayAddUnique(JSONObject data,String key,Object obj)\n\n\n往Array类型不重复地添加一项\n\n\n\n\n\n\nJSONObject arrayAddAllUnique(JSONObject data,String key,JSONArray objects)\n\n\n往Array类型不重复地添加多项\n\n\n\n\n\n\nJSONObject arrayRemoveAll(JSONObject data,String key,JSONArray objects)\n\n\n删除Array类型的多项\n\n\n\n\n\n\nJSONObject addRelations(JSONObject data, String key,BmobPointer...pointers)\n\n\n添加多个Relation关系\n\n\n\n\n\n\nJSONObject removeRelations(JSONObject data, String key,BmobPointer...pointers)\n\n\n移除多个Relation关系\n\n\n\n\n\n\n\n\nJSON\n\n\n静态方法：\n\n\n    String stringify(JSONObject m)\n    String stringify(JSONArray m)\n    JSONObject parse(String s)\n    JSONArray parseArray(String s)\n    JSONObject setJson(JSONObject json, Object... kNvs)\n    JSONArray append(JSONArray array, Object... objs)\n    JSONArray toArray(Object... objs)\n    JSONObject strsToJson(String... kNvs)\n    JSONObject toJson(Object... kNvs)\n\n\n\nJSONObject\n\n\n类方法：\n\n\n    int size()\n    boolean isEmpty()\n    boolean containsKey(Object key)\n    boolean containsValue(Object value)\n    Object get(Object key)\n    Object put(String key, Object value) \n    Object remove(Object key)\n    void clear()\n    Set\nString\n keySet()\n    BigInteger getBigInteger(String key)\n    BigDecimal getBigDecimal(String key)\n    Boolean getBoolean(String key)\n    boolean getBooleanValue(String key) \n    Byte getByte(String key)\n    byte getByteValue(String key)\n    Date getDate(String key)\n    Double getDouble(String key)\n    double getDoubleValue(String key)\n    Float getFloat(String key)\n    float getFloatValue(String key)\n    Integer getInteger(String key)\n    int getIntValue(String key)\n    JSONArray getJSONArray(String key)\n    JSONObject getJSONObject(String key)\n    Long getLong(String key)\n    long getLongValue(String key)\n    Short getShort(String key)\n    short getShortValue(String key)\n    String getString(String key)\n\n\n\nJSONArray\n\n\n类方法：\n\n\n    int size() \n    boolean isEmpty() \n    boolean contains(Object o) \n    boolean add(Object e) \n    boolean remove(Object o) \n    boolean containsAll(Collection\n?\n c) \n    boolean addAll(Collection\n? extends Object\n c) \n    boolean addAll(int index, Collection\n? extends Object\n c) \n    boolean removeAll(Collection\n?\n c) \n    boolean retainAll(Collection\n?\n c) \n    void clear() \n    Object get(int index) \n    Object set(int index, Object element) \n    void add(int index, Object element) \n    Object remove(int index) \n    BigInteger getBigInteger(int index) \n    BigDecimal getBigDecimal(int index) \n    Boolean getBoolean(int index) \n    boolean getBooleanValue(int index) \n    Byte getByte(int index) \n    byte getByteValue(int index) \n    Date getDate(int index) \n    Double getDouble(int index) \n    double getDoubleValue(int index) \n    Float getFloat(int index) \n    float getFloatValue(int index) \n    Integer getInteger(int index) \n    int getIntValue(int index) \n    JSONArray getJSONArray(int index) \n    JSONObject getJSONObject(int index) \n    Long getLong(int index) \n    long getLongValue(int index) \n    Short getShort(int index) \n    short getShortValue(int index) \n    String getString(int index)\n\n\n\nBmobPointer\n\n\n构造方法：\n\n\n    BmobPointer(String className, String objectId)\n\n\n\nBmobfile\n\n\n构造方法：\n\n\n    Bmobfile(String filename, String url)\n\n\n\nBmobDate\n\n\n构造方法：\n\n\n    BmobDate(String timeStamp)\n    BmobDate(long millSec)\n\n\n\nBmobGeoPoint\n\n\n构造方法：\n\n\n    BmobGeoPoint(double longitude, double latitude)\n\n\n\nAES\n\n\n静态方法：\n\n\n    byte[] aes(byte[] str, byte[] key, byte[] iv, boolean eOd, String keyAlgorithm, String cipherAlgorithm)\n    byte[] Encode(byte[] content, byte[] key, byte[] iv)\n    byte[] Decode(byte[] content, byte[] key, byte[] iv)\n\n\n\nBase64\n\n\n静态方法：\n\n\n    String Encode(byte[] data)\n    byte[] Decode(String str)\n\n\n\nCrypto\n\n\n静态方法：\n\n\n    String Encode(String algorithm, String content)\n    String Encode(String algorithm, byte[] bytes)\n    byte[] EncodeToBytes(String algorithm, byte[] bytes)\n    String Bytes2Hex(byte bytes[])\n    String Bytes2Hex(byte bytes[], int offset, int length)\n\n\n\nGZip\n\n\n静态方法：\n\n\n    byte[] Decode(byte[] bytes)\n    byte[] Encode(byte[] bytes)\n\n\n\nMD5\n\n\n静态方法：\n\n\n    String Encode(String content)\n    String Encode(byte[] bytes)\n    byte[] EncodeToBytes(byte[] bytes)\n\n\n\nRSA\n\n\n静态方法：\n\n\n    KeyPair GenerateKeys()\n    KeyPair RestoreKeys(byte[] keyBytes)\n    PublicKey ParsePublicKey(byte[] keyBytes)\n    byte[] Encode(PublicKey pubKey, byte[] content)\n    byte[] Decode(PrivateKey priKey, byte[] content)\n    byte[] Sign(PrivateKey priKey, byte[] content)\n    boolean Verify(PublicKey pubKey, byte[] content, byte[] sign)\n\n\n\nSHA1\n\n\n静态方法：\n\n\n    String Encode(String content)\n    String Encode(byte[] bytes)\n    byte[] EncodeToBytes(byte[] bytes)\n\n\n\n内置方法：\n\n\n    long getTime() // 获取当前毫秒\n    String fmt(String, Object...) // 格式化\n    JSON.toJson(Object...) // Json化\n    JSONObject JSON.parse(String) // String转JSONObject\n    JSONArray JSON.parseArray(String) // String转JSONArray\n    boolean isStrEmpty(String) // 判断字符串是否为空\n    arraycopy(Object from, int fromOffset, Object to, int toOffset, int length) // 复制数组内容\n\n\n\n示例：\n\n\n\n\n\n\n场景1\n:\n\n\n用户在app提交了反馈，参数有\"userObjectId\"、\"title\"、\"content\"、\"type\"，需要保存到FeedBack表\n\n\nJSONObject params = request.getParams();\nString title = params.getString(\"title\");\nString content = params.getString(\"content\");\nString userId = params.getString(\"userObjectId\");\nint type = params.getIntValue(\"type\");\n\nJSONObject data = JSON.toJson(\n    \"title\", title,\n    \"content\", content,\n    \"type\", type\n);\nBmobUpdater.add(\n    data,\n    \"user\",\n    new BmobPointer(\"_User\", userId)\n);\n\nresponse.send(\n    modules.oData.insert(\n        \"Feedback\",\n        data\n    ).stringData\n);\n\n\n\n\n\n\n\n场景2\n:\n\n\n查询Feedback表中，type为1、title字段不为空，且创建时间在12小时以内的最新10条数据，并只需要反馈content和对应user的用户名\n\n\nQuerier q = new Querier(\"Feedback\")\n                .limit(10)\n                .include(\"user\")\n                .order(\"-createdAt\");\nq.addWhereEqualTo(\"type\", 1);\nq.addWhereExists(\"title\");\nq.addWhereGreaterThanOrEqualTo(\"createdAt\",\n    new BmobDate(getTime() - 12 * 60 * 60 * 1000)\n);\nHttpResponse res = modules.oData.find(q);\nJSONArray feedbacks = res.jsonData.getJSONArray(\"results\");\nif (feedbacks == null)// 请求有错误，直接返回全部内容\n    response.send(res.data);\nelse {\n    JSONArray arr = new JSONArray();\n    for (int i = 0, l = feedbacks.size(); i \n l; i++) {\n        JSONObject fb = feedbacks.getJSONObject(i);\n        JSONObject user = fb.getJSONObject(\"user\");\n        arr.add(\n            JSON.toJson(\n                \"username\",\n                user == null ? null : user.getString(\"username\"),\n                \"content\",\n                fb.getString(\"content\")\n            )\n        );\n    }\n    response.send(JSON.toJson(\"results\", arr));\n}\n\n\n\n\n\n\n\n注意事项\n\n\n\n\n\n\n如果你编写的Java云函数经常发生运行超时、上下行超流量、滥用内存等现象，官方将会自动封停你的云函数功能，修改后向客服申请方可继续使用\n\n\n\n\n\n\n如果某接口调用频率较高，超过默认并发量，则会直接返回错误，解决方法：\n\n\n1.修改客户端代码，降低请求频率\n2.修改云函数，提高代码质量和效率，减少网络请求相关的超时时长，尽快结束工作\n3.购买更高的并发配置\n\n\n\n\n\n\n\n如果需要接受更大的请求体，或返回更大的结果，请购买更高的配置", 
            "title": "开发文档"
        }, 
        {
            "location": "/cloud_function/java/#_1", 
            "text": "云函数提供了以下几种方式提供调用：     调用方式  所需信息  优点      SDK  AppId  交互自带加密,接入快速    RestApi  AppId、RestKey  所有平台适用，通用性强    Http请求  Secret Key  所有平台适用，可用浏览器打开", 
            "title": "调用方法"
        }, 
        {
            "location": "/cloud_function/java/#android-sdk", 
            "text": "", 
            "title": "Android SDK"
        }, 
        {
            "location": "/cloud_function/java/#ios-sdk", 
            "text": "", 
            "title": "iOS SDK"
        }, 
        {
            "location": "/cloud_function/java/#c-sdk", 
            "text": "", 
            "title": "C# SDK"
        }, 
        {
            "location": "/cloud_function/java/#restful-api", 
            "text": "", 
            "title": "Restful api"
        }, 
        {
            "location": "/cloud_function/java/#http", 
            "text": "", 
            "title": "Http请求"
        }, 
        {
            "location": "/cloud_function/java/#_2", 
            "text": "可在Bmob后台根据时间、日志级别、内容关键字、方法名搜索想要的日志  每个应用拥有最大10m的日志空间，循环写入  高级用户有实时日志功能", 
            "title": "日志"
        }, 
        {
            "location": "/cloud_function/java/#_3", 
            "text": "java云函数必须遵循以下格式：  public static void onRequest(final Request request, final Response response, final Modules modules) throws Throwable {\n// 上面这个方法体，不允许任何修改\n// 这里使用Java编写云函数\n// 最后一个字符必须是 }\n}    代码不能包含以下关键字：(保存代码时有错误提醒)  Class\nFile\nSystem\n...    需要获取当前毫秒时，可用  getTime()  、 new java.util.Date().getTime()  替代  System.currentTimeMillis()   如果确实需要用到被禁止使用的关键字，例如查询\"File\"表，可用\"F\"+\"ile\"的形式拼接  不可包含 /**/ 注释，如需注释，请用  //  仅可写一个Java的方法，不能写多个方法、类变量、静态变量等  云函数执行完毕后，必须用response.send方法返回响应数据，否则会被当做超时，多次超时可能会被暂停使用", 
            "title": "代码规范"
        }, 
        {
            "location": "/cloud_function/java/#request", 
            "text": "onRequest方法参数中  Request request  包含了本次请求的全部信息：     名称  类型  获取方法  示例      路径Path  String  request.getPath()  /xxxxxxxxxxxxxxxx/test1    方法Method  String  request.getMethod()  POST    请求头Headers  JSONObject  request.getHeaders()  {\"User-Agent\":[\"Chorme\"]}    请求体Body  byte[]  request.getBody()  [98, 109, 111, 98]    Get参数  JSONObject  request.getQueryParams()  {\"page\": \"1\"}    Body内参数  JSONObject  request.getParams()  {\"username\": \"zwr\"}    单个请求头  String  request.getHeader(String key)  request.getHeader(\"User-Agent\") = \"Chrome\"    单个Get参数  String  request.getQueryParam(String key)  request.getQueryParam(\"page\") = \"1\"", 
            "title": "Request对象"
        }, 
        {
            "location": "/cloud_function/java/#response", 
            "text": "onRequest方法参数中  Response response  用于响应请求，返回数据   Response对象仅有名为  send  的方法，参数不同共有4种重载形式(Overloading):    send(Object res)   send(Object res, int statusCode)  send(Object res, int statusCode, String statusMsg)  send(Object res, int statusCode, String statusMsg, JSONObject headers)   以下是参数说明：     名称  类型  意义      res  Object  返回的内容：如果为byte[]类型直接返回；否则会返回res.toString(\"UTF-8\")    statusCode  int  返回的Http响应状态码，例如200、404    statusMsg  String  返回的Http响应状态，例如OK、NotFound    headers  JSONObject  返回的头部信息，采用String-String的格式，例如{\"Content-Type\": \"text/plain; charset=UTF-8\"}      示例 // 1. 直接返回字符串\nresponse.send(\"Hello world--Bmob\");\n// 2. 返回404错误\nresponse.send(\"Error\", 404, \"NotFound\");\n// 3. 返回中文字符串，需要返回包含charset的header\nresponse.send(\n    \"你好，比目\",\n    200,\n    \"OK\",\n    JSON.toJson(\"Content-Type\", \"text/plain; charset=UTF-8\")\n);", 
            "title": "Response对象"
        }, 
        {
            "location": "/cloud_function/java/#modules", 
            "text": "onRequest方法参数中  Modules modules  提供了几个模块供开发者调用：      模块名  获取方式  作用      Bmob数据库操作对象  modules.oData  封装了Bmob的大多数api，以供开发者进行快速的业务逻辑开发，详见下文  Bmob数据操作    日志输出对象  modules.oLog  提供了几个级别的日志输出，以便调试，详见下文  日志输出", 
            "title": "Modules对象"
        }, 
        {
            "location": "/cloud_function/java/#_4", 
            "text": "// 设置需要输出的日志级别\n    // Level_All = 0\n    // Level_Debug = 1\n    // Level_Warn = 2\n    // Level_Error = 3\n    modules.oLog.level = modules.oLog.Level_All // 全部都会输出\n    modules.oLog.level = modules.oLog.Level_Warn // 仅输出Warn和Error\n    modules.oLog.level = modules.oLog.Level_Error // 仅Error级别日志\n\n    modules.oLog.d(Object) // 输出Debug级别日志\n    modules.oLog.w(Object) // 输出Warn级别日志\n    modules.oLog.e(Object) // 输出Error级别日志\n    modules.oLog.debug(String,Object...) // 格式化输出Debug级别日志\n    modules.oLog.warn(String,Object...) // 格式化输出Warn级别日志\n    modules.oLog.error(String,Object...) // 格式化输出Error级别日志", 
            "title": "日志输出"
        }, 
        {
            "location": "/cloud_function/java/#bmob", 
            "text": "以下均为  modules.oData  的方法：     方法体  返回值  描述      setDomain(String)  this  设置请求的域名，仅迁移用户需要使用    setTimeout(int)  this  设置超时时间(单位:毫秒)，与云函数超时无关    setHeader(String...)  this  设置请求头    setHeader(JSONObject)  this  设置请求头    setUserSession(String)  this  设置用户的Session Token    setMasterKey(String)  this  设置应用的Master Key    insert(String table,JSONObject data)  HttpResponse  往数据表中添加一行    remove(String table,String objectId)  HttpResponse  删除数据表中的一行    update(String table,String objectId,JSONObject data)  HttpResponse  更新数据表中的一行    find(Querier)  HttpResponse  使用查询器查询数据    findOne(String table,String objectId)  HttpResponse  查询数据表中的一行    uploadfile(String fileName,bytes[] bytes)  HttpResponse  上传一个文件    uploadfile(String fileName,bytes[] bytes,String contentType)  HttpResponse  上传一个文件，并指定格式    deletefile(String cdnName,String url)  HttpResponse  删除文件    deletefiles(JSONObject)  HttpResponse  批量删除文件    bql(String,Object...)  HttpResponse  使用BQL查询    userSignUp(JSONObject)  HttpResponse  用户注册    userLogin(String username,String password  HttpResponse  用户通过账号、密码登陆    userLoginBySMS(String mobile, String smsCode,JSONObject userInfo)  HttpResponse  用户通过短信验证码一键注册或登录    userResetPasswordByEmail(String email)  HttpResponse  用户请求Email重置密码    userResetPasswordBySMS(String smsCode,String password)  HttpResponse  用户通过短信验证码重置密码    userResetPasswordByPWD(String userId,String session, String oldPassword, String newPassword)  HttpResponse  用户通过旧密码修改新密码    sendCustomSMS(String mobile, String content)  HttpResponse  发送自定义短信    sendSMSCode(String mobile, String template)  HttpResponse  发送某模版的短信验证码    verifySMSCode(String mobile, String smsCode)  HttpResponse  验证短信验证码    payQuery(String orderId)  HttpResponse  查询支付订单    cloudCode(String funcName, JSONObject body)  HttpResponse  调用云函数    push(JSONObject body)  HttpResponse  向客户端推送消息    roleInsert(JSONObject data)  HttpResponse  ACL:创建角色    roleFindOne(String roleId)  HttpResponse  ACL:查询角色    roleUpdate(String roleId, JSONObject data)  HttpResponse  ACL:修改角色    roleDelete(String roleId)  HttpResponse  ACL:删除角色    getDBTime()  HttpResponse  获取Restful服务器的时间    batch(JSONArray requests)  HttpResponse  批量请求", 
            "title": "Bmob数据操作"
        }, 
        {
            "location": "/cloud_function/java/#_5", 
            "text": "", 
            "title": "内置类"
        }, 
        {
            "location": "/cloud_function/java/#httpresponse", 
            "text": "类变量 :     变量名  类型  描述      err  String  错误信息    res  ResponseStatus  请求状态(见下表)    data  byte[]  返回的数据    stringData  String  返回的数据转String格式    jsonData  JSONObject  返回的数据转JSON格式", 
            "title": "HttpResponse"
        }, 
        {
            "location": "/cloud_function/java/#responsestatus", 
            "text": "类变量 :     变量名  类型  描述      code  int  状态码    status  String  状态描述    headers  JSONObject  返回的Http头部", 
            "title": "ResponseStatus"
        }, 
        {
            "location": "/cloud_function/java/#querier", 
            "text": "类方法 :     方法体  描述      \\ init>(String table)  构造方法，传入表名    Querier limit(int)  设置最大返回行数    Querier skip(int)  设置跳过的个数    Querier order(String)  排序规则    Querier keys(String)  需要返回的属性    Querier include(String)  需要返回详细信息的Pointer属性    Querier where(JSONObject)  设置查询条件", 
            "title": "Querier"
        }, 
        {
            "location": "/cloud_function/java/#bmobupdater", 
            "text": "该类的全部静态方法都用于设置insert、update方法的请求内容  静态方法 ：     方法体  描述      JSONObject add(JSONObject data,String key,Object value)  往data添加一个键值    JSONObject increment(JSONObject data,String key,Number number)  原子计数    JSONObject arrayAdd(JSONObject data,String key,Object obj)  往Array类型添加一项    JSONObject arrayAddAll(JSONObject data,String key,JSONArray objects)  往Array类型添加多项    JSONObject arrayAddUnique(JSONObject data,String key,Object obj)  往Array类型不重复地添加一项    JSONObject arrayAddAllUnique(JSONObject data,String key,JSONArray objects)  往Array类型不重复地添加多项    JSONObject arrayRemoveAll(JSONObject data,String key,JSONArray objects)  删除Array类型的多项    JSONObject addRelations(JSONObject data, String key,BmobPointer...pointers)  添加多个Relation关系    JSONObject removeRelations(JSONObject data, String key,BmobPointer...pointers)  移除多个Relation关系", 
            "title": "BmobUpdater"
        }, 
        {
            "location": "/cloud_function/java/#json", 
            "text": "静态方法：      String stringify(JSONObject m)\n    String stringify(JSONArray m)\n    JSONObject parse(String s)\n    JSONArray parseArray(String s)\n    JSONObject setJson(JSONObject json, Object... kNvs)\n    JSONArray append(JSONArray array, Object... objs)\n    JSONArray toArray(Object... objs)\n    JSONObject strsToJson(String... kNvs)\n    JSONObject toJson(Object... kNvs)", 
            "title": "JSON"
        }, 
        {
            "location": "/cloud_function/java/#jsonobject", 
            "text": "类方法：      int size()\n    boolean isEmpty()\n    boolean containsKey(Object key)\n    boolean containsValue(Object value)\n    Object get(Object key)\n    Object put(String key, Object value) \n    Object remove(Object key)\n    void clear()\n    Set String  keySet()\n    BigInteger getBigInteger(String key)\n    BigDecimal getBigDecimal(String key)\n    Boolean getBoolean(String key)\n    boolean getBooleanValue(String key) \n    Byte getByte(String key)\n    byte getByteValue(String key)\n    Date getDate(String key)\n    Double getDouble(String key)\n    double getDoubleValue(String key)\n    Float getFloat(String key)\n    float getFloatValue(String key)\n    Integer getInteger(String key)\n    int getIntValue(String key)\n    JSONArray getJSONArray(String key)\n    JSONObject getJSONObject(String key)\n    Long getLong(String key)\n    long getLongValue(String key)\n    Short getShort(String key)\n    short getShortValue(String key)\n    String getString(String key)", 
            "title": "JSONObject"
        }, 
        {
            "location": "/cloud_function/java/#jsonarray", 
            "text": "类方法：      int size() \n    boolean isEmpty() \n    boolean contains(Object o) \n    boolean add(Object e) \n    boolean remove(Object o) \n    boolean containsAll(Collection ?  c) \n    boolean addAll(Collection ? extends Object  c) \n    boolean addAll(int index, Collection ? extends Object  c) \n    boolean removeAll(Collection ?  c) \n    boolean retainAll(Collection ?  c) \n    void clear() \n    Object get(int index) \n    Object set(int index, Object element) \n    void add(int index, Object element) \n    Object remove(int index) \n    BigInteger getBigInteger(int index) \n    BigDecimal getBigDecimal(int index) \n    Boolean getBoolean(int index) \n    boolean getBooleanValue(int index) \n    Byte getByte(int index) \n    byte getByteValue(int index) \n    Date getDate(int index) \n    Double getDouble(int index) \n    double getDoubleValue(int index) \n    Float getFloat(int index) \n    float getFloatValue(int index) \n    Integer getInteger(int index) \n    int getIntValue(int index) \n    JSONArray getJSONArray(int index) \n    JSONObject getJSONObject(int index) \n    Long getLong(int index) \n    long getLongValue(int index) \n    Short getShort(int index) \n    short getShortValue(int index) \n    String getString(int index)", 
            "title": "JSONArray"
        }, 
        {
            "location": "/cloud_function/java/#bmobpointer", 
            "text": "构造方法：      BmobPointer(String className, String objectId)", 
            "title": "BmobPointer"
        }, 
        {
            "location": "/cloud_function/java/#bmobfile", 
            "text": "构造方法：      Bmobfile(String filename, String url)", 
            "title": "Bmobfile"
        }, 
        {
            "location": "/cloud_function/java/#bmobdate", 
            "text": "构造方法：      BmobDate(String timeStamp)\n    BmobDate(long millSec)", 
            "title": "BmobDate"
        }, 
        {
            "location": "/cloud_function/java/#bmobgeopoint", 
            "text": "构造方法：      BmobGeoPoint(double longitude, double latitude)", 
            "title": "BmobGeoPoint"
        }, 
        {
            "location": "/cloud_function/java/#aes", 
            "text": "静态方法：      byte[] aes(byte[] str, byte[] key, byte[] iv, boolean eOd, String keyAlgorithm, String cipherAlgorithm)\n    byte[] Encode(byte[] content, byte[] key, byte[] iv)\n    byte[] Decode(byte[] content, byte[] key, byte[] iv)", 
            "title": "AES"
        }, 
        {
            "location": "/cloud_function/java/#base64", 
            "text": "静态方法：      String Encode(byte[] data)\n    byte[] Decode(String str)", 
            "title": "Base64"
        }, 
        {
            "location": "/cloud_function/java/#crypto", 
            "text": "静态方法：      String Encode(String algorithm, String content)\n    String Encode(String algorithm, byte[] bytes)\n    byte[] EncodeToBytes(String algorithm, byte[] bytes)\n    String Bytes2Hex(byte bytes[])\n    String Bytes2Hex(byte bytes[], int offset, int length)", 
            "title": "Crypto"
        }, 
        {
            "location": "/cloud_function/java/#gzip", 
            "text": "静态方法：      byte[] Decode(byte[] bytes)\n    byte[] Encode(byte[] bytes)", 
            "title": "GZip"
        }, 
        {
            "location": "/cloud_function/java/#md5", 
            "text": "静态方法：      String Encode(String content)\n    String Encode(byte[] bytes)\n    byte[] EncodeToBytes(byte[] bytes)", 
            "title": "MD5"
        }, 
        {
            "location": "/cloud_function/java/#rsa", 
            "text": "静态方法：      KeyPair GenerateKeys()\n    KeyPair RestoreKeys(byte[] keyBytes)\n    PublicKey ParsePublicKey(byte[] keyBytes)\n    byte[] Encode(PublicKey pubKey, byte[] content)\n    byte[] Decode(PrivateKey priKey, byte[] content)\n    byte[] Sign(PrivateKey priKey, byte[] content)\n    boolean Verify(PublicKey pubKey, byte[] content, byte[] sign)", 
            "title": "RSA"
        }, 
        {
            "location": "/cloud_function/java/#sha1", 
            "text": "静态方法：      String Encode(String content)\n    String Encode(byte[] bytes)\n    byte[] EncodeToBytes(byte[] bytes)", 
            "title": "SHA1"
        }, 
        {
            "location": "/cloud_function/java/#_6", 
            "text": "long getTime() // 获取当前毫秒\n    String fmt(String, Object...) // 格式化\n    JSON.toJson(Object...) // Json化\n    JSONObject JSON.parse(String) // String转JSONObject\n    JSONArray JSON.parseArray(String) // String转JSONArray\n    boolean isStrEmpty(String) // 判断字符串是否为空\n    arraycopy(Object from, int fromOffset, Object to, int toOffset, int length) // 复制数组内容", 
            "title": "内置方法："
        }, 
        {
            "location": "/cloud_function/java/#_7", 
            "text": "场景1 :  用户在app提交了反馈，参数有\"userObjectId\"、\"title\"、\"content\"、\"type\"，需要保存到FeedBack表  JSONObject params = request.getParams();\nString title = params.getString(\"title\");\nString content = params.getString(\"content\");\nString userId = params.getString(\"userObjectId\");\nint type = params.getIntValue(\"type\");\n\nJSONObject data = JSON.toJson(\n    \"title\", title,\n    \"content\", content,\n    \"type\", type\n);\nBmobUpdater.add(\n    data,\n    \"user\",\n    new BmobPointer(\"_User\", userId)\n);\n\nresponse.send(\n    modules.oData.insert(\n        \"Feedback\",\n        data\n    ).stringData\n);    场景2 :  查询Feedback表中，type为1、title字段不为空，且创建时间在12小时以内的最新10条数据，并只需要反馈content和对应user的用户名  Querier q = new Querier(\"Feedback\")\n                .limit(10)\n                .include(\"user\")\n                .order(\"-createdAt\");\nq.addWhereEqualTo(\"type\", 1);\nq.addWhereExists(\"title\");\nq.addWhereGreaterThanOrEqualTo(\"createdAt\",\n    new BmobDate(getTime() - 12 * 60 * 60 * 1000)\n);\nHttpResponse res = modules.oData.find(q);\nJSONArray feedbacks = res.jsonData.getJSONArray(\"results\");\nif (feedbacks == null)// 请求有错误，直接返回全部内容\n    response.send(res.data);\nelse {\n    JSONArray arr = new JSONArray();\n    for (int i = 0, l = feedbacks.size(); i   l; i++) {\n        JSONObject fb = feedbacks.getJSONObject(i);\n        JSONObject user = fb.getJSONObject(\"user\");\n        arr.add(\n            JSON.toJson(\n                \"username\",\n                user == null ? null : user.getString(\"username\"),\n                \"content\",\n                fb.getString(\"content\")\n            )\n        );\n    }\n    response.send(JSON.toJson(\"results\", arr));\n}", 
            "title": "示例："
        }, 
        {
            "location": "/cloud_function/java/#_8", 
            "text": "如果你编写的Java云函数经常发生运行超时、上下行超流量、滥用内存等现象，官方将会自动封停你的云函数功能，修改后向客服申请方可继续使用    如果某接口调用频率较高，超过默认并发量，则会直接返回错误，解决方法：  1.修改客户端代码，降低请求频率\n2.修改云函数，提高代码质量和效率，减少网络请求相关的超时时长，尽快结束工作\n3.购买更高的并发配置    如果需要接受更大的请求体，或返回更大的结果，请购买更高的配置", 
            "title": "注意事项"
        }, 
        {
            "location": "/cloud_function/javascript/", 
            "text": "开发文档\n\n\n云函数调用使用\nBmob.Cloud.run\n方法，如调用云函数中的\"test\"方法，并传递name参数到服务器中的示例代码如下：\n\n\nBmob.Cloud.run('test', {\nname\n:\ntom\n}, {\n  success: function(result) {\n    alert(result);\n  },\n  error: function(error) {\n  }\n})\n\n\n\n\n如果不需要传递参数，示例代码如下：\n\n\nBmob.Cloud.run('test', {}, {\n  success: function(result) {\n    alert(result);\n  },\n  error: function(error) {\n  }\n})", 
            "title": "开发文档"
        }, 
        {
            "location": "/cloud_function/javascript/#_1", 
            "text": "云函数调用使用 Bmob.Cloud.run 方法，如调用云函数中的\"test\"方法，并传递name参数到服务器中的示例代码如下：  Bmob.Cloud.run('test', { name : tom }, {\n  success: function(result) {\n    alert(result);\n  },\n  error: function(error) {\n  }\n})  如果不需要传递参数，示例代码如下：  Bmob.Cloud.run('test', {}, {\n  success: function(result) {\n    alert(result);\n  },\n  error: function(error) {\n  }\n})", 
            "title": "开发文档"
        }, 
        {
            "location": "/cloud_function/csharp/", 
            "text": "开发 文档\n\n\n云函数的调用方法非常简单，如下为调用执行云端方法\ntest\n的实现代码：\n\n\nBmob.Endpoint\nHashtable\n(\ntest\n, (resp, exception) =\n \n{\n    if (exception != null)\n    {\n        print(\n调用失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n返回对象为： \n + resp);\n});\n\n\n\n\n调用时传递参数：\n\n\nIDictionary\nString, Object\n parameters ＝  new IDictionary\nString, Object\n{{\nname\n,\njay\n}};\n\nBmob.Endpoint\nHashtable\n(\ntest\n, parameters, (resp, exception) =\n \n    {\n        if (exception != null)\n        {\n            print(\n调用失败, 失败原因为： \n + exception.Message);\n            return;\n        }\n\n        print(\n返回对象为： \n + resp);\n    });\n\n\n\n\n相关云函数的编写方式，请参考\n云函数开发文档\n。", 
            "title": "开发文档"
        }, 
        {
            "location": "/cloud_function/csharp/#_1", 
            "text": "云函数的调用方法非常简单，如下为调用执行云端方法 test 的实现代码：  Bmob.Endpoint Hashtable ( test , (resp, exception) =  \n{\n    if (exception != null)\n    {\n        print( 调用失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 返回对象为：   + resp);\n});  调用时传递参数：  IDictionary String, Object  parameters ＝  new IDictionary String, Object {{ name , jay }};\n\nBmob.Endpoint Hashtable ( test , parameters, (resp, exception) =  \n    {\n        if (exception != null)\n        {\n            print( 调用失败, 失败原因为：   + exception.Message);\n            return;\n        }\n\n        print( 返回对象为：   + resp);\n    });  相关云函数的编写方式，请参考 云函数开发文档 。", 
            "title": "开发 文档"
        }, 
        {
            "location": "/cloud_function/php/", 
            "text": "云函数\n\n\n相关云函数的编写方式，请参考\n云函数开发文档\n\n\n运行云函数\n\n\n在REST API中可以调用云函数。例如，想调用云函数的方法getMsgCode:\n\n\n$cloudCode = new BmobCloudCode('getMsgCode'); //调用名字为getMsgCode的云函数\n$res = $cloudCode-\nget(array(\nname\n=\nbmob\n)); //传入参数name，其值为bmob", 
            "title": "开发文档"
        }, 
        {
            "location": "/cloud_function/php/#_1", 
            "text": "相关云函数的编写方式，请参考 云函数开发文档", 
            "title": "云函数"
        }, 
        {
            "location": "/cloud_function/php/#_2", 
            "text": "在REST API中可以调用云函数。例如，想调用云函数的方法getMsgCode:  $cloudCode = new BmobCloudCode('getMsgCode'); //调用名字为getMsgCode的云函数\n$res = $cloudCode- get(array( name = bmob )); //传入参数name，其值为bmob", 
            "title": "运行云函数"
        }, 
        {
            "location": "/cloud_function/restful/", 
            "text": "开发文档\n\n\n相关云函数的编写方式，请参考\n云函数开发文档\n\n\n在REST API中可以调用云函数。例如，想调用云函数的方法hello:\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/functions/funcName\n\n\n\n\n\n\nmethod ：POST\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  key1 : value1,\n  key2 : value2,\n  ...\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody: 对应云函数返回的格式。\n\n\n\n\n\n\n例子\n\n\n如调用名为hello的云函数可使用以下请求。\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\nname\n:1337.23,\nplayerName\n:\nSean Plott\n,\ncheatMode\n:false}' \\\n  https://api.bmob.cn/1/functions/hello\n\n\n\n\n如果运行的云函数不需要传入参数，请参考下面的例子。\n\n注意，\"{}\"是不能缺的\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{}' \\\n  https://api.bmob.cn/1/functions/test", 
            "title": "开发文档"
        }, 
        {
            "location": "/cloud_function/restful/#_1", 
            "text": "相关云函数的编写方式，请参考 云函数开发文档  在REST API中可以调用云函数。例如，想调用云函数的方法hello:  请求    url ：https://api.bmob.cn/1/functions/funcName    method ：POST    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n  key1 : value1,\n  key2 : value2,\n  ...\n}  成功时响应    status: 200 OK    body: 对应云函数返回的格式。    例子  如调用名为hello的云函数可使用以下请求。  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{ name :1337.23, playerName : Sean Plott , cheatMode :false}' \\\n  https://api.bmob.cn/1/functions/hello  如果运行的云函数不需要传入参数，请参考下面的例子。 注意，\"{}\"是不能缺的  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{}' \\\n  https://api.bmob.cn/1/functions/test", 
            "title": "开发文档"
        }, 
        {
            "location": "/cloud_function/web/", 
            "text": "注册Bmob帐号\n\n\n在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。\n\n\n\n\n网站后台创建应用\n\n\n登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。\n\n\n\n\n获取应用密钥和下载SDK\n\n\n选择你要开发的应用，进入该应用\n\n\n\n\n在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID\n\n\n\n\n获取Application ID后，下载SDK，开发者可以根据自己的需求选择相应的iOS SDK 或Android SDK，点击下载即可。\n\n\n\n\n创建云函数\n\n\n在Bmob后台中，选择你刚刚创建好的应用，然后依次点击“云函数-\n添加方法”，在弹出窗口中输入云函数的方法名，该方法名将会在SDK调用时使用到。如下图所示：\n\n\n\n\n\n\n接着，你就可以在云函数的编辑器中撰写云函数了。如果你熟悉js脚本语言的话，撰写云函数非常简单，你只需要在onRequest方法中补充你的业务逻辑代码就可以了。onRequest方法包含3个参数，分别是request（请求对象，可以从中获取SDK上传的参数）, response（回应对象，可以将云函数的执行结果返回到SDK中）, modules（可调用的模块，包含数据库对象、HTTP对象等）。为方便演示，这里简单实现一个功能：接收客户端上传上来的name参数，根据name的值返回不同的结果。代码如下：\n\n\nfunction onRequest(request, response, modules) {\n  //获取SDK客户端上传的name参数\n  var name = request.body.name;\n    if(name == 'bmob')\n      response.end('欢迎使用Bmob');\n    else\n      response.end('输入错误，请重新输入');\n}                         \n\n\n\n\n安装和初始化BmobSDK\n\n\n云函数的调用执行可以是在云端（通过“定时任务”模块去设置执行，实现定时业务逻辑计算的功能，如排行榜，这个操作非常简单，这里不再一一介绍），但更多的开发者是通过SDK调用的方式来执行云函数。这有点像存储过程，大家可以将更多的业务逻辑放在云端，可以随意改变，不需要更新应用，也不需要上传太多的数据参数。\n\n\n安装和初始化SDK的过程大家根据各自的平台（\nAndroid\n / \niOS\n等）具体参考快速入门文档即可。\n\n\n调用云函数\n\n\n将如下的代码根据各自平台，插入到触发执行的方法里面。\n\n\nAndroid调用云函数\n\n\n//test对应你刚刚创建的云函数名称\nString cloudCodeName = \ntest\n;\nJSONObject params = new JSONObject();\n//name是上传到云端的参数名称，值是bmob，云函数可以通过调用request.body.name获取这个值 \nparams.put(\nname\n, \nbmob\n);\n//创建云函数对象\nAsyncCustomEndpoints cloudCode = new AsyncCustomEndpoints();\n//异步调用云函数\ncloudCode.callEndpoint(MainActivity.this, cloudCodeName, params, new CloudCodeListener() {\n\n    //执行成功时调用，返回result对象\n    @Override\n    public void onSuccess(Object result) {\n        Log.i(\nbmob\n, \nresult = \n+result.toString());\n    }\n\n    //执行失败时调用\n    @Override\n    public void onFailure(String err) {\n        Log.i(\nbmob\n, \nBmobException = \n+err);\n    }\n});\n\n\n\n\niOS调用云函数\n\n\n    //name是上传到云端的参数名称，值是bmob，云函数可以通过调用request.body.name获取这个值 \n    NSDictionary  *dic = [NSDictionary  dictionaryWithObject:@\nbmob\n forKey:@\nname\n];\n    //test对应你刚刚创建的云函数名称\n    [BmobCloud callFunctionInBackground:@\ntest\n withParameters:dic block:^(id object, NSError *error) {\n\n    if (!error) {\n        //执行成功时调用\n        NSLog(@\nerror %@\n,[object description]);\n    }else{\n       //执行失败时调用\n        NSLog(@\nerror %@\n,[error description]);\n    }\n\n    }] ;\n\n\n\n\n源码下载\n\n\niOS源码下载\n\n\nAndroid源码下载", 
            "title": "快速入门"
        }, 
        {
            "location": "/cloud_function/web/#bmob", 
            "text": "在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。", 
            "title": "注册Bmob帐号"
        }, 
        {
            "location": "/cloud_function/web/#_1", 
            "text": "登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。", 
            "title": "网站后台创建应用"
        }, 
        {
            "location": "/cloud_function/web/#sdk", 
            "text": "选择你要开发的应用，进入该应用   在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID   获取Application ID后，下载SDK，开发者可以根据自己的需求选择相应的iOS SDK 或Android SDK，点击下载即可。", 
            "title": "获取应用密钥和下载SDK"
        }, 
        {
            "location": "/cloud_function/web/#_2", 
            "text": "在Bmob后台中，选择你刚刚创建好的应用，然后依次点击“云函数- 添加方法”，在弹出窗口中输入云函数的方法名，该方法名将会在SDK调用时使用到。如下图所示：    接着，你就可以在云函数的编辑器中撰写云函数了。如果你熟悉js脚本语言的话，撰写云函数非常简单，你只需要在onRequest方法中补充你的业务逻辑代码就可以了。onRequest方法包含3个参数，分别是request（请求对象，可以从中获取SDK上传的参数）, response（回应对象，可以将云函数的执行结果返回到SDK中）, modules（可调用的模块，包含数据库对象、HTTP对象等）。为方便演示，这里简单实现一个功能：接收客户端上传上来的name参数，根据name的值返回不同的结果。代码如下：  function onRequest(request, response, modules) {\n  //获取SDK客户端上传的name参数\n  var name = request.body.name;\n    if(name == 'bmob')\n      response.end('欢迎使用Bmob');\n    else\n      response.end('输入错误，请重新输入');\n}", 
            "title": "创建云函数"
        }, 
        {
            "location": "/cloud_function/web/#bmobsdk", 
            "text": "云函数的调用执行可以是在云端（通过“定时任务”模块去设置执行，实现定时业务逻辑计算的功能，如排行榜，这个操作非常简单，这里不再一一介绍），但更多的开发者是通过SDK调用的方式来执行云函数。这有点像存储过程，大家可以将更多的业务逻辑放在云端，可以随意改变，不需要更新应用，也不需要上传太多的数据参数。  安装和初始化SDK的过程大家根据各自的平台（ Android  /  iOS 等）具体参考快速入门文档即可。", 
            "title": "安装和初始化BmobSDK"
        }, 
        {
            "location": "/cloud_function/web/#_3", 
            "text": "将如下的代码根据各自平台，插入到触发执行的方法里面。", 
            "title": "调用云函数"
        }, 
        {
            "location": "/cloud_function/web/#android", 
            "text": "//test对应你刚刚创建的云函数名称\nString cloudCodeName =  test ;\nJSONObject params = new JSONObject();\n//name是上传到云端的参数名称，值是bmob，云函数可以通过调用request.body.name获取这个值 \nparams.put( name ,  bmob );\n//创建云函数对象\nAsyncCustomEndpoints cloudCode = new AsyncCustomEndpoints();\n//异步调用云函数\ncloudCode.callEndpoint(MainActivity.this, cloudCodeName, params, new CloudCodeListener() {\n\n    //执行成功时调用，返回result对象\n    @Override\n    public void onSuccess(Object result) {\n        Log.i( bmob ,  result =  +result.toString());\n    }\n\n    //执行失败时调用\n    @Override\n    public void onFailure(String err) {\n        Log.i( bmob ,  BmobException =  +err);\n    }\n});", 
            "title": "Android调用云函数"
        }, 
        {
            "location": "/cloud_function/web/#ios", 
            "text": "//name是上传到云端的参数名称，值是bmob，云函数可以通过调用request.body.name获取这个值 \n    NSDictionary  *dic = [NSDictionary  dictionaryWithObject:@ bmob  forKey:@ name ];\n    //test对应你刚刚创建的云函数名称\n    [BmobCloud callFunctionInBackground:@ test  withParameters:dic block:^(id object, NSError *error) {\n\n    if (!error) {\n        //执行成功时调用\n        NSLog(@ error %@ ,[object description]);\n    }else{\n       //执行失败时调用\n        NSLog(@ error %@ ,[error description]);\n    }\n\n    }] ;", 
            "title": "iOS调用云函数"
        }, 
        {
            "location": "/cloud_function/web/#_4", 
            "text": "iOS源码下载  Android源码下载", 
            "title": "源码下载"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/", 
            "text": "简介\n\n\nBmob旨在让移动开发变得更简单。对于一些复杂的应用，您可能希望增加一些特有的业务逻辑，并能灵活掌控，Bmob云函数提供了这种灵活性，可以让您的代码直接在Bmob云上运行。一旦你在云端更新了代码，所有的移动应用都会立即自动更新，新功能的发布将会变得更加简单可控。\n\n\n开源案例\n\n\n为方便大家更好的使用云函数，Bmob为大家提供了一些常用模块，方便大家直接拿来使用的。\n\n\n\n\n\n\n对整个表进行排序：\nhttps://github.com/bmob/bmob-cloudcode-demo-ranking/blob/master/order1.js\n 可结合定时任务使用\n\n\n\n\n\n\n获取某行数据对应排行的信息： \nhttps://github.com/bmob/bmob-cloudcode-demo-ranking/blob/master/order2.js\n\n\n\n\n\n\n获取前N名数据排行信息：\nhttps://github.com/bmob/bmob-cloudcode-demo-ranking/blob/master/order3.js\n\n\n\n\n\n\n在开发云函数时，希望大家能够先看看我们提供的编码规范文档：\nhttp://docs.bmob.cn/cloudcode/WEB/f_codehelp/doc/index.html\n\n\n调用云函数的方式\n\n\nbmob允许以http的方式直接调用云函数。\n\n\n获取Secret Key\n\n\n用户需要以http的方式运行云函数，需要先确定应用的Secret Key。 调用云函数时，通过Secret Key标识一个应用，获取Secret Key的路径：\n管理后台-\n应用密钥-\nSecret Key, 如下图所示：\n\n\n\n注意：请妥善保管Secret Key，避免Secret Key的泄露！！！\n\n\n以Get的方式调用云函数\n\n\n下面展示了以Get的方式调用云函数：\n\n\ncurl -X GET http://cloud.bmob.cn/0348d0c262bc91d9/test?name=jeff\n\n\n\n\n其中：\n0348d0c262bc91d9：应用的Secret Key。\ntest：云函数的名称\nname=jeff: 传入一个参数，名称是name，值是jeff\n与restful不同，无需再传其它诸如app id等请求头。\n\n\n以Post的方式调用云函数\n\n\n下面展示了以Post的方式调用云函数：\n\n\ncurl -X POST \\\n    -H \nContent-Type: application/x-www-form-urlencoded\n \\\n    -d 'name=jeff' \\\n    http://cloud.bmob.cn/0348d0c262bc91d9/test\n\n\n\n\n其中：\n0348d0c262bc91d9：应用的Secret Key。\ntest：云函数的名称\nname=jeff: 传入一个参数，名称是name，值是jeff\n与restful不同，无需再传其它诸如app id等请求头。\n\n\n转为套餐后调用云函数的方式\n\n\n注意：升级云函数套餐后就没法在微信公众号中调用云函数\n\n\nbmob允许以http的方式直接调用云函数。\n\n\n获取应用的id值\n\n\n进入应用后台-\n云函数，下图中的箭头所指的数字就是该应用的id值：\n\n\n\nGet的方式调用云函数\n\n\n下面展示了以Get的方式调用云函数：\n\n\ncurl -X GET http://cloud-xxxxx.bmobapp.com/test?name=jeff\n\n\n\n\n其中：\ncloud-xxxxx.bmobapp.com：该应用的云函数专属域名，其中xxxxx为上节“获取应用的id值”所获取的id值。\ntest：云函数的名称。\nname=jeff: 传入一个参数，名称是name，值是jeff。\n与restful不同，无需再传其它诸如app id等请求头。\n\n\nPost的方式调用云函数\n\n\n下面展示了以Post的方式调用云函数：\n\n\ncurl -X POST \\\n    -H \nContent-Type: application/x-www-form-urlencoded\n \\\n    -d 'name=jeff' \\\n    http://cloud-xxxxx.bmobapp.com/test\n\n\n\n\n其中：\ncloud-xxxxx.bmobapp.com：该应用的云函数专属域名，其中xxxxx为上节“获取应用的id值”所获取的id值。\ntest：云函数的名称\nname=jeff: 传入一个参数，名称是name，值是jeff\n与restful不同，无需再传其它诸如app id等请求头。\n\n\n云函数模块解释\n\n\n从云函数的入口方法function onRequest(request, response, modules)可知，云函数包含三个模块，分别是request模块、response模块和modules模块。\n\n\nrequest模块\n\n\nrequest模块用于获取传入的参数。由于现在调用云函数有两种方式（get和post），所以获取传入的参数的方式需要使用不同的方法。\n\n\n注意，当通过android，ios等客户端sdk调用云函数，或者通过restful api的方式调用云函数，都是采用post的方式。\n\n\nget方式\n\n\n用get方式调用云函数，例如：\n\n\ncurl -X GET http://cloud.bmob.cn/0348d0c262bc91d9/test?name=jeff\n\n\n\n\n可用下面的方法获取name的值：\n\n\nrequest.query.name\n\n\n\n\npost方式\n\n\n用post方式调用云函数，例如：\n\n\ncurl -X POST \\\n    -H \nContent-Type: application/x-www-form-urlencoded\n \\\n    -d 'name=jeff' \\\n    http://cloud.bmob.cn/0348d0c262bc91d9/test\n\n\n\n\n可用下面的方法获取name的值：\n\n\nrequest.body.name\n\n\n\n\n获取调用云函数的http方式\n\n\n当云函数是用于某些平台的回调时，同一段云函数可能有时是采用get的方式调用，有时是采用post的方式调用, 可用下面的方法获取当前云函数是采用get还是post方式调用。\n\n\n例子如下：\n\n\n    var httptype = request.method;　//获取调用云函数的是post或者get方式\n    if (\nGET\n == httptype) {\n        //采用get方式调用云函数\n    }else{\n        //采用post方式调用云函数\n    }\n\n\n\n\n\nresponse模块\n\n\nresponse为云函数的信息回传模块，该模块包含了一个send方法，实现将云端的执行结果（如查询的数据）返回给SDK或者RestApi等调用端：\n\n\nresponse.send(string result)\n\n\n\n\nmodules模块\n\n\nmodules是Bmob云函数提供给大家的各种对象处理的模块，包括数据库对象（oData）、文件对象（oFile）、地理位置对象（oLocation）、关联关系对象（oRelation）、原子操作对象（oAtom）、数据批量操作对象（oBatch）、数组对象（oArray）、消息推送对象（oPush）、云函数对象（oFunctions）、邮件发送对象（oMail）、HTTP对象（oHttp）、字符编码转换对象（oEncodeing）、事件对象（oEvent）、bql对象（oBql）、html元素解析对象（oHtmlparser）、加密对象（oCrypto）。云函数想要调用这些对象时，只需要用如下的方法即可获取：\n\n\n  //获取数据库对象\n  var db = modules.oData;\n  //下面进行其他操作\n\n\n\n\n 这里需要说明一点的是：云函数对数据格式的封装遵循RestApi的规则，如果在查看过程中有什么疑问，请移步到\nRestApi开发文档\n。 \n\n\n数据库对象\n\n\n数据库操作的简单实例如下：\n\n\nfunction onRequest(request, response, modules) {\n  //获取数据库对象\n  var db = modules.oData;\n  //获取Posts表中的所有值\n  db.find({\n    \ntable\n:\nPosts\n,\n  },function(err,data){\n    response.send(data);\n  });\n}\n\n\n\n\n其中，Posts是查找的数据表名称，table是关键词。\n\n\n需要注意的是，Bmob云函数底层采用Nodejs进行开发，继承了Nodejs的异步非阻塞事件驱动模式，因此也不可避免的需要大量使用回调方法，这些方法往往以非显式声明的闭包形式存在。\n\n\n此外，通过oData数据库对象获取返回的回调接口中，所有的data数据都是string类型，如果需要在云端中作为对象类型调用的话，需要将string类型转换为object类型，即：\n\n\n    var dataObject= JSON.parse(data);\n\n\n\n\noData对象的其他操作方法如下：\n\n\n查询多条数据\n\n\nfind({\n  \ntable\n:\nXXX\n,          //表名\n  \nkeys\n:\na,b,c\n,         //返回字段列表，多个字段用,分隔\n  \nwhere\n:{\na\n:\nXXXX\n,\nb\n:\nXXXX\n},       //查询条件是一个JSON object\n  \norder\n:\n-a,b\n,         //排序列表，[-]字段名称,-表示降序，默认为升序\n  \nlimit\n:10,            //limit大小，一页返回多少条记录，默认为0\n  \nskip\n:2,             //skip,分页offset，(page-1)*limit\n  \ncount\n:1            //count,只返回符合条件的记录总数\n },function(err,data){    //回调函数\n });\n\n\n\n\n以下是读取Games表（包含name字段）的数据，并对这些数据进行遍历，将name字段连接起来的一段代码样例：\n\n\nfunction onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.find({\n    \ntable\n:\nGames\n\n  },function(err,data){ \n  //将返回结果转换为Json对象\n  var resultObject= JSON.parse(data);\n  //遍历这个Json对象\n  for(var results in resultObject)\n  {\n    var resultArr = resultObject[results];\n    var str =\n \n;\n    //遍历得到的每行结果\n    for(var oneline in resultArr){\n      str =str +\n \n + resultArr[oneline].name;\n    }\n    response.send(str);\n  }\n});\n}\n\n\n\n\n查询单条数据\n\n\nfindOne({\n  \ntable\n:\nXXX\n,             //表名\n  \nobjectId\n:\nXXXX\n         //记录的objectId\n},function(err,data){         //回调函数\n});\n\n\n\n\n需要注意的是：\n\n1. 为确保User表的安全性，findOne方法不能直接操作User表。\n2. find方法返回的data是字符串类型，如果需要直接对象化调用的话，需要将string类型转换为object类型，即如下，从_User表中查找objectId=YIuNDDDO的数据，并把username信息显示出来：\n\n\nfunction onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.findOne({\n    \ntable\n:\n_User\n,\n    \nobjectId\n:\nYIuNDDDO\n\n  },function(err,data){ \n    var dataObject= JSON.parse(data);\n    response.send(\n获取用户名信息为： \n + dataObject.username);\n  });\n}\n\n\n\n\n获取表的记录数\n\n\nfunction onRequest(request, response, modules) {\n    var db = modules.oData;\n    //获取表\nGameScore\n的总记录数\n    db.find({\n      \ntable\n:\nGameScore\n,\n      \nlimit\n:0,\n      \ncount\n:1 \n    },function(err,data){     \n\n        resultObject= JSON.parse(data);\n        count=resultObject.count;\n        response.send(\n表记录数:\n+count);\n\n    });     \n}                                                    \n\n\n\n\n其中，\ncount\n为标识位，具体原因大家可以参考Restapi说明文档：\nhttp://docs.bmob.cn/data/Restful/b_developdoc/doc/index.html#查询结果计数\n。\n\n\n修改数据\n\n\nupdate({\n  \ntable\n:\nXXX\n,             //表名\n  \nobjectId\n:\nXXXX\n,        //记录的objectId\n  \ndata\n:{\na\n:\nXXXX\n,\nb\n:\nXXXX\n}           //需要更新的数据，格式为JSON\n},function(err,data){         //回调函数\n});\n\n\n\n\n以下是一个更新数据的示例代码，实现的效果是从Games表中找到objectId=hmw9888C的数据，将其name数据改为pingpang games。\n\n\nfunction onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.update({\n    \ntable\n:\nGames\n,\n    \nobjectId\n:\nhmw9888C\n,\n    \ndata\n:{\nname\n:\npingpang games\n}\n  },function(err,data){ \n    response.send(\nsuccess\n);\n  });\n}\n\n\n\n\n添加数据\n\n\ninsert({\n  \ntable\n:\nXXX\n,             //表名\n  \ndata\n:{\na\n:\nXXXX\n,\nb\n:\nXXXX\n}            //需要更新的数据，格式为JSON\n},function(err,data){         //回调函数\n});\n\n\n\n\n删除数据\n\n\nremove({\n  \ntable\n:\nXXX\n,             //表名\n  \nobjectId\n:\nXXXX\n        //记录的objectId\n},function(err,data){         //回调函数\n});\n\n\n\n\n用户注册\n\n\nuserSignUp({\n  \ndata\n:{\na\n:\nXXXX\n,\nb\n:\nXXXX\n}             //用户注册的信息，格式为JSON\n},function(err,data){         //回调函数\n});\n\n\n\n\n用户登录\n\n\nuserLogin({\n  \nusername\n:\naa\n,            //登录用户名\n  \npassword\n:\n              //用户密码\n},function(err,data){         //回调函数\n});\n\n\n\n\n用户密码重置\n\n\nuserRestPassword({\n  \ndata\n:{\nemail\n:\nXX@XX.com\n}      //需要重置密码的用户邮件账号\n},function(err,data){         //回调函数\n});\n\n\n\n\n获取某一用户记录\n\n\ngetUserByObjectId({\n  \nobjectId\n:\nXXXX\n          //记录的objectId\n},function(err,data){         //回调函数\n});\n\n\n\n\n更新某一用户记录\n\n\n说明：必须先登录才能更新，切记！！！否则会报sessionToken error\n\n\nupdateUserByObjectId({\n      \nobjectId\n:\nXXXX\n,        //记录的objectId\n      \ndata\n:{\na\n:\nXXXX\n,\nb\n:\nXXXX\n}           //需要更新的数据，格式为JSON\n    },function(err,data){         //回调函数\n});\n\n\n\n\n以下是更新用户信息的示例代码：\n\n\nfunction onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.userLogin({\n    \nusername\n:\n123567\n,\n    \npassword\n:\n123\n\n  },function(err, data){\n    if(data){\n      var dataObject = JSON.parse(data);\n      if(dataObject.error == null){\n        //需要设置登录之后获取的sessionToken头信息\n        db.setHeader({\nX-Bmob-Session-Token\n:dataObject.sessionToken});\n        db.updateUserByObjectId({\nobjectId\n:dataObject.objectId ,data:{\nusername\n:\n123\n}},function(err,data){\n          response.send(\n更新成功\n);\n      })\n    }else{\n      response.send(\n找不到该用户！\n);\n    }\n  }\n}); \n} \n\n\n\n\n获得所有用户信息\n\n\ngetAllUser(function(err,data){         //回调函数\n});\n\n\n\n\n删除某一个指定用户\n\n\n说明：必须登录才行，切记！！！否则会报sessionToken error\n\n\nremoveUserByObjectId({\n      \nobjectId\n:\nXXXX\n        //记录的objectId\n    },function(err,data){         //回调函数\n});\n\n\n\n\n邮箱验证\n\n\n发送给用户的邮箱验证的邮件会在一周内失效，可以通过下面的方法来强制重新发送\n\n\nrequestEmailVerify({\n      \ndata\n:{\nemail\n:\ncoolguy@iloveapps.com\n}\n  },function(err,data){ \n    //回调函数\n  });\n\n\n\n\n这里有一个小技巧分享给大家，有时候你会希望能够用Master Key（Bmob给大家提供的超级权限，可以对数据进行任何操作）对数据进行操作，包括不需要用户登录就可以修改用户信息等。那么你只需要在对数据进行操作前，通过db.setHeader方法设置下Master Key头信息即可，如下：\n\n\nfunction onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.setHeader({\nX-Bmob-Master-Key\n:\n这里填写Master Key信息\n});\n  db.updateUserByObjectId({\nobjectId\n:\n这里是需要更新的用户ObjectId信息\n ,data:{\nusername\n:\n123\n}},function(err,data){\n    response.send(\n更新成功\n);\n  }); \n} \n\n\n\n\n文件对象\n\n\n云函数只支持文件的删除操作。删除文件，必须要知道文件的组名和url，示例代码如下：\n\n\nfunction onRequest(request, response, modules) {\n\n  var file = modules.oFile;\n\n  file.del({\n    \ngroup\n:\ngroup1\n,\n    \nurl\n:\nM00/00/01/wKgBP1N3FAWRJXsSAAAB_rYZATs52.html\n\n  },function(err,data){\n     //回调函数\n  });\n}\n\n\n\n\n在上面的例子中，group1是组名，M00/00/01/wKgBP1N3FAWRJXsSAAAB_rYZATs52.html是url。\n\n\n返回结果是个json对象：\n\n\n{\n  \nmsg\n: \ndelete file success\n\n}\n\n\n\n\n云函数对象\n\n\n在云函数中可以调用本app的其它云函数，示例代码如下：\n\n\nfunction onRequest(request, response, modules) {\n\n    var functions = modules.oFunctions;\n\n    functions.run({\n       \nname\n: \ntest\n,\n       \ndata\n:{\ncontent\n:\n你好\n,\naddress\n:\nguangzhou\n}\n    },function(err,data){\n       //回调函数\n    });\n}\n\n\n\n\n在上面的例子中，\nname\n是云函数的函数名，\ndata\n中是传递的参数\n\n\n如果不需要传递任何参数，可以用下面的实例代码：\n\n\nfunction onRequest(request, response, modules) {\n\n    var functions = modules.oFunctions;\n\n    functions.run({\n       \nname\n: \ntest\n\n    },function(err,data){\n       //回调函数\n    });\n}\n\n\n\n\n地理位置对象\n\n\nBmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询。你可以在查询中添加一个GeoPoint的对象查询。您可以实现轻松查找出离当前用户最接近的信息或地点的功能。\n\n\n创建地理位置\n\n\n创建地理位置的示例代码如下：\n\n\nfunction onRequest(request, response, modules) {\n\n  var location = modules.oLocation;\n\n  location.create({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\nj4w2DDDT\n,\n    \ndata\n:{\nlocation\n:{            \n            \n__type\n: \nGeoPoint\n,\n            \nlatitude\n:  12.934755,\n            \nlongitude\n: 24.52065\n        }}\n  },function(err,data){\n     //回调函数\n  });\n}\n\n\n\n\n查询地理位置\n\n\n现在您有一系列的对象对应的地理坐标，如果能发现那些对象离指定的点近就好了，这可以通过GeoPoint数据类型加上在查询中使用$nearSphere做到。获取离用户最近的10个地点的实现代码如下：\n\n\n  location.query({\n    \ntable\n:\nGameScore\n,\n    \nlimit\n:10,\n    \nwhere\n:{\n        \nlocation\n: {\n            \n$nearSphere\n: {\n                \n__type\n: \nGeoPoint\n,\n                \nlatitude\n: 30.0,\n                \nlongitude\n: 20.0\n            }\n          }\n    }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n这会按离纬度30.0，经度-20.0的距离排序返回一系列的结果，第一个就是最近的对象。(注意如果一个特定的order参数给了的话，它会覆盖按距离排序)，例如，下面是两个上面的查询返回的结果：\n\n\n{\n    \nresults\n: [\n    {\n        \nlocation\n: {\n             \n__type\n: \nGeoPoint\n,\n            \nlatitude\n: 40.0,\n            \nlongitude\n: -30.0\n        },\n        \nupdatedAt\n: \n2011-12-06 22:36:04\n,\n        \ncreatedAt\n: \n2011-12-06 22:36:04\n,\n        \nobjectId\n: \ne1kXT22L\n\n        },\n        {\n        \nlocation\n: {\n             \n__type\n: \nGeoPoint\n,\n             \nlatitude\n: 30.0,\n             \nlongitude\n: 20.0\n        },\n        \nupdatedAt\n: \n2011-12-06 22:36:26\n,\n        \ncreatedAt\n: \n2011-12-06 22:36:26\n,\n        \nobjectId\n: \n51e3a2a8e4b015ead4d95dd9\n\n        }\n    ]\n}\n\n\n\n\n为了限定搜素的最大举例，需要加入$maxDistanceInMiles和$maxDistanceInKilometers或者$maxDistanceInRadians参数来限定。如果不加，则默认是100KM的半径。如，要找半径在10公里内的数据的实现代码如下：\n\n\n  location.query({\n    \ntable\n:\nGameScore\n,\n    \nlimit\n:10,\n    \nwhere\n:{\n        \nlocation\n: {\n            \n$nearSphere\n: {\n                \n__type\n: \nGeoPoint\n,\n                \nlatitude\n: 30.0,\n                \nlongitude\n: 20.0\n            },\n        \n$maxDistanceInKilometers\n: 10.0\n        }\n    }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n同样做查询寻找在一个特定的范围里面的对象也是可以的，为了找到在一个矩形的区域里的对象，按下面的格式加入一个约束 {\"$within\": {\"$box\": {[southwestGeoPoint, northeastGeoPoint]}}}，下面是一段示例代码：\n\n\n  location.query({\n    \ntable\n:\nGameScore\n,\n    \nlimit\n:10,\n    \nwhere\n:{\n        \nlocation\n: {\n            \n$within\n: {\n                \n$box\n: [\n                    {\n                        \n__type\n: \nGeoPoint\n,\n                        \nlatitude\n: 37.71,\n                        \nlongitude\n: 22.53\n                    },\n                    {\n                        \n__type\n: \nGeoPoint\n,\n                        \nlatitude\n: 30.82,\n                        \nlongitude\n: 22.37\n                    }\n                ]\n            }\n        }\n    }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n关联关系对象\n\n\n一个对象可以与其他对象相联系。就像数据库中的主外键关系一样，数据表 A 的某一个字段是数据表 B 的外键，只有表 B 中存在的数据才可插入进表 A 中的字段。 \n\n\n添加关联关系\n\n\n为了更新 \nPointer\n 的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个指针，我们可以像这样添加一行记录时并添加一个指针：\n\n\nfunction onRequest(request, response, modules) {\n\n  var rel = modules.oRelation;\n  rel.add({\n    \ntable\n:\nGameScore\n,\n    \ndata\n:{\ngame\n:{\n__type\n:\nPointer\n,\nclassName\n:\nGame\n,\nobjectId\n:\nekZq111a\n}}\n  },function(err,data){\n     //回调函数\n  });\n}\n\n\n\n\n为了更新 \nRelation\n 的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个或多个关系，我们可以像这样添加一行记录时并添加多个关系:\n\n\n  rel.add({\n    \ntable\n:\nGameScore\n,\n    \ndata\n:{\ngamerel\n:{\n__op\n:\nAddRelation\n,\nobjects\n:[{\n__type\n:\nPointer\n,\nclassName\n:\nGame\n,\nobjectId\n:\nekZq111a\n},{\n__type\n:\nPointer\n,\nclassName\n:\nGame\n,\nobjectId\n:\n80SLHHHj\n}]}}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n修改关联对象\n\n\n为了更新 \nPointer\n 的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个指针，我们可以像这样添加一个指针:\n\n\n  rel.update({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\n8106dc7c9e\n,\n    \ndata\n:{\ngame\n:{\n__type\n:\nPointer\n,\nclassName\n:\nGame\n,\nobjectId\n:\n80SLHHHj\n}}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n为了更新 \nRelation\n 的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个或多个关系，我们可以像这样添加多个关系:\n\n\n  rel.update({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\n8106dc7c9e\n,\n    \ndata\n:{\ngamerel\n:{\n__op\n:\nAddRelation\n,\nobjects\n:[{\n__type\n:\nPointer\n,\nclassName\n:\nGame\n,\nobjectId\n:\nekZq111a\n}]}}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n查询关联对象\n\n\n有几种方式来对关系 \nRelation\n 或 指针 \nPointer\n 类型数据进行查询, 如果您将要获取对象中有个Key类型是关系 \nRelation\n 或 指针 \nPointer\n，这都说明你要获取的对象是匹配到另一个特殊（关联或指向）的对象的, 您可以用一个 \nwhere\n 参数查询, 自己使用 \n__type\n 构造一个 \nPointer\n, 就像你构造其他数据类型一样。举例说, 如果每一条评论(Comment对象)有一个Key叫post，类型是Pointer，并且指向了一个具体的帖子(Post对象，用objectId表示一个帖子)，那么您可以使用下面的请求获取一个帖子的所有评论:\n\n\nrel.query({\n  \ntable\n:\nComment\n,   \n  \nwhere\n:{\npost\n:{\n__type\n:\nPointer\n,\nclassName\n:\nPost\n,\nobjectId\n:\nl4fQ999O\n}},\n },function(err,data){    \n    //回调函数\n });\n\n\n\n\n如果您想要获取对象, 这些对象的一个字段指向的对象是符合另一个查询的, 您可以使用 $inQuery 操作符，注意默认的 limit 是 100 而且最大的 limit 是 1000，这个限制同样适用于内部的查询, 所以对于较大的数据集您可能需要细心地构建查询来获得期望的行为。举例说, 假设您有一个 帖子(Post)类和一个评论(Comment)类, 每个评论(Comment)都有一个指向它的帖子(Post)的关系Key名为post，并且类型为Pointer, 您可以找到所有有图片的帖子(Post)的评论(Comment):\n\n\nrel.query({\n  \ntable\n:\nComment\n,   \n  \nwhere\n:{\npost\n:{\n$inQuery\n:{\nwhere\n:{\nimage\n:{\n$exists\n:true}},\nclassName\n:\nPost\n}}},\n },function(err,data){    \n    //回调函数\n });\n\n\n\n\n同理，使用下面的请求，您可以找到所有没有图片的帖子(Post)的评论(Comment):\n\n\nrel.query({\n  \ntable\n:\nComment\n,   \n  \nwhere\n:{\npost\n:{\n$notInQuery\n:{\nwhere\n:{\nimage\n:{\n$exists\n:true}},\nclassName\n:\nPost\n}}},\n },function(err,data){    \n    //回调函数\n });\n\n\n\n\n如果您想获取的对象，是其父对象的关系 \nRelation\n 类型的Key的所有成员的话, 您可以使用 $relatedTo 操作符, 假设您有一个帖子(Post)类和一个系统默认的用户(_User)类, 而每一个帖子(Post)都可以被不同的用户(_User)所喜欢。 如果帖子(Post)类下面有一个Key名为likes，且是 \nRelation\n 类型, 存储了喜欢这个帖子(Post)的用户(_User)。那么您可以找到喜欢过同一个指定的帖子(Post)的所有用户：\n\n\nrel.query({\n  \ntable\n:\nusers\n,   \n  \nwhere\n:{\n$relatedTo\n:{\nobject\n:{\n__type\n:\nPointer\n,\nclassName\n:\nPost\n,\nobjectId\n:\nl4fQ999O\n},\nkey\n:\nlikes\n}},\n },function(err,data){    \n    //回调函数\n });\n\n\n\n\n还可以使用组合查询，比如下面这样，判断用户是否喜欢(likes)过这个帖子：\n\n\nrel.query({\n  \ntable\n:\nComment\n,   \n  \nwhere\n:{\nlikes\n:{\n$inQuery\n:{\nwhere\n:{\nobjectId\n:\nl3xRGGGa\n},\nclassName\n:\n_User\n}}, \nobjectId\n:\nl4fQ999O\n},\n  \nlimit\n:10,  \n  \ncount\n:true   \n },function(err,data){    \n    //回调函数\n });\n\n\n\n\n返回结果集如下：\n\n\n{\n    count: 1\n    results: [ ]\n}\n\n\n\n\n你可以做如下判断，如果count=1，表明用户喜欢的这个帖子objectId存在，即用户喜欢过这个帖子；若count=0, 表明用户没有喜欢过这个帖子。\n\n\n在某些情况之下，您可能需要在一个查询之中返回关联对象的多种类型，您可以通过传入字段名称到include参数中，多个字段名称用,间隔， 比如，我们想获得最近的10篇评论，而您想同时得到它们相关的post：\n\ninclude的Key必须是Pointer类型\n\n\nrel.query({\n  \ntable\n:\nComment\n,   \n  \norder\n:\n-createdAt\n,\n  \nlimit\n:10,  \n  \ninclude\n:\npost\n   \n },function(err,data){    \n    //回调函数\n });\n\n\n\n\n不是作为一个 \nPointer\n 类型表示，post字段现在已经被展开为一个完整的帖子(Post)对象， __type 被设置为 \nObject\n 而 \nclassName\n 同样也被提供了。 举例说， 一个指向帖子(Post)的Pointer原本展示为：\n\n\n{\n  \n__type\n: \nPointer\n,\n  \nclassName\n: \nPost\n,\n  \nobjectId\n: \n51e3a359e4b015ead4d95ddc\n\n}\n\n\n\n\n当一个查询使用include参数来包含进去来取代 \nPointer\n 之后，可以看到 \nPointer\n 被展开为：\n\n\n{\n  \n__type\n: \nObject\n,\n  \nclassName\n: \nPost\n,\n  \nobjectId\n: \n51e3a359e4b015ead4d95ddc\n,\n  \ncreatedAt\n: \n2011-12-06T20:59:34.428Z\n,\n  \nupdatedAt\n: \n2011-12-06T20:59:34.428Z\n,\n  \notherFields\n: \nwillAlsoBeIncluded\n\n}\n\n\n\n\n您可以同样做多层的include, 这时要使用 \".\" 号. 如果您要include一条评论(Comment)对应的帖子(Post)的作者(author)：\n\ninclude的Key必须是Pointer类型\n\n\nrel.query({\n  \ntable\n:\nComment\n,   \n  \norder\n:\n-createdAt\n,\n  \nlimit\n:10,  \n  \ninclude\n:\npost.author\n   \n },function(err,data){    \n    //回调函数\n });\n\n\n\n\n删除关联关系\n\n\n可以在一个对象中删除一个关系:\n\n\n  rel.delete({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\n8106dc7c9e\n,\n    \ndata\n:{\ngamerel\n:{\n__op\n:\nRemoveRelation\n,\nobjects\n:[{\n__type\n:\nPointer\n,\nclassName\n:\nGame\n,\nobjectId\n:\nekZq111a\n}]}}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n原子操作对象\n\n\n很多应用可能会有需要计数器的功能，比如某条信息被点赞多少次等。Bmob提供了非常便捷的方式来保证原子性的修改某一数值字段的值，示例代码如下：\n\n\nfunction onRequest(request, response, modules) {\n  //获取原子操作对象\n  var atom = modules.oAtom;\n\n  //score增加一个固定值操作\n  atom.exec({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\nj4w2DDDT\n,\n    \ndata\n:{\nscore\n:{\n__op\n:\nIncrement\n,\namount\n:1}}\n  },function(err,data){\n     //回调函数\n  });\n}\n\n\n\n\nfunction onRequest(request, response, modules) {\n  //获取原子操作对象\n  var atom = modules.oAtom;\n\n  //score减少一个固定值操作\n  atom.exec({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\nj4w2DDDT\n,\n    \ndata\n:{\nscore\n:{\n__op\n:\nIncrement\n,\namount\n:-1}}\n  },function(err,data){\n     //回调函数\n  });\n}\n\n\n\n\n批量操作对象\n\n\n为了减少因为网络通讯次数太多而带来的时间浪费, 您使用使用下面的批量(batch)操作，在一个请求中对多个普通对象(不支持系统内置的用户对象)进行添加(create)、更新(update)、删除(delete) 操作，上限为50个。\n\n\nfunction onRequest(request, response, modules) {\n  //获取数组对象\n  var bat = modules.oBatch;\n\n  //批量操作\n  bat.exec({\n    \ndata\n:{\n        \nrequests\n: [\n          {\n            \nmethod\n: \nPOST\n,\n            \npath\n: \n/1/classes/GameScore\n,\n            \nbody\n: {\n              \nscore\n: 1337,\n              \nplayerName\n: \nSean Plott\n\n            }\n          },\n          {\n            \nmethod\n: \nPOST\n,\n            \npath\n: \n/1/classes/GameScore\n,\n            \nbody\n: {\n              \nscore\n: 1338,\n              \nplayerName\n: \nZeroCool\n\n            }\n          }\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n}\n\n\n\n\n批量操作的响应会是一个列表, 列表的返回值个数同给定的requests请求个数是相等的。列表中每个返回项都有一个字段是 \n\"success\"\n 或者 \n\"error\"\n， \n\"success\"\n 的值是通常是和你进行其他REST操作成功时返回的值是一样的:\n\n\n{\n  \nsuccess\n: {\n    \ncreatedAt\n: \n2012-06-15T16:59:11.276Z\n,\n    \nobjectId\n: \n51c3ba67e4b0f0e851c16221\n\n  }\n}\n\n\n\n\n\"error\"\n 的值是有返回码和错误信息字符串的一个对象:\n\n\n{\n  \nerror\n: {\n    \ncode\n: 101,\n    \nerror\n: \nobject not found for delete\n\n  }\n}\n\n\n\n\n在 batch 操作中更新(update)和删除(delete)同样是有效的:\n\n\nfunction onRequest(request, response, modules) {\n  //获取数组对象\n  var bat = modules.oBatch;\n\n  //批量操作\n  bat.exec({\n    \ndata\n:{\n        \nrequests\n: [\n          {\n            \nmethod\n: \nPUT\n,\n            \npath\n: \n/1/classes/GameScore/51e3a334e4b0b3eb44adbe1a\n,\n            \nbody\n: {\n              \nscore\n: 999999\n            }\n          },\n          {\n            \nmethod\n: \nDELETE\n,\n            \npath\n: \n/1/classes/GameScore/51a8a4d9e4b0d034f6159a35\n\n          }\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n}\n\n\n\n\n数组操作对象\n\n\n用下面的方法来获取数组对象：\n\n\n  var arr = modules.oArray;\n\n\n\n\n\n添加数组对象\n\n\n添加数组对象,不管元素是否存在都添加的实现代码如下：\n\n\n  arr.add({\n    \ntable\n:\nGameScore\n,\n    \ndata\n:{\nskills\n:{\n__op\n:\nAdd\n,\nobjects\n:[\nflying\n,\nkungfu\n]}}\n  },function(err,data){\n      //回调函数\n  });\n\n\n\n\n\n添加数组对象,只有在元素不存在情况下才添加的实现代码如下：\n\n\n  //往GameScore表中字段skills添加的数组\n  arr.addUnique({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\nj4w2DDDT\n,\n    \ndata\n:{\nskills\n:{\n__op\n:\nAddUnique\n,\nobjects\n:[\nflying\n,\nkungfu\n]}}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n删除数组对象\n\n\n  //往GameScore表中字段skills删除数组\n  arr.remove({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\nj4w2DDDT\n,\n    \ndata\n:{\nskills\n:{\n__op\n:\nRemove\n,\nobjects\n:[\nflying\n,\nkungfu\n]}}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n查询数组对象\n\n\n查询数组对象,可以查找skills的数组值中包含有\"flying\"的对象的实现方法如下:\n\n\n  //往GameScore表中字段skills添加的数组\n  arr.query({\n    \ntable\n:\nGameScore\n,\n    \nwhere\n:{\nskills\n:\nflying\n}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n查询数组对象,可以查找skills的数组值中包含有\"flying\",\"kungfu\"的对象的实现方法如下：\n\n\n  //往GameScore表中字段skills添加的数组\n  arr.query({\n    \ntable\n:\nGameScore\n,\n    \nwhere\n:{\nskills\n:{\n$all\n:[\nflying\n,\nkungfu\n]}}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n消息推送对象\n\n\n推送通知是让用户及时被通知、和你的应用保持联系的一种非常棒的方式，你可以快速而有效地通知到所有的用户，下面这个教程将会教会你使用Bmob来推送消息。用下面的方法来获取消息推送对象：\n\n\n  var push = modules.oPush;\n\n\n\n\n\n安装消息推送服务\n\n\n每一个Bmob的App安装在用户设备后，如果要使用消息推送功能，Bmob SDK会自动生成一个Installation对象。Installation对象包含了推送所需要的所有信息。举例：一个棒球的App，你可以让用户订阅感兴趣的棒球队，然后及时将这个球队的消息推送给用户 。\n\n\nInstallation对象有几个系统默认的特殊字段来帮助你的管理和定位到设备：\n- \nbadge\n : iOS应用中右上角的图标标识\n- \nchannels\n : 当前这个设备订阅的渠道名称数组\n- \ntimeZone\n : 设备所在位置的时区， 如Asia/Shanghai，这个会在每个Installation对象更新时同步（只读）\n- \ndeviceType\n : 设备的的类型, 值为：\"ios\" 或 \"android\" (只读)\n- \ninstallationId\n : Bmob使用的设备唯一号，Android设备是必须的，iOS可选 (只读)\n- \ndeviceToken\n : iOS设备由Apple APNS生成的唯一性token标识 (只读)\n\n\n保存installation\n\n\n保存iOS设备的deviceToken\n\n\niOS设备通常使用deviceToken来惟一标识一台设备。\n\n\n  push.add({\n    \ndata\n:{\n        \ndeviceType\n: \nios\n,\n        \ndeviceToken\n: \nabcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789\n,\n        \nchannels\n: [\n          \nGiants\n\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n保存Android设备的installationId\n\n\n对于Android设备，SDK会自动生成uuid作为installationId保存到Bmob。 您可以使用以下云函数保存Android设备的installation ID：\n\n\n  push.add({\n    \ndata\n:{\n        \ndeviceType\n: \nandroid\n,\n        \ninstallationId\n: \n12345678-4312-1234-1234-1234567890ab\n,\n        \nchannels\n: [\n          \nGiants\n\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n你还可以更新Installation对象的更多属性，用来查询installationId，定制更通用的推送：\n\n\n  push.update({\n    \nobjectId\n:\n400a12ed3a\n,\n    \ndata\n:{\n        \nscores\n: true,\n        \ngameResults\n: true,\n        \ninjuryReports\n: true\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n保存Windows Phone设备的 notificationUri\n\n\n对于Windows Phone设备，BmobSDK会自动从Windows Push Center获取到notificationUri并保存到 Bmob。 你可以使用以下REST API保存Windows Phone设备的notificationUri：\n\n\n  push.add({\n    \ndata\n:{\n        \ndeviceType\n: \nwindows phone\n,\n        \nnotificationUri\n: \nhttps://hk1.notify.live.net/unthrottledthirdparty/01.00/AQHgHh6EuwNtTa1TbwvaAjnmAgAAAAADEAAAAAQUZm52OkZDM0U5RDkxQzIzREJBNDYFBkFTRUEwMQ\n,\n        \nchannels\n: [\n          \nGiants\n\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n订阅频道和退订\n\n\n订阅频道\n\n\n覆盖已订阅的频道：\n\n\n  push.update({\n    \nobjectId\n:\n400a12ed3a\n,\n    \ndata\n:{\n        \nchannels\n: [\n          \nGiants\n,\n          \nMets\n\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n订阅一个新频道，不覆盖已订阅的频道：\n\n\n  push.update({\n    \nobjectId\n:\n400a12ed3a\n,\n    \ndata\n:{\n        \nchannels\n:{\n__op\n:\nAddUnique\n,\nobjects\n:[\nGiants111\n]}\n    }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n退订频道\n\n\n  push.update({\n    \nobjectId\n:\n400a12ed3a\n,\n    \ndata\n:{\n        \nchannels\n:{\n__op\n:\nRemove\n,\nobjects\n:[\nGiants\n,\nMets\n]}\n    }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n广播推送消息\n\n\n  push.send({\n    \ndata\n:{\n        \ndata\n: {\n          \nalert\n: \nHello From Bmob.\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n组播推送消息\n\n\n发送给订阅了Giants频道的用户\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n:{\n          \nchannels\n:[\nGiants\n]\n        },\n        \ndata\n: {\n          \nalert\n: \nHello From Bmob.\n\n        }\n      }\n  },function(err,data){删除数据\n     //回调函数\n  });\n\n\n\n\n\n或者更简便的方式\n\n\n  push.send({\n    \ndata\n:{\n        \nchannels\n:[\nGiants\n],\n        \ndata\n: {\n          \nalert\n: \nHello From Bmob.\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n多播推送消息\n\n\n推送给不活跃的用户\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n:{\n            \nupdatedAt\n:{\n                \n$lt\n:{\n__type\n:\nDate\n,\niso\n:\n2014-01-29 11:33:53\n}\n              }\n        },\n        \ndata\n: {\n            \nalert\n: \nHello From Bmob.\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n根据查询条件做推送\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n: {\n          \nscores\n: true\n        },\n        \ndata\n: {\n          \nalert\n: \nWillie Hayes injured by own pop fly.\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n请注意，where 条件查询的都是 installations 表。这里是假设 installations 表存储了 scores 的布尔属性，你可以像查询普通对象一样构造where查询\n\n\n根据平台做推送\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n: {\n          \ndeviceType\n: \nandroid\n\n        },\n        \ndata\n: {\n          \nalert\n: \nYour suitcase has been filled with tiny robots!\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n: {\n          \ndeviceType\n: \nios\n\n        },\n        \ndata\n: {\n          \nalert\n: \nYour suitcase has been filled with tiny robots!\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n根据地理信息位置做推送\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n: {\n          \nuser\n: {\n            \n$inQuery\n: {\n              \nlocation\n: {\n                \n$nearSphere\n: {\n                  \n__type\n: \nGeoPoint\n,\n                  \nlatitude\n: 30.0,\n                  \nlongitude\n: -20.0\n                },\n                \n$maxDistanceInMiles\n: 1.0\n              }\n            }\n          }\n        },\n        \ndata\n: {\n          \nalert\n: \nFree hotdogs at the bmob concession stand!\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n上面的例子假设 installation 有个 user 属性指向_User 表的记录，并且用户有个 location 属性是 GeoPoint 类型，我们就可以根据地理信息位置做推送。\n\n\n点播推送消息\n\n\n发送给Android单个客户端\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n:{\n            \ninstallationId\n:\n12345678-4312-1234-1234-1234567890ab\n\n            },\n        \ndata\n: {\n          \nalert\n: \nHello From Bmob.\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n发送给iOS单个客户端\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n:{\n            \ndeviceToken\n:\nabcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789\n\n            },\n        \ndata\n: {\n          \nalert\n: \nHello From Bmob.\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n发送选项设置\n\n\n推送通知不仅仅可以用来发送消息，iOS中，推送内容还可以包含要播放的声音和要显示的badge数字值,还可以定制任何你想发送的内容，对于Android，你甚至可以指定Intent应用于接收消息，对于时间性有要求的消息您还可以设置一个消息过期时间。\n\n\n定制您的通知\n\n\n如果你想发送更多的消息，你可以在data的字典对象中设置其他字段，下面这些保留的字段有其特殊的意义：\n- \nalert\n : 通知的消息内容\n- \nbadge\n : (仅iOS)一个数字值将会高亮显示在应用图标的右上角\n- \nsound\n : (仅iOS)应用绑定包中的声音文件 \n- \ncontent-available\n : (仅iOS)如果你的应用是新闻类的，或者你的应用正在使用iOS7的Remote Notification Background Mode，设定这个值为1将为触发离线下载功能。\n- \naction\n : (仅Android)接收到推送消息时应用Intent，如果没有指定title或alert，Intent将被应用，但是没有通知呈现给用户。\n- \ntitle\n : (仅Android)这个值将显示在系统通知栏\n\n\n例如，推送一条通知，将当前的badge值自增1,并且播放iOS设备上定制的音乐，对于Android用户，将在系统通知栏中显示特殊的标题，则请求如下：\n\n\n  push.send({\n    \ndata\n:{\n        \nchannels\n: [\n          \nGiants\n\n        ],\n        \ndata\n: {\n          \nalert\n: \nThe Mets scored! The game is now tied 1-1.\n,\n          \nbadge\n: 1,\n          \nsound\n: \ncheering.caf\n,\n          \ntitle\n: \nMets Score!\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n当然，你也可以在data字典对象中定制自己的字段，推送消息，但不显示在 Andoid 系统的通知栏中，而是执行应用程序预定义的逻辑，Android或iOS接收消息文档中对此有说明，iOS只有当用户从通知中打开应用，才能访问data的数据，Android将提供这个数据在action Intent应用之后,\n\n\n  push.send({\n    \ndata\n:{\n        \nchannels\n: [\n          \nGiants\n\n        ],\n        \ndata\n: {\n          \nalert\n: \nThe Mets scored! The game is now tied 1-1.\n,\n          \nbadge\n: \nIncrement\n,\n          \nsound\n: \ncheering.caf\n,\n          \ntitle\n: \nMets Score!\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n设置消息过期时间\n\n\n过期时间，可以是绝对时间：\n\n\n  push.send({\n    \ndata\n:{\n        \nexpiration_time\n: \n2015-12-04 00:51:13\n,\n        \ndata\n: {\n          \nalert\n: \nSeason tickets on sale until December  4, 2013\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n也可以是相对时间（根据push_time做定期推送，从push_time时间开始算起，直到expiration_interval时间后过期），下面请求表示消息将在2012-01-28 00:51:13这个时间点开始推送，直到7天后过期:\n\n\n  push.send({\n    \ndata\n:{\n        \npush_time\n: \n2012-01-28 00:51:13\n,\n        \nexpiration_interval\n: 518400,\n        \ndata\n: {\n          \nalert\n: \nSeason tickets on sale until December  4, 2013\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n邮件发送对象\n\n\nBmob的邮件发送对象采用Nodejs提供的nodemailer模块，这里提供简单的一个发送邮件的操作实例。更多的功能详细参考：\nhttps://npmjs.org/package/nodemailer\n\n\nfunction onRequest(request, response, modules) {\n//获得发送邮件的对象 \nvar mailer = modules.oMail; \n//设置发送服务器信息 \nvar  transport = mailer.createTransport( \nSMTP\n , {\n    host: \nsmtp.126.com\n ,\n    secureConnection: true , // use SSL\n    port: 465, // port for secure SMTP\n    auth: {\nuser: \nbmobtest111@126.com\n, //设置发送邮箱帐号 \npass: \nxxx\n //设置发送邮箱密码 \n    }\n});\n\ntransport.sendMail({\n    from : \nbmobtest111@126.com\n ,\n    to : \ntest@126.com\n ,\n    subject: \n主题\n ,\n    generateTextFromHTML : true ,\n    html : \n啊哈哈哈\n\n}, function (error, responseback){\n\n    transport.close();\n     if(error){\n        //发送失败\n    }else{\n        //发送成功\n        response.send(\n发送成功\n);\n    }\n});\n\n\n\n}                                                                                                                                                                                                                                   \n\n\n\n\nHTTP请求对象\n\n\noHttp对象可以模拟实现get、post、put、delete等各种HTTP请求信息，让你在云端实现诸如数据采集、OAuth授权登录等功能。Bmob的HTTP请求模块采用Nodejs提供的request模块，这里提供简单的Get和Post的操作实例。更多的功能详细参考：\nhttps://npmjs.org/package/request\n\n\n/**\n*发起Get请求\n*/\n//获取Http模块\nvar http = modules.oHttp;\n//发起Get请求\nhttp('http://www.bmob.cn', function (error, res, body) {\n    if (!error \n res.statusCode == 200) {\n      response.send(body);\n    }\n})\n\n-\n\n/**\n*发起Post请求\n*/\n//获取Http模块\nvar http = modules.oHttp;\n//往http://bmob.cn/save发起POST请求\nhttp.post('http://bmob.cn/save', {form:{key:'value'}})\n\n\n\n\n事件对象\n\n\noEvent，也就是eventproxy模块，解决异步回调的问题。\n\n\n更多的功能详细参考：\nhttps://github.com/JacksonTian/eventproxy\n\n\nfunction onRequest(request, response, modules) {\n\n    var ep = modules.oEvent;  //eventproxy模块，解决异步回调的问题\n\n    ep.after('got_file', 3, function (list) {\n        response.send(\nlen:\n+list.length);\n\n    });\n\n    //发送3次事件后触发事件，输出list的长度\n    ep.emit(\ngot_file\n, \n1\n);  \n    ep.emit(\ngot_file\n, \n1\n);  \n    ep.emit(\ngot_file\n, \n1\n);  \n\n\n}                        \n\n\n\n\nEncode编码转换对象\n\n\nEncode对象可以实现字符编码的转换。更多的功能详细参考：\nhttps://www.npmjs.org/package/encoding\n\n\nEncode对象就一个方法convert()，使用方法为：encoding.convert(text, toCharset, fromCharset)。\n\n\ntext: 需要转换的对象，可以为Buffer或者String对象。\n\n\ntoCharset: 转换后的编码。\n\n\nfromCharset: 转换前的编码，缺省为uft8。\n\n\n转换后的输入结果为Buffer对象。\n\n\nvar encoding = modules.oEncodeing;\nvar result = encoding.convert(\n禅\n,\ngbk\n,\nutf8\n);\nresponse.send(result.toString()); \n\n\n\n\n\nhtml元素解析对象（oHtmlparser）\n\n\nhtml元素解析对象可以实现html的解释。更多的功能详细参考：\nhttps://www.npmjs.org/package/htmlparser\n\n\n代码例子\n\n\nfunction onRequest(request, response, modules) {\n    var htmlparser = modules.oHtmlparser;\n    var rawHtml = \na href='test.html'\nxxx\n/a\n;\n    var handler = new htmlparser.DefaultHandler(function (error, dom) {});\n    var parser = new htmlparser.Parser(handler);\n    parser.parseComplete(rawHtml);\n    response.send(JSON.stringify(handler.dom, null, 2));\n\n}                                                                                                                         \n\n\n\n\n\n代码的输出：\n\n\n[\n  {\n    \nraw\n: \na href='test.html'\n,\n    \ndata\n: \na href='test.html'\n,\n    \ntype\n: \ntag\n,\n    \nname\n: \na\n,\n    \nattribs\n: {\n      \nhref\n: \ntest.html\n\n    },\n    \nchildren\n: [\n      {\n        \nraw\n: \nxxx\n,\n        \ndata\n: \nxxx\n,\n        \ntype\n: \ntext\n\n      }\n    ]\n  }\n]                                                                                                                        \n\n\n\n\n\nbql对象（oBql）\n\n\n我们提供类 SQL 语法的 BQL 查询语言来查询数据\n\n\n下面的代码例子就是查询GameScore表的所有数据\n\n\nfunction onRequest(request, response, modules) {\n    //获得bql的对象 \n    var Bql = modules.oBql; \n\n    Bql.exec({\n      \nbql\n:\nselect * from GameScore\n\n    },function(err,data){\n      response.send(data);\n    });\n\n\n}                                                                                                                        \n\n\n\n\n\nBQL 还支持占位符查询，where 和 limit 子句的条件参数可以使用问号替换，然后通过 values 数组传入：\n\n\nfunction onRequest(request, response, modules) {\n    //获得bql的对象 \n    var Bql = modules.oBql; \n\n    Bql.exec({\n      \nbql\n:\nselect * from GameScore where name=? limit ?,? \n,\n      \nvalues\n:\n[\\\ntom\\\n,0,100]\n\n    },function(err,data){\n      response.send(data);\n     //回调函数\n    });\n\n\n}                                                                         \n\n\n\n\n更多请参考 \nBQL 详细指南\n 。\n\n\n加密对象（oCrypto）\n\n\n提供md5和sha1两种加密算法。更多的功能详细参考：\nhttps://www.npmjs.org/package/crypto\n\n\n代码例子\n\n\n  function onRequest(request, response, modules) {\n    var crypto = modules.oCrypto;\n    var md5 = crypto.createHash('md5');\n    md5.update(\nhello\n); //输入要md5的内容\n    response.send(md5.digest('hex'));//以16进制编码\n}                                                                                                                         \n\n\n\n\n\n云函数调试工具\n\n\n为方便开发者调试云函数，Bmob为开发者提供了便捷的云端调试工具，你可以直接在云函数的编辑页面下对编写的代码进行调试，如实现从Bar表中查找指定objectId号（SDK中上传参数）的数据，你可以在云函数中实现如下：\n\n\nfunction onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.findOne({\n    \ntable\n:\nBar\n,\n    \nobjectId\n:request.body.objectId\n  },function(err,data){ //回调函数\n     response.send(\n成功 \n + data);\n  });\n}\n\n\n\n\n调试时，你在云端调试工具中输入参数名为objectId，参数值为你想要查询的信息，如下图，即可查看到调试结果。\n\n\n\n\n错误对象\n\n\nBmob提供的官方模块（非第三方）的错误回调中都会有一个\nerr\n对象，这个\nerr\n对象包含两个属性：\nerror\n和\ncode\n，分别代表错误异常信息和错误代码。调用时可以简单如下使用：\n\n\nfunction onRequest(request, response, modules) {\n    var db = modules.oData;\n    db.findOne({\n        \ntable\n:\nYourTableName\n,\n        \nobjectId\n:request.body.oid\n    },function(err,data){ \n        //对返回结果进行处理\n        if(err)  response.send(\nerror is  \n + err.code  + \nerror message is \n + err.error );\n        else response.send(data);\n    });\n}", 
            "title": "开发文档"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_1", 
            "text": "Bmob旨在让移动开发变得更简单。对于一些复杂的应用，您可能希望增加一些特有的业务逻辑，并能灵活掌控，Bmob云函数提供了这种灵活性，可以让您的代码直接在Bmob云上运行。一旦你在云端更新了代码，所有的移动应用都会立即自动更新，新功能的发布将会变得更加简单可控。", 
            "title": "简介"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_2", 
            "text": "为方便大家更好的使用云函数，Bmob为大家提供了一些常用模块，方便大家直接拿来使用的。    对整个表进行排序： https://github.com/bmob/bmob-cloudcode-demo-ranking/blob/master/order1.js  可结合定时任务使用    获取某行数据对应排行的信息：  https://github.com/bmob/bmob-cloudcode-demo-ranking/blob/master/order2.js    获取前N名数据排行信息： https://github.com/bmob/bmob-cloudcode-demo-ranking/blob/master/order3.js    在开发云函数时，希望大家能够先看看我们提供的编码规范文档： http://docs.bmob.cn/cloudcode/WEB/f_codehelp/doc/index.html", 
            "title": "开源案例"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_3", 
            "text": "bmob允许以http的方式直接调用云函数。", 
            "title": "调用云函数的方式"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#secret-key", 
            "text": "用户需要以http的方式运行云函数，需要先确定应用的Secret Key。 调用云函数时，通过Secret Key标识一个应用，获取Secret Key的路径：\n管理后台- 应用密钥- Secret Key, 如下图所示：  注意：请妥善保管Secret Key，避免Secret Key的泄露！！！", 
            "title": "获取Secret Key"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#get", 
            "text": "下面展示了以Get的方式调用云函数：  curl -X GET http://cloud.bmob.cn/0348d0c262bc91d9/test?name=jeff  其中：\n0348d0c262bc91d9：应用的Secret Key。\ntest：云函数的名称\nname=jeff: 传入一个参数，名称是name，值是jeff\n与restful不同，无需再传其它诸如app id等请求头。", 
            "title": "以Get的方式调用云函数"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#post", 
            "text": "下面展示了以Post的方式调用云函数：  curl -X POST \\\n    -H  Content-Type: application/x-www-form-urlencoded  \\\n    -d 'name=jeff' \\\n    http://cloud.bmob.cn/0348d0c262bc91d9/test  其中：\n0348d0c262bc91d9：应用的Secret Key。\ntest：云函数的名称\nname=jeff: 传入一个参数，名称是name，值是jeff\n与restful不同，无需再传其它诸如app id等请求头。", 
            "title": "以Post的方式调用云函数"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_4", 
            "text": "注意：升级云函数套餐后就没法在微信公众号中调用云函数  bmob允许以http的方式直接调用云函数。", 
            "title": "转为套餐后调用云函数的方式"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#id", 
            "text": "进入应用后台- 云函数，下图中的箭头所指的数字就是该应用的id值：", 
            "title": "获取应用的id值"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#get_1", 
            "text": "下面展示了以Get的方式调用云函数：  curl -X GET http://cloud-xxxxx.bmobapp.com/test?name=jeff  其中：\ncloud-xxxxx.bmobapp.com：该应用的云函数专属域名，其中xxxxx为上节“获取应用的id值”所获取的id值。\ntest：云函数的名称。\nname=jeff: 传入一个参数，名称是name，值是jeff。\n与restful不同，无需再传其它诸如app id等请求头。", 
            "title": "Get的方式调用云函数"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#post_1", 
            "text": "下面展示了以Post的方式调用云函数：  curl -X POST \\\n    -H  Content-Type: application/x-www-form-urlencoded  \\\n    -d 'name=jeff' \\\n    http://cloud-xxxxx.bmobapp.com/test  其中：\ncloud-xxxxx.bmobapp.com：该应用的云函数专属域名，其中xxxxx为上节“获取应用的id值”所获取的id值。\ntest：云函数的名称\nname=jeff: 传入一个参数，名称是name，值是jeff\n与restful不同，无需再传其它诸如app id等请求头。", 
            "title": "Post的方式调用云函数"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_5", 
            "text": "从云函数的入口方法function onRequest(request, response, modules)可知，云函数包含三个模块，分别是request模块、response模块和modules模块。", 
            "title": "云函数模块解释"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#request", 
            "text": "request模块用于获取传入的参数。由于现在调用云函数有两种方式（get和post），所以获取传入的参数的方式需要使用不同的方法。  注意，当通过android，ios等客户端sdk调用云函数，或者通过restful api的方式调用云函数，都是采用post的方式。", 
            "title": "request模块"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#get_2", 
            "text": "用get方式调用云函数，例如：  curl -X GET http://cloud.bmob.cn/0348d0c262bc91d9/test?name=jeff  可用下面的方法获取name的值：  request.query.name", 
            "title": "get方式"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#post_2", 
            "text": "用post方式调用云函数，例如：  curl -X POST \\\n    -H  Content-Type: application/x-www-form-urlencoded  \\\n    -d 'name=jeff' \\\n    http://cloud.bmob.cn/0348d0c262bc91d9/test  可用下面的方法获取name的值：  request.body.name", 
            "title": "post方式"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#http", 
            "text": "当云函数是用于某些平台的回调时，同一段云函数可能有时是采用get的方式调用，有时是采用post的方式调用, 可用下面的方法获取当前云函数是采用get还是post方式调用。  例子如下：      var httptype = request.method;　//获取调用云函数的是post或者get方式\n    if ( GET  == httptype) {\n        //采用get方式调用云函数\n    }else{\n        //采用post方式调用云函数\n    }", 
            "title": "获取调用云函数的http方式"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#response", 
            "text": "response为云函数的信息回传模块，该模块包含了一个send方法，实现将云端的执行结果（如查询的数据）返回给SDK或者RestApi等调用端：  response.send(string result)", 
            "title": "response模块"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#modules", 
            "text": "modules是Bmob云函数提供给大家的各种对象处理的模块，包括数据库对象（oData）、文件对象（oFile）、地理位置对象（oLocation）、关联关系对象（oRelation）、原子操作对象（oAtom）、数据批量操作对象（oBatch）、数组对象（oArray）、消息推送对象（oPush）、云函数对象（oFunctions）、邮件发送对象（oMail）、HTTP对象（oHttp）、字符编码转换对象（oEncodeing）、事件对象（oEvent）、bql对象（oBql）、html元素解析对象（oHtmlparser）、加密对象（oCrypto）。云函数想要调用这些对象时，只需要用如下的方法即可获取：    //获取数据库对象\n  var db = modules.oData;\n  //下面进行其他操作   这里需要说明一点的是：云函数对数据格式的封装遵循RestApi的规则，如果在查看过程中有什么疑问，请移步到 RestApi开发文档 。", 
            "title": "modules模块"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_6", 
            "text": "数据库操作的简单实例如下：  function onRequest(request, response, modules) {\n  //获取数据库对象\n  var db = modules.oData;\n  //获取Posts表中的所有值\n  db.find({\n     table : Posts ,\n  },function(err,data){\n    response.send(data);\n  });\n}  其中，Posts是查找的数据表名称，table是关键词。  需要注意的是，Bmob云函数底层采用Nodejs进行开发，继承了Nodejs的异步非阻塞事件驱动模式，因此也不可避免的需要大量使用回调方法，这些方法往往以非显式声明的闭包形式存在。  此外，通过oData数据库对象获取返回的回调接口中，所有的data数据都是string类型，如果需要在云端中作为对象类型调用的话，需要将string类型转换为object类型，即：      var dataObject= JSON.parse(data);  oData对象的其他操作方法如下：", 
            "title": "数据库对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_7", 
            "text": "find({\n   table : XXX ,          //表名\n   keys : a,b,c ,         //返回字段列表，多个字段用,分隔\n   where :{ a : XXXX , b : XXXX },       //查询条件是一个JSON object\n   order : -a,b ,         //排序列表，[-]字段名称,-表示降序，默认为升序\n   limit :10,            //limit大小，一页返回多少条记录，默认为0\n   skip :2,             //skip,分页offset，(page-1)*limit\n   count :1            //count,只返回符合条件的记录总数\n },function(err,data){    //回调函数\n });  以下是读取Games表（包含name字段）的数据，并对这些数据进行遍历，将name字段连接起来的一段代码样例：  function onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.find({\n     table : Games \n  },function(err,data){ \n  //将返回结果转换为Json对象\n  var resultObject= JSON.parse(data);\n  //遍历这个Json对象\n  for(var results in resultObject)\n  {\n    var resultArr = resultObject[results];\n    var str =   ;\n    //遍历得到的每行结果\n    for(var oneline in resultArr){\n      str =str +    + resultArr[oneline].name;\n    }\n    response.send(str);\n  }\n});\n}", 
            "title": "查询多条数据"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_8", 
            "text": "findOne({\n   table : XXX ,             //表名\n   objectId : XXXX          //记录的objectId\n},function(err,data){         //回调函数\n});  需要注意的是： \n1. 为确保User表的安全性，findOne方法不能直接操作User表。\n2. find方法返回的data是字符串类型，如果需要直接对象化调用的话，需要将string类型转换为object类型，即如下，从_User表中查找objectId=YIuNDDDO的数据，并把username信息显示出来：  function onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.findOne({\n     table : _User ,\n     objectId : YIuNDDDO \n  },function(err,data){ \n    var dataObject= JSON.parse(data);\n    response.send( 获取用户名信息为：   + dataObject.username);\n  });\n}", 
            "title": "查询单条数据"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_9", 
            "text": "function onRequest(request, response, modules) {\n    var db = modules.oData;\n    //获取表 GameScore 的总记录数\n    db.find({\n       table : GameScore ,\n       limit :0,\n       count :1 \n    },function(err,data){     \n\n        resultObject= JSON.parse(data);\n        count=resultObject.count;\n        response.send( 表记录数: +count);\n\n    });     \n}                                                      其中， count 为标识位，具体原因大家可以参考Restapi说明文档： http://docs.bmob.cn/data/Restful/b_developdoc/doc/index.html#查询结果计数 。", 
            "title": "获取表的记录数"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_10", 
            "text": "update({\n   table : XXX ,             //表名\n   objectId : XXXX ,        //记录的objectId\n   data :{ a : XXXX , b : XXXX }           //需要更新的数据，格式为JSON\n},function(err,data){         //回调函数\n});  以下是一个更新数据的示例代码，实现的效果是从Games表中找到objectId=hmw9888C的数据，将其name数据改为pingpang games。  function onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.update({\n     table : Games ,\n     objectId : hmw9888C ,\n     data :{ name : pingpang games }\n  },function(err,data){ \n    response.send( success );\n  });\n}", 
            "title": "修改数据"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_11", 
            "text": "insert({\n   table : XXX ,             //表名\n   data :{ a : XXXX , b : XXXX }            //需要更新的数据，格式为JSON\n},function(err,data){         //回调函数\n});", 
            "title": "添加数据"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_12", 
            "text": "remove({\n   table : XXX ,             //表名\n   objectId : XXXX         //记录的objectId\n},function(err,data){         //回调函数\n});", 
            "title": "删除数据"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_13", 
            "text": "userSignUp({\n   data :{ a : XXXX , b : XXXX }             //用户注册的信息，格式为JSON\n},function(err,data){         //回调函数\n});", 
            "title": "用户注册"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_14", 
            "text": "userLogin({\n   username : aa ,            //登录用户名\n   password :               //用户密码\n},function(err,data){         //回调函数\n});", 
            "title": "用户登录"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_15", 
            "text": "userRestPassword({\n   data :{ email : XX@XX.com }      //需要重置密码的用户邮件账号\n},function(err,data){         //回调函数\n});", 
            "title": "用户密码重置"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_16", 
            "text": "getUserByObjectId({\n   objectId : XXXX           //记录的objectId\n},function(err,data){         //回调函数\n});", 
            "title": "获取某一用户记录"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_17", 
            "text": "说明：必须先登录才能更新，切记！！！否则会报sessionToken error  updateUserByObjectId({\n       objectId : XXXX ,        //记录的objectId\n       data :{ a : XXXX , b : XXXX }           //需要更新的数据，格式为JSON\n    },function(err,data){         //回调函数\n});  以下是更新用户信息的示例代码：  function onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.userLogin({\n     username : 123567 ,\n     password : 123 \n  },function(err, data){\n    if(data){\n      var dataObject = JSON.parse(data);\n      if(dataObject.error == null){\n        //需要设置登录之后获取的sessionToken头信息\n        db.setHeader({ X-Bmob-Session-Token :dataObject.sessionToken});\n        db.updateUserByObjectId({ objectId :dataObject.objectId ,data:{ username : 123 }},function(err,data){\n          response.send( 更新成功 );\n      })\n    }else{\n      response.send( 找不到该用户！ );\n    }\n  }\n}); \n}", 
            "title": "更新某一用户记录"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_18", 
            "text": "getAllUser(function(err,data){         //回调函数\n});", 
            "title": "获得所有用户信息"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_19", 
            "text": "说明：必须登录才行，切记！！！否则会报sessionToken error  removeUserByObjectId({\n       objectId : XXXX         //记录的objectId\n    },function(err,data){         //回调函数\n});", 
            "title": "删除某一个指定用户"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_20", 
            "text": "发送给用户的邮箱验证的邮件会在一周内失效，可以通过下面的方法来强制重新发送  requestEmailVerify({\n       data :{ email : coolguy@iloveapps.com }\n  },function(err,data){ \n    //回调函数\n  });  这里有一个小技巧分享给大家，有时候你会希望能够用Master Key（Bmob给大家提供的超级权限，可以对数据进行任何操作）对数据进行操作，包括不需要用户登录就可以修改用户信息等。那么你只需要在对数据进行操作前，通过db.setHeader方法设置下Master Key头信息即可，如下：  function onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.setHeader({ X-Bmob-Master-Key : 这里填写Master Key信息 });\n  db.updateUserByObjectId({ objectId : 这里是需要更新的用户ObjectId信息  ,data:{ username : 123 }},function(err,data){\n    response.send( 更新成功 );\n  }); \n}", 
            "title": "邮箱验证"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_21", 
            "text": "云函数只支持文件的删除操作。删除文件，必须要知道文件的组名和url，示例代码如下：  function onRequest(request, response, modules) {\n\n  var file = modules.oFile;\n\n  file.del({\n     group : group1 ,\n     url : M00/00/01/wKgBP1N3FAWRJXsSAAAB_rYZATs52.html \n  },function(err,data){\n     //回调函数\n  });\n}  在上面的例子中，group1是组名，M00/00/01/wKgBP1N3FAWRJXsSAAAB_rYZATs52.html是url。  返回结果是个json对象：  {\n   msg :  delete file success \n}", 
            "title": "文件对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_22", 
            "text": "在云函数中可以调用本app的其它云函数，示例代码如下：  function onRequest(request, response, modules) {\n\n    var functions = modules.oFunctions;\n\n    functions.run({\n        name :  test ,\n        data :{ content : 你好 , address : guangzhou }\n    },function(err,data){\n       //回调函数\n    });\n}  在上面的例子中， name 是云函数的函数名， data 中是传递的参数  如果不需要传递任何参数，可以用下面的实例代码：  function onRequest(request, response, modules) {\n\n    var functions = modules.oFunctions;\n\n    functions.run({\n        name :  test \n    },function(err,data){\n       //回调函数\n    });\n}", 
            "title": "云函数对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_23", 
            "text": "Bmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询。你可以在查询中添加一个GeoPoint的对象查询。您可以实现轻松查找出离当前用户最接近的信息或地点的功能。", 
            "title": "地理位置对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_24", 
            "text": "创建地理位置的示例代码如下：  function onRequest(request, response, modules) {\n\n  var location = modules.oLocation;\n\n  location.create({\n     table : GameScore ,\n     objectId : j4w2DDDT ,\n     data :{ location :{            \n             __type :  GeoPoint ,\n             latitude :  12.934755,\n             longitude : 24.52065\n        }}\n  },function(err,data){\n     //回调函数\n  });\n}", 
            "title": "创建地理位置"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_25", 
            "text": "现在您有一系列的对象对应的地理坐标，如果能发现那些对象离指定的点近就好了，这可以通过GeoPoint数据类型加上在查询中使用$nearSphere做到。获取离用户最近的10个地点的实现代码如下：    location.query({\n     table : GameScore ,\n     limit :10,\n     where :{\n         location : {\n             $nearSphere : {\n                 __type :  GeoPoint ,\n                 latitude : 30.0,\n                 longitude : 20.0\n            }\n          }\n    }\n  },function(err,data){\n     //回调函数\n  });  这会按离纬度30.0，经度-20.0的距离排序返回一系列的结果，第一个就是最近的对象。(注意如果一个特定的order参数给了的话，它会覆盖按距离排序)，例如，下面是两个上面的查询返回的结果：  {\n     results : [\n    {\n         location : {\n              __type :  GeoPoint ,\n             latitude : 40.0,\n             longitude : -30.0\n        },\n         updatedAt :  2011-12-06 22:36:04 ,\n         createdAt :  2011-12-06 22:36:04 ,\n         objectId :  e1kXT22L \n        },\n        {\n         location : {\n              __type :  GeoPoint ,\n              latitude : 30.0,\n              longitude : 20.0\n        },\n         updatedAt :  2011-12-06 22:36:26 ,\n         createdAt :  2011-12-06 22:36:26 ,\n         objectId :  51e3a2a8e4b015ead4d95dd9 \n        }\n    ]\n}  为了限定搜素的最大举例，需要加入$maxDistanceInMiles和$maxDistanceInKilometers或者$maxDistanceInRadians参数来限定。如果不加，则默认是100KM的半径。如，要找半径在10公里内的数据的实现代码如下：    location.query({\n     table : GameScore ,\n     limit :10,\n     where :{\n         location : {\n             $nearSphere : {\n                 __type :  GeoPoint ,\n                 latitude : 30.0,\n                 longitude : 20.0\n            },\n         $maxDistanceInKilometers : 10.0\n        }\n    }\n  },function(err,data){\n     //回调函数\n  });  同样做查询寻找在一个特定的范围里面的对象也是可以的，为了找到在一个矩形的区域里的对象，按下面的格式加入一个约束 {\"$within\": {\"$box\": {[southwestGeoPoint, northeastGeoPoint]}}}，下面是一段示例代码：    location.query({\n     table : GameScore ,\n     limit :10,\n     where :{\n         location : {\n             $within : {\n                 $box : [\n                    {\n                         __type :  GeoPoint ,\n                         latitude : 37.71,\n                         longitude : 22.53\n                    },\n                    {\n                         __type :  GeoPoint ,\n                         latitude : 30.82,\n                         longitude : 22.37\n                    }\n                ]\n            }\n        }\n    }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "查询地理位置"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_26", 
            "text": "一个对象可以与其他对象相联系。就像数据库中的主外键关系一样，数据表 A 的某一个字段是数据表 B 的外键，只有表 B 中存在的数据才可插入进表 A 中的字段。", 
            "title": "关联关系对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_27", 
            "text": "为了更新  Pointer  的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个指针，我们可以像这样添加一行记录时并添加一个指针：  function onRequest(request, response, modules) {\n\n  var rel = modules.oRelation;\n  rel.add({\n     table : GameScore ,\n     data :{ game :{ __type : Pointer , className : Game , objectId : ekZq111a }}\n  },function(err,data){\n     //回调函数\n  });\n}  为了更新  Relation  的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个或多个关系，我们可以像这样添加一行记录时并添加多个关系:    rel.add({\n     table : GameScore ,\n     data :{ gamerel :{ __op : AddRelation , objects :[{ __type : Pointer , className : Game , objectId : ekZq111a },{ __type : Pointer , className : Game , objectId : 80SLHHHj }]}}\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "添加关联关系"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_28", 
            "text": "为了更新  Pointer  的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个指针，我们可以像这样添加一个指针:    rel.update({\n     table : GameScore ,\n     objectId : 8106dc7c9e ,\n     data :{ game :{ __type : Pointer , className : Game , objectId : 80SLHHHj }}\n  },function(err,data){\n     //回调函数\n  });  为了更新  Relation  的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个或多个关系，我们可以像这样添加多个关系:    rel.update({\n     table : GameScore ,\n     objectId : 8106dc7c9e ,\n     data :{ gamerel :{ __op : AddRelation , objects :[{ __type : Pointer , className : Game , objectId : ekZq111a }]}}\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "修改关联对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_29", 
            "text": "有几种方式来对关系  Relation  或 指针  Pointer  类型数据进行查询, 如果您将要获取对象中有个Key类型是关系  Relation  或 指针  Pointer ，这都说明你要获取的对象是匹配到另一个特殊（关联或指向）的对象的, 您可以用一个  where  参数查询, 自己使用  __type  构造一个  Pointer , 就像你构造其他数据类型一样。举例说, 如果每一条评论(Comment对象)有一个Key叫post，类型是Pointer，并且指向了一个具体的帖子(Post对象，用objectId表示一个帖子)，那么您可以使用下面的请求获取一个帖子的所有评论:  rel.query({\n   table : Comment ,   \n   where :{ post :{ __type : Pointer , className : Post , objectId : l4fQ999O }},\n },function(err,data){    \n    //回调函数\n });  如果您想要获取对象, 这些对象的一个字段指向的对象是符合另一个查询的, 您可以使用 $inQuery 操作符，注意默认的 limit 是 100 而且最大的 limit 是 1000，这个限制同样适用于内部的查询, 所以对于较大的数据集您可能需要细心地构建查询来获得期望的行为。举例说, 假设您有一个 帖子(Post)类和一个评论(Comment)类, 每个评论(Comment)都有一个指向它的帖子(Post)的关系Key名为post，并且类型为Pointer, 您可以找到所有有图片的帖子(Post)的评论(Comment):  rel.query({\n   table : Comment ,   \n   where :{ post :{ $inQuery :{ where :{ image :{ $exists :true}}, className : Post }}},\n },function(err,data){    \n    //回调函数\n });  同理，使用下面的请求，您可以找到所有没有图片的帖子(Post)的评论(Comment):  rel.query({\n   table : Comment ,   \n   where :{ post :{ $notInQuery :{ where :{ image :{ $exists :true}}, className : Post }}},\n },function(err,data){    \n    //回调函数\n });  如果您想获取的对象，是其父对象的关系  Relation  类型的Key的所有成员的话, 您可以使用 $relatedTo 操作符, 假设您有一个帖子(Post)类和一个系统默认的用户(_User)类, 而每一个帖子(Post)都可以被不同的用户(_User)所喜欢。 如果帖子(Post)类下面有一个Key名为likes，且是  Relation  类型, 存储了喜欢这个帖子(Post)的用户(_User)。那么您可以找到喜欢过同一个指定的帖子(Post)的所有用户：  rel.query({\n   table : users ,   \n   where :{ $relatedTo :{ object :{ __type : Pointer , className : Post , objectId : l4fQ999O }, key : likes }},\n },function(err,data){    \n    //回调函数\n });  还可以使用组合查询，比如下面这样，判断用户是否喜欢(likes)过这个帖子：  rel.query({\n   table : Comment ,   \n   where :{ likes :{ $inQuery :{ where :{ objectId : l3xRGGGa }, className : _User }},  objectId : l4fQ999O },\n   limit :10,  \n   count :true   \n },function(err,data){    \n    //回调函数\n });  返回结果集如下：  {\n    count: 1\n    results: [ ]\n}  你可以做如下判断，如果count=1，表明用户喜欢的这个帖子objectId存在，即用户喜欢过这个帖子；若count=0, 表明用户没有喜欢过这个帖子。  在某些情况之下，您可能需要在一个查询之中返回关联对象的多种类型，您可以通过传入字段名称到include参数中，多个字段名称用,间隔， 比如，我们想获得最近的10篇评论，而您想同时得到它们相关的post： include的Key必须是Pointer类型  rel.query({\n   table : Comment ,   \n   order : -createdAt ,\n   limit :10,  \n   include : post    \n },function(err,data){    \n    //回调函数\n });  不是作为一个  Pointer  类型表示，post字段现在已经被展开为一个完整的帖子(Post)对象， __type 被设置为  Object  而  className  同样也被提供了。 举例说， 一个指向帖子(Post)的Pointer原本展示为：  {\n   __type :  Pointer ,\n   className :  Post ,\n   objectId :  51e3a359e4b015ead4d95ddc \n}  当一个查询使用include参数来包含进去来取代  Pointer  之后，可以看到  Pointer  被展开为：  {\n   __type :  Object ,\n   className :  Post ,\n   objectId :  51e3a359e4b015ead4d95ddc ,\n   createdAt :  2011-12-06T20:59:34.428Z ,\n   updatedAt :  2011-12-06T20:59:34.428Z ,\n   otherFields :  willAlsoBeIncluded \n}  您可以同样做多层的include, 这时要使用 \".\" 号. 如果您要include一条评论(Comment)对应的帖子(Post)的作者(author)： include的Key必须是Pointer类型  rel.query({\n   table : Comment ,   \n   order : -createdAt ,\n   limit :10,  \n   include : post.author    \n },function(err,data){    \n    //回调函数\n });", 
            "title": "查询关联对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_30", 
            "text": "可以在一个对象中删除一个关系:    rel.delete({\n     table : GameScore ,\n     objectId : 8106dc7c9e ,\n     data :{ gamerel :{ __op : RemoveRelation , objects :[{ __type : Pointer , className : Game , objectId : ekZq111a }]}}\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "删除关联关系"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_31", 
            "text": "很多应用可能会有需要计数器的功能，比如某条信息被点赞多少次等。Bmob提供了非常便捷的方式来保证原子性的修改某一数值字段的值，示例代码如下：  function onRequest(request, response, modules) {\n  //获取原子操作对象\n  var atom = modules.oAtom;\n\n  //score增加一个固定值操作\n  atom.exec({\n     table : GameScore ,\n     objectId : j4w2DDDT ,\n     data :{ score :{ __op : Increment , amount :1}}\n  },function(err,data){\n     //回调函数\n  });\n}  function onRequest(request, response, modules) {\n  //获取原子操作对象\n  var atom = modules.oAtom;\n\n  //score减少一个固定值操作\n  atom.exec({\n     table : GameScore ,\n     objectId : j4w2DDDT ,\n     data :{ score :{ __op : Increment , amount :-1}}\n  },function(err,data){\n     //回调函数\n  });\n}", 
            "title": "原子操作对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_32", 
            "text": "为了减少因为网络通讯次数太多而带来的时间浪费, 您使用使用下面的批量(batch)操作，在一个请求中对多个普通对象(不支持系统内置的用户对象)进行添加(create)、更新(update)、删除(delete) 操作，上限为50个。  function onRequest(request, response, modules) {\n  //获取数组对象\n  var bat = modules.oBatch;\n\n  //批量操作\n  bat.exec({\n     data :{\n         requests : [\n          {\n             method :  POST ,\n             path :  /1/classes/GameScore ,\n             body : {\n               score : 1337,\n               playerName :  Sean Plott \n            }\n          },\n          {\n             method :  POST ,\n             path :  /1/classes/GameScore ,\n             body : {\n               score : 1338,\n               playerName :  ZeroCool \n            }\n          }\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n}  批量操作的响应会是一个列表, 列表的返回值个数同给定的requests请求个数是相等的。列表中每个返回项都有一个字段是  \"success\"  或者  \"error\" ，  \"success\"  的值是通常是和你进行其他REST操作成功时返回的值是一样的:  {\n   success : {\n     createdAt :  2012-06-15T16:59:11.276Z ,\n     objectId :  51c3ba67e4b0f0e851c16221 \n  }\n}  \"error\"  的值是有返回码和错误信息字符串的一个对象:  {\n   error : {\n     code : 101,\n     error :  object not found for delete \n  }\n}  在 batch 操作中更新(update)和删除(delete)同样是有效的:  function onRequest(request, response, modules) {\n  //获取数组对象\n  var bat = modules.oBatch;\n\n  //批量操作\n  bat.exec({\n     data :{\n         requests : [\n          {\n             method :  PUT ,\n             path :  /1/classes/GameScore/51e3a334e4b0b3eb44adbe1a ,\n             body : {\n               score : 999999\n            }\n          },\n          {\n             method :  DELETE ,\n             path :  /1/classes/GameScore/51a8a4d9e4b0d034f6159a35 \n          }\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n}", 
            "title": "批量操作对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_33", 
            "text": "用下面的方法来获取数组对象：    var arr = modules.oArray;", 
            "title": "数组操作对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_34", 
            "text": "添加数组对象,不管元素是否存在都添加的实现代码如下：    arr.add({\n     table : GameScore ,\n     data :{ skills :{ __op : Add , objects :[ flying , kungfu ]}}\n  },function(err,data){\n      //回调函数\n  });  添加数组对象,只有在元素不存在情况下才添加的实现代码如下：    //往GameScore表中字段skills添加的数组\n  arr.addUnique({\n     table : GameScore ,\n     objectId : j4w2DDDT ,\n     data :{ skills :{ __op : AddUnique , objects :[ flying , kungfu ]}}\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "添加数组对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_35", 
            "text": "//往GameScore表中字段skills删除数组\n  arr.remove({\n     table : GameScore ,\n     objectId : j4w2DDDT ,\n     data :{ skills :{ __op : Remove , objects :[ flying , kungfu ]}}\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "删除数组对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_36", 
            "text": "查询数组对象,可以查找skills的数组值中包含有\"flying\"的对象的实现方法如下:    //往GameScore表中字段skills添加的数组\n  arr.query({\n     table : GameScore ,\n     where :{ skills : flying }\n  },function(err,data){\n     //回调函数\n  });  查询数组对象,可以查找skills的数组值中包含有\"flying\",\"kungfu\"的对象的实现方法如下：    //往GameScore表中字段skills添加的数组\n  arr.query({\n     table : GameScore ,\n     where :{ skills :{ $all :[ flying , kungfu ]}}\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "查询数组对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_37", 
            "text": "推送通知是让用户及时被通知、和你的应用保持联系的一种非常棒的方式，你可以快速而有效地通知到所有的用户，下面这个教程将会教会你使用Bmob来推送消息。用下面的方法来获取消息推送对象：    var push = modules.oPush;", 
            "title": "消息推送对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_38", 
            "text": "每一个Bmob的App安装在用户设备后，如果要使用消息推送功能，Bmob SDK会自动生成一个Installation对象。Installation对象包含了推送所需要的所有信息。举例：一个棒球的App，你可以让用户订阅感兴趣的棒球队，然后及时将这个球队的消息推送给用户 。  Installation对象有几个系统默认的特殊字段来帮助你的管理和定位到设备：\n-  badge  : iOS应用中右上角的图标标识\n-  channels  : 当前这个设备订阅的渠道名称数组\n-  timeZone  : 设备所在位置的时区， 如Asia/Shanghai，这个会在每个Installation对象更新时同步（只读）\n-  deviceType  : 设备的的类型, 值为：\"ios\" 或 \"android\" (只读)\n-  installationId  : Bmob使用的设备唯一号，Android设备是必须的，iOS可选 (只读)\n-  deviceToken  : iOS设备由Apple APNS生成的唯一性token标识 (只读)", 
            "title": "安装消息推送服务"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#installation", 
            "text": "", 
            "title": "保存installation"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#iosdevicetoken", 
            "text": "iOS设备通常使用deviceToken来惟一标识一台设备。    push.add({\n     data :{\n         deviceType :  ios ,\n         deviceToken :  abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789 ,\n         channels : [\n           Giants \n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "保存iOS设备的deviceToken"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#androidinstallationid", 
            "text": "对于Android设备，SDK会自动生成uuid作为installationId保存到Bmob。 您可以使用以下云函数保存Android设备的installation ID：    push.add({\n     data :{\n         deviceType :  android ,\n         installationId :  12345678-4312-1234-1234-1234567890ab ,\n         channels : [\n           Giants \n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });  你还可以更新Installation对象的更多属性，用来查询installationId，定制更通用的推送：    push.update({\n     objectId : 400a12ed3a ,\n     data :{\n         scores : true,\n         gameResults : true,\n         injuryReports : true\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "保存Android设备的installationId"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#windows-phone-notificationuri", 
            "text": "对于Windows Phone设备，BmobSDK会自动从Windows Push Center获取到notificationUri并保存到 Bmob。 你可以使用以下REST API保存Windows Phone设备的notificationUri：    push.add({\n     data :{\n         deviceType :  windows phone ,\n         notificationUri :  https://hk1.notify.live.net/unthrottledthirdparty/01.00/AQHgHh6EuwNtTa1TbwvaAjnmAgAAAAADEAAAAAQUZm52OkZDM0U5RDkxQzIzREJBNDYFBkFTRUEwMQ ,\n         channels : [\n           Giants \n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "保存Windows Phone设备的 notificationUri"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_39", 
            "text": "", 
            "title": "订阅频道和退订"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_40", 
            "text": "覆盖已订阅的频道：    push.update({\n     objectId : 400a12ed3a ,\n     data :{\n         channels : [\n           Giants ,\n           Mets \n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });  订阅一个新频道，不覆盖已订阅的频道：    push.update({\n     objectId : 400a12ed3a ,\n     data :{\n         channels :{ __op : AddUnique , objects :[ Giants111 ]}\n    }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "订阅频道"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_41", 
            "text": "push.update({\n     objectId : 400a12ed3a ,\n     data :{\n         channels :{ __op : Remove , objects :[ Giants , Mets ]}\n    }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "退订频道"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_42", 
            "text": "push.send({\n     data :{\n         data : {\n           alert :  Hello From Bmob. \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "广播推送消息"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_43", 
            "text": "发送给订阅了Giants频道的用户    push.send({\n     data :{\n         where :{\n           channels :[ Giants ]\n        },\n         data : {\n           alert :  Hello From Bmob. \n        }\n      }\n  },function(err,data){删除数据\n     //回调函数\n  });  或者更简便的方式    push.send({\n     data :{\n         channels :[ Giants ],\n         data : {\n           alert :  Hello From Bmob. \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "组播推送消息"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_44", 
            "text": "", 
            "title": "多播推送消息"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_45", 
            "text": "push.send({\n     data :{\n         where :{\n             updatedAt :{\n                 $lt :{ __type : Date , iso : 2014-01-29 11:33:53 }\n              }\n        },\n         data : {\n             alert :  Hello From Bmob. \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "推送给不活跃的用户"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_46", 
            "text": "push.send({\n     data :{\n         where : {\n           scores : true\n        },\n         data : {\n           alert :  Willie Hayes injured by own pop fly. \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });  请注意，where 条件查询的都是 installations 表。这里是假设 installations 表存储了 scores 的布尔属性，你可以像查询普通对象一样构造where查询", 
            "title": "根据查询条件做推送"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_47", 
            "text": "push.send({\n     data :{\n         where : {\n           deviceType :  android \n        },\n         data : {\n           alert :  Your suitcase has been filled with tiny robots! \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });    push.send({\n     data :{\n         where : {\n           deviceType :  ios \n        },\n         data : {\n           alert :  Your suitcase has been filled with tiny robots! \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "根据平台做推送"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_48", 
            "text": "push.send({\n     data :{\n         where : {\n           user : {\n             $inQuery : {\n               location : {\n                 $nearSphere : {\n                   __type :  GeoPoint ,\n                   latitude : 30.0,\n                   longitude : -20.0\n                },\n                 $maxDistanceInMiles : 1.0\n              }\n            }\n          }\n        },\n         data : {\n           alert :  Free hotdogs at the bmob concession stand! \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });  上面的例子假设 installation 有个 user 属性指向_User 表的记录，并且用户有个 location 属性是 GeoPoint 类型，我们就可以根据地理信息位置做推送。", 
            "title": "根据地理信息位置做推送"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_49", 
            "text": "发送给Android单个客户端    push.send({\n     data :{\n         where :{\n             installationId : 12345678-4312-1234-1234-1234567890ab \n            },\n         data : {\n           alert :  Hello From Bmob. \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });  发送给iOS单个客户端    push.send({\n     data :{\n         where :{\n             deviceToken : abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789 \n            },\n         data : {\n           alert :  Hello From Bmob. \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "点播推送消息"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_50", 
            "text": "推送通知不仅仅可以用来发送消息，iOS中，推送内容还可以包含要播放的声音和要显示的badge数字值,还可以定制任何你想发送的内容，对于Android，你甚至可以指定Intent应用于接收消息，对于时间性有要求的消息您还可以设置一个消息过期时间。", 
            "title": "发送选项设置"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_51", 
            "text": "如果你想发送更多的消息，你可以在data的字典对象中设置其他字段，下面这些保留的字段有其特殊的意义：\n-  alert  : 通知的消息内容\n-  badge  : (仅iOS)一个数字值将会高亮显示在应用图标的右上角\n-  sound  : (仅iOS)应用绑定包中的声音文件 \n-  content-available  : (仅iOS)如果你的应用是新闻类的，或者你的应用正在使用iOS7的Remote Notification Background Mode，设定这个值为1将为触发离线下载功能。\n-  action  : (仅Android)接收到推送消息时应用Intent，如果没有指定title或alert，Intent将被应用，但是没有通知呈现给用户。\n-  title  : (仅Android)这个值将显示在系统通知栏  例如，推送一条通知，将当前的badge值自增1,并且播放iOS设备上定制的音乐，对于Android用户，将在系统通知栏中显示特殊的标题，则请求如下：    push.send({\n     data :{\n         channels : [\n           Giants \n        ],\n         data : {\n           alert :  The Mets scored! The game is now tied 1-1. ,\n           badge : 1,\n           sound :  cheering.caf ,\n           title :  Mets Score! \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });  当然，你也可以在data字典对象中定制自己的字段，推送消息，但不显示在 Andoid 系统的通知栏中，而是执行应用程序预定义的逻辑，Android或iOS接收消息文档中对此有说明，iOS只有当用户从通知中打开应用，才能访问data的数据，Android将提供这个数据在action Intent应用之后,    push.send({\n     data :{\n         channels : [\n           Giants \n        ],\n         data : {\n           alert :  The Mets scored! The game is now tied 1-1. ,\n           badge :  Increment ,\n           sound :  cheering.caf ,\n           title :  Mets Score! \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "定制您的通知"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_52", 
            "text": "过期时间，可以是绝对时间：    push.send({\n     data :{\n         expiration_time :  2015-12-04 00:51:13 ,\n         data : {\n           alert :  Season tickets on sale until December  4, 2013 \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });  也可以是相对时间（根据push_time做定期推送，从push_time时间开始算起，直到expiration_interval时间后过期），下面请求表示消息将在2012-01-28 00:51:13这个时间点开始推送，直到7天后过期:    push.send({\n     data :{\n         push_time :  2012-01-28 00:51:13 ,\n         expiration_interval : 518400,\n         data : {\n           alert :  Season tickets on sale until December  4, 2013 \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "设置消息过期时间"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_53", 
            "text": "Bmob的邮件发送对象采用Nodejs提供的nodemailer模块，这里提供简单的一个发送邮件的操作实例。更多的功能详细参考： https://npmjs.org/package/nodemailer  function onRequest(request, response, modules) {\n//获得发送邮件的对象 \nvar mailer = modules.oMail; \n//设置发送服务器信息 \nvar  transport = mailer.createTransport(  SMTP  , {\n    host:  smtp.126.com  ,\n    secureConnection: true , // use SSL\n    port: 465, // port for secure SMTP\n    auth: {\nuser:  bmobtest111@126.com , //设置发送邮箱帐号 \npass:  xxx  //设置发送邮箱密码 \n    }\n});\n\ntransport.sendMail({\n    from :  bmobtest111@126.com  ,\n    to :  test@126.com  ,\n    subject:  主题  ,\n    generateTextFromHTML : true ,\n    html :  啊哈哈哈 \n}, function (error, responseback){\n\n    transport.close();\n     if(error){\n        //发送失败\n    }else{\n        //发送成功\n        response.send( 发送成功 );\n    }\n});\n\n\n\n}", 
            "title": "邮件发送对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#http_1", 
            "text": "oHttp对象可以模拟实现get、post、put、delete等各种HTTP请求信息，让你在云端实现诸如数据采集、OAuth授权登录等功能。Bmob的HTTP请求模块采用Nodejs提供的request模块，这里提供简单的Get和Post的操作实例。更多的功能详细参考： https://npmjs.org/package/request  /**\n*发起Get请求\n*/\n//获取Http模块\nvar http = modules.oHttp;\n//发起Get请求\nhttp('http://www.bmob.cn', function (error, res, body) {\n    if (!error   res.statusCode == 200) {\n      response.send(body);\n    }\n})\n\n-\n\n/**\n*发起Post请求\n*/\n//获取Http模块\nvar http = modules.oHttp;\n//往http://bmob.cn/save发起POST请求\nhttp.post('http://bmob.cn/save', {form:{key:'value'}})", 
            "title": "HTTP请求对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_54", 
            "text": "oEvent，也就是eventproxy模块，解决异步回调的问题。  更多的功能详细参考： https://github.com/JacksonTian/eventproxy  function onRequest(request, response, modules) {\n\n    var ep = modules.oEvent;  //eventproxy模块，解决异步回调的问题\n\n    ep.after('got_file', 3, function (list) {\n        response.send( len: +list.length);\n\n    });\n\n    //发送3次事件后触发事件，输出list的长度\n    ep.emit( got_file ,  1 );  \n    ep.emit( got_file ,  1 );  \n    ep.emit( got_file ,  1 );  \n\n\n}", 
            "title": "事件对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#encode", 
            "text": "Encode对象可以实现字符编码的转换。更多的功能详细参考： https://www.npmjs.org/package/encoding  Encode对象就一个方法convert()，使用方法为：encoding.convert(text, toCharset, fromCharset)。  text: 需要转换的对象，可以为Buffer或者String对象。  toCharset: 转换后的编码。  fromCharset: 转换前的编码，缺省为uft8。  转换后的输入结果为Buffer对象。  var encoding = modules.oEncodeing;\nvar result = encoding.convert( 禅 , gbk , utf8 );\nresponse.send(result.toString());", 
            "title": "Encode编码转换对象"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#htmlohtmlparser", 
            "text": "html元素解析对象可以实现html的解释。更多的功能详细参考： https://www.npmjs.org/package/htmlparser  代码例子  function onRequest(request, response, modules) {\n    var htmlparser = modules.oHtmlparser;\n    var rawHtml =  a href='test.html' xxx /a ;\n    var handler = new htmlparser.DefaultHandler(function (error, dom) {});\n    var parser = new htmlparser.Parser(handler);\n    parser.parseComplete(rawHtml);\n    response.send(JSON.stringify(handler.dom, null, 2));\n\n}                                                                                                                           代码的输出：  [\n  {\n     raw :  a href='test.html' ,\n     data :  a href='test.html' ,\n     type :  tag ,\n     name :  a ,\n     attribs : {\n       href :  test.html \n    },\n     children : [\n      {\n         raw :  xxx ,\n         data :  xxx ,\n         type :  text \n      }\n    ]\n  }\n]", 
            "title": "html元素解析对象（oHtmlparser）"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#bqlobql", 
            "text": "我们提供类 SQL 语法的 BQL 查询语言来查询数据  下面的代码例子就是查询GameScore表的所有数据  function onRequest(request, response, modules) {\n    //获得bql的对象 \n    var Bql = modules.oBql; \n\n    Bql.exec({\n       bql : select * from GameScore \n    },function(err,data){\n      response.send(data);\n    });\n\n\n}                                                                                                                          BQL 还支持占位符查询，where 和 limit 子句的条件参数可以使用问号替换，然后通过 values 数组传入：  function onRequest(request, response, modules) {\n    //获得bql的对象 \n    var Bql = modules.oBql; \n\n    Bql.exec({\n       bql : select * from GameScore where name=? limit ?,?  ,\n       values : [\\ tom\\ ,0,100] \n    },function(err,data){\n      response.send(data);\n     //回调函数\n    });\n\n\n}                                                                           更多请参考  BQL 详细指南  。", 
            "title": "bql对象（oBql）"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#ocrypto", 
            "text": "提供md5和sha1两种加密算法。更多的功能详细参考： https://www.npmjs.org/package/crypto  代码例子    function onRequest(request, response, modules) {\n    var crypto = modules.oCrypto;\n    var md5 = crypto.createHash('md5');\n    md5.update( hello ); //输入要md5的内容\n    response.send(md5.digest('hex'));//以16进制编码\n}", 
            "title": "加密对象（oCrypto）"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_55", 
            "text": "为方便开发者调试云函数，Bmob为开发者提供了便捷的云端调试工具，你可以直接在云函数的编辑页面下对编写的代码进行调试，如实现从Bar表中查找指定objectId号（SDK中上传参数）的数据，你可以在云函数中实现如下：  function onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.findOne({\n     table : Bar ,\n     objectId :request.body.objectId\n  },function(err,data){ //回调函数\n     response.send( 成功   + data);\n  });\n}  调试时，你在云端调试工具中输入参数名为objectId，参数值为你想要查询的信息，如下图，即可查看到调试结果。", 
            "title": "云函数调试工具"
        }, 
        {
            "location": "/cloud_function/web/develop_doc/#_56", 
            "text": "Bmob提供的官方模块（非第三方）的错误回调中都会有一个 err 对象，这个 err 对象包含两个属性： error 和 code ，分别代表错误异常信息和错误代码。调用时可以简单如下使用：  function onRequest(request, response, modules) {\n    var db = modules.oData;\n    db.findOne({\n         table : YourTableName ,\n         objectId :request.body.oid\n    },function(err,data){ \n        //对返回结果进行处理\n        if(err)  response.send( error is    + err.code  +  error message is   + err.error );\n        else response.send(data);\n    });\n}", 
            "title": "错误对象"
        }, 
        {
            "location": "/cloud_function/web/timing_tasks/", 
            "text": "定时任务\n\n\n\n\n定时任务是专门为云函数提供定时服务，用来定时触发云函数的特定操作，满足比如定时计算排行榜等需求。规则如下：\n\n\n注意：免费版用户最短间隔时间须大于1小时，否则规则无法保存，付费版用户不受该限制。\n\n\n具体规则写法如下：\n\n\n\n\n\n\n\n\n字段名\n\n\n取值范围\n\n\n\n\n\n\n\n\n\n\n秒\n\n\n0到59\n\n\n\n\n\n\n分\n\n\n0到59\n\n\n\n\n\n\n小时\n\n\n0到23\n\n\n\n\n\n\n天\n\n\n1到31\n\n\n\n\n\n\n月\n\n\n1到12\n\n\n\n\n\n\n星期\n\n\n0到6, 分别对应：星期天、星期一、星期二、星期三、星期四、星期五、星期六\n\n\n\n\n\n\n\n\n“ * * * * * * ”\n 分别对应：秒 分 时 日 月 星期。当星期的字段填了数字时，天和月的字段就应为\n“ * ”\n。具体例子如下：\n\n\n\n\n\n\n\n\n规则\n\n\n作用\n\n\n\n\n\n\n\n\n\n\n* * * * * *\n\n\n表示每一秒，触发定时器一次\n\n\n\n\n\n\n1 * * * * *\n\n\n表示每分钟的秒数是1时，触发定时器一次\n\n\n\n\n\n\n0 0 * * * *\n\n\n表示每小时，触发定时器一次\n\n\n\n\n\n\n0 0 16 * * *\n\n\n表示每天的16时0分0秒，触发定时器一次\n\n\n\n\n\n\n0 0 0 1 * *\n\n\n表示每个月的1号0时0分0秒，触发定时器一次\n\n\n\n\n\n\n0 0 0 * * 0\n\n\n表示每个星期天的0时0分0秒，触发定时器一次\n\n\n\n\n\n\n0 0 0 1 5 *\n\n\n表示每年的5月的1号0时0分0秒，触发定时器一次\n\n\n\n\n\n\n* 0 * * * *\n\n\n表示每小时的0分里面的每一秒，触发定时器一次，即定时器触发了60次，一秒一次\n\n\n\n\n\n\n*/3 * * * * *\n\n\n表示每分钟的秒数是3的倍数时，触发定时器一次\n\n\n\n\n\n\n0 */10 * * * *\n\n\n表示每小时的0分、10分、20分、30分、40分、50分，触发定时器一次\n\n\n\n\n\n\n* * */5 * * *\n\n\n表示每天的0时、5时、10时、15时、20时里面的每一秒钟都触发定时器一次\n\n\n\n\n\n\n0 0 0 */10 * *\n\n\n表示每个月的10号、20号、30号的凌晨，触发定时器一次\n\n\n\n\n\n\n0 0 0 * * */3\n\n\n表示每个星期三和星期六的凌晨，触发定时器一次", 
            "title": "定时任务"
        }, 
        {
            "location": "/cloud_function/web/timing_tasks/#_1", 
            "text": "定时任务是专门为云函数提供定时服务，用来定时触发云函数的特定操作，满足比如定时计算排行榜等需求。规则如下：  注意：免费版用户最短间隔时间须大于1小时，否则规则无法保存，付费版用户不受该限制。  具体规则写法如下：     字段名  取值范围      秒  0到59    分  0到59    小时  0到23    天  1到31    月  1到12    星期  0到6, 分别对应：星期天、星期一、星期二、星期三、星期四、星期五、星期六     “ * * * * * * ”  分别对应：秒 分 时 日 月 星期。当星期的字段填了数字时，天和月的字段就应为 “ * ” 。具体例子如下：     规则  作用      * * * * * *  表示每一秒，触发定时器一次    1 * * * * *  表示每分钟的秒数是1时，触发定时器一次    0 0 * * * *  表示每小时，触发定时器一次    0 0 16 * * *  表示每天的16时0分0秒，触发定时器一次    0 0 0 1 * *  表示每个月的1号0时0分0秒，触发定时器一次    0 0 0 * * 0  表示每个星期天的0时0分0秒，触发定时器一次    0 0 0 1 5 *  表示每年的5月的1号0时0分0秒，触发定时器一次    * 0 * * * *  表示每小时的0分里面的每一秒，触发定时器一次，即定时器触发了60次，一秒一次    */3 * * * * *  表示每分钟的秒数是3的倍数时，触发定时器一次    0 */10 * * * *  表示每小时的0分、10分、20分、30分、40分、50分，触发定时器一次    * * */5 * * *  表示每天的0时、5时、10时、15时、20时里面的每一秒钟都触发定时器一次    0 0 0 */10 * *  表示每个月的10号、20号、30号的凌晨，触发定时器一次    0 0 0 * * */3  表示每个星期三和星期六的凌晨，触发定时器一次", 
            "title": "定时任务"
        }, 
        {
            "location": "/cloud_function/web/weixin/", 
            "text": "简介\n\n\n在这篇微信公众平台开发教程中，将会带领你一步步领略使用云后端服务bmob的方便性，同时使用bmob进行微信公众号平台开发。\n\n\n注意：升级云函数套餐后就没法在微信公众号中调用云函数\n\n\n使用bmob有什么好处，下面一一为你道来：\n\n\n\n\n不需要购买服务器，不需要懂linux，不需要懂运维知识，零成本地拥有属于自己的后台系统。\n\n\n不在需要mysql，轻松存储和获取数据，同时提供了一个方便的数据管理后台。\n\n\n提供灵活的“云函数”，其融合了bmob的数据服务和大量的第三方服务，让你轻松应对复杂的业务逻辑。同时云函数能被第三方平台调用，再也不需要php，java等复杂的web服务。\n\n\n\n\n本教程将引导你完成如下任务：\n\n\n\n\n创建bmob应用\n\n\n使用bmob云函数实现微信公众平台的开发\n\n\n\n\n创建bmob应用\n\n\n在这节中，将会从基本的创建bmob账号开始，到创建应用，数据的基本操作，到云函数的运行，使读者对bmob的功能有初步的了解。\n\n\n在这个教程中，用到了bmob的两个功能：\n\n\n\n\n\n\n数据存储：把订阅者发到微信公众号的信息存储起来。\n\n\n\n\n\n\n云函数：微信后台回调云函数后，完成公众号所需的业务逻辑：信息存储，把信息加工后返回给订阅者的微信。\n\n\n\n\n\n\n注册bmob账号\n\n\n在网址栏输入\nwww.bmob.cn\n或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，如下图1所示：\n\n\n\n\n注册成功，到注册所填入的邮箱查看bmob发送的邮件，点击其中激活链接后，就能使用邮箱和密码登录bmob。\n\n\n创建应用\n\n\n登录后，点击“我的控制台”，进入到了管理后台，如下图2所示：\n\n\n\n在bmob中，一个用户可以创建多个应用，每个应用拥有其所属的专用数据库，多个应用之间相互独立。\n\n\n用户需要创建一个应用，先点击管理后台中的“创建应用”按钮，如下图3所示：\n\n\n\n\n在创建应用的输入框中输入app的名称，点击“创建应用”，就能成功创建应用，如下图4所示：\n\n\n\n\n数据的基本操作\n\n\n创建应用成功后，开发者在管理后台点击刚才创建的应用，进入到应用的后台界面，其中最常用的是“数据浏览界面”，在该界面提供了便利的图形化操作，让开发者轻松地对该应用所属的数据库进行表的增删，数据的增删改查等操作，如下图5所示：\n\n\n\n\n每个应用的数据库都有一个默认的表\"_User\",其提供了一些常用的字段来记录该应用的用户信息。\n\n\n开发者需要增加新的表来存储信息时，点击“添加表”按钮，输入表名，就能创建一张新表，如下图6所示：\n\n\n\n\n在\"添加新的表\"界面中,选项“自定义”选项即可创建一张新的普通表，另外两个选项是较高级的功能，在本教程中暂时不需要用到。\n\n\n在这里，创建了一张名为\"message\"的表，用于存储订阅者发送到公众号后台的信息。\n\n\n在表\"message\"的操作界面中可看到，表\"message\"有4个默认的字段，其中3个最常用字段的含义如下：\n\n\n\n\nobjectId：该行的id，objectId的作用和mysql中的经常使用的id类似，用于唯一标示一行。\n\n\ncreatedAt：改行数据的创建时间。\n\n\nupdatedAt：改行数据的最后修改时间。\n\n\n\n\n当操作一行数据的时候，以上的3个字段的值由bmob后台自动管理。另外这些字段的名字是保留的，你不能自行设置它们。\n\n\n由于表\"message\"是需要把订阅者发到微信公众号的信息存储起来，存储信息的两个属性：谁发送这条信息，信息的内容，所以添加下面所需的字段：\n\n\nuserId：订阅者的id，String类型。\ncontent：发送的内容，String。\n\n\n通过图8的“添加一列”功能，依次把userId和content这两个字段添加到表\"message\"中。\n\n\n\n\n注意：在用云函数添加数据时，如果发现其所操作的表和所操作的列不存，bmob后台会自动创建。这里为了演示bmob的数据浏览操作，所以才手动创建一次。\n\n\n云函数\n\n\n阅读了上面的“数据的基本操作”的内容后，读者可能有个疑问，怎么对表的数据进行增删改查等操作呢？除了可以在\"数据浏览\"界面可以进行操作外，也可以通过云函数进行数据的增删改查，开发者也可以通过云函数完成更加复杂的业务逻辑。\n\n\n云函数的基本知识\n\n\n对于一些复杂的应用，您可能希望增加一些特有的业务逻辑，并能灵活掌控，Bmob 云函数提供了这种灵活性，可以让您的代码直接在 Bmob云上运行, 通过SDK（Android，iOS），restful api或者任何http的方式调用，即可获取结果数据。\n\n\n云函数的编码采用nodejs语法，简单易用。在云函数的编辑器中，系统默认生成了云函数的入口函数function onRequest(request, response, modules)，你可以根据自己的需求实现业务逻辑代码。 \n\n\n在云函数界面，创建一个名为\"helloworld\"的云函数，如下图9所示：\n\n\n\n\n生成云函数后，可看到云函数生成的入口方法，如下图10所示：\n\n\n\n\n开发者按照云函数的相关语法和提供的模块编写云函数，就能实现各种业务逻辑。\n\n\n从云函数的入口方法function onRequest(request, response, modules)可知，云函数包含三个模块，分别是request模块、response模块和modules模块。\n\n\nrequest模块\n\n\nrequest模块用于获取传入的参数。由于现在调用云函数有两种方式（get和post），所以获取传入的参数的方式需要使用不同的方法。\n\n\n当用get请求的方式传入参数，可用如下的方法获取参数的值：\n\n\nrequest.query.name  //获取传入参数name的值\n\n\n\n\n当用post请求的方式传入参数，可用如下的方法获取参数的值：\n\n\nrequest.body.name  //获取传入参数name的值\n\n\n\n\nresponse模块\n\n\nresponse为云函数的信息回传模块，该模块包含了一个end方法，实现将云端的执行结果（如查询的数据）返回给SDK或者RestApi等调用端：\n\n\nresponse.end(string result)\n\n\n\n\nmodules模块\n\n\nmodules是Bmob云函数提供给大家的各种对象处理的模块，包括数据库对象（oData）、文件对象（oFile）、地理位置对象（oLocation）、关联关系对象（oRelation）、原子操作对象（oAtom）、数据批量操作对象（oBatch）、数组对象（oArray）、消息推送对象（oPush）、云函数对象（oFunctions）、邮件发送对象（oMail）、同步对象（oAsync）、HTTP对象（oHttp）、字符编码转换对象（oEncodeing）、事件对象（oEvent）、bql对象（oBql）、html元素解析对象（oHtmlparser）、加密对象（oCrypto）。云函数想要调用这些对象时，只需要用如下的方法即可获取：\n\n\n  //获取数据库对象\n  var db = modules.oData;\n  //下面进行其他操作\n\n\n\n\n用云函数实现\"helleworld\"\n\n\n下面用云函数输出一个经典的\"helleworld\"程序，让开发者对编写云函数有个初步的了解。\n\n\n输出\"helleworld\"的云函数如下：\n\n\nfunction onRequest(request, response, modules) {\n    response.end(\nthis is hello world\n);  //返回字符串\nthis is hello world\n\n}                         \n\n\n\n\n在\"helloworld\"的云函数编辑界面上输入上面的代码，按下“保存”按钮就能把编辑完毕的代码保存在云端，如下图11所示：\n\n\n\n\n怎么运行上面编辑完毕云函数呢？bmob在每个云函数的编辑界面下方提供了一个方便的调试工具，如下图12所示：\n\n\n\n\n这个工具有下面的功能：\n\n\n\n\n可选择以http \"post\"或者\"get\"的方法运行云函数。\n\n\n选择request的参数和对应值：可添加传入云函数的request的参数和对应值，参数的数目可以通过“再添加一个”按钮调整。\n\n\n\n\n需要运行名称为\"helloworld\"的云函数，在\"helloworld\"的云函数编辑界面下点击“发送请求”按钮，就能在调试工具上看到云函数返回的字符串“this is hello world”，如下图13所示：\n\n\n\n\n整个云函数的执行流程如图13.1所示：\n\n\n\n\n调用云函数的方式\n\n\n除了使用bmob提供的云函数调式工具外，bmob允许开发者以http的方式直接调用云函数。\n\n\n获取Secret Key\n\n\n用户需要以http的方式运行云函数，需要先确定应用的Secret Key。 调用云函数时，通过Secret Key标识一个应用，获取Secret Key的路径：\n管理后台-\n应用密钥-\nSecret Key, 如下图14所示：\n\n\n\n\n注意：请妥善保管Secret Key，避免Secret Key的泄露！！！\n\n\n以Get的方式调用云函数\n\n\n下面展示了以Get的方式调用云函数，在浏览器中输入下面的url：\n\n\nhttp://cloudweixinopen.bmob.cn/a12af19a1b8bf434/helloworld\n\n\n\n\n其中：\n\n\n\n\na12af19a1b8bf434：应用的Secret Key。\n\n\nhelloworld：云函数的名称\n\n\n\n\n看到云函数的返回结果如下图15所示：\n\n\n\n\n以Post的方式调用云函数\n\n\n下面通过curl工具展示了以Post的方式调用云函数：\n\n\ncurl -X POST \\\n    http://cloudweixinopen.bmob.cn/a12af19a1b8bf434/helloworld\n\n\n\n\n其中：\n\n\n\n\na12af19a1b8bf434：应用的Secret Key。\n\n\nhelloworld：云函数的名称\n\n\n\n\n云函数操作数据库初步入门\n\n\nbmob提供了数据库对象（oData）用于操作数据。\n\n\n用云函数往数据表“message”插入一条数据，可用如下的代码\n\n\nfunction onRequest(request, response, modules) {\n    //获取数据库对象\n    var db = modules.oData;\n    db.insert({\n      \ntable\n:\nmessage\n,             //表名\n      \ndata\n:{\nuserId\n:\ndsfd2324\n,\ncontent\n:\n插入的第一条信息\n}            //需要插入的数据，格式为JSON\n    },function(err,data){         //回调函数\n        response.end(\nsuccess\n);  //运行完毕后返回“success”\n    });\n}                         \n\n\n\n\n点击保存后在云函数调试区按“发送请求”，返回“success”的值，如下图16所示：\n\n\n\n\n在管理后台-\n数据浏览-\n应用表“message”下查看通过云函数新增的数据，如下图17所示：\n\n\n\n\n用云函数查询表“message”的所有数据，可用如下的代码：\n\n\nfunction onRequest(request, response, modules) {\n    //获取数据库对象\n    var db = modules.oData;\n    db.find({\n      \ntable\n:\nmessage\n             //表名\n    },function(err,data){         //回调函数\n        response.end(data);       //data为返回的数据，格式为json\n    });\n}                                                 \n\n\n\n\n点击保存后在云函数调试区按“发送请求”，返回表“message”的数据，如下图18所示：\n\n\n\n\n需要了解更多云函数的操作，可阅读\nhttp://docs.bmob.cn/cloudcode/WEB/a_faststart/doc/index.html\n\n\n在编写云函数时有个注意事项：云函数是使用异步编程。也就是说，当遇到文件读写请求，网络请求等IO操作时，代码不等待IO操作返回结果就执行后面的语句,当接收到IO操作的返回结果后才调用回调函数。\n\n\n当使用php，java等非异步编程语言时，如果需要插入数据后再查找数据，可用类似下面的代码：\n\n\n    db-\ninsert(xxxxx);\n    db-\nfind(xxxxx);                                                 \n\n\n\n\n在同步型的编程语言中，find和insert都是数据库的操作，有文件读写的IO操作，在db-\nfind执行前，能确保db-\ninsert已经执行完毕了。\n\n\n在异步编程中，用类似下面的代码才能保证执行完db.insert后才执行：\n\n\n    db.insert({xxx},function(xxx){\n        db.find({xxx},function(xxx){xxxx});\n    });\n\n\n\n\n\n只有通过在db.insert的回调函数中执行db.find，才能保证执行db.find前db.insert的数据库操作已经完成。\n\n\n举个生活中的例子说明异步编程。在饭馆里，服务员接待客人一般是这样的：\n\n\n\n\n服务员指引客人就座，把菜单递给客人，在客人浏览菜单时服务员在旁边一直等待，当客户点菜后，服务员把订单交给厨房后继续干别的事情。\n\n\n\n\n采用异步模式的服务员可以这样接待客人：\n\n\n\n\n服务员指引客人就座，把菜单递给客人，在客人浏览菜单时服务员就去干别的事情。当客户决定点菜后，客人把服务员招来，服务员把客人下的订单交给厨房后继续干别的事情。\n\n\n\n\n在服务员接待客人的行为中，通过比较普通的做法和异步的做法，能发现采用异步的方法后服务员的效率大大提高，云函数使用异步也是基于同样的理由，当云函数在等待IO操作（文件读写请求，网络请求）的结果时是一直空闲，如果不等待IO的结果继续执行下面的语句，能大大提高系统的效率。\n\n\n在云函数异步编程中“function(xxx){xxxx}”部分称为回调函数，云函数会把IO操作的返回结果封装后传入到function函数执行里面的逻辑。\n\n\n    db.insert({xxx},function(xxx){xxxx});                            \n\n\n\n\n微信公众平台的开发\n\n\n在本节中，通过bmob云函数开发微信公众平台，实现一个反馈意见收集的功能：\n1.把订阅者发送到公众号后台的反馈意见存储在上一节在bmob中创建的表“message”中。\n2.订阅者提交反馈意见后，公众号自动给订阅者发送消息，表示消息已收到。\n\n\n创建云函数\n\n\n创建一个名为\"feedback\"的云函数用于实现上面的功能，代码如下：\n\n\n\nfunction onRequest(request, response, modules) {\n    var token = \nweixin\n;         //这里的值必须与在微信公众号后台填入的token值一致\n    var crypto = modules.oCrypto; //使用加解密模块\n    var httptype = modules.oHttptype;　//获取调用云函数的是post或者get方式\n    var xml2js = modules.oXml2js;　//实现xml和js格式之间的相互转换\n    var db = modules.oData;         //数据库对象\n    if (\nget\n == httptype) {\n        　//是get方法,则是微信验证回调的url是否有效\n          var oriStr = [token, request.query.timestamp, request.query.nonce].sort().join('')\n          var code = crypto.createHash('sha1').update(oriStr).digest('hex');\n          if (code == request.query.signature) {　//验证通过，输出\n              response.end(request.query.echostr);\n          } else {\n              response.end(\nUnauthorized\n);\n          }\n    } else {\n           //是post,接收定阅者发送过来的消息后返回，把反馈意见存储表“message”中。\n            db.insert({\n              \ntable\n:\nmessage\n,             //表名\n              \ndata\n:{\nuserId\n:request.body.xml.FromUserName,\ncontent\n:request.body.xml.Content}           \n            },function(err,data){                        \n              //构造公众号后台所需要的xml格式，并返回给公众号后台  \n               var result = {\n                    xml: {\n                      ToUserName: request.body.xml.FromUserName,\n                      FromUserName: request.body.xml.ToUserName ,\n                      CreateTime: new Date().getTime(),\n                      MsgType: 'text',\n                      Content: '你好，你发送的反馈内容「' + request.body.xml.Content + '」已收到。'\n                    }\n                }\n                var builder = new xml2js.Builder();\n                var xml = builder.buildObject(result); //利用模块xml2js，把json对象转换为一个xml文本\n                response.set('Content-Type', 'text/xml'); //设置返回的http header\n                response.end(xml);\n            });\n\n\n\n    }\n}                                                                         \n\n\n\n\n\n这个云函数的内容暂时看不懂没关系，下面会逐渐解释其中的含义。\n\n\n启用微信公众号的开发模式\n\n\n只有启用微信公众号的开发模式后，才能把订阅者发送到微信公众号后台的消息发送到bmob云函数中进行处理。\n\n\n微信公众平台地址：\nhttps://mp.weixin.qq.com \n\n\n登录微信公众平台后台，在左侧列表中最下方，找到“开发者中心”，点击进入，如图19所示：\n\n\n\n\n进入服云函数务器配置填写框，如图20所示：\n\n\n\n\n点击“修改配置”按钮，如图21所示：\n\n\n\n\n此处的URL（http://cloudweixinopen.bmob.cn/a12af19a1b8bf434/feedback）为上节中生成的云函数“feedback”的调用，按照云函数的调用规格，a12af19a1b8bf434为该应用的Secret Key，标明调用的是哪个应用，feedback为云函数的名称。Token定义为weixin。EncodingAESKey则不用填，点击“随机生成”让自动生成一个，消息加解密方式选择“明文模式”，然后点击“提交”按钮，如图22所示：\n\n\n\n\n在弹出框中点击确定，如图24所示：\n\n\n\n\n成功启用后如图25所示：\n\n\n\n\n恭喜，你成功启用开发模式。\n\n\n用户往该公众号发送消息后，用户收到的反馈内容如图27所示：\n\n\n\n\n查看应用的后台，可看到接收的消息已存储在表message中，如图28所示：\n\n\n\n\n数据收发原理及消息数据格式\n\n\n云函数开发微信公众号有两个重要原理一定要弄明白：\n\n\n\n\n变为开发模式时，微信公众号后台往配置的url发送校验请求，这个过程云函数校验信息的原理。\n\n\n云函数收发微信公众号后台传递过来的消息的原理。\n\n\n\n\n变为开发模式时的消息校验原理\n\n\n在开发者首次提交验证申请时，微信公众号后台将发送GET请求到填写的URL上，并且带上四个参数（signature、timestamp、nonce、echostr），开发者通过对签名（signature）的效验来判断此条消息的真实性。\n\n\n这4个参数的含义如下：\n\n\n\n\nsignature：微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。\n\n\ntimestamp：时间戳。\n\n\nnonce：随机数\n\n\nechostr：随机字符串\n\n\n\n\n此后，每次开发者接收用户消息的时候，微信公众号后台也都会带上前面三个参数（signature、timestamp、nonce）访问开发者设置的URL，开发者依然通过对签名的效验判断此条消息的真实性。效验方式与首次提交验证申请一致。\n\n\n开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信公众号后台，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。\n\n\n消息校验流程如下：\n\n\n\n\n将token、timestamp、nonce三个参数进行字典序排序。\n\n\n将三个参数字符串拼接成一个字符串进行sha1加密。\n\n\n开发者获得加密后的字符串可与signature对比，标识该请求来源于微信。\n\n\n\n\n整个流程如图26所示：\n\n\n\n\n使用的云函数如下：\n\n\n        　//是get方法,则是微信验证回调的url是否有效\n          var oriStr = [token, request.query.timestamp, request.query.nonce].sort().join('')\n          var code = crypto.createHash('sha1').update(oriStr).digest('hex');\n          if (code == request.query.signature) {　//验证通过，输出\n              response.end(request.query.echostr);\n          } else {\n              response.end(\nUnauthorized\n);\n          }\n\n\n\n\n其中token的值是在微信公众号后台填入的token值：“weixin”。\n\n\n在这个校验流程的云函数中，使用oCrypto这个云函数的加密对象模块，提供md5和sha1两种加密算法。通过这个模块，按照微信校验的流程完成校验。oCrypto更多的功能详细参考：https://www.npmjs.org/package/crypto\n\n\n另外，云函数使用了oHttptype模块获取当前的http调用方式。因为微信公众平台调用云函数有两种方式：\n\n\n\n\nget方式，用于检验。\n\n\npost方式，用于转发订阅者往公众平台发送的消息。\n\n\n\n\n通过oHttptype模块得知是用采用get方式调用云函数，运行校验的代码并返回echostr参数。\n\n\n云函数收发微信公众号后台传递过来的消息的原理\n\n\n在上一节的演示中，订阅者往该公众号发送消息后，返回已收到反馈内容的消息。\n\n\n这一原理的消息流程如图29所示：\n\n\n\n\n云函数内部通过下面的代码处理用户发送的消息：\n\n\n           //是post,接收定阅者发送过来的消息后返回，把反馈意见存储表“message”中。\n            db.insert({\n              \ntable\n:\nmessage\n,             //表名\n              \ndata\n:{\nuserId\n:request.body.xml.FromUserName,\ncontent\n:request.body.xml.Content}           \n            },function(err,data){         \n              //构造公众号后台所需要的xml格式，并返回给公众号后台  \n               var result = {\n                    xml: {\n                      ToUserName: request.body.xml.FromUserName,\n                      FromUserName: request.body.xml.ToUserName ,\n                      CreateTime: new Date().getTime(),\n                      MsgType: 'text',\n                      Content: '你好，你发送的反馈内容「' + request.body.xml.Content + '」已收到。'\n                    }\n                }\n                var builder = new xml2js.Builder();\n                var xml = builder.buildObject(result); //利用模块xml2js，把json对象转换为一个xml文本\n                response.set('Content-Type', 'text/xml'); //设置返回的http header\n                response.end(xml);\n            });\n\n\n\n\n从上图可以看出，用户在发送一个文本后，微信公众号后台将组装一个xml消息发送给云函数服务器。当云函数接收到http头部Content-Type为text/xml的请求后，云函数自动把xml消息转换为一个对象放在request.body.xml中，通过获取request.body.xml对应的属性就能获取xml节点的值。\n\n\n云函数解析xml对象，根据节点信息，把发送者(request.body.xml.FromUserName)和消息内容（request.body.xml.Content）存储在表“message”后，然后通过一定的规则组装成一个xml文本回复给微信公众号后台，微信公众号后台再回复给用户。在这个收发过程中，发送方和接收方进行了调换(ToUserName和FromUserName值互换)，收发都是以xml格式在后台进行传输的。所以掌握各种消息类型的接收回复是进行微信公众平台开发的基础！\n\n\n最常见的消息类型为文本的xml格式如下：\n\n\nxml\n\n\nToUserName\n![CDATA[gh_b36303ca8941]]\n/ToUserName\n\n\nFromUserName\n![CDATA[oqwUds6-SG7L8t6ZBDexZvaRWnXM]]\n/FromUserName\n\n\nCreateTime\n1444464955\n/CreateTime\n\n\nMsgType\n![CDATA[text]]\n/MsgType\n\n\nContent\n![CDATA[这个公众号不错]]\n/Content\n\n\nMsgId\n6203929742163889773\n/MsgId\n\n\n/xml\n                                           \n\n\n\n\nXML格式讲解：\n\n\n\n\nToUserName 消息接收方微信号，一般为公众平台账号微信号\n\n\nFromUserName 消息发送方微信号\n\n\nCreateTime 消息创建时间\n\n\nMsgType 消息类型；文本消息为text\n\n\nContent 消息内容\n\n\nMsgId 消息ID号\n\n\n\n\n各种类型的消息详解，请查看微信开发文档：\nhttp://mp.weixin.qq.com/wiki/14/89b871b5466b19b3efa4ada8e577d45e.html\n\n\n总结\n\n\n通过本教程，你得到了以下收获：\n\n\n\n\n了解bmob应用和云函数的功能。\n\n\n在不需要搭建服务器，不需要懂得基本的运维知识下，使用bmob云函数在30分钟内实现微信公众平台的开发，完了消息存储和消息自动回复这两个功能。\n\n\n\n\n阅读本教程后，想了解云后端服务bmob可以实现哪些更酷的功能吗？点击\nhttp://www.bmob.cn\n，立刻进入bmob了解更多。", 
            "title": "微信云函数"
        }, 
        {
            "location": "/cloud_function/web/weixin/#_1", 
            "text": "在这篇微信公众平台开发教程中，将会带领你一步步领略使用云后端服务bmob的方便性，同时使用bmob进行微信公众号平台开发。  注意：升级云函数套餐后就没法在微信公众号中调用云函数  使用bmob有什么好处，下面一一为你道来：   不需要购买服务器，不需要懂linux，不需要懂运维知识，零成本地拥有属于自己的后台系统。  不在需要mysql，轻松存储和获取数据，同时提供了一个方便的数据管理后台。  提供灵活的“云函数”，其融合了bmob的数据服务和大量的第三方服务，让你轻松应对复杂的业务逻辑。同时云函数能被第三方平台调用，再也不需要php，java等复杂的web服务。   本教程将引导你完成如下任务：   创建bmob应用  使用bmob云函数实现微信公众平台的开发", 
            "title": "简介"
        }, 
        {
            "location": "/cloud_function/web/weixin/#bmob", 
            "text": "在这节中，将会从基本的创建bmob账号开始，到创建应用，数据的基本操作，到云函数的运行，使读者对bmob的功能有初步的了解。  在这个教程中，用到了bmob的两个功能：    数据存储：把订阅者发到微信公众号的信息存储起来。    云函数：微信后台回调云函数后，完成公众号所需的业务逻辑：信息存储，把信息加工后返回给订阅者的微信。", 
            "title": "创建bmob应用"
        }, 
        {
            "location": "/cloud_function/web/weixin/#bmob_1", 
            "text": "在网址栏输入 www.bmob.cn 或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，如下图1所示：   注册成功，到注册所填入的邮箱查看bmob发送的邮件，点击其中激活链接后，就能使用邮箱和密码登录bmob。", 
            "title": "注册bmob账号"
        }, 
        {
            "location": "/cloud_function/web/weixin/#_2", 
            "text": "登录后，点击“我的控制台”，进入到了管理后台，如下图2所示：  在bmob中，一个用户可以创建多个应用，每个应用拥有其所属的专用数据库，多个应用之间相互独立。  用户需要创建一个应用，先点击管理后台中的“创建应用”按钮，如下图3所示：   在创建应用的输入框中输入app的名称，点击“创建应用”，就能成功创建应用，如下图4所示：", 
            "title": "创建应用"
        }, 
        {
            "location": "/cloud_function/web/weixin/#_3", 
            "text": "创建应用成功后，开发者在管理后台点击刚才创建的应用，进入到应用的后台界面，其中最常用的是“数据浏览界面”，在该界面提供了便利的图形化操作，让开发者轻松地对该应用所属的数据库进行表的增删，数据的增删改查等操作，如下图5所示：   每个应用的数据库都有一个默认的表\"_User\",其提供了一些常用的字段来记录该应用的用户信息。  开发者需要增加新的表来存储信息时，点击“添加表”按钮，输入表名，就能创建一张新表，如下图6所示：   在\"添加新的表\"界面中,选项“自定义”选项即可创建一张新的普通表，另外两个选项是较高级的功能，在本教程中暂时不需要用到。  在这里，创建了一张名为\"message\"的表，用于存储订阅者发送到公众号后台的信息。  在表\"message\"的操作界面中可看到，表\"message\"有4个默认的字段，其中3个最常用字段的含义如下：   objectId：该行的id，objectId的作用和mysql中的经常使用的id类似，用于唯一标示一行。  createdAt：改行数据的创建时间。  updatedAt：改行数据的最后修改时间。   当操作一行数据的时候，以上的3个字段的值由bmob后台自动管理。另外这些字段的名字是保留的，你不能自行设置它们。  由于表\"message\"是需要把订阅者发到微信公众号的信息存储起来，存储信息的两个属性：谁发送这条信息，信息的内容，所以添加下面所需的字段：  userId：订阅者的id，String类型。\ncontent：发送的内容，String。  通过图8的“添加一列”功能，依次把userId和content这两个字段添加到表\"message\"中。   注意：在用云函数添加数据时，如果发现其所操作的表和所操作的列不存，bmob后台会自动创建。这里为了演示bmob的数据浏览操作，所以才手动创建一次。", 
            "title": "数据的基本操作"
        }, 
        {
            "location": "/cloud_function/web/weixin/#_4", 
            "text": "阅读了上面的“数据的基本操作”的内容后，读者可能有个疑问，怎么对表的数据进行增删改查等操作呢？除了可以在\"数据浏览\"界面可以进行操作外，也可以通过云函数进行数据的增删改查，开发者也可以通过云函数完成更加复杂的业务逻辑。", 
            "title": "云函数"
        }, 
        {
            "location": "/cloud_function/web/weixin/#_5", 
            "text": "对于一些复杂的应用，您可能希望增加一些特有的业务逻辑，并能灵活掌控，Bmob 云函数提供了这种灵活性，可以让您的代码直接在 Bmob云上运行, 通过SDK（Android，iOS），restful api或者任何http的方式调用，即可获取结果数据。  云函数的编码采用nodejs语法，简单易用。在云函数的编辑器中，系统默认生成了云函数的入口函数function onRequest(request, response, modules)，你可以根据自己的需求实现业务逻辑代码。   在云函数界面，创建一个名为\"helloworld\"的云函数，如下图9所示：   生成云函数后，可看到云函数生成的入口方法，如下图10所示：   开发者按照云函数的相关语法和提供的模块编写云函数，就能实现各种业务逻辑。  从云函数的入口方法function onRequest(request, response, modules)可知，云函数包含三个模块，分别是request模块、response模块和modules模块。", 
            "title": "云函数的基本知识"
        }, 
        {
            "location": "/cloud_function/web/weixin/#request", 
            "text": "request模块用于获取传入的参数。由于现在调用云函数有两种方式（get和post），所以获取传入的参数的方式需要使用不同的方法。  当用get请求的方式传入参数，可用如下的方法获取参数的值：  request.query.name  //获取传入参数name的值  当用post请求的方式传入参数，可用如下的方法获取参数的值：  request.body.name  //获取传入参数name的值", 
            "title": "request模块"
        }, 
        {
            "location": "/cloud_function/web/weixin/#response", 
            "text": "response为云函数的信息回传模块，该模块包含了一个end方法，实现将云端的执行结果（如查询的数据）返回给SDK或者RestApi等调用端：  response.end(string result)", 
            "title": "response模块"
        }, 
        {
            "location": "/cloud_function/web/weixin/#modules", 
            "text": "modules是Bmob云函数提供给大家的各种对象处理的模块，包括数据库对象（oData）、文件对象（oFile）、地理位置对象（oLocation）、关联关系对象（oRelation）、原子操作对象（oAtom）、数据批量操作对象（oBatch）、数组对象（oArray）、消息推送对象（oPush）、云函数对象（oFunctions）、邮件发送对象（oMail）、同步对象（oAsync）、HTTP对象（oHttp）、字符编码转换对象（oEncodeing）、事件对象（oEvent）、bql对象（oBql）、html元素解析对象（oHtmlparser）、加密对象（oCrypto）。云函数想要调用这些对象时，只需要用如下的方法即可获取：    //获取数据库对象\n  var db = modules.oData;\n  //下面进行其他操作", 
            "title": "modules模块"
        }, 
        {
            "location": "/cloud_function/web/weixin/#helleworld", 
            "text": "下面用云函数输出一个经典的\"helleworld\"程序，让开发者对编写云函数有个初步的了解。  输出\"helleworld\"的云函数如下：  function onRequest(request, response, modules) {\n    response.end( this is hello world );  //返回字符串 this is hello world \n}                           在\"helloworld\"的云函数编辑界面上输入上面的代码，按下“保存”按钮就能把编辑完毕的代码保存在云端，如下图11所示：   怎么运行上面编辑完毕云函数呢？bmob在每个云函数的编辑界面下方提供了一个方便的调试工具，如下图12所示：   这个工具有下面的功能：   可选择以http \"post\"或者\"get\"的方法运行云函数。  选择request的参数和对应值：可添加传入云函数的request的参数和对应值，参数的数目可以通过“再添加一个”按钮调整。   需要运行名称为\"helloworld\"的云函数，在\"helloworld\"的云函数编辑界面下点击“发送请求”按钮，就能在调试工具上看到云函数返回的字符串“this is hello world”，如下图13所示：   整个云函数的执行流程如图13.1所示：", 
            "title": "用云函数实现\"helleworld\""
        }, 
        {
            "location": "/cloud_function/web/weixin/#_6", 
            "text": "除了使用bmob提供的云函数调式工具外，bmob允许开发者以http的方式直接调用云函数。", 
            "title": "调用云函数的方式"
        }, 
        {
            "location": "/cloud_function/web/weixin/#secret-key", 
            "text": "用户需要以http的方式运行云函数，需要先确定应用的Secret Key。 调用云函数时，通过Secret Key标识一个应用，获取Secret Key的路径：\n管理后台- 应用密钥- Secret Key, 如下图14所示：   注意：请妥善保管Secret Key，避免Secret Key的泄露！！！", 
            "title": "获取Secret Key"
        }, 
        {
            "location": "/cloud_function/web/weixin/#get", 
            "text": "下面展示了以Get的方式调用云函数，在浏览器中输入下面的url：  http://cloudweixinopen.bmob.cn/a12af19a1b8bf434/helloworld  其中：   a12af19a1b8bf434：应用的Secret Key。  helloworld：云函数的名称   看到云函数的返回结果如下图15所示：", 
            "title": "以Get的方式调用云函数"
        }, 
        {
            "location": "/cloud_function/web/weixin/#post", 
            "text": "下面通过curl工具展示了以Post的方式调用云函数：  curl -X POST \\\n    http://cloudweixinopen.bmob.cn/a12af19a1b8bf434/helloworld  其中：   a12af19a1b8bf434：应用的Secret Key。  helloworld：云函数的名称", 
            "title": "以Post的方式调用云函数"
        }, 
        {
            "location": "/cloud_function/web/weixin/#_7", 
            "text": "bmob提供了数据库对象（oData）用于操作数据。  用云函数往数据表“message”插入一条数据，可用如下的代码  function onRequest(request, response, modules) {\n    //获取数据库对象\n    var db = modules.oData;\n    db.insert({\n       table : message ,             //表名\n       data :{ userId : dsfd2324 , content : 插入的第一条信息 }            //需要插入的数据，格式为JSON\n    },function(err,data){         //回调函数\n        response.end( success );  //运行完毕后返回“success”\n    });\n}                           点击保存后在云函数调试区按“发送请求”，返回“success”的值，如下图16所示：   在管理后台- 数据浏览- 应用表“message”下查看通过云函数新增的数据，如下图17所示：   用云函数查询表“message”的所有数据，可用如下的代码：  function onRequest(request, response, modules) {\n    //获取数据库对象\n    var db = modules.oData;\n    db.find({\n       table : message              //表名\n    },function(err,data){         //回调函数\n        response.end(data);       //data为返回的数据，格式为json\n    });\n}                                                   点击保存后在云函数调试区按“发送请求”，返回表“message”的数据，如下图18所示：   需要了解更多云函数的操作，可阅读 http://docs.bmob.cn/cloudcode/WEB/a_faststart/doc/index.html  在编写云函数时有个注意事项：云函数是使用异步编程。也就是说，当遇到文件读写请求，网络请求等IO操作时，代码不等待IO操作返回结果就执行后面的语句,当接收到IO操作的返回结果后才调用回调函数。  当使用php，java等非异步编程语言时，如果需要插入数据后再查找数据，可用类似下面的代码：      db- insert(xxxxx);\n    db- find(xxxxx);                                                   在同步型的编程语言中，find和insert都是数据库的操作，有文件读写的IO操作，在db- find执行前，能确保db- insert已经执行完毕了。  在异步编程中，用类似下面的代码才能保证执行完db.insert后才执行：      db.insert({xxx},function(xxx){\n        db.find({xxx},function(xxx){xxxx});\n    });  只有通过在db.insert的回调函数中执行db.find，才能保证执行db.find前db.insert的数据库操作已经完成。  举个生活中的例子说明异步编程。在饭馆里，服务员接待客人一般是这样的：   服务员指引客人就座，把菜单递给客人，在客人浏览菜单时服务员在旁边一直等待，当客户点菜后，服务员把订单交给厨房后继续干别的事情。   采用异步模式的服务员可以这样接待客人：   服务员指引客人就座，把菜单递给客人，在客人浏览菜单时服务员就去干别的事情。当客户决定点菜后，客人把服务员招来，服务员把客人下的订单交给厨房后继续干别的事情。   在服务员接待客人的行为中，通过比较普通的做法和异步的做法，能发现采用异步的方法后服务员的效率大大提高，云函数使用异步也是基于同样的理由，当云函数在等待IO操作（文件读写请求，网络请求）的结果时是一直空闲，如果不等待IO的结果继续执行下面的语句，能大大提高系统的效率。  在云函数异步编程中“function(xxx){xxxx}”部分称为回调函数，云函数会把IO操作的返回结果封装后传入到function函数执行里面的逻辑。      db.insert({xxx},function(xxx){xxxx});", 
            "title": "云函数操作数据库初步入门"
        }, 
        {
            "location": "/cloud_function/web/weixin/#_8", 
            "text": "在本节中，通过bmob云函数开发微信公众平台，实现一个反馈意见收集的功能：\n1.把订阅者发送到公众号后台的反馈意见存储在上一节在bmob中创建的表“message”中。\n2.订阅者提交反馈意见后，公众号自动给订阅者发送消息，表示消息已收到。", 
            "title": "微信公众平台的开发"
        }, 
        {
            "location": "/cloud_function/web/weixin/#_9", 
            "text": "创建一个名为\"feedback\"的云函数用于实现上面的功能，代码如下：  \nfunction onRequest(request, response, modules) {\n    var token =  weixin ;         //这里的值必须与在微信公众号后台填入的token值一致\n    var crypto = modules.oCrypto; //使用加解密模块\n    var httptype = modules.oHttptype;　//获取调用云函数的是post或者get方式\n    var xml2js = modules.oXml2js;　//实现xml和js格式之间的相互转换\n    var db = modules.oData;         //数据库对象\n    if ( get  == httptype) {\n        　//是get方法,则是微信验证回调的url是否有效\n          var oriStr = [token, request.query.timestamp, request.query.nonce].sort().join('')\n          var code = crypto.createHash('sha1').update(oriStr).digest('hex');\n          if (code == request.query.signature) {　//验证通过，输出\n              response.end(request.query.echostr);\n          } else {\n              response.end( Unauthorized );\n          }\n    } else {\n           //是post,接收定阅者发送过来的消息后返回，把反馈意见存储表“message”中。\n            db.insert({\n               table : message ,             //表名\n               data :{ userId :request.body.xml.FromUserName, content :request.body.xml.Content}           \n            },function(err,data){                        \n              //构造公众号后台所需要的xml格式，并返回给公众号后台  \n               var result = {\n                    xml: {\n                      ToUserName: request.body.xml.FromUserName,\n                      FromUserName: request.body.xml.ToUserName ,\n                      CreateTime: new Date().getTime(),\n                      MsgType: 'text',\n                      Content: '你好，你发送的反馈内容「' + request.body.xml.Content + '」已收到。'\n                    }\n                }\n                var builder = new xml2js.Builder();\n                var xml = builder.buildObject(result); //利用模块xml2js，把json对象转换为一个xml文本\n                response.set('Content-Type', 'text/xml'); //设置返回的http header\n                response.end(xml);\n            });\n\n\n\n    }\n}                                                                           这个云函数的内容暂时看不懂没关系，下面会逐渐解释其中的含义。", 
            "title": "创建云函数"
        }, 
        {
            "location": "/cloud_function/web/weixin/#_10", 
            "text": "只有启用微信公众号的开发模式后，才能把订阅者发送到微信公众号后台的消息发送到bmob云函数中进行处理。  微信公众平台地址： https://mp.weixin.qq.com   登录微信公众平台后台，在左侧列表中最下方，找到“开发者中心”，点击进入，如图19所示：   进入服云函数务器配置填写框，如图20所示：   点击“修改配置”按钮，如图21所示：   此处的URL（http://cloudweixinopen.bmob.cn/a12af19a1b8bf434/feedback）为上节中生成的云函数“feedback”的调用，按照云函数的调用规格，a12af19a1b8bf434为该应用的Secret Key，标明调用的是哪个应用，feedback为云函数的名称。Token定义为weixin。EncodingAESKey则不用填，点击“随机生成”让自动生成一个，消息加解密方式选择“明文模式”，然后点击“提交”按钮，如图22所示：   在弹出框中点击确定，如图24所示：   成功启用后如图25所示：   恭喜，你成功启用开发模式。  用户往该公众号发送消息后，用户收到的反馈内容如图27所示：   查看应用的后台，可看到接收的消息已存储在表message中，如图28所示：", 
            "title": "启用微信公众号的开发模式"
        }, 
        {
            "location": "/cloud_function/web/weixin/#_11", 
            "text": "云函数开发微信公众号有两个重要原理一定要弄明白：   变为开发模式时，微信公众号后台往配置的url发送校验请求，这个过程云函数校验信息的原理。  云函数收发微信公众号后台传递过来的消息的原理。", 
            "title": "数据收发原理及消息数据格式"
        }, 
        {
            "location": "/cloud_function/web/weixin/#_12", 
            "text": "在开发者首次提交验证申请时，微信公众号后台将发送GET请求到填写的URL上，并且带上四个参数（signature、timestamp、nonce、echostr），开发者通过对签名（signature）的效验来判断此条消息的真实性。  这4个参数的含义如下：   signature：微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。  timestamp：时间戳。  nonce：随机数  echostr：随机字符串   此后，每次开发者接收用户消息的时候，微信公众号后台也都会带上前面三个参数（signature、timestamp、nonce）访问开发者设置的URL，开发者依然通过对签名的效验判断此条消息的真实性。效验方式与首次提交验证申请一致。  开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信公众号后台，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。  消息校验流程如下：   将token、timestamp、nonce三个参数进行字典序排序。  将三个参数字符串拼接成一个字符串进行sha1加密。  开发者获得加密后的字符串可与signature对比，标识该请求来源于微信。   整个流程如图26所示：   使用的云函数如下：          　//是get方法,则是微信验证回调的url是否有效\n          var oriStr = [token, request.query.timestamp, request.query.nonce].sort().join('')\n          var code = crypto.createHash('sha1').update(oriStr).digest('hex');\n          if (code == request.query.signature) {　//验证通过，输出\n              response.end(request.query.echostr);\n          } else {\n              response.end( Unauthorized );\n          }  其中token的值是在微信公众号后台填入的token值：“weixin”。  在这个校验流程的云函数中，使用oCrypto这个云函数的加密对象模块，提供md5和sha1两种加密算法。通过这个模块，按照微信校验的流程完成校验。oCrypto更多的功能详细参考：https://www.npmjs.org/package/crypto  另外，云函数使用了oHttptype模块获取当前的http调用方式。因为微信公众平台调用云函数有两种方式：   get方式，用于检验。  post方式，用于转发订阅者往公众平台发送的消息。   通过oHttptype模块得知是用采用get方式调用云函数，运行校验的代码并返回echostr参数。", 
            "title": "变为开发模式时的消息校验原理"
        }, 
        {
            "location": "/cloud_function/web/weixin/#_13", 
            "text": "在上一节的演示中，订阅者往该公众号发送消息后，返回已收到反馈内容的消息。  这一原理的消息流程如图29所示：   云函数内部通过下面的代码处理用户发送的消息：             //是post,接收定阅者发送过来的消息后返回，把反馈意见存储表“message”中。\n            db.insert({\n               table : message ,             //表名\n               data :{ userId :request.body.xml.FromUserName, content :request.body.xml.Content}           \n            },function(err,data){         \n              //构造公众号后台所需要的xml格式，并返回给公众号后台  \n               var result = {\n                    xml: {\n                      ToUserName: request.body.xml.FromUserName,\n                      FromUserName: request.body.xml.ToUserName ,\n                      CreateTime: new Date().getTime(),\n                      MsgType: 'text',\n                      Content: '你好，你发送的反馈内容「' + request.body.xml.Content + '」已收到。'\n                    }\n                }\n                var builder = new xml2js.Builder();\n                var xml = builder.buildObject(result); //利用模块xml2js，把json对象转换为一个xml文本\n                response.set('Content-Type', 'text/xml'); //设置返回的http header\n                response.end(xml);\n            });  从上图可以看出，用户在发送一个文本后，微信公众号后台将组装一个xml消息发送给云函数服务器。当云函数接收到http头部Content-Type为text/xml的请求后，云函数自动把xml消息转换为一个对象放在request.body.xml中，通过获取request.body.xml对应的属性就能获取xml节点的值。  云函数解析xml对象，根据节点信息，把发送者(request.body.xml.FromUserName)和消息内容（request.body.xml.Content）存储在表“message”后，然后通过一定的规则组装成一个xml文本回复给微信公众号后台，微信公众号后台再回复给用户。在这个收发过程中，发送方和接收方进行了调换(ToUserName和FromUserName值互换)，收发都是以xml格式在后台进行传输的。所以掌握各种消息类型的接收回复是进行微信公众平台开发的基础！  最常见的消息类型为文本的xml格式如下：  xml  ToUserName ![CDATA[gh_b36303ca8941]] /ToUserName  FromUserName ![CDATA[oqwUds6-SG7L8t6ZBDexZvaRWnXM]] /FromUserName  CreateTime 1444464955 /CreateTime  MsgType ![CDATA[text]] /MsgType  Content ![CDATA[这个公众号不错]] /Content  MsgId 6203929742163889773 /MsgId  /xml                                              XML格式讲解：   ToUserName 消息接收方微信号，一般为公众平台账号微信号  FromUserName 消息发送方微信号  CreateTime 消息创建时间  MsgType 消息类型；文本消息为text  Content 消息内容  MsgId 消息ID号   各种类型的消息详解，请查看微信开发文档： http://mp.weixin.qq.com/wiki/14/89b871b5466b19b3efa4ada8e577d45e.html", 
            "title": "云函数收发微信公众号后台传递过来的消息的原理"
        }, 
        {
            "location": "/cloud_function/web/weixin/#_14", 
            "text": "通过本教程，你得到了以下收获：   了解bmob应用和云函数的功能。  在不需要搭建服务器，不需要懂得基本的运维知识下，使用bmob云函数在30分钟内实现微信公众平台的开发，完了消息存储和消息自动回复这两个功能。   阅读本教程后，想了解云后端服务bmob可以实现哪些更酷的功能吗？点击 http://www.bmob.cn ，立刻进入bmob了解更多。", 
            "title": "总结"
        }, 
        {
            "location": "/cloud_function/web/norm/", 
            "text": "好的编码规范是攻城师们要遵循的法则，Bmob云函数希望大家能够养成良好的编码规范。Nodejs的编码规范与其他语言稍微有所不同，这里列举有所区别的地方。\n\n\n关于缩进\n\n\n缩进，2个space，tab要转为2 space。这是Nodejs源码和module采用的标准，希望大家入乡随俗。\n\n\n关于空格\n\n\nfunction关键词和函数名之间有一个空格；调用函数时，函数名和左括号之间没有空格。\n\n\n// 正确\nfunction foo(bar) {...}\nfoo(bar);\nfoo(function callback(err, data) {...});\nfoo(function (err, data) {...});\n\n// 错误\nfunction foo (bar) {...}\nfoo (bar);\nfoo(function callback (err, data) {...});\nfoo(function(err, data) {...});\n\n\n\n\n所有其他语法元素与左括号之间，都有一个空格。\n\n\n// 正确\nreturn (a + b);\nif (a === 0) {...}\nfor (var k in map) {...}\nwhile (i \n 0) {...}\n\n// 错误\nreturn(a + b);\nif(a === 0) {...}\nfor(var k in map) {...}\nwhile(i \n 0) {...}\n\n\n\n\n操作符号与参数之间有一个空格；能提高阅读性的空格不能省略。\n\n\n// 正确\nvar a = 1 + 2;\nfor (var i = 0, l = items.length; i \n l; i++) {...}\n\n//错误\nvar a=1+2;\nfor(var i=0,l=items.length;i\nl;i++){...}\n\n\n\n\n关于命名\n\n\n好的变量与函数命名，可以避免大量的注释。Nodejs推荐使用驼峰式命名：\n\n\n函数和变量：functionNamesLikeThis, variableNamesLikeThis\n类名和枚举类型：ClassNamesLikeThis, EnumNamesLikeThis\n类方法：methodNamesLikeThis\n常量：SYMBOLIC_CONSTANTS_LIKE_THIS\n\n\n\n关于双等号\n\n\n开发的时候大家请慎重使用==号，有时候结果未必会是您想的那样，请看下面的调试计算结果：\n\n\n 0 == ''\ntrue\n\n 1 == true\ntrue\n\n 2 == true\nfalse\n\n 0 == '0'\ntrue\n\n false == 'false'\nfalse\n\n false == '0'\ntrue\n\n \" \\t\\r\\n \" == 0\ntrue\n\n\n\n关于双引号\n\n\n使用string时，用单引号替代双引号（写JSON时除外）。\n\n\n//正确\nvar foo = 'bar';\n\n//错误\nvar foo = \nbar\n;\n\n\n\n\n关于大括号位置\n\n\n//正确\nif (true) {\n  response.end('winning');\n}\n//错误\nif (true)\n{\n  response.end ('losing');\n}\n\n\n\n\n关于字面表达式的问题\n\n\n使用字面表达式，用 '{}' ,'[]' 代替 new Array ，new Object，不要使用 string，bool，number 的对象类型，即不要调用 new String ，new Boolean ，new Number。 \n\n\nObject和Array创建时的逗号问题\n\n\nObject ，Array 创建，当有多个元素时，注意分行排列时逗号的位置。\n\n\n//正确\nvar a = ['hello', 'world'];\nvar b = {\n  good: 'code',\n  'is generally': 'pretty',\n};\n\n//错误\nvar a = [\n  'hello', 'world'\n];\nvar b = {\ngood\n: 'code'\n  , is generally: 'pretty'\n};\n\n\n\n\n避免使用with与eval\n\n\n关于for-in循环\n\n\nfor-in 循环，仅在 object/hash/map 时使用，绝不要对Array 使用。\n\n\n关于Array数组的问题\n\n\n不要把Array 当做关联数组或Object 使用,即你不应该用非数字作为Array 的索引（有PHP开发经验的朋友尤其注意这点）。\n\n\n//正确\nvar a = {};\na.hello = 'shit';\na.foo = 'bar';\n\n//错误\nvar a = []; // use '{}' instead\na['hello'] = 'shit';\na['foo'] = 'bar';\n\n\n\n\n关于变量声明\n\n\n变量声明时，应该每行声明一个，不应该都写在一行。\n\n\n//正确\nvar name = 'bmob';\nvar website = 'www.bmob.cn';\n\n//错误\nvar name = 'bmob'\n  ,website = 'www.bmob.cn'; \n\n\n\n\n注释规范\n\n\n注释的规范如下所示：\n\n\n/**\n * 获取文章列表\n * @param {number} num 文章数量.\n * @param {string|date|null} dateTime 发布时间.\n */\nvar getPosts = function (num, dateTime) {\n  // ...\n};", 
            "title": "编码规范"
        }, 
        {
            "location": "/cloud_function/web/norm/#_1", 
            "text": "缩进，2个space，tab要转为2 space。这是Nodejs源码和module采用的标准，希望大家入乡随俗。", 
            "title": "关于缩进"
        }, 
        {
            "location": "/cloud_function/web/norm/#_2", 
            "text": "function关键词和函数名之间有一个空格；调用函数时，函数名和左括号之间没有空格。  // 正确\nfunction foo(bar) {...}\nfoo(bar);\nfoo(function callback(err, data) {...});\nfoo(function (err, data) {...});\n\n// 错误\nfunction foo (bar) {...}\nfoo (bar);\nfoo(function callback (err, data) {...});\nfoo(function(err, data) {...});  所有其他语法元素与左括号之间，都有一个空格。  // 正确\nreturn (a + b);\nif (a === 0) {...}\nfor (var k in map) {...}\nwhile (i   0) {...}\n\n// 错误\nreturn(a + b);\nif(a === 0) {...}\nfor(var k in map) {...}\nwhile(i   0) {...}  操作符号与参数之间有一个空格；能提高阅读性的空格不能省略。  // 正确\nvar a = 1 + 2;\nfor (var i = 0, l = items.length; i   l; i++) {...}\n\n//错误\nvar a=1+2;\nfor(var i=0,l=items.length;i l;i++){...}", 
            "title": "关于空格"
        }, 
        {
            "location": "/cloud_function/web/norm/#_3", 
            "text": "好的变量与函数命名，可以避免大量的注释。Nodejs推荐使用驼峰式命名：  函数和变量：functionNamesLikeThis, variableNamesLikeThis\n类名和枚举类型：ClassNamesLikeThis, EnumNamesLikeThis\n类方法：methodNamesLikeThis\n常量：SYMBOLIC_CONSTANTS_LIKE_THIS", 
            "title": "关于命名"
        }, 
        {
            "location": "/cloud_function/web/norm/#_4", 
            "text": "开发的时候大家请慎重使用==号，有时候结果未必会是您想的那样，请看下面的调试计算结果：   0 == ''\ntrue  1 == true\ntrue  2 == true\nfalse  0 == '0'\ntrue  false == 'false'\nfalse  false == '0'\ntrue  \" \\t\\r\\n \" == 0\ntrue", 
            "title": "关于双等号"
        }, 
        {
            "location": "/cloud_function/web/norm/#_5", 
            "text": "使用string时，用单引号替代双引号（写JSON时除外）。  //正确\nvar foo = 'bar';\n\n//错误\nvar foo =  bar ;", 
            "title": "关于双引号"
        }, 
        {
            "location": "/cloud_function/web/norm/#_6", 
            "text": "//正确\nif (true) {\n  response.end('winning');\n}\n//错误\nif (true)\n{\n  response.end ('losing');\n}", 
            "title": "关于大括号位置"
        }, 
        {
            "location": "/cloud_function/web/norm/#_7", 
            "text": "使用字面表达式，用 '{}' ,'[]' 代替 new Array ，new Object，不要使用 string，bool，number 的对象类型，即不要调用 new String ，new Boolean ，new Number。", 
            "title": "关于字面表达式的问题"
        }, 
        {
            "location": "/cloud_function/web/norm/#objectarray", 
            "text": "Object ，Array 创建，当有多个元素时，注意分行排列时逗号的位置。  //正确\nvar a = ['hello', 'world'];\nvar b = {\n  good: 'code',\n  'is generally': 'pretty',\n};\n\n//错误\nvar a = [\n  'hello', 'world'\n];\nvar b = { good : 'code'\n  , is generally: 'pretty'\n};", 
            "title": "Object和Array创建时的逗号问题"
        }, 
        {
            "location": "/cloud_function/web/norm/#witheval", 
            "text": "", 
            "title": "避免使用with与eval"
        }, 
        {
            "location": "/cloud_function/web/norm/#for-in", 
            "text": "for-in 循环，仅在 object/hash/map 时使用，绝不要对Array 使用。", 
            "title": "关于for-in循环"
        }, 
        {
            "location": "/cloud_function/web/norm/#array", 
            "text": "不要把Array 当做关联数组或Object 使用,即你不应该用非数字作为Array 的索引（有PHP开发经验的朋友尤其注意这点）。  //正确\nvar a = {};\na.hello = 'shit';\na.foo = 'bar';\n\n//错误\nvar a = []; // use '{}' instead\na['hello'] = 'shit';\na['foo'] = 'bar';", 
            "title": "关于Array数组的问题"
        }, 
        {
            "location": "/cloud_function/web/norm/#_8", 
            "text": "变量声明时，应该每行声明一个，不应该都写在一行。  //正确\nvar name = 'bmob';\nvar website = 'www.bmob.cn';\n\n//错误\nvar name = 'bmob'\n  ,website = 'www.bmob.cn';", 
            "title": "关于变量声明"
        }, 
        {
            "location": "/cloud_function/web/norm/#_9", 
            "text": "注释的规范如下所示：  /**\n * 获取文章列表\n * @param {number} num 文章数量.\n * @param {string|date|null} dateTime 发布时间.\n */\nvar getPosts = function (num, dateTime) {\n  // ...\n};", 
            "title": "注释规范"
        }, 
        {
            "location": "/pay/android/", 
            "text": "简介\n\n\nAndroid支付SDK接口是Bmob为广大开发人员提供的统一、正规的收费手段，让没有企业认证的个人开发者，也能通过支付宝和微信向用户收费。该文档可以让您快速为自己的应用接入Bmob的支付功能。下图为使用支付的流程。\n\n\n\n\n使用需知\n\n\n使用Bmob支付组件前，请认真阅读\nBmob服务协议\n。\n\n\n对于以下两种情况，开发者需要特别注意：\n\n\n1.违反服务协议，特别是含有以下内容的应用：\n\n\n1）封建迷信和/或淫秽、色情、下流的信息或教唆犯罪的信息；\n\n\n2）博彩有奖、赌博游戏、“私服”、“外挂”等非法互联网出版活动；\n\n\nBmob平台有权进行独立判断并采取技术手段予以删除、屏蔽或断开链接。同时，本平台有权视用户的行为性质，采取包括但不限于暂停或终止服务，限制、冻结或终止本平台网站账号的使用，追究法律责任等措施。\n\n\n2.应用遇到过多的用户投诉，如应用的使用者支付了相关款项，但是该应用却没有提供相应的服务。本平台有权限制或冻结该应用支付收入的所有款项，并保留追究法律责任的权利。\n\n\n3.\nBmob将在每笔交易中收取10%服务费。\n\n\n打款需知\n\n\n1.打款前请先在控制台填写以下信息\n\n\n\n\n2.每月的1、2、16、17号为申请打款时间，15号、月尾日为打款时间，确保用户有半个月的追诉期。\n\n\n支持平台\n\n\n目前安卓的支付支持支付宝和微信支付。\n\n\n启用须知\n\n\n\n\n在Bmob账号管理平台进行身份认证，以保证资金安全，否则无法使用支付等功能。\n\n\n\n\n提交申请时，开发者的联系方式至少要有两种(邮箱，电话，QQ)，方便后续支付弹出的订单页面展示，如下\n\n\n\n\n\n\n\n如有任何疑问或者建议，欢迎加入Bmob支付的技术支持QQ群：273080081(1群)，521591577(2群)\n\n\n\n\n\n\n支付接口快速入门\n\n\n\n\n\n\n添加相关文件\n\n\n1 将下载的支付SDK的libs目录添加到项目下，包括\n和\n，so文件按项目需求添加(这个版本不需要支付宝jar包)\n\n\n2 将下载的支付SDK的assets目录添加到项目下，包括\n和\n，其中bp.db其实是apk文件，是微信支付插件\n\n\n\n\n\n\n在您项目的AndroidManifest.xml中添加以下权限:\n\n\nuses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /\n\n\n\n\n\n\n\n\n修改混淆规则\n\n\n-libraryjars libs/BmobPay_v3.x.x_xxxxxx.jar\n-keepclasseswithmembers class c.b.** { *; }\n-keep interface c.b.PListener{ *; }\n-keep interface c.b.QListener{ *; }\n\n\n\n\n\n\n\n添加下免责Activity(注意这个是在运行时加载的类,可以忽略IDE给出的红色标识)\n\n\nactivity android:name=\"cn.bmob.pay.v3.act.PayAct\" /\n\n\n\n\n\n\n\n\n在您的应用程序主Application的onCreate中调用如下方法：\n  （Application ID在后台应用管理的 数据浏览-\n应用信息-\n应用密钥-\nApplication ID，如果appKey为空或者混淆规则不正确，会抛出IllegalArgumentException异常,因为init是异步的，越早初始化越好）\n\n\nBP.init(\"你的Application ID\");\n\n\n\n注意：新版的支付SDK不能被数据服务SDK的初始化方法取代了，无论您是否使用了Bmob数据服务SDK，都要进行支付SDK的初始化\n\n\n\n\n\n\n发起支付调用，请使用如下方法：\n\n\n\n\n\n\n    /**\n     * 第4个参数为支付方式：BP.PayType_Alipay(支付宝)、BP.PayType_Wechat(微信)、BP.PayType_QQ(QQ)\n     */\n    BP.pay(\n商品名称\n, \n商品描述\n, 0.02, BP.PayType_Alipay,, new Plistener(){...});\n\n\n\n\n\n\n在需要调用订单查询的地方，调用如下方法(微信订单和支付宝订单通用)：\n\n\n\n\n    BP.query(\n订单id\n, new QListener(){...});\n\n\n\n\n类库说明\n\n\nc.b.BP\n\n\n\n\nBP.pay(String title, String descript, double money, int payType, Plistener listener)\n\n\n\n\n\n\n\n\n\n\n类型\n\n\n名称\n\n\n说明\n\n\n\n\n\n\n\n\n\n\nString\n\n\ntitle\n\n\n商品的名称,请注意不要有违禁字眼,可以为空\n只允许中文、数字、英文和下划线、英文破折号，否则过滤\n\n\n\n\n\n\nString\n\n\ndescript\n\n\n商品的详情描述,请注意不要有违禁字眼,可以为空\n只允许中文、数字、英文和下划线、英文破折号，否则过滤\n\n\n\n\n\n\ndouble\n\n\nprice\n\n\n商品的价格,建议测试用0.02\n\n\n\n\n\n\nInt\n\n\npayType\n\n\n支付方式：BP.PayType_Alipay(支付宝)、BP.PayType_Wechat(微信)、BP.PayType_QQ(QQ)\n\n\n\n\n\n\nPlistener\n\n\nlistener\n\n\n支付结果监听类c.b.PListener\n有成功、失败、未知结果、返回订单号等方法\n\n\n\n\n\n\n\n\n注意\n\n\n支付时返回的信息都未必可靠，一切以查询订单返回的信息为准\n\n\n调用微信支付，要安装插件(如果没有安装,会监听器的fail方法会返回-3错误码)，插件在SDK文档的plugin文件夹下，demo有通过assets安装的示例\n\n\n\n\n\nBP.query(String orderId, QListener listener)\n\n\n\n\n\n\n\n\n\n\n类型\n\n\n名称\n\n\n说明\n\n\n\n\n\n\n\n\n\n\nString\n\n\norderId\n\n\n支付订单号,不可为空\n\n\n\n\n\n\nOrderQueryListener\n\n\nlistener\n\n\n查询结果监听类c.b.QListener\n有成功、失败等方法\n\n\n\n\n\n\n\n\n\n\n！！！ForceFree方法已经弃用(开发者需自己控制用户多次点击支付产生多个订单的问题)\n\n\n\n\nForceFree() \n\n\n当上一次支付操作尚未完成时,如果BmobPay对象发起再次请求,PayListener会回调fail方法返回并10777错误码,以免生成多个订单\n\n如果使用过程中出现了阻塞(比如异常强制关闭支付插件页面,会导致一直不能再发起请求，这是小概率事件),则调用此方法进行BmobPay的重置\n\n仅对下一次请求生效,而不是永久消除限制\n\n\n\n\n\n\nc.b.PListener\n\n\n\n\n\n\norderId(String orderId)\n\n\n无论支付成功与否,只要成功产生了请求,就返回订单号,请自行保存以便以后查询\n\n\n\n\n\n\nsucceed()\n\n\n支付成功,保险起见请调用查询方法确认结果\n\n\n\n\n\n\nfail(int code, String reason)\n\n\n支付失败,有可能是用户中断支付,也有可能是网络问题\n返回10777时说明上次操作尚未完成,拒绝多次请求以免生成多个订单(可用BP.ForceFree()方法强制取消一次限制)\n支付宝支付时6001为用户主动中断支付操作\n微信支付返回-2时为用户主动中断操作,返回-3为未安装Bmob支付插件.apk\n(如果多次出现异常请向Bmob工作人员反馈)\n\n\n\n\n\n\nunknow()\n\n\n因为网络等问题,不能确认是否支付成功,请稍后手动查询(小概率事件)\n\n\n\n\n\n\nc.b.QListener\n\n\n\n\n\n\nsucceed(String status)\n\n\n查询成功(并不是说支付成功),返回的status有NOTPAY和SUCCESS两种可能\n\n\n\n\n\n\nfail(int code, String reason)\n\n\n查询失败,有可能是网络问题,也有可能是订单号错误\n\n\n\n\n\n\n支付服务\n\n\n关于如何使用支付功能，请查看 \nAndroid支付SDK\n 或 \niOS支付SDK\n。RestAPI目前只提供了查询订单的功能。\n\n\n查询订单\n\n\ncurl -X GET \\\n-H \"X-Bmob-Application-Id: Your Application ID\" \\\n-H \"X-Bmob-REST-API-Key: Your REST API Key\" \\\nhttps://api.bmob.cn/1/pay/Bmob系统生成的订单号\n\n\n\n成功返回以下JSON, 失败时返回请看 \n支付功能相关错误码\n\n\n{\n\"name\": \"商品\",\n\"body\": \"商品详情\",\n\"create_time\": \"2015-03-24 11:14:58\",\n\"out_trade_no\": \"9f392618f449a71c6fcfdee38d2b29e4\",\n\"transaction_id\": \"2015061100001000330057820379\"\n\"pay_type\": \"WECHATPAY\",\n\"total_fee\": 0.01,\n\"trade_state\": \"NOTPAY\"\n}\n\n\n\n返回的信息简单描述如下：\n\n\n\n\nname           : 订单或商品名称 \n\n\nbody-商品详情\n\n\ncreate_time    : 调起支付的时间\n\n\nout_trade_no   : Bmob系统的订单号\n\n\ntransaction_id : 微信或支付宝的系统订单号\n\n\npay_type       : WECHATPAY（微信支付）或ALIPAY（支付宝支付）\n\n\ntotal_fee      : 订单总金额\n\n\ntrade_state    : NOTPAY（未支付）或 SUCCESS（支付成功）\n\n\n\n\n支付回调\n\n\n如图，可以在支付-配置信息处填入通知url。\n\n\n\n\n这样在支付成功后会向该url（SDK使用异步通知URL，PHP等调用网页支付的使用同步返回URL）发送post请求，结构如下：\n\n\n{\n    \ntrade_status\n:\n1\n,\n    \nout_trade_no\n:\n809488d695ed42ec56b57546d2df94cc\n,\n    \ntrade_no\n:\n2016033021001004810225607152\n\n}\n\n\n\n\ntrade_status：表示支付状态，目前只有支付成功才产生回调，值恒为1.\nout_trade_no：Bmob返回的订单号\ntrade_no：支付宝或微信返回的订单号\n\n\n新版支付v3.1.1(20170111)的更新提示\n\n\n\n\nForceFree方法已经弃用，开发者需自己控制用户多次点击支付产生多个订单的问题\n\n\n这一版本的SDK将会在支付的过程中呈现一个中间页面，这个页面负责引导用户的支付流程，带来的影响是：\n    1)可以不用在pay的回调里调用BP.query进行查询，因为这个页面会确定用户的支付结果(试用demo.apk进行体验)\n    2)可以不用在你自己的app内提供责任说明的页面\n\n\n支付宝支付需要用户手机已经安装支付宝，微信支付仍然需要安装插件\n\n\n市面上还流传小部分内存很吃紧的老款手机，在打开支付宝或者微信的时候可能导致你自己的app被系统杀掉，这种情况可以通过在后台填写\n支付结果的异步通知URL\n解决，结合云端代码来使用(详情见云端代码文档)\n\n\n不用再针对小米手机获取订单时9015的问题添加额外的代码，微信支付插件不用网络权限，但在部分手机可能还是需要用户手动开启\n允许微信支付插件被其它app调起\n的权限\n\n\n新版支付SDK对Unity支持的解决方法:\n\n\n新版支付SDK需要so文件，Unity3d开发者如果没有处理过类似情况，可以这样做：\n\n\n将SDK中libs文件夹下，除了/armeabi、/armeabi-v7a、x86以外的文件夹删掉(jar文件需要保留)，然后把libs文件夹放在Plugins/Android/下。也就是最后会有 Plugins/Android/libs/armeabi/bmobwpay.so文件\n\n\n\n\n\n\n\n\n其他\n\n\n\n\n\n\n混淆规则如下: \n\n\n-libraryjars libs/BmobPay_v3.x.x_xxxxxx.jar\n-keepclasseswithmembers class c.b.** { *; }\n-keep interface c.b.PListener{ *; }\n-keep interface c.b.QListener{ *; }\n\n\n\n\n\n\n\n在\nBmob财务管理平台\n订单管理处，金额从小数点后第三位开始不显示，比如支付了0.01元实收0.00，其实是0.0095\n\n\n\n\n如果用户的手机有“应用锁”功能（即点击应用后跳出系统设定的解锁界面，如小米、360、腾讯管家都可能有该功能），则可能会导致支付中断（支付宝返回6001，微信返回-2），这是微信和支付宝SDK出于安全考虑设置的，请建议用户出现该问题时先关掉支付宝钱包或微信的应用锁\n\n\n由于微信SDK的限制，无法判断微信是否已登陆用户，\n如果未登陆用户，监听器的fail方法可能不被调用\n，请开发者们提醒自己的用户确保微信已登陆\n\n\n如果支付宝已经选定了支付用的账户（或银行卡），但是支付失败，用户的支付宝账号会保留该订单，有可能从支付宝官网、支付宝钱包APP再次发起支付，在开发过程中请注意这种事情的处理情况\n\n\n如果请求支付的页面为横屏，微信支付页面可能出现抽风现象（卡顿甚至重启），是因为微信出现莫名Bug不停开启新支付页面导致内存爆满，解决方法：在AndroidManifest.xml中将com.bmob.pay.tool.PayActivity设为强制竖屏（上方有示例），并尽可能将自己调用的Activity也设置为竖屏", 
            "title": "开发文档"
        }, 
        {
            "location": "/pay/android/#_1", 
            "text": "Android支付SDK接口是Bmob为广大开发人员提供的统一、正规的收费手段，让没有企业认证的个人开发者，也能通过支付宝和微信向用户收费。该文档可以让您快速为自己的应用接入Bmob的支付功能。下图为使用支付的流程。", 
            "title": "简介"
        }, 
        {
            "location": "/pay/android/#_2", 
            "text": "使用Bmob支付组件前，请认真阅读 Bmob服务协议 。  对于以下两种情况，开发者需要特别注意：  1.违反服务协议，特别是含有以下内容的应用：  1）封建迷信和/或淫秽、色情、下流的信息或教唆犯罪的信息；  2）博彩有奖、赌博游戏、“私服”、“外挂”等非法互联网出版活动；  Bmob平台有权进行独立判断并采取技术手段予以删除、屏蔽或断开链接。同时，本平台有权视用户的行为性质，采取包括但不限于暂停或终止服务，限制、冻结或终止本平台网站账号的使用，追究法律责任等措施。  2.应用遇到过多的用户投诉，如应用的使用者支付了相关款项，但是该应用却没有提供相应的服务。本平台有权限制或冻结该应用支付收入的所有款项，并保留追究法律责任的权利。  3. Bmob将在每笔交易中收取10%服务费。", 
            "title": "使用需知"
        }, 
        {
            "location": "/pay/android/#_3", 
            "text": "1.打款前请先在控制台填写以下信息   2.每月的1、2、16、17号为申请打款时间，15号、月尾日为打款时间，确保用户有半个月的追诉期。", 
            "title": "打款需知"
        }, 
        {
            "location": "/pay/android/#_4", 
            "text": "目前安卓的支付支持支付宝和微信支付。", 
            "title": "支持平台"
        }, 
        {
            "location": "/pay/android/#_5", 
            "text": "在Bmob账号管理平台进行身份认证，以保证资金安全，否则无法使用支付等功能。   提交申请时，开发者的联系方式至少要有两种(邮箱，电话，QQ)，方便后续支付弹出的订单页面展示，如下    如有任何疑问或者建议，欢迎加入Bmob支付的技术支持QQ群：273080081(1群)，521591577(2群)", 
            "title": "启用须知"
        }, 
        {
            "location": "/pay/android/#_6", 
            "text": "添加相关文件  1 将下载的支付SDK的libs目录添加到项目下，包括 和 ，so文件按项目需求添加(这个版本不需要支付宝jar包)  2 将下载的支付SDK的assets目录添加到项目下，包括 和 ，其中bp.db其实是apk文件，是微信支付插件    在您项目的AndroidManifest.xml中添加以下权限:  uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /     修改混淆规则  -libraryjars libs/BmobPay_v3.x.x_xxxxxx.jar\n-keepclasseswithmembers class c.b.** { *; }\n-keep interface c.b.PListener{ *; }\n-keep interface c.b.QListener{ *; }    添加下免责Activity(注意这个是在运行时加载的类,可以忽略IDE给出的红色标识)  activity android:name=\"cn.bmob.pay.v3.act.PayAct\" /     在您的应用程序主Application的onCreate中调用如下方法：\n  （Application ID在后台应用管理的 数据浏览- 应用信息- 应用密钥- Application ID，如果appKey为空或者混淆规则不正确，会抛出IllegalArgumentException异常,因为init是异步的，越早初始化越好）  BP.init(\"你的Application ID\");  注意：新版的支付SDK不能被数据服务SDK的初始化方法取代了，无论您是否使用了Bmob数据服务SDK，都要进行支付SDK的初始化    发起支付调用，请使用如下方法：        /**\n     * 第4个参数为支付方式：BP.PayType_Alipay(支付宝)、BP.PayType_Wechat(微信)、BP.PayType_QQ(QQ)\n     */\n    BP.pay( 商品名称 ,  商品描述 , 0.02, BP.PayType_Alipay,, new Plistener(){...});   在需要调用订单查询的地方，调用如下方法(微信订单和支付宝订单通用)：       BP.query( 订单id , new QListener(){...});", 
            "title": "支付接口快速入门"
        }, 
        {
            "location": "/pay/android/#_7", 
            "text": "c.b.BP   BP.pay(String title, String descript, double money, int payType, Plistener listener)      类型  名称  说明      String  title  商品的名称,请注意不要有违禁字眼,可以为空 只允许中文、数字、英文和下划线、英文破折号，否则过滤    String  descript  商品的详情描述,请注意不要有违禁字眼,可以为空 只允许中文、数字、英文和下划线、英文破折号，否则过滤    double  price  商品的价格,建议测试用0.02    Int  payType  支付方式：BP.PayType_Alipay(支付宝)、BP.PayType_Wechat(微信)、BP.PayType_QQ(QQ)    Plistener  listener  支付结果监听类c.b.PListener 有成功、失败、未知结果、返回订单号等方法     注意  支付时返回的信息都未必可靠，一切以查询订单返回的信息为准  调用微信支付，要安装插件(如果没有安装,会监听器的fail方法会返回-3错误码)，插件在SDK文档的plugin文件夹下，demo有通过assets安装的示例   BP.query(String orderId, QListener listener)      类型  名称  说明      String  orderId  支付订单号,不可为空    OrderQueryListener  listener  查询结果监听类c.b.QListener 有成功、失败等方法      ！！！ForceFree方法已经弃用(开发者需自己控制用户多次点击支付产生多个订单的问题)   ForceFree()   当上一次支付操作尚未完成时,如果BmobPay对象发起再次请求,PayListener会回调fail方法返回并10777错误码,以免生成多个订单 \n如果使用过程中出现了阻塞(比如异常强制关闭支付插件页面,会导致一直不能再发起请求，这是小概率事件),则调用此方法进行BmobPay的重置 \n仅对下一次请求生效,而不是永久消除限制    c.b.PListener    orderId(String orderId)  无论支付成功与否,只要成功产生了请求,就返回订单号,请自行保存以便以后查询    succeed()  支付成功,保险起见请调用查询方法确认结果    fail(int code, String reason)  支付失败,有可能是用户中断支付,也有可能是网络问题 返回10777时说明上次操作尚未完成,拒绝多次请求以免生成多个订单(可用BP.ForceFree()方法强制取消一次限制) 支付宝支付时6001为用户主动中断支付操作 微信支付返回-2时为用户主动中断操作,返回-3为未安装Bmob支付插件.apk (如果多次出现异常请向Bmob工作人员反馈)    unknow()  因为网络等问题,不能确认是否支付成功,请稍后手动查询(小概率事件)    c.b.QListener    succeed(String status)  查询成功(并不是说支付成功),返回的status有NOTPAY和SUCCESS两种可能    fail(int code, String reason)  查询失败,有可能是网络问题,也有可能是订单号错误", 
            "title": "类库说明"
        }, 
        {
            "location": "/pay/android/#_8", 
            "text": "关于如何使用支付功能，请查看  Android支付SDK  或  iOS支付SDK 。RestAPI目前只提供了查询订单的功能。", 
            "title": "支付服务"
        }, 
        {
            "location": "/pay/android/#_9", 
            "text": "curl -X GET \\\n-H \"X-Bmob-Application-Id: Your Application ID\" \\\n-H \"X-Bmob-REST-API-Key: Your REST API Key\" \\\nhttps://api.bmob.cn/1/pay/Bmob系统生成的订单号  成功返回以下JSON, 失败时返回请看  支付功能相关错误码  {\n\"name\": \"商品\",\n\"body\": \"商品详情\",\n\"create_time\": \"2015-03-24 11:14:58\",\n\"out_trade_no\": \"9f392618f449a71c6fcfdee38d2b29e4\",\n\"transaction_id\": \"2015061100001000330057820379\"\n\"pay_type\": \"WECHATPAY\",\n\"total_fee\": 0.01,\n\"trade_state\": \"NOTPAY\"\n}  返回的信息简单描述如下：   name           : 订单或商品名称   body-商品详情  create_time    : 调起支付的时间  out_trade_no   : Bmob系统的订单号  transaction_id : 微信或支付宝的系统订单号  pay_type       : WECHATPAY（微信支付）或ALIPAY（支付宝支付）  total_fee      : 订单总金额  trade_state    : NOTPAY（未支付）或 SUCCESS（支付成功）", 
            "title": "查询订单"
        }, 
        {
            "location": "/pay/android/#_10", 
            "text": "如图，可以在支付-配置信息处填入通知url。   这样在支付成功后会向该url（SDK使用异步通知URL，PHP等调用网页支付的使用同步返回URL）发送post请求，结构如下：  {\n     trade_status : 1 ,\n     out_trade_no : 809488d695ed42ec56b57546d2df94cc ,\n     trade_no : 2016033021001004810225607152 \n}  trade_status：表示支付状态，目前只有支付成功才产生回调，值恒为1.\nout_trade_no：Bmob返回的订单号\ntrade_no：支付宝或微信返回的订单号", 
            "title": "支付回调"
        }, 
        {
            "location": "/pay/android/#v31120170111", 
            "text": "ForceFree方法已经弃用，开发者需自己控制用户多次点击支付产生多个订单的问题  这一版本的SDK将会在支付的过程中呈现一个中间页面，这个页面负责引导用户的支付流程，带来的影响是：\n    1)可以不用在pay的回调里调用BP.query进行查询，因为这个页面会确定用户的支付结果(试用demo.apk进行体验)\n    2)可以不用在你自己的app内提供责任说明的页面  支付宝支付需要用户手机已经安装支付宝，微信支付仍然需要安装插件  市面上还流传小部分内存很吃紧的老款手机，在打开支付宝或者微信的时候可能导致你自己的app被系统杀掉，这种情况可以通过在后台填写 支付结果的异步通知URL 解决，结合云端代码来使用(详情见云端代码文档)  不用再针对小米手机获取订单时9015的问题添加额外的代码，微信支付插件不用网络权限，但在部分手机可能还是需要用户手动开启 允许微信支付插件被其它app调起 的权限  新版支付SDK对Unity支持的解决方法:  新版支付SDK需要so文件，Unity3d开发者如果没有处理过类似情况，可以这样做：  将SDK中libs文件夹下，除了/armeabi、/armeabi-v7a、x86以外的文件夹删掉(jar文件需要保留)，然后把libs文件夹放在Plugins/Android/下。也就是最后会有 Plugins/Android/libs/armeabi/bmobwpay.so文件", 
            "title": "新版支付v3.1.1(20170111)的更新提示"
        }, 
        {
            "location": "/pay/android/#_11", 
            "text": "混淆规则如下:   -libraryjars libs/BmobPay_v3.x.x_xxxxxx.jar\n-keepclasseswithmembers class c.b.** { *; }\n-keep interface c.b.PListener{ *; }\n-keep interface c.b.QListener{ *; }    在 Bmob财务管理平台 订单管理处，金额从小数点后第三位开始不显示，比如支付了0.01元实收0.00，其实是0.0095   如果用户的手机有“应用锁”功能（即点击应用后跳出系统设定的解锁界面，如小米、360、腾讯管家都可能有该功能），则可能会导致支付中断（支付宝返回6001，微信返回-2），这是微信和支付宝SDK出于安全考虑设置的，请建议用户出现该问题时先关掉支付宝钱包或微信的应用锁  由于微信SDK的限制，无法判断微信是否已登陆用户， 如果未登陆用户，监听器的fail方法可能不被调用 ，请开发者们提醒自己的用户确保微信已登陆  如果支付宝已经选定了支付用的账户（或银行卡），但是支付失败，用户的支付宝账号会保留该订单，有可能从支付宝官网、支付宝钱包APP再次发起支付，在开发过程中请注意这种事情的处理情况  如果请求支付的页面为横屏，微信支付页面可能出现抽风现象（卡顿甚至重启），是因为微信出现莫名Bug不停开启新支付页面导致内存爆满，解决方法：在AndroidManifest.xml中将com.bmob.pay.tool.PayActivity设为强制竖屏（上方有示例），并尽可能将自己调用的Activity也设置为竖屏", 
            "title": "其他"
        }, 
        {
            "location": "/pay/android/example/", 
            "text": "示例和功能\n\n\nandroid及iOS的demo在相应SDK压缩包里一起提供\nhttp://www.bmob.cn/downloads", 
            "title": "示例/功能"
        }, 
        {
            "location": "/pay/android/example/#_1", 
            "text": "android及iOS的demo在相应SDK压缩包里一起提供 http://www.bmob.cn/downloads", 
            "title": "示例和功能"
        }, 
        {
            "location": "/pay/android/class_doc/", 
            "text": "类库文档\n\n\n支付SDK类库文档：\nhttp://docs.bmob.cn/pay/Android/i_doc/doc/index.html", 
            "title": "类库文档"
        }, 
        {
            "location": "/pay/android/class_doc/#_1", 
            "text": "支付SDK类库文档： http://docs.bmob.cn/pay/Android/i_doc/doc/index.html", 
            "title": "类库文档"
        }, 
        {
            "location": "/pay/android/update_log/", 
            "text": "v3.1.1   2017年1月11日\n\n\n1.需要在AndroidManifest.xml添加声明一个Activity(cn.bmob.pay.v3.act.PayAct)\n2.需要添加so文件、更换jar文件、往assets文件夹放一个payassets.db文件\n3.恢复了对支付宝支付的支持(不需添加支付sdk，要求用户手机已安装支付宝客户端)\n4.网络请求过程不再放在插件，不会再因为插件无法请求网络导致出现9015、9016的错误，不会再出现不回调订单的错误\n5.取消10077(重复提交订单)的错误，不再提供ForceFree方法，由开发者自己控制好，避免短时间内频繁生成订单\n6.责任声明的页面由sdk统一提供了，开发者可以不再展示该声明(试用demo可体验)\n7.初始化方法参数无需传入Context\n8.初始化方法变成异步的，最好放在Application的onCreate方法内\n9.回调fail时，部分编译阶段的错误码对应的文字换成了中文的，以便快速排查问题，如果有编码问题请及时反馈\n\n\nv3.0.3   2016年6月21日\n\n\n1.请勿将支付sdk用于违规途径,一经发现,本平台可在不通知开发者的情况下紧急封禁账号以避免损失;\n2.支付宝支付和微信支付都需要使用支付插件(本目录下的’BmobPayPlugin.apk’),请确保有读写SD卡权限;\n3.如果担心插件被应用市场扫描出带有支付功能,可将插件通过加密或下载的方式隐藏起来;\n4.混淆规则如下:\n-libraryjars libs/xxx.jar(替换jar包名)\n-keepclasseswithmembers class c.b.\n { \n; }\n-keep interface c.b.PListener{ \n; }\n-keep interface c.b.QListener{ *; }\n\n\nv3.0.2   2016年5月31日\n\n\n1.将过长字符串通过getResourceAsStream方式加载,兼容部分旧的编译器\n2.更新了混淆规则,详细内容见文档\n3.支付插件的名字统一为\"安全支付控件\"\n\n\nv3.0.1   2016年5月30日\n\n\n1.提供关闭Service的接口，BP.ForceExit();\n2.修复102(安全认证)的问题\n3.将插件上的支付宝sdk升级到最新版\n4.支付插件改名为\"BPay安全控件\"\n5.Demo中添加了检查支付插件版本并更新的示例\n\n\nv3.0   2016年5月27日\n\n\n1.请勿将支付sdk用于违规途径,一经发现,本平台可在不通知开发者的情况下紧急封禁账号以避免损失;\n2.支付宝支付和微信支付都需要使用支付插件(本目录下的’BmobPlugin.apk’),请确保有读写SD卡权限;\n3.如果担心插件被应用市场扫描出带有支付功能,可将插件通过加密或下载的方式隐藏起来;\n4.混淆规则如下:\n-keep class c.b.BP\n-keep class c.b.PListener\n-keep class c.b.QListener\n-keepclasseswithmembers class c.b.BP{ \n; }\n-keepclasseswithmembers class * implements c.b.PListener{ \n; }\n-keepclasseswithmembers class * implements c.b.QListener{ *; }\n\n\nv2.7   2016年4月27日\n\n\n修复了Unity项目初始化时提示混淆失败的问题(在Assets/Android/assets下添加了s.db和j.db文件)\n\n\nv2.6   2016年4月11日\n\n\nBmobPay更新：\n1.修复了部分旧版混淆工具混淆失败的问题；\n2.处理了在非主线程初始化sdk失败的问题；\n3.提高了加载效率；\n4.sdk版本号为7\n微信支付插件更新：\n1.修复了未登录用户回调失败的问题；\n2.隐藏了中转页面；\n3.插件版本号改为4，可通过支付sdk的BP.getPluginVersion判断更新\n\n\nv2.5   2016年3月24日\n\n\n1、兼容armeabi、armeabi-v7a、arm64-v8a、x86、x86_64、mips等CPU指令集 2、修复某些特殊机型会崩溃的问题 3、修复已知Bug \n\n\nv2.4   2016年1月25日\n\n\n1.兼容64位机器，如果发现还有不兼容的机型请联系客服\n\n\nv2.3   2016年1月23日\n\n\n1.取消so文件\n2.提高sdk兼容性\n3.Unity添加安装微信支付插件功能(需更新so文件和jar文件,并提供cs文件参考)\n4.提示语优化\n5.混淆规则在demo的proguard-project.txt文件有示例\n\n\nv2.1   2016年1月18日\n\n\n1.支持Unity调用并提供了教程和示例代码,不懂Android也可以快速接入\n2.so文件缩小一半,更加轻量\n3.安全性大大提升\n4.推荐将插件后缀名改为db等,更容易上应用市场\n\n\nv2.0   2016年1月13日\n\n\n2.0版本与之前的版本有较大区别，不向下兼容。\n主要更新内容如下：\n1.去除SDK中Pay关键字\n2.添加两个新的Activity需要在AndroidManifest文件中注册。(旧版已注册的Activity可删除)\n3.类名改动，详细见支付文档说明。\n4.混淆改动，详细见支付文档说明。\n\n\nv1.0.3   2015年10月20日\n\n\n1.支付宝sdk更新:     \n    1)默认用主线程调用调用支付;     \n    2)更新支付宝官方sdk,从3个jar包改成1个jar包;     \n    3)版本号更新为3; \n2.微信支付插件:     \n    1)微信支付插件无更新; \n3.支付Demo更新:     \n    1)支付宝支付sdk更新成官方最新版;     \n    2)Dialog的调用增加了异常捕捉; \n\n\nv1.0.2a   2015年7月09日\n\n\n1.微信支付插件更新：\n    1）在近期任务中不可见\n    2）兼容微信的新Bug\n    3）状态栏（TitleBar）设为不可见\n    4）版本号更新为3\n2.支付 Sdk无更新\nPS：如果请求支付的页面为横屏，微信支付页面可能出现抽风现象（卡顿甚至重启），是因为微信出现莫名Bug不停开启新支付页面导致内存爆满，解决方法：在AndroidManifest.xml中将com.bmob.pay.tool.PayActivity设为强制竖屏（上方有示例），并尽可能将自己调用的Activity也设置为竖屏\n支付Sdk版本号 : 2\n微信支付插件版本号 : 3\n\n\nv1.0.2   2015年5月12日\n\n\n支付Sdk更新： \n1.BmobPay下增加了静态方法getPluginVersion，用于查看微信插件的版本号（当前版本为2），可按需更新； \n2.BmobPay下增加了静态方法getPaySdkVersion，用于查看Bmob支付Sdk的版本号（当前版本为2）； 微信支付插件更新： 修复了部分用户在未安装微信时调用微信支付未回调fail的Bug \n支付Sdk版本号 : 2 \n微信支付插件版本号 : 2 \n\n\nV1.0.1a   2015年4月14日\n\n\n支付宝官方的sdk有更新，Bmob的支付sdk无更新 \n支付宝sdk更新信息如下：     \n安卓版本号：v2.2.1    \n修改时间：2015-03-31    \n安卓更新点：修正部分机型横屏下安全输入法兼容问题，改成强制竖屏     \n          \n\n\nV1.0.1   2015年4月10日\n\n\n1.修复了商品名、描述字符串非法导致支付宝报ALI64的问题                              \n2.修复了防止多次提交订单时的锁只对下一次有效的BUG                                        3.优化了微信支付插件的Logo \n\n\nV1.0.0   2015年4月08日\n\n\n1、调用支付宝、微信支付的支付以及查询功能完成\n2、添加支付成功、失败、返回订单号等监听事件；\n3、更改支付宝支付、查询订单时无需安装插件，微信支付需要安装插件", 
            "title": "更新日志"
        }, 
        {
            "location": "/pay/android/update_log/#v311-2017111", 
            "text": "1.需要在AndroidManifest.xml添加声明一个Activity(cn.bmob.pay.v3.act.PayAct)\n2.需要添加so文件、更换jar文件、往assets文件夹放一个payassets.db文件\n3.恢复了对支付宝支付的支持(不需添加支付sdk，要求用户手机已安装支付宝客户端)\n4.网络请求过程不再放在插件，不会再因为插件无法请求网络导致出现9015、9016的错误，不会再出现不回调订单的错误\n5.取消10077(重复提交订单)的错误，不再提供ForceFree方法，由开发者自己控制好，避免短时间内频繁生成订单\n6.责任声明的页面由sdk统一提供了，开发者可以不再展示该声明(试用demo可体验)\n7.初始化方法参数无需传入Context\n8.初始化方法变成异步的，最好放在Application的onCreate方法内\n9.回调fail时，部分编译阶段的错误码对应的文字换成了中文的，以便快速排查问题，如果有编码问题请及时反馈", 
            "title": "v3.1.1   2017年1月11日"
        }, 
        {
            "location": "/pay/android/update_log/#v303-2016621", 
            "text": "1.请勿将支付sdk用于违规途径,一经发现,本平台可在不通知开发者的情况下紧急封禁账号以避免损失;\n2.支付宝支付和微信支付都需要使用支付插件(本目录下的’BmobPayPlugin.apk’),请确保有读写SD卡权限;\n3.如果担心插件被应用市场扫描出带有支付功能,可将插件通过加密或下载的方式隐藏起来;\n4.混淆规则如下:\n-libraryjars libs/xxx.jar(替换jar包名)\n-keepclasseswithmembers class c.b.  {  ; }\n-keep interface c.b.PListener{  ; }\n-keep interface c.b.QListener{ *; }", 
            "title": "v3.0.3   2016年6月21日"
        }, 
        {
            "location": "/pay/android/update_log/#v302-2016531", 
            "text": "1.将过长字符串通过getResourceAsStream方式加载,兼容部分旧的编译器\n2.更新了混淆规则,详细内容见文档\n3.支付插件的名字统一为\"安全支付控件\"", 
            "title": "v3.0.2   2016年5月31日"
        }, 
        {
            "location": "/pay/android/update_log/#v301-2016530", 
            "text": "1.提供关闭Service的接口，BP.ForceExit();\n2.修复102(安全认证)的问题\n3.将插件上的支付宝sdk升级到最新版\n4.支付插件改名为\"BPay安全控件\"\n5.Demo中添加了检查支付插件版本并更新的示例", 
            "title": "v3.0.1   2016年5月30日"
        }, 
        {
            "location": "/pay/android/update_log/#v30-2016527", 
            "text": "1.请勿将支付sdk用于违规途径,一经发现,本平台可在不通知开发者的情况下紧急封禁账号以避免损失;\n2.支付宝支付和微信支付都需要使用支付插件(本目录下的’BmobPlugin.apk’),请确保有读写SD卡权限;\n3.如果担心插件被应用市场扫描出带有支付功能,可将插件通过加密或下载的方式隐藏起来;\n4.混淆规则如下:\n-keep class c.b.BP\n-keep class c.b.PListener\n-keep class c.b.QListener\n-keepclasseswithmembers class c.b.BP{  ; }\n-keepclasseswithmembers class * implements c.b.PListener{  ; }\n-keepclasseswithmembers class * implements c.b.QListener{ *; }", 
            "title": "v3.0   2016年5月27日"
        }, 
        {
            "location": "/pay/android/update_log/#v27-2016427", 
            "text": "修复了Unity项目初始化时提示混淆失败的问题(在Assets/Android/assets下添加了s.db和j.db文件)", 
            "title": "v2.7   2016年4月27日"
        }, 
        {
            "location": "/pay/android/update_log/#v26-2016411", 
            "text": "BmobPay更新：\n1.修复了部分旧版混淆工具混淆失败的问题；\n2.处理了在非主线程初始化sdk失败的问题；\n3.提高了加载效率；\n4.sdk版本号为7\n微信支付插件更新：\n1.修复了未登录用户回调失败的问题；\n2.隐藏了中转页面；\n3.插件版本号改为4，可通过支付sdk的BP.getPluginVersion判断更新", 
            "title": "v2.6   2016年4月11日"
        }, 
        {
            "location": "/pay/android/update_log/#v25-2016324", 
            "text": "1、兼容armeabi、armeabi-v7a、arm64-v8a、x86、x86_64、mips等CPU指令集 2、修复某些特殊机型会崩溃的问题 3、修复已知Bug", 
            "title": "v2.5   2016年3月24日"
        }, 
        {
            "location": "/pay/android/update_log/#v24-2016125", 
            "text": "1.兼容64位机器，如果发现还有不兼容的机型请联系客服", 
            "title": "v2.4   2016年1月25日"
        }, 
        {
            "location": "/pay/android/update_log/#v23-2016123", 
            "text": "1.取消so文件\n2.提高sdk兼容性\n3.Unity添加安装微信支付插件功能(需更新so文件和jar文件,并提供cs文件参考)\n4.提示语优化\n5.混淆规则在demo的proguard-project.txt文件有示例", 
            "title": "v2.3   2016年1月23日"
        }, 
        {
            "location": "/pay/android/update_log/#v21-2016118", 
            "text": "1.支持Unity调用并提供了教程和示例代码,不懂Android也可以快速接入\n2.so文件缩小一半,更加轻量\n3.安全性大大提升\n4.推荐将插件后缀名改为db等,更容易上应用市场", 
            "title": "v2.1   2016年1月18日"
        }, 
        {
            "location": "/pay/android/update_log/#v20-2016113", 
            "text": "2.0版本与之前的版本有较大区别，不向下兼容。\n主要更新内容如下：\n1.去除SDK中Pay关键字\n2.添加两个新的Activity需要在AndroidManifest文件中注册。(旧版已注册的Activity可删除)\n3.类名改动，详细见支付文档说明。\n4.混淆改动，详细见支付文档说明。", 
            "title": "v2.0   2016年1月13日"
        }, 
        {
            "location": "/pay/android/update_log/#v103-20151020", 
            "text": "1.支付宝sdk更新:     \n    1)默认用主线程调用调用支付;     \n    2)更新支付宝官方sdk,从3个jar包改成1个jar包;     \n    3)版本号更新为3; \n2.微信支付插件:     \n    1)微信支付插件无更新; \n3.支付Demo更新:     \n    1)支付宝支付sdk更新成官方最新版;     \n    2)Dialog的调用增加了异常捕捉;", 
            "title": "v1.0.3   2015年10月20日"
        }, 
        {
            "location": "/pay/android/update_log/#v102a-2015709", 
            "text": "1.微信支付插件更新：\n    1）在近期任务中不可见\n    2）兼容微信的新Bug\n    3）状态栏（TitleBar）设为不可见\n    4）版本号更新为3\n2.支付 Sdk无更新\nPS：如果请求支付的页面为横屏，微信支付页面可能出现抽风现象（卡顿甚至重启），是因为微信出现莫名Bug不停开启新支付页面导致内存爆满，解决方法：在AndroidManifest.xml中将com.bmob.pay.tool.PayActivity设为强制竖屏（上方有示例），并尽可能将自己调用的Activity也设置为竖屏\n支付Sdk版本号 : 2\n微信支付插件版本号 : 3", 
            "title": "v1.0.2a   2015年7月09日"
        }, 
        {
            "location": "/pay/android/update_log/#v102-2015512", 
            "text": "支付Sdk更新： \n1.BmobPay下增加了静态方法getPluginVersion，用于查看微信插件的版本号（当前版本为2），可按需更新； \n2.BmobPay下增加了静态方法getPaySdkVersion，用于查看Bmob支付Sdk的版本号（当前版本为2）； 微信支付插件更新： 修复了部分用户在未安装微信时调用微信支付未回调fail的Bug \n支付Sdk版本号 : 2 \n微信支付插件版本号 : 2", 
            "title": "v1.0.2   2015年5月12日"
        }, 
        {
            "location": "/pay/android/update_log/#v101a-2015414", 
            "text": "支付宝官方的sdk有更新，Bmob的支付sdk无更新 \n支付宝sdk更新信息如下：     \n安卓版本号：v2.2.1    \n修改时间：2015-03-31    \n安卓更新点：修正部分机型横屏下安全输入法兼容问题，改成强制竖屏", 
            "title": "V1.0.1a   2015年4月14日"
        }, 
        {
            "location": "/pay/android/update_log/#v101-2015410", 
            "text": "1.修复了商品名、描述字符串非法导致支付宝报ALI64的问题                              \n2.修复了防止多次提交订单时的锁只对下一次有效的BUG                                        3.优化了微信支付插件的Logo", 
            "title": "V1.0.1   2015年4月10日"
        }, 
        {
            "location": "/pay/android/update_log/#v100-2015408", 
            "text": "1、调用支付宝、微信支付的支付以及查询功能完成\n2、添加支付成功、失败、返回订单号等监听事件；\n3、更改支付宝支付、查询订单时无需安装插件，微信支付需要安装插件", 
            "title": "V1.0.0   2015年4月08日"
        }, 
        {
            "location": "/pay/ios/", 
            "text": "简介\n\n\niOS支付SDK接口是Bmob为广大开发人员提供的统一、正规的收费手段，让没有企业认证的个人开发者，也能通过支付宝和微信向用户收费。该文档可以让您快速为自己的应用接入Bmob的支付功能。下图为使用支付的流程。\n\n\n\n\n使用需知\n\n\n使用Bmob支付组件前，请认真阅读\nBmob服务协议\n。\n\n\n对于以下两种情况，开发者需要特别注意：\n\n\n1.违反服务协议，特别是含有以下内容的应用：\n\n\n1）封建迷信和/或淫秽、色情、下流的信息或教唆犯罪的信息；\n\n\n2）博彩有奖、赌博游戏、“私服”、“外挂”等非法互联网出版活动；\n\n\nBmob平台有权进行独立判断并采取技术手段予以删除、屏蔽或断开链接。同时，本平台有权视用户的行为性质，采取包括但不限于暂停或终止服务，限制、冻结或终止本平台网站账号的使用，追究法律责任等措施。\n\n\n2.应用遇到过多的用户投诉，如应用的使用者支付了相关款项，但是该应用却没有提供相应的服务。本平台有权限制或冻结该应用支付收入的所有款项，并保留追究法律责任的权利。\n\n\n3.\nBmob将在每笔交易中收取10%服务费。\n\n\n打款需知\n\n\n1.打款前请先在控制台填写以下信息\n\n\n\n\n2.每月的1、2、16、17号为申请打款时间，15号、月尾日为打款时间，确保用户有半个月的追诉期。\n\n\n支持平台\n\n\n目前 iOS 端仅提供支付宝和微信支付支持。\n\n\n启用须知\n\n\n\n\n在Bmob账号管理平台进行身份认证，以保证资金安全，否则无法使用支付等功能。\n\n\n提交申请时，开发者的联系方式至少要有两种(邮箱，电话，QQ)，方便后续支付弹出的订单页面展示，如下：\n\n\n\n\n\n\nSDK 接入\n\n\n\n\n\n\n\n\n将 \nBmobPaySDK.framework\n 拖入项目中，并选取 \ncopy items if needed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n在 info.plist 添加以下两个字端：\n\nA. \nView controller-based status bar appearance\n，类型为 \nBOOL\n，值为 \nNO\n\nB. \nLSApplicationQueriesSchemes\n，类型为 \nArray\n，字符串元素 \nalipays\n 和 \nweixin\n\n\n\n\n\n\n\n\n\n\nkey\nUIViewControllerBasedStatusBarAppearance\n/key\n\n\nfalse/\n\n\nkey\nLSApplicationQueriesSchemes\n/key\n\n\narray\n\n    \nstring\nalipays\n/string\n\n    \nstring\nweixin\n/string\n\n\n/array\n\n\n\n\n\n\n\n\n\n\n\n添加使用的framework: \n\nA. CoreTelephony.framework\n\nB. libz.1.2.5.tbd\n\nC. libsqlite3.tbd\n\nD. libc++.tbd\n\nE. \nlibWeChatSDK.a\n -\n 可以直接点击下载，使用微信支付需要导入此模块\n\n\n\n\n\n\n\n\n\n\n注意，如果使用微信支付的话，导入 \nlibWeChatSDK.a\n 文件可能会产生模块重复。发生重复模块时，删除其中一个 \nlibWeChatSDK.a\n 文件即可。\n\n\n\n\n支付调用\n\n\n#import \nBmobPaySDK/Bmob.h\n\n\n\n\n\n在 AppDelegaet 注册应用：\n\n\n[Bmob registerWithAppKey:@\nxxxxxxxx\n]; \n\n\n\n\n\n\n\n注意，如果没有注册 AppKey ，则不会有任何反应，也不会有回调。\n\n\n\n\n然后进行关键函数调用：\n\n\n[BmobPay payWithPayType:BmobAlipay //支付类型选择\n                  price:@888 //订单价格，0 - 5000\n              orderName:@\n订单名称\n //不为空\n               describe:@\n订单描述\n //不为空\n                 result:nil]; //应用内支付回调\n\n\n\n\n订单查询\n\n\n\n\n注意事项：查询操作自动从内存中获取订单号，应该等待支付操作回调执行时或执行后才进行查询接口调用。\n\n\n\n\n接口如下：\n\n\n+ (void)queryWithResult:(BmobPayResultBlock)result;\n\n\n\n\n成功查询会返回以下类似数据：\n\n\n{\n\nname\n: \n商品\n,    //商品名称 \n\nbody\n: \n商品详情\n,\n\ncreate_time\n: \n2015-03-24 11:14:58\n,   //调起支付的时间\n\nout_trade_no\n: \n9f392618f449a71c6fcfdee38d2b29e4\n,  //Bmob系统的订单号\n\ntransaction_id\n: \n2015061100001000330057820379\n  //微信或支付宝的系统订单号\n\npay_type\n: \nWECHATPAY\n,  //WECHATPAY（微信支付）或ALIPAY（支付宝支付）\n\ntotal_fee\n: 0.01,  //订单总金额\n\ntrade_state\n: \nNOTPAY\n  //NOTPAY（未支付）或 SUCCESS（支付成功） \n}\n\n\n\n\n应用外支付回调\n\n\n如图，可以在支付-配置信息处填入通知url。\n\n\n\n\n这样在支付成功后会向该url（SDK使用异步通知URL，PHP等调用网页支付的使用同步返回URL）发送post请求，结构如下：\n\n\n{\n    \ntrade_status\n:\n1\n,\n    \nout_trade_no\n:\n809488d695ed42ec56b57546d2df94cc\n,\n    \ntrade_no\n:\n2016033021001004810225607152\n\n}\n\n\n\n\ntrade_status：表示支付状态，目前只有支付成功才产生回调，值恒为1.\n\nout_trade_no：Bmob返回的订单号\n\ntrade_no：支付宝或微信返回的订单号", 
            "title": "开发文档"
        }, 
        {
            "location": "/pay/ios/#_1", 
            "text": "iOS支付SDK接口是Bmob为广大开发人员提供的统一、正规的收费手段，让没有企业认证的个人开发者，也能通过支付宝和微信向用户收费。该文档可以让您快速为自己的应用接入Bmob的支付功能。下图为使用支付的流程。", 
            "title": "简介"
        }, 
        {
            "location": "/pay/ios/#_2", 
            "text": "使用Bmob支付组件前，请认真阅读 Bmob服务协议 。  对于以下两种情况，开发者需要特别注意：  1.违反服务协议，特别是含有以下内容的应用：  1）封建迷信和/或淫秽、色情、下流的信息或教唆犯罪的信息；  2）博彩有奖、赌博游戏、“私服”、“外挂”等非法互联网出版活动；  Bmob平台有权进行独立判断并采取技术手段予以删除、屏蔽或断开链接。同时，本平台有权视用户的行为性质，采取包括但不限于暂停或终止服务，限制、冻结或终止本平台网站账号的使用，追究法律责任等措施。  2.应用遇到过多的用户投诉，如应用的使用者支付了相关款项，但是该应用却没有提供相应的服务。本平台有权限制或冻结该应用支付收入的所有款项，并保留追究法律责任的权利。  3. Bmob将在每笔交易中收取10%服务费。", 
            "title": "使用需知"
        }, 
        {
            "location": "/pay/ios/#_3", 
            "text": "1.打款前请先在控制台填写以下信息   2.每月的1、2、16、17号为申请打款时间，15号、月尾日为打款时间，确保用户有半个月的追诉期。", 
            "title": "打款需知"
        }, 
        {
            "location": "/pay/ios/#_4", 
            "text": "目前 iOS 端仅提供支付宝和微信支付支持。", 
            "title": "支持平台"
        }, 
        {
            "location": "/pay/ios/#_5", 
            "text": "在Bmob账号管理平台进行身份认证，以保证资金安全，否则无法使用支付等功能。  提交申请时，开发者的联系方式至少要有两种(邮箱，电话，QQ)，方便后续支付弹出的订单页面展示，如下：", 
            "title": "启用须知"
        }, 
        {
            "location": "/pay/ios/#sdk", 
            "text": "将  BmobPaySDK.framework  拖入项目中，并选取  copy items if needed         在 info.plist 添加以下两个字端： \nA.  View controller-based status bar appearance ，类型为  BOOL ，值为  NO \nB.  LSApplicationQueriesSchemes ，类型为  Array ，字符串元素  alipays  和  weixin      key UIViewControllerBasedStatusBarAppearance /key  false/  key LSApplicationQueriesSchemes /key  array \n     string alipays /string \n     string weixin /string  /array      添加使用的framework:  \nA. CoreTelephony.framework \nB. libz.1.2.5.tbd \nC. libsqlite3.tbd \nD. libc++.tbd \nE.  libWeChatSDK.a  -  可以直接点击下载，使用微信支付需要导入此模块      注意，如果使用微信支付的话，导入  libWeChatSDK.a  文件可能会产生模块重复。发生重复模块时，删除其中一个  libWeChatSDK.a  文件即可。", 
            "title": "SDK 接入"
        }, 
        {
            "location": "/pay/ios/#_6", 
            "text": "#import  BmobPaySDK/Bmob.h   在 AppDelegaet 注册应用：  [Bmob registerWithAppKey:@ xxxxxxxx ];    注意，如果没有注册 AppKey ，则不会有任何反应，也不会有回调。   然后进行关键函数调用：  [BmobPay payWithPayType:BmobAlipay //支付类型选择\n                  price:@888 //订单价格，0 - 5000\n              orderName:@ 订单名称  //不为空\n               describe:@ 订单描述  //不为空\n                 result:nil]; //应用内支付回调", 
            "title": "支付调用"
        }, 
        {
            "location": "/pay/ios/#_7", 
            "text": "注意事项：查询操作自动从内存中获取订单号，应该等待支付操作回调执行时或执行后才进行查询接口调用。   接口如下：  + (void)queryWithResult:(BmobPayResultBlock)result;  成功查询会返回以下类似数据：  { name :  商品 ,    //商品名称  body :  商品详情 , create_time :  2015-03-24 11:14:58 ,   //调起支付的时间 out_trade_no :  9f392618f449a71c6fcfdee38d2b29e4 ,  //Bmob系统的订单号 transaction_id :  2015061100001000330057820379   //微信或支付宝的系统订单号 pay_type :  WECHATPAY ,  //WECHATPAY（微信支付）或ALIPAY（支付宝支付） total_fee : 0.01,  //订单总金额 trade_state :  NOTPAY   //NOTPAY（未支付）或 SUCCESS（支付成功） \n}", 
            "title": "订单查询"
        }, 
        {
            "location": "/pay/ios/#_8", 
            "text": "如图，可以在支付-配置信息处填入通知url。   这样在支付成功后会向该url（SDK使用异步通知URL，PHP等调用网页支付的使用同步返回URL）发送post请求，结构如下：  {\n     trade_status : 1 ,\n     out_trade_no : 809488d695ed42ec56b57546d2df94cc ,\n     trade_no : 2016033021001004810225607152 \n}  trade_status：表示支付状态，目前只有支付成功才产生回调，值恒为1. \nout_trade_no：Bmob返回的订单号 \ntrade_no：支付宝或微信返回的订单号", 
            "title": "应用外支付回调"
        }, 
        {
            "location": "/pay/ios/example/", 
            "text": "示例和功能\n\n\nandroid及iOS的demo在相应SDK压缩包里一起提供\nhttp://www.bmob.cn/downloads", 
            "title": "示例/功能"
        }, 
        {
            "location": "/pay/ios/example/#_1", 
            "text": "android及iOS的demo在相应SDK压缩包里一起提供 http://www.bmob.cn/downloads", 
            "title": "示例和功能"
        }, 
        {
            "location": "/pay/ios/update_log/", 
            "text": "v2.1.0 (2017-06-07)\n\n\n\n\n修复微信支付\n\n\n\n\nv2.0.9 (2017-03-09)\n\n\n\n\nbug修复\n\n\n\n\nv2.0.8 (2017-02-16)\n\n\n\n\nbug修复\n\n\n\n\nv2.0.7 (2017-02-10)\n\n\n\n\n修改支付异常回调\n\n\n分离微信支付模块\n\n\n\n\nv2.0.6 (2017-02-08)\n\n\n\n\n修改支付查询接口\n\n\n\n\nv2.0.5  (2017-02-06)\n\n\n\n\n添加订单信息回调接口\n\n\n\n\nv2.0.4 (2017-01-20)\n\n\n\n\n修复模块重复问题\n\n\n\n\nv2.0.3 (2017-01-19)\n\n\n\n\n添加微信支付\n\n\n\n\nv2.0.2 (2017-01-17)\n\n\n\n\nBug修复\n\n\n\n\nv2.0.1 (2017-01-17)\n\n\n\n\nBug修复\n\n\n取消xib，该用纯代码实现支付界面\n\n\n扩展iOS6-iOS7支持\n\n\n\n\nv2.0.0 (2017-01-14)\n\n\n\n\n更新demo，使用最新版sdk；\n\n\n接口更新\n\n\n\n\nv1.0.6 (2016-03-25)\n\n\n\n\n修复打包错误bug\n\n\n\n\nv1.0.5 (2016-03-22)\n\n\n\n\n更新支付宝SDK依赖包\n\n\n添加对bitcode的支持\n\n\n\n\nv1.0.4 (2015-08-24)\n\n\n\n\n修复调用bug，确保跳转前先调用payInBackgroundWithBlock中的block。\n\n\n\n\nv1.0.3 (2015-07-22)\n\n\n\n\n更新demo，使用最新版sdk；\n\n\n修改BmobPaySDK与BmobSDK共存时产生的冲突bug；\n\n\n修改查看版本的函数名为BmobPayVersion。\n\n\n\n\nv1.0.2 (2015-06-17)\n\n\n\n\n修改依赖关系，不需要导入BmobSDK，可独立使用支付SDK；\n\n\n添加version()方法以查看版本号。\n\n\n\n\nv1.0.1 (2015-04-13)\n\n\n\n\n商品名及商品描述允许为空（自动替换成\"无商品名称\"，\"无商品描述\"），只支持输入中文、英语、数字、下划线(_)及英文破折号(-);\n\n\n上一次支付调用未完成时不允许进行下一次支付调用，避免生成多个相同订单；\n\n\n\n\nv1.0.0_Beta (2015-04-07)\n\n\n\n\n支付宝支付功能完成\n\n\n添加支付成功、失败等代理事件；\n\n\n修改客户安装支付宝钱包的情况下无法获得回调的bug", 
            "title": "更新日志"
        }, 
        {
            "location": "/pay/ios/update_log/#v210-2017-06-07", 
            "text": "修复微信支付", 
            "title": "v2.1.0 (2017-06-07)"
        }, 
        {
            "location": "/pay/ios/update_log/#v209-2017-03-09", 
            "text": "bug修复", 
            "title": "v2.0.9 (2017-03-09)"
        }, 
        {
            "location": "/pay/ios/update_log/#v208-2017-02-16", 
            "text": "bug修复", 
            "title": "v2.0.8 (2017-02-16)"
        }, 
        {
            "location": "/pay/ios/update_log/#v207-2017-02-10", 
            "text": "修改支付异常回调  分离微信支付模块", 
            "title": "v2.0.7 (2017-02-10)"
        }, 
        {
            "location": "/pay/ios/update_log/#v206-2017-02-08", 
            "text": "修改支付查询接口", 
            "title": "v2.0.6 (2017-02-08)"
        }, 
        {
            "location": "/pay/ios/update_log/#v205-2017-02-06", 
            "text": "添加订单信息回调接口", 
            "title": "v2.0.5  (2017-02-06)"
        }, 
        {
            "location": "/pay/ios/update_log/#v204-2017-01-20", 
            "text": "修复模块重复问题", 
            "title": "v2.0.4 (2017-01-20)"
        }, 
        {
            "location": "/pay/ios/update_log/#v203-2017-01-19", 
            "text": "添加微信支付", 
            "title": "v2.0.3 (2017-01-19)"
        }, 
        {
            "location": "/pay/ios/update_log/#v202-2017-01-17", 
            "text": "Bug修复", 
            "title": "v2.0.2 (2017-01-17)"
        }, 
        {
            "location": "/pay/ios/update_log/#v201-2017-01-17", 
            "text": "Bug修复  取消xib，该用纯代码实现支付界面  扩展iOS6-iOS7支持", 
            "title": "v2.0.1 (2017-01-17)"
        }, 
        {
            "location": "/pay/ios/update_log/#v200-2017-01-14", 
            "text": "更新demo，使用最新版sdk；  接口更新", 
            "title": "v2.0.0 (2017-01-14)"
        }, 
        {
            "location": "/pay/ios/update_log/#v106-2016-03-25", 
            "text": "修复打包错误bug", 
            "title": "v1.0.6 (2016-03-25)"
        }, 
        {
            "location": "/pay/ios/update_log/#v105-2016-03-22", 
            "text": "更新支付宝SDK依赖包  添加对bitcode的支持", 
            "title": "v1.0.5 (2016-03-22)"
        }, 
        {
            "location": "/pay/ios/update_log/#v104-2015-08-24", 
            "text": "修复调用bug，确保跳转前先调用payInBackgroundWithBlock中的block。", 
            "title": "v1.0.4 (2015-08-24)"
        }, 
        {
            "location": "/pay/ios/update_log/#v103-2015-07-22", 
            "text": "更新demo，使用最新版sdk；  修改BmobPaySDK与BmobSDK共存时产生的冲突bug；  修改查看版本的函数名为BmobPayVersion。", 
            "title": "v1.0.3 (2015-07-22)"
        }, 
        {
            "location": "/pay/ios/update_log/#v102-2015-06-17", 
            "text": "修改依赖关系，不需要导入BmobSDK，可独立使用支付SDK；  添加version()方法以查看版本号。", 
            "title": "v1.0.2 (2015-06-17)"
        }, 
        {
            "location": "/pay/ios/update_log/#v101-2015-04-13", 
            "text": "商品名及商品描述允许为空（自动替换成\"无商品名称\"，\"无商品描述\"），只支持输入中文、英语、数字、下划线(_)及英文破折号(-);  上一次支付调用未完成时不允许进行下一次支付调用，避免生成多个相同订单；", 
            "title": "v1.0.1 (2015-04-13)"
        }, 
        {
            "location": "/pay/ios/update_log/#v100_beta-2015-04-07", 
            "text": "支付宝支付功能完成  添加支付成功、失败等代理事件；  修改客户安装支付宝钱包的情况下无法获得回调的bug", 
            "title": "v1.0.0_Beta (2015-04-07)"
        }, 
        {
            "location": "/pay/restful/", 
            "text": "注意：目前支付宝无法使用，请用户暂时不要接入，等待官方的恢复公告！\n\n\n打款需知\n\n\n1.打款前请先在控制台填写以下信息\n\n\n\n\n2.每月的1、2、16、17号为申请打款时间，15号、月尾日为打款时间，确保用户有半个月的追诉期。Bmob将收取10%手续费。\n\n\n支付回调\n\n\n如图，可以在支付-支付配置处填入通知url。\n\n\n\n\n这样在支付成功后会向该url（SDK使用异步通知URL，PHP等调用网页支付的使用同步返回URL）发送post请求，结构如下：\n\n\n{\n    \ntrade_status\n:\n1\n,\n    \nout_trade_no\n:\n809488d695ed42ec56b57546d2df94cc\n,\n    \ntrade_no\n:\n2016033021001004810225607152\n\n}\n\n\n\n\ntrade_status：表示支付状态，目前只有支付成功才产生回调，值恒为1.\nout_trade_no：Bmob返回的订单号\ntrade_no：支付宝或微信返回的订单号\n\n\n查询订单\n\n\n请求描述\n\n\n在进行支付请求后会返回 \nout_trade_no\n 订单号，使用该订单号可以查询订单的支付情况。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/pay/out_trade_no\n\n\n\n\n\n\nmethod ：GET\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n    name:订单或商品名称 \n    body:商品详情  \n    create_time:调起支付的时间  \n    out_trade_no:Bmob系统的订单号  \n    transaction_id:微信或支付宝的系统订单号\n    pay_type:WECHATPAY（微信支付）或ALIPAY（支付宝支付） \n    total_fee:订单总金额  \n    trade_state:NOTPAY（未支付）或 SUCCESS（支付成功）\n}\n\n\n\n\n失败时返回请看 \n支付功能相关错误码\n\n\n例子\n\n\n一个查询例子如下：\n\n\ncurl -X GET \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  https://api.bmob.cn/1/pay/9f392618f449a71c6fcfdee38d2b29e4\n\n\n\n\n其返回值：\n\n\n{\n  \nname\n: \n商品\n,\n  \nbody\n: \n商品详情\n,\n  \ncreate_time\n: \n2015-03-24 11:14:58\n,\n  \nout_trade_no\n: \n9f392618f449a71c6fcfdee38d2b29e4\n,\n  \ntransaction_id\n: \n2015061100001000330057820379\n\n  \npay_type\n: \nWECHATPAY\n,\n  \ntotal_fee\n: 0.01,\n  \ntrade_state\n: \nNOTPAY\n,\n}\n\n\n\n\nBmob支付回调\n\n\nBmob 加入了支付后页面跳转同步通知页面的URL和异步的通知URL功能，可供开发者在应用的设置页面自行增加。\n\n\n填写页面跳转同步通知页面的URL(return_url)和异步的通知URL(notify_url)的页面在 应用列表-\n应用信息-\n支付设置 。\n\n\nBmob异步通知回调（支持微信和支付宝）\n\n\n\n\n\n\n必须保证服务器异步通知页面（notify_url）上无任何字符，如空格、HTML标签、开发系统自带抛出的异常提示信息等；\n\n\n\n\n\n\nBmob支付是用POST方式发送异步通知信息，因此该页面中获取参数的方式，如：\nrequest.Form(“out_trade_no”)、$_POST[‘out_trade_no’]；\n\n\n\n\n\n\n支付宝主动发起通知，该方式才会被启用；\n\n\n\n\n\n\n只有在Bmob的交易管理中存在该笔交易，且发生了交易状态的改变，Bmob才会通过该方式发起服务器通知；\n\n\n\n\n\n\n服务器间的交互，不像页面跳转同步通知可以在页面上显示出来，这种交互方式是不可见的；\n\n\n\n\n\n\n第一次交易状态改变（即时到账中此时交易状态是交易完成）时，不仅页面跳转同步通知页面会启用，而且服务器异步通知页面也会收到Bmob发来的处理结果通知；\n\n\n\n\n\n\n程序执行完后必须打印输出“success”（不包含引号）。如果商户反馈给Bmob的字符不是success这7个字符，Bmob服务器会不断重发通知，直到超过24小时。\n\n\n\n\n\n\n一般情况下，24小时以内完成8次通知（通知的间隔频率一般是：2m,10m,10m,1h,2h,6h,15h）；\n\n\n\n\n\n\n程序执行完成后，该页面不能执行页面跳转。如果执行页面跳转，Bmob会收不到success字符，会被Bmob服务器判定为该页面程序运行出现异常，而重发处理结果通知；\n\n\n\n\n\n\n异步通URL的调试与运行必须在服务器上，即互联网上能访问；\n\n\n\n\n\n\n当用户的服务端收到Bmob服务器异步通知的$_POST[‘out_trade_no’]时，应该调起一次查询订单的接口获得订单的状态是1，才能准确的判断该笔订单是成功;\n\n\n\n\n\n\n支付成功结果以Bmob后台订单列表或查询订单接口查询到的订单状态为准。", 
            "title": "开发文档"
        }, 
        {
            "location": "/pay/restful/#_1", 
            "text": "1.打款前请先在控制台填写以下信息   2.每月的1、2、16、17号为申请打款时间，15号、月尾日为打款时间，确保用户有半个月的追诉期。Bmob将收取10%手续费。", 
            "title": "打款需知"
        }, 
        {
            "location": "/pay/restful/#_2", 
            "text": "如图，可以在支付-支付配置处填入通知url。   这样在支付成功后会向该url（SDK使用异步通知URL，PHP等调用网页支付的使用同步返回URL）发送post请求，结构如下：  {\n     trade_status : 1 ,\n     out_trade_no : 809488d695ed42ec56b57546d2df94cc ,\n     trade_no : 2016033021001004810225607152 \n}  trade_status：表示支付状态，目前只有支付成功才产生回调，值恒为1.\nout_trade_no：Bmob返回的订单号\ntrade_no：支付宝或微信返回的订单号", 
            "title": "支付回调"
        }, 
        {
            "location": "/pay/restful/#_3", 
            "text": "请求描述  在进行支付请求后会返回  out_trade_no  订单号，使用该订单号可以查询订单的支付情况。  请求    url ：https://api.bmob.cn/1/pay/out_trade_no    method ：GET    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json  成功时响应    status: 200 OK    body:    {\n    name:订单或商品名称 \n    body:商品详情  \n    create_time:调起支付的时间  \n    out_trade_no:Bmob系统的订单号  \n    transaction_id:微信或支付宝的系统订单号\n    pay_type:WECHATPAY（微信支付）或ALIPAY（支付宝支付） \n    total_fee:订单总金额  \n    trade_state:NOTPAY（未支付）或 SUCCESS（支付成功）\n}  失败时返回请看  支付功能相关错误码  例子  一个查询例子如下：  curl -X GET \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  https://api.bmob.cn/1/pay/9f392618f449a71c6fcfdee38d2b29e4  其返回值：  {\n   name :  商品 ,\n   body :  商品详情 ,\n   create_time :  2015-03-24 11:14:58 ,\n   out_trade_no :  9f392618f449a71c6fcfdee38d2b29e4 ,\n   transaction_id :  2015061100001000330057820379 \n   pay_type :  WECHATPAY ,\n   total_fee : 0.01,\n   trade_state :  NOTPAY ,\n}", 
            "title": "查询订单"
        }, 
        {
            "location": "/pay/restful/#bmob", 
            "text": "Bmob 加入了支付后页面跳转同步通知页面的URL和异步的通知URL功能，可供开发者在应用的设置页面自行增加。  填写页面跳转同步通知页面的URL(return_url)和异步的通知URL(notify_url)的页面在 应用列表- 应用信息- 支付设置 。", 
            "title": "Bmob支付回调"
        }, 
        {
            "location": "/pay/restful/#bmob_1", 
            "text": "必须保证服务器异步通知页面（notify_url）上无任何字符，如空格、HTML标签、开发系统自带抛出的异常提示信息等；    Bmob支付是用POST方式发送异步通知信息，因此该页面中获取参数的方式，如：\nrequest.Form(“out_trade_no”)、$_POST[‘out_trade_no’]；    支付宝主动发起通知，该方式才会被启用；    只有在Bmob的交易管理中存在该笔交易，且发生了交易状态的改变，Bmob才会通过该方式发起服务器通知；    服务器间的交互，不像页面跳转同步通知可以在页面上显示出来，这种交互方式是不可见的；    第一次交易状态改变（即时到账中此时交易状态是交易完成）时，不仅页面跳转同步通知页面会启用，而且服务器异步通知页面也会收到Bmob发来的处理结果通知；    程序执行完后必须打印输出“success”（不包含引号）。如果商户反馈给Bmob的字符不是success这7个字符，Bmob服务器会不断重发通知，直到超过24小时。    一般情况下，24小时以内完成8次通知（通知的间隔频率一般是：2m,10m,10m,1h,2h,6h,15h）；    程序执行完成后，该页面不能执行页面跳转。如果执行页面跳转，Bmob会收不到success字符，会被Bmob服务器判定为该页面程序运行出现异常，而重发处理结果通知；    异步通URL的调试与运行必须在服务器上，即互联网上能访问；    当用户的服务端收到Bmob服务器异步通知的$_POST[‘out_trade_no’]时，应该调起一次查询订单的接口获得订单的状态是1，才能准确的判断该笔订单是成功;    支付成功结果以Bmob后台订单列表或查询订单接口查询到的订单状态为准。", 
            "title": "Bmob异步通知回调（支持微信和支付宝）"
        }, 
        {
            "location": "/sms/android/", 
            "text": "短信服务 Android 开发文档\n\n\n\n\n除了与用户相关的包括一键注册，手机号码登录等操作外，Bmob 还推出了单独的短信验证码服务。 在实际的应用中，开发者希望能够通过短信验证的方式来与用户进行某些重要操作的确认，你就可以在用户验证过手机号码的前提下，使用 Bmob 提供的短信验证码服务(\nBmob SMS SDK\n)。\n\n\n每个 Bmob 帐户有 30 条免费 (分别为SDK短信 15 条、RestApi短信 15 条) 的短信用于测试。超出免费条数后，需要购买短信条数才能继续使用。\n\n\n默认使用 【比目科技】 作为签名，可以在控制台创建自定义短信模板进行修改。\n\n\n下面是使用方法：\n\n\nSMS初始化\n\n\n此短信SDK可单独使用，调用如下方法完成 SDK 的初始化：\n\n\n方法 1：默认的初始化\n\n\nBmobSMS.initialize(context, Bmob_Application_ID);\n\n\n\n\n\n方法 2：从v1.2.0开始，提供了对应的接口回调，收到短信验证码能读取到验证码，读取后能自动填入EditText，能提高用户体验，你需要传对应的接口参数：\n\n\nBmobSMS.initialize(context,Bmob_Application_ID，new MySMSCodeListener());\n\nclass MySMSCodeListener implements SMSCodeListener{\n\n        @Override\n        public void onReceive(String content) {\n            if(et_smscode != null){\n                et_smscode.setText(content);\n            }\n        }\n\n    }\n\n\n\n\n\n注: 如果用第二种方式初始化，需要相应的广播和短信权限，详见 BmobSMSDemo。\n\n\n请求发送自定义的短信内容\n\n\n使用场景\n\n\n此方法允许开发者使用 Bmob 的短信功能灵活发送自定义的短信内容到用户的手机上，可运用于多种场景下，比如 \n发送祝福短信、推送消息、通知\n等\n\n\n使用前准备\n\n\n有两种方式可以使用自定义模板\n\n\n\n\n开发者可在Bmob后台提交身份证信息（\nBmob后台-\n账户管理-\n身份验证\n），并经\nBmob官方审核\n通过，可以自定义模板。\n\n\n不提交身份信息，直接提交短信模板，并经\nBmob官方审核\n通过，可以使用该模板。\n\n\n\n\n短信模板需要符以下要求，否则模板审核不予通过\n\n\n注意：请不要发送任何敏感内容，请不要定制广告、营销以诱导用户行为的信息。\n 具体如下：\n\n\n\n\n不得包含敏感关键，\n关键字列表文档下载\n，不得包含【】和 [] \n\n\n带联系方式（电话、qq微信、邮箱地址）的短信。如：“目前我司推出xx产品最新优惠，联系陈生了解详情，电话123-1234-1234”;\n\n\n诱导用户行为，特别是带超链接。如“我司推出新作xxx游戏，下载链接http://xxx.com”等；\n\n\n\n\n发现上述情况，针对通过身份审核的开发者，第一次给予警告，第二次将直接关闭接口使用，针对未通过身份审核的开发者，短信模板审核不给予通过。\n\n\n调用示例\n\n\nSimpleDateFormat format =new SimpleDateFormat(\nyyyy-MM-dd HH:mm:ss\n);\nString sendTime = format.format(new Date());\nBmobSMS.requestSMS(context, number, \n审核通过后的短信内容\n,sendTime,new RequestSMSCodeListener() {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        // TODO Auto-generated method stub\n        if(ex==null){//\n            Log.i(\nbmob\n,\n短信发送成功，短信id：\n+smsId);//用于查询本次短信发送详情\n        }else{\n            Log.i(\nbmob\n,\nerrorCode = \n+ex.getErrorCode()+\n,errorMsg = \n+ex.getLocalizedMessage());\n        }\n    }\n});\n\n\n\n\n注意：\n\n\n\n\n如果需要立即发送，sendTime设置为null(不是空字符串\"\");\n\n\nsendTime的格式为 \nyyyy-MM-dd HH:mm:ss\n,如果sendTime的格式不正确或者是这个时间是过去的时间，那么短信会立即发送;\n\n\nsmsId可用于查询该条短信的发送状态。\n\n\n\n\n请求发送短信验证码\n\n\n通过 \nrequestSMSCode\n 方式给绑定手机号的该用户发送指定短信模板的短信验证码：\n\n\nBmobSMS.requestSMSCode(context, \n11位手机号码\n, \n模板名称\n,new RequestSMSCodeListener() {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        // TODO Auto-generated method stub\n        if(ex==null){//验证码发送成功\n            Log.i(\nbmob\n, \n短信id：\n+smsId);//用于查询本次短信发送详情\n        }\n    }\n});\n\n\n\n\n短信默认模板：\n\n\n您的验证码是`%smscode%`，有效期为`%ttl%`分钟。您正在使用`%appname%`的验证码。【比目科技】\n\n\n\n注意：\n\n\n\n\n模板名称\n：模板名称需要开发者在应用的管理后台进行短信模板的添加工作，具体：\n短信服务\n-\n短信模板\n,之后点击创建即可,具体请看下图：\n\n\n\n\n\n\n\n\n\n\n只有审核通过之后的自定义短信模板才可以被使用，如果自定义的短信模板其状态显示\n审核中\n或者\n审核失败\n,再调用该方法则会以\n默认模板\n来发送验证码。\n\n\n\n\n\n\n模板中不能有【】和 [] ，否则审核不通过；\n\n\n\n\n\n\n如果你提交的短信模板无法发送，则有可能包含一些敏感监控词，具体可去Github下载  \n短信关键字监控参考文档\n 来查看提交内容是否合法。\n\n\n\n\n\n\n一天一个应用给同一手机号发送的短信不能超过10条，否则会报\n10010\n错误，其他错误码可查看：\n短信功能相关错误码\n 。\n\n\n\n\n\n\n验证验证码\n\n\n通过\nverifySmsCode\n方式可验证该短信验证码：\n\n\nBmobSMS.verifySmsCode(context,\n11位手机号码\n, \n验证码\n, new VerifySMSCodeListener() {\n\n    @Override\n    public void done(BmobException ex) {\n        // TODO Auto-generated method stub\n        if(ex==null){//短信验证码已验证成功\n            Log.i(\nbmob\n, \n验证通过\n);\n        }else{\n            Log.i(\nbmob\n, \n验证失败：code =\n+ex.getErrorCode()+\n,msg = \n+ex.getLocalizedMessage());\n        }\n    }\n});\n\n\n\n\n查询短信发送状态\n\n\n通过\nquerySmsState\n方式可查询指定\nsmsId\n的发送状态：\n\n\nBmobSMS.querySmsState(context, smsId, new QuerySMSStateListener() {\n\n    @Override\n    public void done(SmsState state, BmobException ex) {\n        // TODO Auto-generated method stub\n        if(ex==null){\n            Log.i(\nbmob\n,\n短信状态：\n+state.getSmsState()+\n,验证状态：\n+state.getVerifyState());\n        }\n    }\n});\n\n\n\n\n注：\nSmsState\n包含两种状态：\n\n\n\n\nsmsState\n（短信状态）   :SUCCESS（发送成功）、FAIL（发送失败）、SENDING(发送中)。\n\n\nverifyState\n（验证状态）:true(已验证)、false(未验证)。\n\n\n\n\n注意事项：\n\n\n\n\n实际计算的短信字数 = 模板的内容或自定义短信的内容字数 + 6。加上6是因为默认的签名【比目科技】占了6个字。\n\n\n实际计算的短信字数在70个字以下算1条。\n\n\n实际计算的短信字数超过70字的以67字为一条来计算的。也就是135个字数是计算为3条的。\n\n\n计算得到的短信条数在本条短信发送成功后将会从你的账户剩余的短信条数中扣除。\n\n\n短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条。\n\n\n\n\n购买事项\n\n\n短信条数只能输入整数，且不能少于1000条\n\n\n\n\n进入账号控制台，财务/财务统计点击购买短信即可。\n\n\n\n\n发票事宜\n\n\n购买金额满100元可提供发票，1000元以内的到付，1000元以上（含1000元）包邮。\n\n\n登录后台，在 \n财务\n -\n \n发票管理\n 页面可点击申请开票。", 
            "title": "开发文档"
        }, 
        {
            "location": "/sms/android/#android", 
            "text": "除了与用户相关的包括一键注册，手机号码登录等操作外，Bmob 还推出了单独的短信验证码服务。 在实际的应用中，开发者希望能够通过短信验证的方式来与用户进行某些重要操作的确认，你就可以在用户验证过手机号码的前提下，使用 Bmob 提供的短信验证码服务( Bmob SMS SDK )。  每个 Bmob 帐户有 30 条免费 (分别为SDK短信 15 条、RestApi短信 15 条) 的短信用于测试。超出免费条数后，需要购买短信条数才能继续使用。  默认使用 【比目科技】 作为签名，可以在控制台创建自定义短信模板进行修改。  下面是使用方法：", 
            "title": "短信服务 Android 开发文档"
        }, 
        {
            "location": "/sms/android/#sms", 
            "text": "此短信SDK可单独使用，调用如下方法完成 SDK 的初始化：  方法 1：默认的初始化  BmobSMS.initialize(context, Bmob_Application_ID);  方法 2：从v1.2.0开始，提供了对应的接口回调，收到短信验证码能读取到验证码，读取后能自动填入EditText，能提高用户体验，你需要传对应的接口参数：  BmobSMS.initialize(context,Bmob_Application_ID，new MySMSCodeListener());\n\nclass MySMSCodeListener implements SMSCodeListener{\n\n        @Override\n        public void onReceive(String content) {\n            if(et_smscode != null){\n                et_smscode.setText(content);\n            }\n        }\n\n    }  注: 如果用第二种方式初始化，需要相应的广播和短信权限，详见 BmobSMSDemo。", 
            "title": "SMS初始化"
        }, 
        {
            "location": "/sms/android/#_1", 
            "text": "", 
            "title": "请求发送自定义的短信内容"
        }, 
        {
            "location": "/sms/android/#_2", 
            "text": "此方法允许开发者使用 Bmob 的短信功能灵活发送自定义的短信内容到用户的手机上，可运用于多种场景下，比如  发送祝福短信、推送消息、通知 等", 
            "title": "使用场景"
        }, 
        {
            "location": "/sms/android/#_3", 
            "text": "有两种方式可以使用自定义模板   开发者可在Bmob后台提交身份证信息（ Bmob后台- 账户管理- 身份验证 ），并经 Bmob官方审核 通过，可以自定义模板。  不提交身份信息，直接提交短信模板，并经 Bmob官方审核 通过，可以使用该模板。", 
            "title": "使用前准备"
        }, 
        {
            "location": "/sms/android/#_4", 
            "text": "注意：请不要发送任何敏感内容，请不要定制广告、营销以诱导用户行为的信息。  具体如下：   不得包含敏感关键， 关键字列表文档下载 ，不得包含【】和 []   带联系方式（电话、qq微信、邮箱地址）的短信。如：“目前我司推出xx产品最新优惠，联系陈生了解详情，电话123-1234-1234”;  诱导用户行为，特别是带超链接。如“我司推出新作xxx游戏，下载链接http://xxx.com”等；   发现上述情况，针对通过身份审核的开发者，第一次给予警告，第二次将直接关闭接口使用，针对未通过身份审核的开发者，短信模板审核不给予通过。", 
            "title": "短信模板需要符以下要求，否则模板审核不予通过"
        }, 
        {
            "location": "/sms/android/#_5", 
            "text": "SimpleDateFormat format =new SimpleDateFormat( yyyy-MM-dd HH:mm:ss );\nString sendTime = format.format(new Date());\nBmobSMS.requestSMS(context, number,  审核通过后的短信内容 ,sendTime,new RequestSMSCodeListener() {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        // TODO Auto-generated method stub\n        if(ex==null){//\n            Log.i( bmob , 短信发送成功，短信id： +smsId);//用于查询本次短信发送详情\n        }else{\n            Log.i( bmob , errorCode =  +ex.getErrorCode()+ ,errorMsg =  +ex.getLocalizedMessage());\n        }\n    }\n});  注意：   如果需要立即发送，sendTime设置为null(不是空字符串\"\");  sendTime的格式为  yyyy-MM-dd HH:mm:ss ,如果sendTime的格式不正确或者是这个时间是过去的时间，那么短信会立即发送;  smsId可用于查询该条短信的发送状态。", 
            "title": "调用示例"
        }, 
        {
            "location": "/sms/android/#_6", 
            "text": "通过  requestSMSCode  方式给绑定手机号的该用户发送指定短信模板的短信验证码：  BmobSMS.requestSMSCode(context,  11位手机号码 ,  模板名称 ,new RequestSMSCodeListener() {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        // TODO Auto-generated method stub\n        if(ex==null){//验证码发送成功\n            Log.i( bmob ,  短信id： +smsId);//用于查询本次短信发送详情\n        }\n    }\n});  短信默认模板：  您的验证码是`%smscode%`，有效期为`%ttl%`分钟。您正在使用`%appname%`的验证码。【比目科技】  注意：   模板名称 ：模板名称需要开发者在应用的管理后台进行短信模板的添加工作，具体： 短信服务 - 短信模板 ,之后点击创建即可,具体请看下图：      只有审核通过之后的自定义短信模板才可以被使用，如果自定义的短信模板其状态显示 审核中 或者 审核失败 ,再调用该方法则会以 默认模板 来发送验证码。    模板中不能有【】和 [] ，否则审核不通过；    如果你提交的短信模板无法发送，则有可能包含一些敏感监控词，具体可去Github下载   短信关键字监控参考文档  来查看提交内容是否合法。    一天一个应用给同一手机号发送的短信不能超过10条，否则会报 10010 错误，其他错误码可查看： 短信功能相关错误码  。", 
            "title": "请求发送短信验证码"
        }, 
        {
            "location": "/sms/android/#_7", 
            "text": "通过 verifySmsCode 方式可验证该短信验证码：  BmobSMS.verifySmsCode(context, 11位手机号码 ,  验证码 , new VerifySMSCodeListener() {\n\n    @Override\n    public void done(BmobException ex) {\n        // TODO Auto-generated method stub\n        if(ex==null){//短信验证码已验证成功\n            Log.i( bmob ,  验证通过 );\n        }else{\n            Log.i( bmob ,  验证失败：code = +ex.getErrorCode()+ ,msg =  +ex.getLocalizedMessage());\n        }\n    }\n});", 
            "title": "验证验证码"
        }, 
        {
            "location": "/sms/android/#_8", 
            "text": "通过 querySmsState 方式可查询指定 smsId 的发送状态：  BmobSMS.querySmsState(context, smsId, new QuerySMSStateListener() {\n\n    @Override\n    public void done(SmsState state, BmobException ex) {\n        // TODO Auto-generated method stub\n        if(ex==null){\n            Log.i( bmob , 短信状态： +state.getSmsState()+ ,验证状态： +state.getVerifyState());\n        }\n    }\n});  注： SmsState 包含两种状态：   smsState （短信状态）   :SUCCESS（发送成功）、FAIL（发送失败）、SENDING(发送中)。  verifyState （验证状态）:true(已验证)、false(未验证)。   注意事项：   实际计算的短信字数 = 模板的内容或自定义短信的内容字数 + 6。加上6是因为默认的签名【比目科技】占了6个字。  实际计算的短信字数在70个字以下算1条。  实际计算的短信字数超过70字的以67字为一条来计算的。也就是135个字数是计算为3条的。  计算得到的短信条数在本条短信发送成功后将会从你的账户剩余的短信条数中扣除。  短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条。", 
            "title": "查询短信发送状态"
        }, 
        {
            "location": "/sms/android/#_9", 
            "text": "短信条数只能输入整数，且不能少于1000条   进入账号控制台，财务/财务统计点击购买短信即可。", 
            "title": "购买事项"
        }, 
        {
            "location": "/sms/android/#_10", 
            "text": "购买金额满100元可提供发票，1000元以内的到付，1000元以上（含1000元）包邮。  登录后台，在  财务  -   发票管理  页面可点击申请开票。", 
            "title": "发票事宜"
        }, 
        {
            "location": "/sms/ios/", 
            "text": "在一些应用场景下，你可能希望用户验证手机号码后才能进行一些操作，例如充值等。这些操作跟用户系统没有关系，可以通过我们提供的的短信验证API来实现。\n\n\n每个 Bmob 帐户有 10 条免费额度的短信数量用于测试，超过需要购买短信条数才能继续使用。\n\n\n默认使用 【比目科技】 作为签名，可以在控制台进行修改。\n\n\n短信服务除了集成成进原来的BmobSDK包外，还另外拆分了一个独立的SDK包，使用前请先导入 \nSystemConfiguration.framework\n，  \nJavaScriptCore.framework\n 和 \nCoreLocation.framework\n，注册方法还是 \n[Bmob registerWithAppKey:@\"\"];\n。\n\n\n请求发送自定义短信内容\n\n\n使用场景\n\n\n此方法允许开发者使用 Bmob 的短信功能灵活发送自定义的短信内容到用户的手机上，可运用于多种场景下，比如 \n发送祝福短信、推送消息、通知\n等\n\n\n使用前准备\n\n\n有两种方式可以使用自定义模板\n1.开发者可在Bmob后台提交身份证信息（\nBmob后台-\n账户管理-\n身份验证\n），并经\nBmob官方审核\n通过，可以自定义模板。\n2.不提交身份信息，直接提交短信模板，并经\nBmob官方审核\n通过，可以使用该模板。\n\n\n注意：请不要发送任何敏感内容，请不要定制广告、营销以诱导用户行为的信息。具体如下：\n1.不得包含敏感关键，\n关键字列表文档下载\n，不得包含【】和 [] \n2.带联系方式（电话、qq微信、邮箱地址）的短信。如：“目前我司推出xx产品最新优惠，联系陈生了解详情，电话123-1234-1234”;\n3.诱导用户行为，特别是带超链接。如“我司推出新作xxx游戏，下载链接http://xxx.com”等；\n当前有两种使用自定义模板\n\n\n发现上述情况，针对通过身份审核的开发者，第一次给予警告，第二次将直接关闭接口使用，针对通过模板审核请求使用的开发者，模板审核不给予通过。\n这个接口可让开发者使用 Bmob 的短信功能灵活发送短信内容到用户的手机上。\n\n\n发现上述情况，针对通过身份审核的开发者，第一次给予警告，第二次将直接关闭接口使用，针对通过模板审核请求使用的开发者，模板审核不给予通过。\n\n\n调用示例\n\n\n样例代码如下：\n\n\n    [BmobSMS requestSMSInbackgroundWithPhoneNumber:@\nphoneNumber\n Content:@\n您的XX服务还有XX时间到期，请及时续费。\n andSendTime:@\n2015-07-01 10:59:00\n resultBlock:^(int msgId, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            NSLog(@\nsmsId:%d\n,msgId);\n        }\n    }];\n\n\n\n\n说明：\n1.如果需要立即发送，sendTime设置为nil;\n2.sendTime的格式为 yyyy-MM-dd HH:mm:ss;\n3.如果sendTime的格式不正确或者是这个时间已经是过去的时间，那么短信会立即发送;\n4.smsID可用于查询短信的发送状态。\n\n\n\n\n获取短信验证码\n\n\n如下图所示，在使用获取短信验证码功能前可以先设置好几个模板以用于不同的功能。\n\n\n\n\n获取短信验证码可使用以下方法\n\n\n    //请求验证码\n    [BmobSMS requestSMSCodeInBackgroundWithPhoneNumber:mobilePhoneNumber andTemplate:@\ntest\n resultBlock:^(int msgId, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            //获得smsID\n            NSLog(@\nsms ID：%d\n,msgId);\n        }\n    }];\n\n\n\n\n注意，短信模板设置后需要通过审核才能使用，以下情况将使用Bmob设定的默认模板（Bmob 默认的模板是: 您的验证码是%smscode%，有效期为%ttl%分钟。您正在使用%appname%的验证码\n）。\n1.传入模板名为nil或者@“”;\n2.传入不存在的模板；\n3.传入的模板未通过审核\n\n\n\n\n验证短信验证码\n\n\n验证短信验证码状态\n\n\n\n    //验证\n    [BmobSMS verifySMSCodeInBackgroundWithPhoneNumber:mobilePhoneNumber andSMSCode:smsCode resultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@\n%@\n,@\n验证成功，可执行用户请求的操作\n);\n        } else {\n            NSLog(@\n%@\n,error);\n        }\n    }];\n\n}\n\n\n\n\n\n查询短信验证码状态\n\n\n查询短信验证码状态示例代码：\n\n\n    [BmobSMS querySMSCodeStateInBackgroundWithSMSId:smsId resultBlock:^(NSDictionary *dic, NSError *error) {\n        if (dic) {\n            NSLog(@\n%@\n,dic);\n        } else {\n            NSLog(@\n%@\n,error);\n        }\n    }];\n\n\n\n\n注：SmsState包含两种状态：\n\n1、smsState（短信状态） :SUCCESS（发送成功）、FAIL（发送失败）、SENDING(发送中)。\n\n2、verifyState（验证状态）:true(已验证)、false(未验证)。\n\n\n\n\n注意事项：\n\n\n关于短信条数的计算规则如下，\n\n\n\n\n实际计算的短信字数 = 模板的内容或自定义短信的内容字数 + 6。加上6是因为默认的签名【比目科技】占了6个字。\n\n\n实际计算的短信字数在70个字以下算1条。\n\n\n实际计算的短信字数超过70字的以67字为一条来计算的。也就是135个字数是计算为3条的。\n\n\n计算得到的短信条数在本条短信发送成功后将会从你的账户剩余的短信条数中扣除。\n\n\n\n\n短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条。\n\n\n购买事项\n\n\n购买方法\n\n\n短信条数只能输入整数，且不能少于1000条\n\n\n\n\n进入账号控制台，财务/财务统计点击购买短信即可。\n\n\n\n\n发票事宜\n\n\n购买金额满100可提供发票，1000元以内的到付，1000以上（含1000）包邮。\n\n\n登录后台提交工单，提供购买服务的订单号和开票信息。\n\n\n个人\n\n\n发票抬头、邮寄地址、联系人及电话\n\n\n企业\n\n\n公司名称、统一社会信用代码、开户行及账号、邮寄地址、联系人及电话", 
            "title": "开发文档"
        }, 
        {
            "location": "/sms/ios/#_1", 
            "text": "使用场景  此方法允许开发者使用 Bmob 的短信功能灵活发送自定义的短信内容到用户的手机上，可运用于多种场景下，比如  发送祝福短信、推送消息、通知 等  使用前准备  有两种方式可以使用自定义模板\n1.开发者可在Bmob后台提交身份证信息（ Bmob后台- 账户管理- 身份验证 ），并经 Bmob官方审核 通过，可以自定义模板。\n2.不提交身份信息，直接提交短信模板，并经 Bmob官方审核 通过，可以使用该模板。  注意：请不要发送任何敏感内容，请不要定制广告、营销以诱导用户行为的信息。具体如下：\n1.不得包含敏感关键， 关键字列表文档下载 ，不得包含【】和 [] \n2.带联系方式（电话、qq微信、邮箱地址）的短信。如：“目前我司推出xx产品最新优惠，联系陈生了解详情，电话123-1234-1234”;\n3.诱导用户行为，特别是带超链接。如“我司推出新作xxx游戏，下载链接http://xxx.com”等；\n当前有两种使用自定义模板  发现上述情况，针对通过身份审核的开发者，第一次给予警告，第二次将直接关闭接口使用，针对通过模板审核请求使用的开发者，模板审核不给予通过。\n这个接口可让开发者使用 Bmob 的短信功能灵活发送短信内容到用户的手机上。  发现上述情况，针对通过身份审核的开发者，第一次给予警告，第二次将直接关闭接口使用，针对通过模板审核请求使用的开发者，模板审核不给予通过。  调用示例  样例代码如下：      [BmobSMS requestSMSInbackgroundWithPhoneNumber:@ phoneNumber  Content:@ 您的XX服务还有XX时间到期，请及时续费。  andSendTime:@ 2015-07-01 10:59:00  resultBlock:^(int msgId, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            NSLog(@ smsId:%d ,msgId);\n        }\n    }];  说明：\n1.如果需要立即发送，sendTime设置为nil;\n2.sendTime的格式为 yyyy-MM-dd HH:mm:ss;\n3.如果sendTime的格式不正确或者是这个时间已经是过去的时间，那么短信会立即发送;\n4.smsID可用于查询短信的发送状态。", 
            "title": "请求发送自定义短信内容"
        }, 
        {
            "location": "/sms/ios/#_2", 
            "text": "如下图所示，在使用获取短信验证码功能前可以先设置好几个模板以用于不同的功能。   获取短信验证码可使用以下方法      //请求验证码\n    [BmobSMS requestSMSCodeInBackgroundWithPhoneNumber:mobilePhoneNumber andTemplate:@ test  resultBlock:^(int msgId, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            //获得smsID\n            NSLog(@ sms ID：%d ,msgId);\n        }\n    }];  注意，短信模板设置后需要通过审核才能使用，以下情况将使用Bmob设定的默认模板（Bmob 默认的模板是: 您的验证码是%smscode%，有效期为%ttl%分钟。您正在使用%appname%的验证码\n）。\n1.传入模板名为nil或者@“”;\n2.传入不存在的模板；\n3.传入的模板未通过审核", 
            "title": "获取短信验证码"
        }, 
        {
            "location": "/sms/ios/#_3", 
            "text": "验证短信验证码状态  \n    //验证\n    [BmobSMS verifySMSCodeInBackgroundWithPhoneNumber:mobilePhoneNumber andSMSCode:smsCode resultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@ %@ ,@ 验证成功，可执行用户请求的操作 );\n        } else {\n            NSLog(@ %@ ,error);\n        }\n    }];\n\n}", 
            "title": "验证短信验证码"
        }, 
        {
            "location": "/sms/ios/#_4", 
            "text": "查询短信验证码状态示例代码：      [BmobSMS querySMSCodeStateInBackgroundWithSMSId:smsId resultBlock:^(NSDictionary *dic, NSError *error) {\n        if (dic) {\n            NSLog(@ %@ ,dic);\n        } else {\n            NSLog(@ %@ ,error);\n        }\n    }];  注：SmsState包含两种状态：\n\n1、smsState（短信状态） :SUCCESS（发送成功）、FAIL（发送失败）、SENDING(发送中)。\n\n2、verifyState（验证状态）:true(已验证)、false(未验证)。  注意事项：  关于短信条数的计算规则如下，   实际计算的短信字数 = 模板的内容或自定义短信的内容字数 + 6。加上6是因为默认的签名【比目科技】占了6个字。  实际计算的短信字数在70个字以下算1条。  实际计算的短信字数超过70字的以67字为一条来计算的。也就是135个字数是计算为3条的。  计算得到的短信条数在本条短信发送成功后将会从你的账户剩余的短信条数中扣除。   短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条。", 
            "title": "查询短信验证码状态"
        }, 
        {
            "location": "/sms/ios/#_5", 
            "text": "", 
            "title": "购买事项"
        }, 
        {
            "location": "/sms/ios/#_6", 
            "text": "短信条数只能输入整数，且不能少于1000条   进入账号控制台，财务/财务统计点击购买短信即可。", 
            "title": "购买方法"
        }, 
        {
            "location": "/sms/ios/#_7", 
            "text": "购买金额满100可提供发票，1000元以内的到付，1000以上（含1000）包邮。  登录后台提交工单，提供购买服务的订单号和开票信息。  个人  发票抬头、邮寄地址、联系人及电话  企业  公司名称、统一社会信用代码、开户行及账号、邮寄地址、联系人及电话", 
            "title": "发票事宜"
        }, 
        {
            "location": "/sms/javascript/", 
            "text": "短信服务的API集成在BmobSDK中，因此不熟悉的朋友在使用前先可以了解一下BmobSDK的集成\nJS 快速入门\n\n\n在一些应用场景下，你可能希望用户验证手机号码后才能进行一些操作，例如充值等。这些操作跟用户系统没有关系，可以通过我们提供的的短信验证API来实现。\n\n\n每个 \nBmob\n 帐户有 10 个免费额度的短信数量，超过需要购买短信条数才能继续使用。\n\n\n为了保障短信的下发速度和送达率，\nBmob\n 为所有用户申请了一致的独享通道，默认使用 \n【云验证】\n 作为签名，且不可更改。\n\n\n请求发送自定义的短信内容\n\n\n使用场景\n\n\n此方法允许开发者使用 Bmob 的短信功能灵活发送自定义的短信内容到用户的手机上，可运用于多种场景下，比如 \n发送祝福短信、推送消息、通知\n等\n\n\n使用前准备\n\n\n有两种方式可以使用自定义模板\n1.开发者可在Bmob后台提交身份证信息（\nBmob后台-\n账户管理-\n身份验证\n），并经\nBmob官方审核\n通过，可以自定义模板。\n2.不提交身份信息，直接提交短信模板，并经\nBmob官方审核\n通过，可以使用该模板。\n\n\n短信模板需要符以下要求，否则模板审核不予通过。\n\n\n注意：请不要发送任何敏感内容，请不要定制广告、营销以诱导用户行为的信息。具体如下：\n1.不得包含敏感关键，\n关键字列表文档下载\n，不得包含【】和 [] \n2.带联系方式（电话、qq微信、邮箱地址）的短信。如：“目前我司推出xx产品最新优惠，联系陈生了解详情，电话123-1234-1234”;\n3.诱导用户行为，特别是带超链接。如“我司推出新作xxx游戏，下载链接http://xxx.com”等；\n当前有两种使用自定义模板\n\n\n发现上述情况，针对通过身份审核的开发者，第一次给予警告，第二次将直接关闭接口使用，针对通过模板审核请求使用的开发者，模板审核不给予通过。\n\n\n调用示例\n\n\n输入手机号码、短信内容，就可以给用户的手机号码发送自定义的短信内容了，以下的content只要在不违反相关规定的前提下，你可以随意输入：\n\n\nBmob.Sms.requestSms({\nmobilePhoneNumber\n: \n131xxxxxxxx\n,\ncontent\n: \n您的验证码是：222222, 有效期是10分钟。\n} ).then(function(obj) {\n  alert(\nsmsId:\n+obj.smsId); //\n}, function(err){\n  alert(\n发送失败:\n+err);\n});\n\n\n\n\n你还可以选择定时发送，比如未来的某一时刻给某个手机发送一条短信，sendTime的格式必须是YYYY-mm-dd HH:ii:ss， 如: 2015-05-26 12:13:14，请求如下：\n\n\nBmob.Sms.requestSms({\nmobilePhoneNumber\n: \n131xxxxxxxx\n,\ncontent\n: \n您的验证码是：222222, 有效期是10分钟。\n,\nsendTime\n: \n2016-05-26 12:13:14\n} ).then(function(obj) {\n  alert(\nsmsId:\n+obj.smsId); //\n}, function(err){\n  alert(\n发送失败:\n+err);\n});\n\n\n\n\n成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该条短信是否发送成功：\n\n\n{\n    \nsmsId\n: 1232222\n}\n\n\n\n\n请求短信验证码\n\n\n如果没有在管理后台创建好模板，可使用默认的模板，\nBmob\n 默认的模板是: \n您的验证码是%smscode%，有效期为%ttl%分钟。您正在使用%appname%的验证码\n\n\n使用默认的模板请求短信验证码：\n\n\nBmob.Sms.requestSmsCode({\nmobilePhoneNumber\n: \n131xxxxxxxx\n} ).then(function(obj) {\n  alert(\nsmsId:\n+obj.smsId); //\n}, function(err){\n  alert(\n发送失败:\n+err);\n});\n\n\n\n\n成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该短信验证码是否发送成功和是否验证过：\n\n\n{\n    \nsmsId\n: 1232222\n}\n\n\n\n\n如果你已经在 \nBmob\n 后台设置了自己的模板，并已经是审核通过了，则可以使用自己的模板给用户的手机号码发送短信验证码了：\n\n\nBmob.Sms.requestSmsCode({\nmobilePhoneNumber\n: \n131xxxxxxxx\n, \ntemplate\n:\n注册模板\n} ).then(function(obj) {\n  alert(\nsmsId:\n+obj.smsId); //\n}, function(err){\n  alert(\n发送失败:\n+err);\n});\n\n\n\n\n成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该短信验证码是否发送成功和是否验证过：\n\n\n{\n    \nsmsId\n: 1232222\n}\n\n\n\n\n验证短信验证码\n\n\n通过以下接口，你可以验证用户输入的验证码是否是有效的：\n\n\nBmob.Sms.verifySmsCode(\n131xxxxxxxx\n, 125466).then(function(obj) {\n  alert(\nmsg:\n+obj.msg); //\n}, function(err){\n  alert(\n发送失败:\n+err);\n});\n\n\n\n\n成功返回以下JSON，表明验证码验证通过：\n\n\n{\n    \nmsg\n:\nok\n\n}\n\n\n\n\n查询短信状态\n\n\n通过以下接口，你可以查询某条短信是否发送成功，如果是使用了Bmob的模板的话还能查询到是否被验证过，其实:smsId是请求短信验证码API返回的smsId值：\n\n\nBmob.Sms.querySms(6817361).then(function(obj) {\n  alert(\nstatus:\n+obj.sms_state); //\n}, function(err){\n  alert(\n发送失败:\n+err);\n});\n\n\n\n\n成功返回以下JSON：\n\n\n{\n  \nsms_state\n: \nSENDING\n, \n  \nverify_state\n: false\n}\n\n\n\n\n其中sms_state是发送状态，有值: SENDING-发送中，FAIL-发送失败 SUCCESS-发送成功\n其中verify_state是验证码是否验证状态， 有值: true-已验证 false-未验证\n\n\n购买事项\n\n\n购买方法\n\n\n短信条数只能输入整数，且不能少于1000条\n\n\n\n\n进入账号控制台，财务/财务统计点击购买短信即可。\n\n\n\n\n发票事宜\n\n\n购买金额满100可提供发票，1000元以内的到付，1000以上（含1000）包邮。\n\n\n登录后台提交工单，提供购买服务的订单号和开票信息。\n\n\n个人\n\n\n发票抬头、邮寄地址、联系人及电话\n\n\n企业\n\n\n公司名称、统一社会信用代码、开户行及账号、邮寄地址、联系人及电话", 
            "title": "开发文档"
        }, 
        {
            "location": "/sms/javascript/#_1", 
            "text": "使用场景  此方法允许开发者使用 Bmob 的短信功能灵活发送自定义的短信内容到用户的手机上，可运用于多种场景下，比如  发送祝福短信、推送消息、通知 等  使用前准备  有两种方式可以使用自定义模板\n1.开发者可在Bmob后台提交身份证信息（ Bmob后台- 账户管理- 身份验证 ），并经 Bmob官方审核 通过，可以自定义模板。\n2.不提交身份信息，直接提交短信模板，并经 Bmob官方审核 通过，可以使用该模板。  短信模板需要符以下要求，否则模板审核不予通过。  注意：请不要发送任何敏感内容，请不要定制广告、营销以诱导用户行为的信息。具体如下：\n1.不得包含敏感关键， 关键字列表文档下载 ，不得包含【】和 [] \n2.带联系方式（电话、qq微信、邮箱地址）的短信。如：“目前我司推出xx产品最新优惠，联系陈生了解详情，电话123-1234-1234”;\n3.诱导用户行为，特别是带超链接。如“我司推出新作xxx游戏，下载链接http://xxx.com”等；\n当前有两种使用自定义模板  发现上述情况，针对通过身份审核的开发者，第一次给予警告，第二次将直接关闭接口使用，针对通过模板审核请求使用的开发者，模板审核不给予通过。  调用示例  输入手机号码、短信内容，就可以给用户的手机号码发送自定义的短信内容了，以下的content只要在不违反相关规定的前提下，你可以随意输入：  Bmob.Sms.requestSms({ mobilePhoneNumber :  131xxxxxxxx , content :  您的验证码是：222222, 有效期是10分钟。 } ).then(function(obj) {\n  alert( smsId: +obj.smsId); //\n}, function(err){\n  alert( 发送失败: +err);\n});  你还可以选择定时发送，比如未来的某一时刻给某个手机发送一条短信，sendTime的格式必须是YYYY-mm-dd HH:ii:ss， 如: 2015-05-26 12:13:14，请求如下：  Bmob.Sms.requestSms({ mobilePhoneNumber :  131xxxxxxxx , content :  您的验证码是：222222, 有效期是10分钟。 , sendTime :  2016-05-26 12:13:14 } ).then(function(obj) {\n  alert( smsId: +obj.smsId); //\n}, function(err){\n  alert( 发送失败: +err);\n});  成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该条短信是否发送成功：  {\n     smsId : 1232222\n}", 
            "title": "请求发送自定义的短信内容"
        }, 
        {
            "location": "/sms/javascript/#_2", 
            "text": "如果没有在管理后台创建好模板，可使用默认的模板， Bmob  默认的模板是:  您的验证码是%smscode%，有效期为%ttl%分钟。您正在使用%appname%的验证码  使用默认的模板请求短信验证码：  Bmob.Sms.requestSmsCode({ mobilePhoneNumber :  131xxxxxxxx } ).then(function(obj) {\n  alert( smsId: +obj.smsId); //\n}, function(err){\n  alert( 发送失败: +err);\n});  成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该短信验证码是否发送成功和是否验证过：  {\n     smsId : 1232222\n}  如果你已经在  Bmob  后台设置了自己的模板，并已经是审核通过了，则可以使用自己的模板给用户的手机号码发送短信验证码了：  Bmob.Sms.requestSmsCode({ mobilePhoneNumber :  131xxxxxxxx ,  template : 注册模板 } ).then(function(obj) {\n  alert( smsId: +obj.smsId); //\n}, function(err){\n  alert( 发送失败: +err);\n});  成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该短信验证码是否发送成功和是否验证过：  {\n     smsId : 1232222\n}", 
            "title": "请求短信验证码"
        }, 
        {
            "location": "/sms/javascript/#_3", 
            "text": "通过以下接口，你可以验证用户输入的验证码是否是有效的：  Bmob.Sms.verifySmsCode( 131xxxxxxxx , 125466).then(function(obj) {\n  alert( msg: +obj.msg); //\n}, function(err){\n  alert( 发送失败: +err);\n});  成功返回以下JSON，表明验证码验证通过：  {\n     msg : ok \n}", 
            "title": "验证短信验证码"
        }, 
        {
            "location": "/sms/javascript/#_4", 
            "text": "通过以下接口，你可以查询某条短信是否发送成功，如果是使用了Bmob的模板的话还能查询到是否被验证过，其实:smsId是请求短信验证码API返回的smsId值：  Bmob.Sms.querySms(6817361).then(function(obj) {\n  alert( status: +obj.sms_state); //\n}, function(err){\n  alert( 发送失败: +err);\n});  成功返回以下JSON：  {\n   sms_state :  SENDING , \n   verify_state : false\n}  其中sms_state是发送状态，有值: SENDING-发送中，FAIL-发送失败 SUCCESS-发送成功\n其中verify_state是验证码是否验证状态， 有值: true-已验证 false-未验证", 
            "title": "查询短信状态"
        }, 
        {
            "location": "/sms/javascript/#_5", 
            "text": "", 
            "title": "购买事项"
        }, 
        {
            "location": "/sms/javascript/#_6", 
            "text": "短信条数只能输入整数，且不能少于1000条   进入账号控制台，财务/财务统计点击购买短信即可。", 
            "title": "购买方法"
        }, 
        {
            "location": "/sms/javascript/#_7", 
            "text": "购买金额满100可提供发票，1000元以内的到付，1000以上（含1000）包邮。  登录后台提交工单，提供购买服务的订单号和开票信息。  个人  发票抬头、邮寄地址、联系人及电话  企业  公司名称、统一社会信用代码、开户行及账号、邮寄地址、联系人及电话", 
            "title": "发票事宜"
        }, 
        {
            "location": "/sms/php/", 
            "text": "短信服务的API集成在BmobSDK中，因此不熟悉的朋友在使用前先可以了解一下BmobSDK的集成\nPHP 快速入门\n\n\n在一些应用场景下，你可能希望用户验证手机号码后才能进行一些操作，例如充值等。这些操作跟用户系统没有关系，可以通过我们提供的的短信验证API来实现。\n\n\n每个 \nBmob\n 帐户有 10 个免费额度的短信数量，超过需要购买短信条数才能继续使用。\n\n\n为了保障短信的下发速度和送达率，\nBmob\n 为所有用户申请了一致的独享通道，默认使用 \n【比目科技】\n 作为签名，且不可更改。\n\n\n请求发送自定义的短信内容\n\n\n使用场景\n\n\n此方法允许开发者使用 Bmob 的短信功能灵活发送自定义的短信内容到用户的手机上，可运用于多种场景下，比如 \n发送祝福短信、推送消息、通知\n等\n\n\n使用前准备\n\n\n有两种方式可以使用自定义模板\n1.开发者可在Bmob后台提交身份证信息（\nBmob后台-\n账户管理-\n身份验证\n），并经\nBmob官方审核\n通过，可以自定义模板。\n2.不提交身份信息，直接提交短信模板，并经\nBmob官方审核\n通过，可以使用该模板。\n\n\n短信模板需要符以下要求，否则模板审核不予通过。\n\n\n注意：请不要发送任何敏感内容，请不要定制广告、营销以诱导用户行为的信息。具体如下：\n1.不得包含敏感关键，\n关键字列表文档下载\n，不得包含【】和 [] \n2.带联系方式（电话、qq微信、邮箱地址）的短信。如：“目前我司推出xx产品最新优惠，联系陈生了解详情，电话123-1234-1234”;\n3.诱导用户行为，特别是带超链接。如“我司推出新作xxx游戏，下载链接http://xxx.com”等；\n当前有两种使用自定义模板\n\n\n发现上述情况，针对通过身份审核的开发者，第一次给予警告，第二次将直接关闭接口使用，针对通过模板审核请求使用的开发者，模板审核不给予通过。\n\n\n调用示例\n\n\n输入手机号码、短信内容，就可以给用户的手机号码发送自定义的短信内容了，以下的content只要在不违反相关规定的前提下，你可以随意输入：\n\n\n$bmobSms = new BmobSms();\n$res = $bmobSms-\nsendSms(\n131xxxxxxxx\n, \n您的验证码是：222222, 有效期是10分钟。\n); //发送短信\n\n\n\n\n你还可以选择定时发送，比如未来的某一时刻给某个手机发送一条短信，sendTime的格式必须是YYYY-mm-dd HH:ii:ss， 如: 2015-05-26 12:13:14，请求如下：\n\n\n$res = $bmobSms-\nsendSms(\n131xxxxxxxx\n, \n您的验证码是：222222, 有效期是10分钟。\n, \n2016-05-26 12:13:14\n ); //发送短信\n\n\n\n\n\n成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该条短信是否发送成功：\n\n\narray(\n    \nsmsId\n=\n 1232222\n)\n\n\n\n\n请求短信验证码\n\n\n如果没有在管理后台创建好模板，可使用默认的模板，\nBmob\n 默认的模板是: \n您的验证码是%smscode%，有效期为%ttl%分钟。您正在使用%appname%的验证码\n\n\n使用默认的模板请求短信验证码：\n\n\n$res = $bmobSms-\nsendSmsVerifyCode(\n131xxxxxxxx\n); \n\n\n\n\n成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该条短信是否发送成功：\n\n\narray(\n    \nsmsId\n=\n 1232222\n)\n\n\n\n\n如果你已经在 \nBmob\n 后台设置了自己的模板，并已经是审核通过了，则可以使用自己的模板给用户的手机号码发送短信验证码了：\n\n\n$res = $bmobSms-\nsendSmsVerifyCode(\n131xxxxxxxx\n, \n注册模板\n);  //发送短信验证码\n\n\n\n\n成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该短信验证码是否发送成功和是否验证过：\n\n\n{\n    \nsmsId\n: 1232222\n}\n\n\n\n\n验证短信验证码\n\n\n通过以下接口，你可以验证用户输入的验证码是否是有效的：\n\n\n$res = $bmobSms-\nverifySmsCode(\n131xxxxxxxx\n,\n028584\n); \n\n\n\n\n成功返回以下数据，表明验证码验证通过：\n\n\narray(\n    \nmsg\n=\n \nok\n\n)\n\n\n\n\n查询短信状态\n\n\n通过以下接口，你可以查询某条短信是否发送成功，如果是使用了Bmob的模板的话还能查询到是否被验证过，其实:smsId是请求短信验证码API返回的smsId值：\n\n\n$res = $bmobSms-\nquerySms(\n6466181\n);  //查询短信状态\n\n\n\n\n\n成功返回以下JSON：\n\n\narray(\n  \nsms_state\n=\n \nSENDING\n, \n  \nverify_state\n=\n false\n)\n\n\n\n\n其中sms_state是发送状态，有值: SENDING-发送中，FAIL-发送失败 SUCCESS-发送成功\n其中verify_state是验证码是否验证状态， 有值: true-已验证 false-未验证\n\n\n注意事项\n\n\n关于短信条数的计算规则如下:\n\n\n\n\n实际计算的短信字数 = 模板的内容或自定义短信的内容字数 + 6。加上6是因为默认的签名【比目科技】占了6个字。\n\n\n实际计算的短信字数在70个字以下算1条。\n\n\n实际计算的短信字数超过70字的以67字为一条来计算的。也就是135个字数是计算为3条的。\n\n\n计算得到的短信条数在本条短信发送成功后将会从你的账户剩余的短信条数中扣除。\n\n\n\n\n短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条\n\n\n购买事项\n\n\n购买方法\n\n\n短信条数只能输入整数，且不能少于1000条\n\n\n\n\n进入账号控制台，财务/财务统计点击购买短信即可。\n\n\n\n\n发票事宜\n\n\n购买金额满100可提供发票，1000元以内的到付，1000以上（含1000）包邮。\n\n\n登录后台提交工单，提供购买服务的订单号和开票信息。\n\n\n个人\n\n\n发票抬头、邮寄地址、联系人及电话\n\n\n企业\n\n\n公司名称、统一社会信用代码、开户行及账号、邮寄地址、联系人及电话", 
            "title": "开发文档"
        }, 
        {
            "location": "/sms/php/#_1", 
            "text": "使用场景  此方法允许开发者使用 Bmob 的短信功能灵活发送自定义的短信内容到用户的手机上，可运用于多种场景下，比如  发送祝福短信、推送消息、通知 等  使用前准备  有两种方式可以使用自定义模板\n1.开发者可在Bmob后台提交身份证信息（ Bmob后台- 账户管理- 身份验证 ），并经 Bmob官方审核 通过，可以自定义模板。\n2.不提交身份信息，直接提交短信模板，并经 Bmob官方审核 通过，可以使用该模板。  短信模板需要符以下要求，否则模板审核不予通过。  注意：请不要发送任何敏感内容，请不要定制广告、营销以诱导用户行为的信息。具体如下：\n1.不得包含敏感关键， 关键字列表文档下载 ，不得包含【】和 [] \n2.带联系方式（电话、qq微信、邮箱地址）的短信。如：“目前我司推出xx产品最新优惠，联系陈生了解详情，电话123-1234-1234”;\n3.诱导用户行为，特别是带超链接。如“我司推出新作xxx游戏，下载链接http://xxx.com”等；\n当前有两种使用自定义模板  发现上述情况，针对通过身份审核的开发者，第一次给予警告，第二次将直接关闭接口使用，针对通过模板审核请求使用的开发者，模板审核不给予通过。  调用示例  输入手机号码、短信内容，就可以给用户的手机号码发送自定义的短信内容了，以下的content只要在不违反相关规定的前提下，你可以随意输入：  $bmobSms = new BmobSms();\n$res = $bmobSms- sendSms( 131xxxxxxxx ,  您的验证码是：222222, 有效期是10分钟。 ); //发送短信  你还可以选择定时发送，比如未来的某一时刻给某个手机发送一条短信，sendTime的格式必须是YYYY-mm-dd HH:ii:ss， 如: 2015-05-26 12:13:14，请求如下：  $res = $bmobSms- sendSms( 131xxxxxxxx ,  您的验证码是：222222, 有效期是10分钟。 ,  2016-05-26 12:13:14  ); //发送短信  成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该条短信是否发送成功：  array(\n     smsId =  1232222\n)", 
            "title": "请求发送自定义的短信内容"
        }, 
        {
            "location": "/sms/php/#_2", 
            "text": "如果没有在管理后台创建好模板，可使用默认的模板， Bmob  默认的模板是:  您的验证码是%smscode%，有效期为%ttl%分钟。您正在使用%appname%的验证码  使用默认的模板请求短信验证码：  $res = $bmobSms- sendSmsVerifyCode( 131xxxxxxxx );   成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该条短信是否发送成功：  array(\n     smsId =  1232222\n)  如果你已经在  Bmob  后台设置了自己的模板，并已经是审核通过了，则可以使用自己的模板给用户的手机号码发送短信验证码了：  $res = $bmobSms- sendSmsVerifyCode( 131xxxxxxxx ,  注册模板 );  //发送短信验证码  成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该短信验证码是否发送成功和是否验证过：  {\n     smsId : 1232222\n}", 
            "title": "请求短信验证码"
        }, 
        {
            "location": "/sms/php/#_3", 
            "text": "通过以下接口，你可以验证用户输入的验证码是否是有效的：  $res = $bmobSms- verifySmsCode( 131xxxxxxxx , 028584 );   成功返回以下数据，表明验证码验证通过：  array(\n     msg =   ok \n)", 
            "title": "验证短信验证码"
        }, 
        {
            "location": "/sms/php/#_4", 
            "text": "通过以下接口，你可以查询某条短信是否发送成功，如果是使用了Bmob的模板的话还能查询到是否被验证过，其实:smsId是请求短信验证码API返回的smsId值：  $res = $bmobSms- querySms( 6466181 );  //查询短信状态  成功返回以下JSON：  array(\n   sms_state =   SENDING , \n   verify_state =  false\n)  其中sms_state是发送状态，有值: SENDING-发送中，FAIL-发送失败 SUCCESS-发送成功\n其中verify_state是验证码是否验证状态， 有值: true-已验证 false-未验证  注意事项  关于短信条数的计算规则如下:   实际计算的短信字数 = 模板的内容或自定义短信的内容字数 + 6。加上6是因为默认的签名【比目科技】占了6个字。  实际计算的短信字数在70个字以下算1条。  实际计算的短信字数超过70字的以67字为一条来计算的。也就是135个字数是计算为3条的。  计算得到的短信条数在本条短信发送成功后将会从你的账户剩余的短信条数中扣除。   短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条", 
            "title": "查询短信状态"
        }, 
        {
            "location": "/sms/php/#_5", 
            "text": "", 
            "title": "购买事项"
        }, 
        {
            "location": "/sms/php/#_6", 
            "text": "短信条数只能输入整数，且不能少于1000条   进入账号控制台，财务/财务统计点击购买短信即可。", 
            "title": "购买方法"
        }, 
        {
            "location": "/sms/php/#_7", 
            "text": "购买金额满100可提供发票，1000元以内的到付，1000以上（含1000）包邮。  登录后台提交工单，提供购买服务的订单号和开票信息。  个人  发票抬头、邮寄地址、联系人及电话  企业  公司名称、统一社会信用代码、开户行及账号、邮寄地址、联系人及电话", 
            "title": "发票事宜"
        }, 
        {
            "location": "/sms/restful/", 
            "text": "在一些应用场景下，你可能希望用户验证手机号码后才能进行一些操作，例如充值等。这些操作跟用户系统没有关系，可以通过我们提供的的短信验证API来实现。\n\n\n每个 Bmob 帐户有 10 条免费额度的短信数量用于测试，超过需要购买短信条数才能继续使用。\n\n\n默认使用 【比目科技】 作为签名，可以在控制台进行修改。\n\n\n请求发送短信内容\n\n\n请求发送自定义的短信内容\n\n\n使用场景\n\n\n此方法允许开发者使用 Bmob 的短信功能灵活发送自定义的短信内容到用户的手机上，可运用于多种场景下，比如 \n发送祝福短信、推送消息、通知\n等\n\n\n使用前准备\n\n\n有两种方式可以使用自定义模板\n1.开发者可在Bmob后台提交身份证信息（\nBmob后台-\n账户管理-\n身份验证\n），并经\nBmob官方审核\n通过，可以自定义模板。\n2.不提交身份信息，直接提交短信模板，并经\nBmob官方审核\n通过，可以使用该模板。\n\n\n短信模板需要符以下要求，否则模板审核不予通过。\n\n\n注意：请不要发送任何敏感内容，请不要定制广告、营销以诱导用户行为的信息。具体如下：\n1.不得包含敏感关键，\n关键字列表文档下载\n，不得包含【】和 [] \n2.带联系方式（电话、qq微信、邮箱地址）的短信。如：“目前我司推出xx产品最新优惠，联系陈生了解详情，电话123-1234-1234”;\n3.诱导用户行为，特别是带超链接。如“我司推出新作xxx游戏，下载链接http://xxx.com”等；\n当前有两种使用自定义模板\n\n\n发现上述情况，针对通过身份审核的开发者，第一次给予警告，第二次将直接关闭接口使用，针对通过模板审核请求使用的开发者，模板审核不给予通过。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/requestSms\n\n\n\n\n\n\nmethod ：POST\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  \nmobilePhoneNumber\n: phoneNum,\n  \ncontent\n: content,\n  \nsendTime\n:YYYY-mm-dd HH:ii:ss (选填)\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n    \nsmsId\n: smsId（可用于后面使用查询短信状态接口来查询该条短信是否发送成功）\n}\n\n\n\n\n例子\n\n\n输入手机号码、短信内容，就可以给用户的手机号码发送自定义的短信内容了，以下的content只要在不违反相关规定的前提下，你可以随意输入：\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\nmobilePhoneNumber\n: \n186xxxxxxxx\n, \ncontent\n:\n您的验证码是：222222, 有效期是10分钟。\n}' \\\n  https://api.bmob.cn/1/requestSms\n\n\n\n\n你可以选择定时发送，比如未来的某一时刻给某个手机发送一条短信，sendTime的格式必须是YYYY-mm-dd HH:ii:ss， 如: 2015-05-26 12:13:14，请求如下：\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\nmobilePhoneNumber\n: \n186xxxxxxxx\n, \ncontent\n:\n您的验证码是：222222, 有效期是10分钟。感谢您使用Bmob。\n, \nsendTime\n:\n2016-05-26 12:13:14\n}' \\\n  https://api.bmob.cn/1/requestSms\n\n\n\n\n成功返回短信验证码ID：\n\n\n{\n    \nsmsId\n: 1232222\n}\n\n\n\n\n请求短信验证码\n\n\n请求描述\n\n\n使用特定的模板请求验证码，如果没有在管理后台创建好模板，可使用默认的模板，\nBmob\n 默认的模板是: \n您的验证码是%smscode%，有效期为%ttl%分钟。您正在使用%appname%的验证码\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/requestSmsCode\n\n\n\n\n\n\nmethod ：POST\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  \nmobilePhoneNumber\n: phoneNum,\n  \ntemplate\n: templateName(选填，需先在管理后台创建)\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n    \nsmsId\n: smsId（可用于后面使用查询短信状态接口来查询该条短信是否发送成功）\n}\n\n\n\n\n例子\n\n\n使用默认的模板请求短信验证码：\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\nmobilePhoneNumber\n: \n186xxxxxxxx\n}' \\\n  https://api.bmob.cn/1/requestSmsCode\n\n\n\n\n成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该短信验证码是否发送成功和是否验证过：\n\n\n{\n    \nsmsId\n: 1232222\n}\n\n\n\n\n如果你已经在 \nBmob\n 后台设置了自己的模板，并已经是审核通过了，则可以使用自己的模板给用户的手机号码发送短信验证码了：\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\nmobilePhoneNumber\n: \n186xxxxxxxx\n, \ntemplate\n:\n注册模板\n}' \\\n  https://api.bmob.cn/1/requestSmsCode\n\n\n\n\n成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该短信验证码是否发送成功和是否验证过：\n\n\n{\n    \nsmsId\n: 1232222\n}\n\n\n\n\n验证短信验证码\n\n\n请求描述\n\n\n通过以下接口，你可以验证用户输入的验证码是否是有效。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/verifySmsCode/smsCode(用户收到的6位短信验证码)\n\n\n\n\n\n\nmethod ：POST\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody:\n\n\n\n\n{\n  \nmobilePhoneNumber\n: phoneNum\n}\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n    \nmsg\n:\nok\n\n}\n\n\n\n\n例子\n\n\n例如，要验证 \n186xxxxxxxx\n 号码输入的 \n876845\n 验证码是否正确可使用以下请求：\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\nmobilePhoneNumber\n: \n186xxxxxxxx\n}' \\\n  https://api.bmob.cn/1/verifySmsCode/876845\n\n\n\n\n查询短信状态\n\n\n请求描述\n\n\n通过以下接口，你可以查询某条短信是否发送成功，如果是使用了验证码接口，还可以查询该验证码是否被验证过。\n\n\n请求\n\n\n\n\n\n\nurl ：https://api.bmob.cn/1/querySms/:smsId （注意smsId前有冒号(:)）\n\n\n\n\n\n\nmethod ：GET\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n成功时响应\n\n\n\n\n\n\nstatus: 200 OK\n\n\n\n\n\n\nbody:\n\n\n\n\n\n\n{\n  \nsms_state\n: state, \n  \nverify_state\n: isVerify\n}\n\n\n\n\nsms_state是发送状态，有值: SENDING-发送中，FAIL-发送失败 SUCCESS-发送成功\nverify_state是验证码是否验证状态， 有值: true-已验证 false-未验证\n\n\n例子\n\n\n例如，如果在上述发送短信接口或者请求验证码接口请求成功后返回的 \nsmsId\n 为 \n123678\n，则可以使用以下请求查询这些短信的状态。\n\n\ncurl -X GET \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  https://api.bmob.cn/1/querySms/:123678\n\n\n\n\n成功返回以下JSON：\n\n\n{\n  \nsms_state\n: \nSENDING\n, \n  \nverify_state\n: false\n}\n\n\n\n\n注意事项\n\n\n关于短信条数的计算规则如下:\n\n\n\n\n实际计算的短信字数 = 模板的内容或自定义短信的内容字数 + 6。加上6是因为默认的签名【比目科技】占了6个字。\n\n\n实际计算的短信字数在70个字以下算1条。\n\n\n实际计算的短信字数超过70字的以67字为一条来计算的。也就是135个字数是计算为3条的。\n\n\n计算得到的短信条数在本条短信发送成功后将会从你的账户剩余的短信条数中扣除。\n\n\n\n\n短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条\n\n\n购买事项\n\n\n购买方法\n\n\n短信条数只能输入整数，且不能少于1000条\n\n\n\n\n进入账号控制台，财务/财务统计点击购买短信即可。\n\n\n\n\n发票事宜\n\n\n购买金额满100可提供发票，1000元以内的到付，1000以上（含1000）包邮。\n\n\n登录后台提交工单，提供购买服务的订单号和开票信息。\n\n\n个人\n\n\n发票抬头、邮寄地址、联系人及电话\n\n\n企业\n\n\n公司名称、统一社会信用代码、开户行及账号、邮寄地址、联系人及电话", 
            "title": "开发文档"
        }, 
        {
            "location": "/sms/restful/#_1", 
            "text": "", 
            "title": "请求发送短信内容"
        }, 
        {
            "location": "/sms/restful/#_2", 
            "text": "使用场景  此方法允许开发者使用 Bmob 的短信功能灵活发送自定义的短信内容到用户的手机上，可运用于多种场景下，比如  发送祝福短信、推送消息、通知 等  使用前准备  有两种方式可以使用自定义模板\n1.开发者可在Bmob后台提交身份证信息（ Bmob后台- 账户管理- 身份验证 ），并经 Bmob官方审核 通过，可以自定义模板。\n2.不提交身份信息，直接提交短信模板，并经 Bmob官方审核 通过，可以使用该模板。  短信模板需要符以下要求，否则模板审核不予通过。  注意：请不要发送任何敏感内容，请不要定制广告、营销以诱导用户行为的信息。具体如下：\n1.不得包含敏感关键， 关键字列表文档下载 ，不得包含【】和 [] \n2.带联系方式（电话、qq微信、邮箱地址）的短信。如：“目前我司推出xx产品最新优惠，联系陈生了解详情，电话123-1234-1234”;\n3.诱导用户行为，特别是带超链接。如“我司推出新作xxx游戏，下载链接http://xxx.com”等；\n当前有两种使用自定义模板  发现上述情况，针对通过身份审核的开发者，第一次给予警告，第二次将直接关闭接口使用，针对通过模板审核请求使用的开发者，模板审核不给予通过。  请求    url ：https://api.bmob.cn/1/requestSms    method ：POST    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n   mobilePhoneNumber : phoneNum,\n   content : content,\n   sendTime :YYYY-mm-dd HH:ii:ss (选填)\n}  成功时响应    status: 200 OK    body:    {\n     smsId : smsId（可用于后面使用查询短信状态接口来查询该条短信是否发送成功）\n}  例子  输入手机号码、短信内容，就可以给用户的手机号码发送自定义的短信内容了，以下的content只要在不违反相关规定的前提下，你可以随意输入：  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{ mobilePhoneNumber :  186xxxxxxxx ,  content : 您的验证码是：222222, 有效期是10分钟。 }' \\\n  https://api.bmob.cn/1/requestSms  你可以选择定时发送，比如未来的某一时刻给某个手机发送一条短信，sendTime的格式必须是YYYY-mm-dd HH:ii:ss， 如: 2015-05-26 12:13:14，请求如下：  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{ mobilePhoneNumber :  186xxxxxxxx ,  content : 您的验证码是：222222, 有效期是10分钟。感谢您使用Bmob。 ,  sendTime : 2016-05-26 12:13:14 }' \\\n  https://api.bmob.cn/1/requestSms  成功返回短信验证码ID：  {\n     smsId : 1232222\n}", 
            "title": "请求发送自定义的短信内容"
        }, 
        {
            "location": "/sms/restful/#_3", 
            "text": "请求描述  使用特定的模板请求验证码，如果没有在管理后台创建好模板，可使用默认的模板， Bmob  默认的模板是:  您的验证码是%smscode%，有效期为%ttl%分钟。您正在使用%appname%的验证码  请求    url ：https://api.bmob.cn/1/requestSmsCode    method ：POST    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n   mobilePhoneNumber : phoneNum,\n   template : templateName(选填，需先在管理后台创建)\n}  成功时响应    status: 200 OK    body:    {\n     smsId : smsId（可用于后面使用查询短信状态接口来查询该条短信是否发送成功）\n}  例子  使用默认的模板请求短信验证码：  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{ mobilePhoneNumber :  186xxxxxxxx }' \\\n  https://api.bmob.cn/1/requestSmsCode  成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该短信验证码是否发送成功和是否验证过：  {\n     smsId : 1232222\n}  如果你已经在  Bmob  后台设置了自己的模板，并已经是审核通过了，则可以使用自己的模板给用户的手机号码发送短信验证码了：  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{ mobilePhoneNumber :  186xxxxxxxx ,  template : 注册模板 }' \\\n  https://api.bmob.cn/1/requestSmsCode  成功返回，短信验证码ID，可用于后面使用查询短信状态接口来查询该短信验证码是否发送成功和是否验证过：  {\n     smsId : 1232222\n}", 
            "title": "请求短信验证码"
        }, 
        {
            "location": "/sms/restful/#_4", 
            "text": "请求描述  通过以下接口，你可以验证用户输入的验证码是否是有效。  请求    url ：https://api.bmob.cn/1/verifySmsCode/smsCode(用户收到的6位短信验证码)    method ：POST    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body:   {\n   mobilePhoneNumber : phoneNum\n}  成功时响应    status: 200 OK    body:    {\n     msg : ok \n}  例子  例如，要验证  186xxxxxxxx  号码输入的  876845  验证码是否正确可使用以下请求：  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{ mobilePhoneNumber :  186xxxxxxxx }' \\\n  https://api.bmob.cn/1/verifySmsCode/876845", 
            "title": "验证短信验证码"
        }, 
        {
            "location": "/sms/restful/#_5", 
            "text": "请求描述  通过以下接口，你可以查询某条短信是否发送成功，如果是使用了验证码接口，还可以查询该验证码是否被验证过。  请求    url ：https://api.bmob.cn/1/querySms/:smsId （注意smsId前有冒号(:)）    method ：GET    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json  成功时响应    status: 200 OK    body:    {\n   sms_state : state, \n   verify_state : isVerify\n}  sms_state是发送状态，有值: SENDING-发送中，FAIL-发送失败 SUCCESS-发送成功\nverify_state是验证码是否验证状态， 有值: true-已验证 false-未验证  例子  例如，如果在上述发送短信接口或者请求验证码接口请求成功后返回的  smsId  为  123678 ，则可以使用以下请求查询这些短信的状态。  curl -X GET \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  https://api.bmob.cn/1/querySms/:123678  成功返回以下JSON：  {\n   sms_state :  SENDING , \n   verify_state : false\n}  注意事项  关于短信条数的计算规则如下:   实际计算的短信字数 = 模板的内容或自定义短信的内容字数 + 6。加上6是因为默认的签名【比目科技】占了6个字。  实际计算的短信字数在70个字以下算1条。  实际计算的短信字数超过70字的以67字为一条来计算的。也就是135个字数是计算为3条的。  计算得到的短信条数在本条短信发送成功后将会从你的账户剩余的短信条数中扣除。   短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条", 
            "title": "查询短信状态"
        }, 
        {
            "location": "/sms/restful/#_6", 
            "text": "", 
            "title": "购买事项"
        }, 
        {
            "location": "/sms/restful/#_7", 
            "text": "短信条数只能输入整数，且不能少于1000条   进入账号控制台，财务/财务统计点击购买短信即可。", 
            "title": "购买方法"
        }, 
        {
            "location": "/sms/restful/#_8", 
            "text": "购买金额满100可提供发票，1000元以内的到付，1000以上（含1000）包邮。  登录后台提交工单，提供购买服务的订单号和开票信息。  个人  发票抬头、邮寄地址、联系人及电话  企业  公司名称、统一社会信用代码、开户行及账号、邮寄地址、联系人及电话", 
            "title": "发票事宜"
        }, 
        {
            "location": "/im/android/", 
            "text": "1、BmobOldIM SDK 回顾\n\n\nAndroid BmobIM SDK v2.0.0之前的版本统称为\nBmobOldIM SDK\n ，BmobOldIM SDK已经开源但不再进行维护，请开发者集成Android BmobNewIM SDK进行开发。\n\n\n\n\n\n\n\n\nBmobOldIM SDK 问题\n\n\n\n\n\n\n\n\n\n\n无法自定义消息类型\n\n\n\n\n\n\n消息发送受限于BmobPushSDK\n\n\n\n\n\n\nAPI设计不够合理规范且不易扩展\n\n\n\n\n\n\n聊天消息出现接收延迟或丢失\n\n\n\n\n\n\n\n\n2、BmobNewIM SDK 介绍\n\n\nAndroid BmobIM SDK v2.0.0开始的版本统称为\nBmobNewIM SDK\n，BmobNewIM SDK采用全新架构，设计更加合理规范，API更加简单易用，扩展性强，但不兼容 Android BmobOldIM SDK。\n\n\n2.1、Android BmobNewIM SDK 特点及其描述\n\n\n\n\n\n\n\n\nAndroid BmobNewIM SDK 特点\n\n\n描述\n\n\n\n\n\n\n\n\n\n\n与用户系统解耦\n\n\n终端用户聊天的唯一标识是objectId，不再受限于Bmob的用户系统\n\n\n\n\n\n\n支持多账号登录、跨平台\n\n\n支持单个设备多个账号登录，支持与iOS互通聊天\n\n\n\n\n\n\n支持多种格式的富媒体消息\n\n\n支持文本、图片、音频和地理位置等多种格式的富媒体消息\n\n\n\n\n\n\n允许开发者自定义消息\n\n\n支持开发者自定义消息类型，方便开发者扩展本业务逻辑\n\n\n\n\n\n\nAPI设计更加合理规范\n\n\n全新的架构设计，API更加简单易用，较BmobOldIM SDK 进一步降低开发者使用成本\n\n\n\n\n\n\n\n\n2.2、自IM SDK v2.0.5版本开始提供aar格式远程发布包，可以自动集成并结合Data SDK进行开发\n\n\n\n\n\n\n\n\nIM SDK aar格式所包含文件\n\n\nData SDK 版本\n\n\n\n\n\n\n\n\n\n\nBmobNewIM_(版本号)_(发布日期).jar\n\n\nBmobNewIM的核心SDK\n\n\n\n\n\n\nandroidasync_2.1.6.jar\n\n\n用于协议通讯\n\n\n\n\n\n\n\n\n2.3、IM SDK和Data SDK的版本对应关系\n\n\nIM SDK 使用Data SDK的BmobFile用于图片、语音等文件消息的发送，因此必须导入特定版本的BmobSDK。\n\n\n\n\n\n\n\n\nIM SDK 版本\n\n\nData SDK 版本\n\n\n\n\n\n\n\n\n\n\nbmob-im:1.1.8\n\n\nbmob-sdk:3.3.5\n\n\n\n\n\n\nbmob-im:1.1.9\n\n\nbmob-sdk:3.4.3\n\n\n\n\n\n\nbmob-im:2.0.1\n\n\nbmob-sdk:3.4.6-0304\n\n\n\n\n\n\nbmob-im:2.0.2\n\n\nbmob-sdk:3.4.6-0304\n\n\n\n\n\n\nbmob-im:2.0.3\n\n\nbmob-sdk:3.4.6\n\n\n\n\n\n\nbmob-im:2.0.4\n\n\nbmob-sdk:3.4.6\n\n\n\n\n\n\nbmob-im:2.0.5\n\n\nbmob-sdk:3.4.7-aar\n\n\n\n\n\n\nbmob-im:2.0.6\n\n\nbmob-sdk:3.5.5\n\n\n\n\n\n\n\n\n3、BmobNewIM SDK 集成\n\n\n3.1、手动集成\n\n\n3.1.1、下载Android BmobNewIM SDK开发包及其Demo\n\n\n\n\n\n\n\n\n下载平台\n\n\n下载地址\n\n\n\n\n\n\n\n\n\n\nBmob基于BmobNewIM SDK v2.0.6 的Demo\n\n\nbmob-newim-demo\n\n\n\n\n\n\nGithub基于BmobNewIM SDK v2.0.5 的Demo\n\n\nbmob-newim-demo \n\n\n\n\n\n\nGithub基于BmobNewIM SDK v2.0.6 的Demo\n\n\nbmob-newim-demo\n\n\n\n\n\n\n\n\n3.1.2、解压Android BmobNewIM SDK开发包\n\n\n\n\n\n\n\n\n文件\n\n\n使用\n\n\n\n\n\n\n\n\n\n\nlibs\n\n\n外部依赖库，拷贝于工程的libs文件夹；自Data SDK v3.4.7开始，加入libbmob.so文件；自Data SDK v3.5.2开始，加入libBmobStat.so文件。\n\n\n\n\n\n\nNewIM_V2.x.x_Demo\n\n\n开发示例，开发环境是Android Studio，功能是陌生人以及好友聊天\n\n\n\n\n\n\n\n\n3.1.3、在app下的build.gradle文件中设置jni依赖库的目录，设置后点击Sync Now同步配置\n\n\nandroid {\n    sourceSets {\n        main.jniLibs.srcDirs = ['libs']\n   }\n}\n\n\n\n\n3.2、自动集成\n\n\n3.2.1、在Project下的build.gradle文件中添加Bmob的maven仓库地址\n\n\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:1.3.0'\n    }\n}\n\nallprojects {\n    repositories {\n        jcenter()\n        //Bmob的maven仓库地址，必须填写\n        maven { url \nhttps://raw.github.com/bmob/bmob-android-sdk/master\n }\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n\n\n\n\n3.2.2、在app下的build.gradle文件中添加dependencies外部依赖库，添加后点击Sync Now同步配置\n\n\n    dependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n        //bmob-im：特定版本的bmob-im依赖特定版本的bmob-sdk\n        compile 'cn.bmob.android:bmob-im:2.0.6@aar'\n        compile 'cn.bmob.android:bmob-sdk:3.5.5'\n    }\n\n\n\n\n3.3、配置AndroidManifest.xml\n\n\n3.3.1、 添加Bmob_APP_KEY\n\n\n   \nmeta-data\n        android:name=\nBmob_APP_KEY\n\n        android:value=\nBmob平台的Application ID\n /\n\n\n\n\n\n3.3.2、 添加权限\n\n\n请注意在Android 6.0版本开始某些权限需要动态获取，详情请看Android Developwers官方文档，\nandroid-6.0-changes\n和\nandroid-7.0-changes\n。\n\n\n    \n!--网络权限 --\n\n    \nuses-permission android:name=\nandroid.permission.INTERNET\n /\n\n    \n!-- 监听网络的变化 --\n\n    \nuses-permission android:name=\nandroid.permission.ACCESS_NETWORK_STATE\n /\n\n    \nuses-permission android:name=\nandroid.permission.CHANGE_NETWORK_STATE\n /\n\n    \n!-- 设备休眠 --\n\n    \nuses-permission android:name=\nandroid.permission.WAKE_LOCK\n /\n\n    \nuses-permission android:name=\nandroid.permission.READ_PHONE_STATE\n /\n\n    \n!-- sd卡存储--\n\n    \nuses-permission android:name=\nandroid.permission.WRITE_EXTERNAL_STORAGE\n /\n\n    \nuses-permission android:name=\nandroid.permission.READ_EXTERNAL_STORAGE\n /\n\n    \n!--摄像头--\n\n    \nuses-permission android:name=\nandroid.permission.CAMERA\n /\n\n    \n!--录音--\n\n    \nuses-permission android:name=\nandroid.permission.RECORD_AUDIO\n /\n\n    \n!--通知震动--\n\n    \nuses-permission android:name=\nandroid.permission.VIBRATE\n /\n\n\n\n\n\n\n3.3.3、 添加service、receiver标签：\n\n\n  \nreceiver android:name=\ncn.bmob.newim.core.ConnectChangeReceiver\n \n\n        \nintent-filter\n\n            \naction android:name=\ncn.bmob.action.RECONNECT\n /\n\n            \naction android:name=\nandroid.net.conn.CONNECTIVITY_CHANGE\n /\n\n            \naction android:name=\nandroid.intent.action.BOOT_COMPLETED\n /\n\n            \naction android:name=\nandroid.intent.action.USER_PRESENT\n /\n\n        \n/intent-filter\n\n  \n/receiver\n\n  \nservice\n    android:name=\ncn.bmob.newim.core.service.BmobIMService\n\n    android:process=\n:bmobcore\n /\n\n  \nservice\n    android:name=\ncn.bmob.newim.core.service.NotifyService\n\n    android:process=\n:bmobcore\n /\n\n  \nservice android:name=\ncn.bmob.newim.core.service.ReConnectService\n /\n\n  \nservice android:name=\ncn.bmob.newim.core.service.HeartBeatService\n /\n\n\n\n\n\n注：自v2.0.5版本开始，将原来的\nBmobImService\n名称更换为\nBmobIMService\n，请务必修改，否则将无法正常使用IM服务。\n\n\n3.4、代码配置\n\n\n3.4.1、注册消息接收器\n\n\n3.4.1.1、如果你使用的是\nNewIM_V2.0.2\n及以后的版本\n\n\n1、请自定义消息接收器继承自\nBmobIMMessageHandler\n来处理服务器发来的消息和离线消息。\n\n\npublic class DemoMessageHandler extends BmobIMMessageHandler{\n\n    @Override\n    public void onMessageReceive(final MessageEvent event) {\n        //当接收到服务器发来的消息时，此方法被调用\n    }\n\n    @Override\n    public void onOfflineReceive(final OfflineMessageEvent event) {\n        //每次调用connect方法时会查询一次离线消息，如果有，此方法会被调用\n    }\n}\n\n\n\n\n\n2、在Application的onCreate方法中注册这个\nDemoMessageHandler\n。\n\n\n\npublic class BmobIMApplication extends Application{\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //NewIM初始化\n        BmobIM.init(this);\n        //注册消息接收器\n        BmobIM.registerDefaultMessageHandler(new DemoMessageHandler(this));\n    }\n}\n\n\n\n\n3.4.1.2、如果你使用的SDK版本是\nNewIM_V2.0.1\n\n\n1、请创建一个广播消息接收器，用于接收服务器发来的消息。\n\n\n\npublic class MessageReceiver extends BroadcastReceiver {\n\n    @Override\n    public void onReceive(final Context context, Intent intent) {\n        if(intent!=null){\n            final MessageEvent event =(MessageEvent)intent.getSerializableExtra(\nevent\n);\n            //开发者可以在这里发应用通知\n    }\n}\n\n\n\n\n\n2、在\nAndroidManifest.xml\n中注册此receiver。\n\n\nreceiver\n    android:name=\n程序包名.MessageReceiver\n\n    android:enabled=\ntrue\n\n    \nintent-filter\n\n        \naction android:name=\ncn.bmob.im.action.MESSAGE\n/\n\n    \n/intent-filter\n\n\n/receiver\n\n\n\n\n\n\n3.4.2、初始化BmobNewIM SDK\n\n\n在Application的onCreate方法中调用\nBmobIM.init(context)\n。\n\n\npublic class BmobIMApplication extends Application{\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //只有主进程运行的时候才需要初始化\n        if (getApplicationInfo().packageName.equals(getMyProcessName())){\n            //im初始化\n            BmobIM.init(this);\n            //注册消息接收器\n            BmobIM.registerDefaultMessageHandler(new DemoMessageHandler(this));\n        }\n    }\n\n    /**\n     * 获取当前运行的进程名\n     * @return\n     */\n    public static String getMyProcessName() {\n        try {\n            File file = new File(\n/proc/\n + android.os.Process.myPid() + \n/\n + \ncmdline\n);\n            BufferedReader mBufferedReader = new BufferedReader(new FileReader(file));\n            String processName = mBufferedReader.readLine().trim();\n            mBufferedReader.close();\n            return processName;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n}\n\n\n\n\n\n\n注：\n\n\n\n\n初始化方法包含了BmobSDK的初始化步骤，故无需再初始化BmobSDK。\n\n\n在初始化的时候，最好做下判断：只有主进程运行的时候才开始初始化，避免资源浪费。\n\n\n\n\n4、BmobNewIM SDK 使用\n\n\n4.1、服务器连接\n\n\n4.1.1、连接\n\n\n调用\nconnect\n方法，需要传入唯一用户标示\nclientId\n，Demo使用的是Bmob的用户登录系统\nobjectId\n。\n\n\nUser user = BmobUser.getCurrentUser(context,User.class);\nBmobIM.connect(user.getObjectId(), new ConnectListener() {\n    @Override\n    public void done(String uid, BmobException e) {\n        if (e == null) {\n            Logger.i(\nconnect success\n);\n        } else {\n            Logger.e(e.getErrorCode() + \n/\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n4.1.2、断开连接：\n\n\n调用\ndisConnect\n方法，客户端会断开与服务器之间的连接，再次聊天需要重新调用\nconnect\n方法完成与服务器之间的连接。\n\n\nBmobIM.getInstance().disConnect();\n\n\n\n\n\n4.1.3、监听服务器连接状态\n\n\n调用\nsetOnConnectStatusChangeListener\n方法即可监听到当前长链接的连接状态。\n\n\n BmobIM.getInstance().setOnConnectStatusChangeListener(new ConnectStatusChangeListener() {\n            @Override\n            public void onChange(ConnectionStatus status) {\n                Logger.i(\n + status.getMsg());\n            }\n        });\n\n\n\n\n4.2、会话\n\n\n4.2.1、创建会话\n\n\nBmobNewIM SDK 采用会话（\nBmobIMConversation\n）管理消息(\nBmobIMMessage\n)的方式，即消息的查询、发送和删除等操作均在指定会话下进行，因此需要获取指定会话信息并创建会话实例。目前创建会话有两种创建方式，分别是\n暂态会话\n和\n常态会话\n。\n\n\n4.2.1.1、暂态消息\n\n\nBmobNewIM SDK在\nBmobIMMessage\n类中新增\nisTransient\n属性来标识该条消息是否自动保存到\n聊天对象\n的本地DB中。\n\n\n\n\n设置为\ntrue\n,表明为暂态消息，那么这条消息\n并不会保存到聊天对象的本地db中\n，SDK只负责发送和接收。\n\n\n设置为\nfalse\n,表明不为暂态消息，SDK会\n自动保存该类型的消息到指定会话的数据库\n中。\n\n\n\n\n4.2.1.2、创建暂态会话\n\n\n该会话只提供消息发送功能，不可使用其他查询，删除等API，\n不会自动创建会话\n到本地DB中。一般用于\n自定义消息的发送\n，比如，添加好友的请求，在对方还没有同意的情况下，你并不希望在自己的会话列表中显示该会话。\nv2.0.4\n版本的NewIM开始提供此种方式创建暂态会话\n\n\n//开启私聊会话，isTransient可设置是否保存该会话到自己的本地会话表中\nstartPrivateConversation(BmobIMUserInfo info, boolean isTransient,ConversationListener listener)\n\n\n\n\n4.2.1.3、创建常态会话\n\n\n该会话提供消息查询、发送、删除等功能，SDK内部自动创建该会话。\n\n\n//开启私聊会话，默认会保存该会话到自己的本地会话表中\nstartPrivateConversation(BmobIMUserInfo info, ConversationListener listener)\n\n\n\n\n4.2.1.3、创建会话示例\n\n\nBmobIMUserInfo\n类，是用户信息类，有三个属性需要开发者关注下：userId(用户唯一id)，name(用户名)，avatar（用户头像）。\n\n\n//如果需要更新用户资料，开发者只需要传新的info进去就可以\nBmobIM.getInstance().startPrivateConversation(BmobIMUserInfo info, new ConversationListener() {\n    @Override\n    public void done(BmobIMConversation c, BmobException e) {\n        if(e==null){\n            //在此跳转到聊天页面\n            Bundle bundle = new Bundle();\n            bundle.putSerializable(\nc\n, c);\n            startActivity(ChatActivity.class, bundle, false);\n        }else{\n            toast(e.getMessage()+\n(\n+e.getErrorCode()+\n)\n);\n        }\n    }\n});\n\n\n\n\n4.2.2、查询全部会话\n\n\nBmobIM.getInstance().loadAllConversation()\n\n\n\n\n4.2.3、查询会话的未读消息数量\n\n\n4.2.3.1、查询指定会话下的未读消息数量\n\n\nBmobIM.getInstance().getUnReadCount(String conversationId)\n\n\n\n\n4.2.3.2、查询全部会话的全部未读消息数\n\n\nBmobIM.getInstance().getUnReadCount.getAllUnReadCount()\n\n\n\n\n4.2.4、删除指定会话\n\n\n//提供两种方式删除会话\nBmobIM.getInstance().deleteConversation(BmobIMConversation c);\nBmobIM.getInstance().deleteConversation(String conversationId);\n\n\n\n\n4.2.5、清空全部会话\n\n\nBmobIM.getInstance().clearAllConversation();\n\n\n\n\n4.2.6、更新会话标题、会话图标及用户信息\n\n\n由于BmobNewIM SDK并不包含与用户有关的逻辑，只负责存储用户信息并对外提供更新等方法,用来操作本地的用户信息。\n\n\n在与人单聊时，需要更新会话标题和会话图标及用户信息，可调用如下方法在\nDemoMessageHandler\n的全局消息接收器中进行统一更新。\n\n\n/**更新用户资料和会话资料\n * @param event\n * @param listener\n */\npublic void updateUserInfo(MessageEvent event,final UpdateCacheListener listener){\n    final BmobIMConversation conversation=event.getConversation();\n    final BmobIMUserInfo info =event.getFromUserInfo();\n    final BmobIMMessage msg =event.getMessage();\n    String username =info.getName();\n    String title =conversation.getConversationTitle();\n    //sdk内部，将新会话的会话标题用objectId表示，因此需要比对用户名和会话标题--单聊，后续会根据会话类型进行判断\n    if(!username.equals(title)) {\n        UserModel.getInstance().queryUserInfo(info.getUserId(), new QueryUserListener() {\n            @Override\n            public void done(User s, BmobException e) {\n                if(e==null){\n                    String name =s.getUsername();\n                    String avatar = s.getAvatar();\n                    conversation.setConversationIcon(avatar);\n                    conversation.setConversationTitle(name);\n                    info.setName(name);\n                    info.setAvatar(avatar);\n                    //更新用户资料\n                    BmobIM.getInstance().updateUserInfo(info);\n                   //更新会话资料-如果消息是暂态消息，则不更新会话资料\n                    if(!msg.isTransient()){\n                        BmobIM.getInstance().updateConversation(conversation);\n                    }\n                }else{\n                    Logger.e(e);\n                }\n                listener.done(null);\n            }\n        });\n    }else{\n        listener.internalDone(null);\n    }\n}\n\n\n\n\n4.3、消息\n\n\n消息(\nBmobIMMessage\n)是所有消息的基类，以下BmobNewIM SDK目前支持的消息类型。\n\n\n\n\n\n\n\n\n消息类型\n\n\n消息类名\n\n\n\n\n\n\n\n\n\n\n文本\n\n\nBmobIMTextMessage\n\n\n\n\n\n\n文件\n\n\nBmobIMFileMessage\n\n\n\n\n\n\n图像\n\n\nBmobIMImageMessage\n\n\n\n\n\n\n音频\n\n\nBmobIMAudioMessage\n\n\n\n\n\n\n视频\n\n\nBmobIMVideoMessage\n\n\n\n\n\n\n地理位置\n\n\nBmobIMLocationMessage\n\n\n\n\n\n\n\n\n4.3.1、获取指定会话信息并创建会话实例\n\n\nBmobNewIM SDK采用会话（\nBmobIMConversation\n）管理消息(\nBmobIMMessage\n)的方式，即消息的查询、发送和删除等操作均在指定会话下进行，因此需要通过以下两个步骤来获取指定会话信息并创建会话实例。\n\n\n1、 开启私聊\n\n\n//如果需要更新用户资料，开发者只需要传新的info进去就可以\nBmobIM.getInstance().startPrivateConversation(BmobImUserInfo info, new ConversationListener() {\n    @Override\n    public void done(BmobIMConversation c, BmobException e) {\n        if(e==null){\n            //在此跳转到聊天页面\n            Bundle bundle = new Bundle();\n            bundle.putSerializable(\nc\n, c);\n            startActivity(ChatActivity.class, bundle, false);\n        }else{\n            toast(e.getMessage()+\n(\n+e.getErrorCode()+\n)\n);\n        }\n    }\n});\n\n\n\n\n\n2、 创建会话实例\n\n\n使用\nBmobIMConversation.obtain(BmobIMClient client,BmobIMConversation conversation)\n方法传入\nBmobIMClient和BmobIMConversation的各自实例\n就可以创建一个用于控制消息查询、发送和删除的会话实例。\n\n\nBmobIMConversation c;\n//在聊天页面的onCreate方法中，通过如下方法创建新的会话实例,这个obtain方法才是真正创建一个管理消息发送的会话\nc=BmobIMConversation.obtain(BmobIMClient.getInstance(),(BmobIMConversation)getBundle().getSerializable(\nc\n));\n\n\n\n\n\n创建完成后，就可以使用这个会话实例\nc\n对消息进行各种操作啦，以下操作中的\nc\n都指的是该会话实例。\n\n\n注：\n如果不调用BmobIMConversation的\nobtain\n方法是无法控制消息发送等操作的，会报\nclient disconnect\n的错误。\n\n\n4.3.2、查询指定会话的聊天记录\n\n\n//首次加载，可设置msg为null，\n//下拉刷新的时候，可用消息表的第一个msg作为刷新的起始时间点，默认按照消息时间的降序排列，limit由开发者控制\nc.queryMessages(msg, limit, new MessagesQueryListener() {\n            @Override\n            public void done(List\nBmobIMMessage\n list, BmobException e) {\n                sw_refresh.setRefreshing(false);\n                if (e == null) {\n                    if (null != list \n list.size() \n 0) {\n                        adapter.addMessages(list);\n                        adapter.notifyDataSetChanged();\n                        layoutManager.scrollToPositionWithOffset(list.size() - 1, 0);\n                    }\n                } else {\n                    toast(e.getMessage() + \n(\n + e.getErrorCode() + \n)\n);\n                }\n            }\n        });\n\n\n\n\n\n4.3.3、删除指定会话的聊天记录\n\n\n删除消息不同于删除会话，会直接清空本地的消息记录数据。\n\n\n//删除指定聊天消息\nc.deleteMessage(BmobIMMessage msg)\n\n//删除一条或多条聊天消息\nc.deleteBatchMessage(List\nBmobIMMessage\n msgs)\n\n//清空该会话下的聊天消息，允许保留会话（可选）\nc.clearMessage(boolean isKeepConversion,MessageListener listener)\n\n注：isKeepConversion 表示是否保留该会话消息。\n\n\n\n\n\n4.3.4、更新指定会话的所有消息为已读状态\n\n\n可以在\nChatActivity\n的聊天页面的\nonDestory\n方法中调用如下方法\n更新该会话的的所有消息为已读状态\n：\n\n\n//更新此会话的所有消息为已读状态\nc.updateLocalCache();\n\n\n\n\n\n4.4、消息发送\n\n\n4.4.1、文本消息\n\n\n文本消息可以是纯文本，也可以是包含表情的文本消息，通过\nBmobIMTextMessage\n的\nsetContent\n方法设置内容来构建\nBmobIMTextMessage\n实例，再调用\nBmobIMConversation\n的\nsendMessage\n方法发送。\n\n\nBmobIMTextMessage msg =new BmobIMTextMessage();\nmsg.setContent(text);\n//可随意设置额外信息\nMap\nString,Object\n map =new HashMap\n();\nmap.put(\nlevel\n, \n1\n);\nmsg.setExtraMap(map);\nc.sendMessage(msg, new MessageSendListener() {\n    @Override\n    public void onStart(BmobIMMessage msg) {\n        super.onStart(msg);\n        scrollToBottom();\n        adapter.addMessage(msg);\n        adapter.notifyDataSetChanged();\n    }\n\n    @Override\n    public void done(BmobIMMessage msg, BmobException e) {\n        scrollToBottom();\n        adapter.notifyDataSetChanged();\n        edit_msg.setText(\n);\n        if (e != null) {\n            toast(e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n4.4.2、图片消息\n\n\n图片可以是通过系统拍照或本地相册中获取的本地图片地址，也可以使用网络上某个有效的图片地址。然后构造一个\nBmobIMImageMessage\n对象，再调用\nBmobIMConversation\n的\nsendMessage\n方法发送。\n\n\n4.4.2.1、发送本地图片\n\n\n使用系统拍照功能或从本地相册中获取到本地图片地址(\nlocalPath\n)，然后调用构造方法\nBmobIMImageMessage（String localPath）\n来创建\nBmobIMImageMessage\n实例。\n\n\nBmobIMImageMessage image =new BmobIMImageMessage(localPath);\nc.sendMessage(image, new MessageSendListener() {\n\n    @Override\n    public void onProgress(int value) {\n        super.onProgress(value);\n        //文件类型的消息才有进度值:do something\n        Logger.i(\nonProgress：\n+value);\n    }\n\n    @Override\n    public void onStart(BmobIMMessage msg) {\n        scrollToBottom();\n        adapter.addMessage(msg);\n        adapter.notifyDataSetChanged();\n    }\n\n    @Override\n    public void done(BmobIMMessage msg, BmobException e) {\n        scrollToBottom();\n        adapter.notifyDataSetChanged();\n        edit_msg.setText(\n);\n        if (e != null) {\n            toast(e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n4.4.2.2、发送远程图片URL\n\n\n例如，从微博或QQ中获取到某个图片地址，然后调用BmobIMImageMessage的\nsetRemoteUrl\n方法设置远程图片URL来创建\nBmobIMImageMessage\n实例。\n\n\nBmobIMImageMessage image =new BmobIMImageMessage();\nimage.setRemoteUrl(\nhttp://img.lakalaec.com/ad/57ab6dc2-43f2-4087-81e2-b5ab5681642d.jpg\n);\nc.sendMessage(image, new MessageSendListener() {\n\n    @Override\n    public void onProgress(int value) {\n        super.onProgress(value);\n        //文件类型的消息才有进度值\n        Logger.i(\nonProgress：\n+value);\n    }\n\n    @Override\n    public void onStart(BmobIMMessage msg) {\n        scrollToBottom();\n        adapter.addMessage(msg);\n        adapter.notifyDataSetChanged();\n    }\n\n    @Override\n    public void done(BmobIMMessage msg, BmobException e) {\n        scrollToBottom();\n        adapter.notifyDataSetChanged();\n        edit_msg.setText(\n);\n        if (e != null) {\n            toast(e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n4.4.3、语音消息\n\n\n语音可以是通过录制音频得到的本地音频地址，也可以使用网络上某个有效的音频地址。然后构造一个\nBmobIMAudioMessage\n对象，再调用\nBmobIMConversation\n的\nsendMessage\n方法发送。\n\n\n4.4.3.1、发送本地音频文件：\n\n\nBmobIMAudioMessage image =new BmobIMAudioMessage(localPath);\nc.sendMessage(image, new MessageSendListener() {\n\n    @Override\n    public void onProgress(int value) {\n        super.onProgress(value);\n        //文件类型的消息才有进度值:do something\n        Logger.i(\nonProgress：\n+value);\n    }\n\n    @Override\n    public void onStart(BmobIMMessage msg) {\n        scrollToBottom();\n        adapter.addMessage(msg);\n        adapter.notifyDataSetChanged();\n    }\n\n    @Override\n    public void done(BmobIMMessage msg, BmobException e) {\n        scrollToBottom();\n        adapter.notifyDataSetChanged();\n        edit_msg.setText(\n);\n        if (e != null) {\n            toast(e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n4.4.3.2、发送远程语音URL地址\n\n\n同样的，语音消息也支持发送远程语音URL地址：\n\n\nBmobIMAudioMessage image =new BmobIMAudioMessage();\nimage.setRemoteUrl(\n远程语音地址\n);\nc.sendMessage(image, new MessageSendListener() {\n\n    @Override\n    public void onProgress(int value) {\n        super.onProgress(value);\n        //文件类型的消息才有进度值\n        Logger.i(\nonProgress：\n+value);\n    }\n\n    @Override\n    public void onStart(BmobIMMessage msg) {\n        scrollToBottom();\n        adapter.addMessage(msg);\n        adapter.notifyDataSetChanged();\n    }\n\n    @Override\n    public void done(BmobIMMessage msg, BmobException e) {\n        scrollToBottom();\n        adapter.notifyDataSetChanged();\n        edit_msg.setText(\n);\n        if (e != null) {\n            toast(e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n4.4.4、地理位置消息\n\n\n地理位置可以通过任意地图SDK获取到经纬度，详细地址等信息，然后调用\nBmobIMLocationMessage(String address,double latitude,double longitude)\n构造方法构建\nBmobIMLocationMessage\n实例，再调用\nBmobIMConversation\n的\nsendMessage\n方法发送。：\n\n\nBmobIMLocationMessage location =new BmobIMLocationMessage(\n广州番禺区\n,23.5,112.0);\nc.sendMessage(location,  new MessageSendListener() {\n\n    @Override\n    public void onStart(BmobIMMessage msg) {\n        scrollToBottom();\n        adapter.addMessage(msg);\n        adapter.notifyDataSetChanged();\n    }\n\n    @Override\n    public void done(BmobIMMessage msg, BmobException e) {\n        scrollToBottom();\n        adapter.notifyDataSetChanged();\n        edit_msg.setText(\n);\n        if (e != null) {\n            toast(e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n4.5、消息接收\n\n\n4.5.1、自定义消息接收器\n\n\n4.5.1.1、\nNewIM_V2.0.4及以后\n的NewBmobIM SDK版本\n\n\n如果你使用的是\nNewIM_V2.0.4以后(包含v2.0.4)\n的SDK版本,那么不仅可以使用\nBmobIMMessageHandler\n方式来注册全局的消息接收器，还可以使用\nMessageListHandler\n为单个页面注册消息接收器，具体步骤如下：\n\n\n\n\n在\nActivity/Fragment\n中实现\nMessageListHandler\n接口；\n\n\n在\nonResume\n方法中添加页面消息监听器：\nBmobIM.getInstance().addMessageListHandler(this)\n；\n\n\n在\nonPause\n方法中移除页面消息监听器：\nBmobIM.getInstance().removeMessageListHandler(this)\n；\n\n\n在\nMessageListHandler\n接口的\nonMessageReceive\n方法中做相关的操作。\n\n\n\n\n具体示例可查看NewIMDemo中的\nChatActivity\n类：\n\n\n@Override\npublic void onMessageReceive(List\nMessageEvent\n list) {\n    //当注册页面消息监听时候，有消息（包含离线消息）到来时会回调该方法\n    for (int i=0;i\nlist.size();i++){\n        //do something...\n    }\n}\n\n\n\n\n\n4.5.1.2、\nNewIM_V2.0.2及以后\n的NewBmobIM SDK版本\n\n\n如果你使用的是\nNewIM_V2.0.2以后(包含v2.0.2)\n的SDK版本,那么只需要自定义消息接收器继承自\nBmobIMMessageHandler\n来处理服务器发来的消息和离线消息。\n\n\n\npublic class DemoMessageHandler extends BmobIMMessageHandler{\n\n    private Context context;\n    public DemoMessageHandler(Context context) {\n        this.context = context;\n    }\n\n    @Override\n    public void onMessageReceive(final MessageEvent event) {\n        //当接收到服务器发来的消息时，此方法被调用\n        //可以统一在此检测更新会话及用户信息\n        UserModel.getInstance().updateUserInfo(event, new UpdateCacheListener() {\n            @Override\n            public void done(BmobException e) {\n                BmobIMMessage msg = event.getMessage();\n                //用户自定义的消息类型，其类型值均为0\n                if(BmobIMMessageType.getMessageTypeValue(msg.getMsgType())==0){\n                    //自行处理自定义消息类型\n                    Logger.i(msg.getMsgType() + \n,\n + msg.getContent() + \n,\n + msg.getExtra());\n                }else{//SDK内部内部支持的消息类型\n                    if (BmobNotificationManager.getInstance(context).isShowNotification()){\n                        //如果需要显示通知栏，可以使用BmobNotificationManager类提供的方法，也可以自己写通知栏显示方法\n                   }else{//直接发送消息事件\n                        Logger.i(\n当前处于应用内，发送event\n);\n                        EventBus.getDefault().post(event);\n                    }\n                }\n            }\n        });\n    }\n\n    @Override\n    public void onOfflineReceive(final OfflineMessageEvent event) {\n        //每次调用connect方法时会查询一次离线消息，如果有，此方法会被调用\n        Map\nString,List\nMessageEvent\n map =event.getEventMap();\n        Logger.i(\n离线消息属于\n+map.size()+\n个用户\n);\n        for (Map.Entry\nString, List\nMessageEvent\n entry : map.entrySet()) {\n            List\nMessageEvent\n list =entry.getValue();\n            //挨个检测离线用户信息是否需要更新\n            UserModel.getInstance().updateUserInfo(list.get(0), new UpdateCacheListener() {\n                @Override\n                public void done(BmobException e) {\n                    EventBus.getDefault().post(event);\n                }\n            });\n        }\n    }\n}\n\n\n\n\n\n同样，别忘记在Application的onCreate方法中注册这个\nDemoMessageHandler\n：\n\n\n\npublic class BmobIMApplication extends Application{\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //注册消息接收器\n        BmobIM.registerDefaultMessageHandler(new DemoMessageHandler(this));\n    }\n}\n\n\n\n\n4.5.1.3、\nNewIM_V2.0.1\n的NewBmobIM SDK版本\n\n\n如果你使用的SDK版本是\nNewIM_V2.0.1\n,那么你需要在应用中创建一个\nBroadcastReceiver\n广播消息接收器，用于接收服务器发来的消息。\n\n\npublic class MessageReceiver extends BroadcastReceiver {\n\n    @Override\n    public void onReceive(final Context context, Intent intent) {\n        if(intent!=null){\n            final MessageEvent event =(MessageEvent)intent.getSerializableExtra(\"event\");\n            //可以统一在此检测更新会话及用户信息\n            UserModel.getInstance().updateUserInfo(event, new UpdateCacheListener() {\n                @Override\n                public void done(BmobException e) {\n                    BmobIMMessage msg = event.getMessage();\n                    //用户自定义的消息类型，其类型值均为0\n                    if(BmobIMMessageType.getMessageTypeValue(msg.getMsgType())==0){\n                        //自行处理自定义消息类型\n                        Logger.i(msg.getMsgType() + \",\" + msg.getContent() + \",\" + msg.getExtra());\n                    }else{//SDK内部内部支持的消息类型\n                        if (BmobNotificationManager.getInstance(context).isShowNotification()){\n                            //如果需要显示通知栏，可以使用BmobNotificationManager类提供的方法，也可以自己写通知栏显示方法\n                       }else{//直接发送消息事件\n                            Logger.i(\"当前处于应用内，发送event\");\n                            EventBus.getDefault().post(event);\n                        }\n                    }\n                }\n            });\n    }\n}\n\n\n\n别忘记在\nAndroidManifest.xml\n中注册这个receiver\n\n\nreceiver\n    android:name=\n程序包名.MessageReceiver\n\n    android:enabled=\ntrue\n\n    \nintent-filter\n\n        \naction android:name=\ncn.bmob.im.action.MESSAGE\n/\n\n    \n/intent-filter\n\n\n/receiver\n\n\n\n\n\n\n4.5.2、应用内消息接收\n\n\nV2.0.1\n的SDK内部集成EventBus库（\nV2.0.2\nSDK内部不再集成EventBus，开发者可以自行使用新版EventBus）来进行应用内消息的分发，故在应用内需要接收消息的地方注册和解注册EventBus即可。\n\n\nSDK内部有两种事件：\nMessageEvent（聊天消息）\n、\nOfflineMessageEvent(离线消息)\n。\n\n\n1、注册EventBus\n\n\nEventBus.getDefault().register(this);\n\n\n\n\n\n2、解注册EventBus\n\n\nEventBus.getDefault().unregister(this);\n\n\n\n\n\n3、处理聊天消息\n\n\n/**聊天消息接收事件\n * @param event\n */\npublic void onEventMainThread(MessageEvent event){\n    //处理聊天消息\n}\n\n\n\n\n\n4、处理离线消息\n\n\n\n/**离线消息接收事件\n * @param event\n */\npublic void onEventMainThread(OfflineMessageEvent event){\n    //处理离线消息\n}\n\n\n\n\n\n4.5.3、应用外通知栏提醒\n\n\nSDK新增\nBmobNotificationManager\n类，并提供如下两个方法供开发者展示通知栏:\n\n\n\n\n多个用户的多条消息合并成一条通知：有XX个联系人发来了XX条消息\n\n\n\n\n/**显示通知：多个用户的多条消息合并显示一条通知\n * @param event 某个消息事件：包含消息、会话及发送用户的信息\n * @param intent 跳转intent\n */\n BmobNotificationManager.getInstance(context).showNotification(MessageEvent event,Intent pendingIntent);\n\n\n\n\n\n\n\n自定义通知消息：始终只有一条通知，新消息覆盖旧消息\n\n\n\n\n /**显示通知\n * @param largerIcon 通知栏图标 开发者可传应用图标，也可以将聊天头像转成bitmap\n * @param title 标题\n * @param content 内容\n * @param ticker 状态栏上显示的内容\n * @param intent 跳转的intent\n */\nBmobNotificationManager.getInstance(context).showNotification(Bitmap largerIcon,String title, String content, String ticker,Intent intent);\n\n\n\n\n注：为了使SDK能够区分当前应用是否退出，开发者需进行以下几个步骤：\n\n\n1、在会话和聊天的Activity类实现'ObseverListener'监听器；\n\n\n2、在\nonResume\n方法中调用\nBmobNotificationManager.getInstance(context).addObserver(this)\n方法添加观察者；\n   在\nonPause\n方法中调用\nBmobNotificationManager.getInstance(context).removeObserver(this)\n方法移除观察者\n\n\n3、在主Activity的\nonDestroy\n方法中调用\nBmobNotificationManager.getInstance(context).clearObserver()\n清空观察者。\n\n\n4.6、自定义消息\n\n\n4.6.1、设置额外信息\n\n\n有些时候，开发者需要在发送消息时携带一些额外信息，例如\n发送方的设备类型、图片的拍摄地点或者音频的来源\n等，那么开发者可以通过 \nBmobIMExtraMessage.extraMap\n属性来解决，任何继承\nBmobIMExtraMessage\n类的消息均支持设置额外信息。\n\n\n    BmobIMAudioMessage audio =new BmobIMAudioMessage();\n    image.setRemoteUrl(\n远程音频地址\n);\n    //设置音频文件的来源\n    Map\nString,Object\n map =new HashMap\n();\n    map.put(\nfrom\n, \n优酷\n);\n    audio.setExtraMap(map);\n    c.sendMessage(audio, listener);\n\n\n\n\n4.6.2、创建新的消息类型\n\n\n如果设置额外信息无法满足开发者的需求，那么开发者也可以自定义自己的消息类型。\n\n\n4.6.2.1、创建自定义消息\n\n\n\n\n继承自\nBmobIMExtraMessage\n类；\n\n\n重写\ngetMsgType\n方法，填写自定义的消息类型；\n\n\n重写\nisTransient\n方法。\n\n\n\n\n    public class AddFriendMessage extends BmobIMExtraMessage{\n\n        @Override\n        public String getMsgType() {\n            return \nadd\n;\n        }\n\n        @Override\n        public boolean isTransient() {\n            //设置为true,表明为暂态消息，那么这条消息并不会保存到对方的本地db中\n            //设置为false,则会保存到对方指定会话的本地数据库中\n            return true;\n        }\n\n        public AddFriendMessage(){}\n\n    }\n\n\n\n\n4.6.2.2、发送自定义消息\n\n\n    //启动一个会话，如果isTransient设置为true,则不会创建在本地会话表中创建该会话，\n    //设置isTransient设置为false,则会在本地数据库的会话列表中先创建（如果没有）与该用户的会话信息，且将用户信息存储到本地的用户表中\n    BmobIMConversation c = BmobIM.getInstance().startPrivateConversation(info, true,null);\n    //这个obtain方法才是真正创建一个管理消息发送的会话\n    BmobIMConversation conversation = BmobIMConversation.obtain(BmobIMClient.getInstance(), c);\n    AddFriendMessage msg =new AddFriendMessage();\n    User currentUser = BmobUser.getCurrentUser(this,User.class);\n    msg.setContent(\n很高兴认识你，可以加个好友吗?\n);//给对方的一个留言信息\n    Map\nString,Object\n map =new HashMap\n();\n    map.put(\nname\n, currentUser.getUsername());//发送者姓名，这里只是举个例子，其实可以不需要传发送者的信息过去\n    map.put(\navatar\n,currentUser.getAvatar());//发送者的头像\n    map.put(\nuid\n,currentUser.getObjectId());//发送者的uid\n    msg.setExtraMap(map);\n    conversation.sendMessage(msg, new MessageSendListener() {\n        @Override\n        public void done(BmobIMMessage msg, BmobException e) {\n            if (e == null) {//发送成功\n                toast(\n好友请求发送成功，等待验证\n);\n            } else {//发送失败\n                toast(\n发送失败:\n + e.getMessage());\n            }\n        }\n    });\n\n\n\n\n4.7、用户管理\n\n\nBmobNewIM SDK只是即时通讯的消息收发渠道，本身并不提供用户体系。开发者可使用BmobSDK提供的用户管理方面功能，也可使用开发者自己的用户体系。\n\n\nBmobNewIM SDK内部会自动创建本地用户表，并对外提供方法供开发者调用来操作本地用户表。开发者只需要调用\nupdateUserInfo\n方法即可更新本地用户信息。\n\n\n4.7.1、BmobIMUserInfo介绍\n\n\nBmobNewIM SDK中用户的实体类为\nBmobIMUserInfo\n，其有四个属性，开发者只需要关心后三个即可。\n\n\n\n\n\n\n\n\n属性名\n\n\n属性含义\n\n\n\n\n\n\n\n\n\n\nid\n\n\n本地数据库用户表的id值，开发者无需关心\n\n\n\n\n\n\nuserId\n\n\n用户唯一id（Demo中用的是BmobUser的objectId）\n\n\n\n\n\n\nname\n\n\n用户名 （Demo中是用的是BmobUser的username）\n\n\n\n\n\n\navatar\n\n\n用户头像\n\n\n\n\n\n\n\n\n4.7.2、更新本地用户信息\n\n\n以下两种情况需要更新用户信息：\n1. 当注册或登录成功后，需要更新下当前用户的信息到本地数据库的用户表中，这样才能通过getUserInfo方法获取到本地的用户信息。\n2. 当接收到某人消息的时候，同样需要更新A的用户信息到本地用户表中，否则在会话界面将默认显示的是用户的userId，也就是Demo中的BmobUser的objectId值。\n\n\n4.7.2.1、更新单一本地用户信息\n\n\nBmobIM.getInstance().updateUserInfo(BmobIMUserInfo info)\n\n\n\n\n4.7.2.2、批量更新本地用户信息\n\n\nBmobIM.getInstance().updateBatchUserInfo(List\nBmobIMUserInfo\n list)\n\n\n\n\n4.7.3、获取本地用户信息\n\n\nBmobNewIM SDK内部会自动创建了一个本地数据库用来存储用户信息，开发者需要先调用\nupdateUserInfo\n更新用户信息到本地数据库中，才能通过\ngetUserInfo(uid)\n获取到本地用户信息。\n\n\nBmobIM.getInstance().getUserInfo(String uid)\n\n\n\n\n4.8、好友管理\n\n\nBmobNewIM SDK中并没有集成好友管理相关的功能，为了方便开发者建立基于好友之间的聊天模式，在\nv2.0.4\n版本开始的Demo中使用Data SDK新建了\nFriend\n表来进行好友管理。\n\n\n/**好友表\n * @author smile\n * @project Friend\n * @date 2016-04-26\n */\npublic class Friend extends BmobObject{\n\n    //用户\n    private User user;\n    //好友\n    private User friendUser;\n\n    //getter setter...\n}\n\n\n\n\n4.8.1、获取好友列表\n\n\n以下摘自\nUserModel(cn.bmob.imdemo.model)\n类：\n\n\n/**\n * 查询好友\n * @param listener\n */\npublic void queryFriends(final FindListener\nFriend\n listener){\n    BmobQuery\nFriend\n query = new BmobQuery\n();\n    User user =BmobUser.getCurrentUser(getContext(), User.class);\n    query.addWhereEqualTo(\nuser\n, user);\n    query.include(\nfriendUser\n);\n    query.order(\n-updatedAt\n);\n    query.findObjects(getContext(), new FindListener\nFriend\n() {\n        @Override\n        public void onSuccess(List\nFriend\n list) {\n            if (list != null \n list.size() \n 0) {\n                listener.onSuccess(list);\n            } else {\n                listener.onError(0, \n暂无联系人\n);\n            }\n        }\n\n        @Override\n        public void onError(int i, String s) {\n            listener.onError(i, s);\n        }\n    });\n}\n\n\n\n\n\n4.8.2、删除好友\n\n\n以下摘自\nUserModel(cn.bmob.imdemo.model)\n类：\n\n\n/**\n * 删除好友\n * @param f\n * @param listener\n */\npublic void deleteFriend(Friend f,DeleteListener listener){\n    Friend friend =new Friend();\n    friend.delete(getContext(),f.getObjectId(),listener);\n}\n\n\n\n\n\n4.8.3、添加好友\n\n\nDemo中创建了一个\nNewFriend\n的本地数据库类用来存储所有的添加好友请求。\n\n\n/**本地的好友请求表\n * @author :smile\n * @project:NewFriend\n * @date :2016-04-26-17:28\n */\npublic class NewFriend implements java.io.Serializable {\n\n    private Long id;\n    //用户uid\n    private String uid;\n    //留言消息\n    private String msg;\n    //用户名\n    private String name;\n    //头像\n    private String avatar;\n    //状态：未读、已读、已添加、已拒绝等\n    private Integer status;\n    //请求时间\n    private Long time;\n\n    //getter setter...\n\n}\n\n\n\n\n\nDemo中创建了一个\nAddFriendMessage\n类来展示如何发送自定义的添加好友请求的消息。\n\n\n/**添加好友请求-自定义消息类型\n * @author :smile\n * @project:AddFriendMessage\n * @date :2016-01-30-17:28\n */\npublic class AddFriendMessage extends BmobIMExtraMessage{\n\n    public AddFriendMessage(){}\n\n    @Override\n    public String getMsgType() {\n        //自定义一个`add`的消息类型\n        return \nadd\n;\n    }\n\n    @Override\n    public boolean isTransient() {\n        //设置为true,表明为暂态消息，那么这条消息并不会保存到本地db中，SDK只负责发送出去\n        //设置为false,则会保存到指定会话的数据库中\n        return true;\n    }\n\n    ...\n\n}\n\n\n\n\n\nDemo中创建了一个\nAgreeAddFriendMessage\n类来展示如何发送自定义的同意添加好友请求的消息，并在对方的本地会话表中新增消息类型。\n\n\n/**同意添加好友请求-仅仅只用于发送同意添加好友的消息\n * @author smile\n * @project AgreeAddFriendMessage\n * @date 2016-03-04-10:41\n */\npublic class AgreeAddFriendMessage extends BmobIMExtraMessage{\n\n    //以下均是从extra里面抽离出来的字段，方便获取\n    private String uid;//最初的发送方\n    private Long time;\n    private String msg;//用于通知栏显示的内容\n\n    @Override\n    public String getMsgType() {\n        return \nagree\n;\n    }\n\n    @Override\n    public boolean isTransient() {\n        //如果需要在对方的会话表中新增一条该类型的消息，则设置为false，表明是非暂态会话\n        //此处将同意添加好友的请求设置为false，为了演示怎样向会话表和消息表中新增一个类型，在对方的会话列表中增加`我通过了你的好友验证请求，我们可以开始聊天了!`这样的类型\n        return false;\n    }\n\n    //getter setter...\n\n    ...\n}\n\n\n\n\n\n4.8.4、发送添加好友的请求\n\n\n以下摘自\nUserInfoActivity(cn.bmob.imdemo.ui)\n类：\n\n\n/**\n * 发送添加好友的请求\n */\nprivate void sendAddFriendMessage(){\n    //启动一个暂态会话，也就是isTransient为true,表明该会话仅执行发送消息的操作，不会保存会话和消息到本地数据库中，\n    BmobIMConversation c = BmobIM.getInstance().startPrivateConversation(info, true,null);\n    //这个obtain方法才是真正创建一个管理消息发送的会话\n    BmobIMConversation conversation = BmobIMConversation.obtain(BmobIMClient.getInstance(), c);\n    //新建一个添加好友的自定义消息实体\n    AddFriendMessage msg =new AddFriendMessage();\n    User currentUser = BmobUser.getCurrentUser(this,User.class);\n    msg.setContent(\n很高兴认识你，可以加个好友吗?\n);//给对方的一个留言信息\n    Map\nString,Object\n map =new HashMap\n();\n    map.put(\nname\n, currentUser.getUsername());//发送者姓名，这里只是举个例子，其实可以不需要传发送者的信息过去\n    map.put(\navatar\n,currentUser.getAvatar());//发送者的头像\n    map.put(\nuid\n,currentUser.getObjectId());//发送者的uid\n    msg.setExtraMap(map);\n    conversation.sendMessage(msg, new MessageSendListener() {\n        @Override\n        public void done(BmobIMMessage msg, BmobException e) {\n            if (e == null) {//发送成功\n                toast(\n好友请求发送成功，等待验证\n);\n            } else {//发送失败\n                toast(\n发送失败:\n + e.getMessage());\n            }\n        }\n    });\n}\n\n\n\n\n\n4.8.5、发送同意添加好友的请求\n\n\n以下摘自\nNewFriendHolder(cn.bmob.imdemo.adapter)\n类：\n\n\n/**\n * 发送同意添加好友的请求\n */\nprivate void sendAgreeAddFriendMessage(final NewFriend add,final SaveListener listener){\n    //发给谁，就填谁的用户信息\n    BmobIMUserInfo info = new BmobIMUserInfo(add.getUid(), add.getName(), add.getAvatar());\n    //启动一个暂态会话，也就是isTransient为true,表明该会话仅执行发送消息的操作，不会保存会话和消息到本地数据库中，\n    BmobIMConversation c = BmobIM.getInstance().startPrivateConversation(info,true,null);\n    //这个obtain方法才是真正创建一个管理消息发送的会话\n    BmobIMConversation conversation = BmobIMConversation.obtain(BmobIMClient.getInstance(),c);\n    //而AgreeAddFriendMessage的isTransient设置为false，表明我希望在对方的会话数据库中保存该类型的消息\n    AgreeAddFriendMessage msg =new AgreeAddFriendMessage();\n    User currentUser = BmobUser.getCurrentUser(getContext(), User.class);\n    msg.setContent(\n我通过了你的好友验证请求，我们可以开始聊天了!\n);//---这句话是直接存储到对方的消息表中的\n    Map\nString,Object\n map =new HashMap\n();\n    map.put(\nmsg\n,currentUser.getUsername()+\n同意添加你为好友\n);//显示在通知栏上面的内容\n    map.put(\nuid\n,add.getUid());//发送者的uid-方便请求添加的发送方找到该条添加好友的请求\n    map.put(\ntime\n, add.getTime());//添加好友的请求时间\n    msg.setExtraMap(map);\n    conversation.sendMessage(msg, new MessageSendListener() {\n        @Override\n        public void done(BmobIMMessage msg, BmobException e){\n            if (e == null) {//发送成功\n                //修改本地的好友请求记录\n                NewFriendManager.getInstance(getContext()).updateNewFriend(add.getUid(),add.getTime(),Config.STATUS_VERIFIED);\n                listener.onSuccess();\n            } else {//发送失败\n                listener.onFailure(e.getErrorCode(),e.getMessage());\n            }\n        }\n    });\n}\n\n\n\n\n\n4.8.6、接收并处理好友相关的请求\n\n\n以下摘自\nDemoMessageHandler(cn.bmob.imdemo)\n类：\n\n\n/**\n * 处理自定义消息类型:用户自定义的消息类型，其类型值均为0\n * @param msg\n */\nprivate void processCustomMessage(BmobIMMessage msg,BmobIMUserInfo info){\n    String type =msg.getMsgType();\n    //发送页面刷新的广播\n    EventBus.getDefault().post(new RefreshEvent());\n    //处理消息\n    if(type.equals(\nadd\n)){//接收到的添加好友的请求\n        NewFriend friend = AddFriendMessage.convert(msg);\n        //本地好友请求表做下校验，本地没有的才允许显示通知栏--有可能离线消息会有些重复\n        long id = NewFriendManager.getInstance(context).insertOrUpdateNewFriend(friend);\n        if(id\n0){\n            showAddNotify(friend);\n        }\n    }else if(type.equals(\nagree\n)){//接收到的对方同意添加自己为好友,此时需要做的事情：1、添加对方为好友，2、显示通知\n        AgreeAddFriendMessage agree = AgreeAddFriendMessage.convert(msg);\n        addFriend(agree.getFromId());//添加消息的发送方为好友\n        //这里应该也需要做下校验--来检测下是否已经同意过该好友请求，我这里省略了\n        showAgreeNotify(info,agree);\n    }else{\n        Toast.makeText(context,\n接收到的自定义消息：\n+msg.getMsgType() + \n,\n + msg.getContent() + \n,\n + msg.getExtra(),Toast.LENGTH_SHORT).show();\n    }\n}\n\n\n\n\n\n4.8.7、添加到Friend表中\n\n\n以下摘自\nDemoMessageHandler(cn.bmob.imdemo)\n类：\n\n\n/**\n * 添加对方为自己的好友\n * @param uid\n */\nprivate void addFriend(String uid){\n    User user =new User();\n    user.setObjectId(uid);\n    //添加到Friend表中\n    UserModel.getInstance().agreeAddFriend(user, new SaveListener() {\n        @Override\n        public void onSuccess() {\n            Log.i(\nbmob\n, \nonSuccess\n);\n        }\n\n        @Override\n        public void onFailure(int i, String s) {\n            Log.i(\nbmob\n, \nonFailure:\n+s+\n-\n+i);\n        }\n    });\n}\n\n\n\n\n5. 混淆\n\n\n# 不混淆im sdk\n-keep class cn.bmob.newim.**{*;}\n-dontwarn cn.bmob.newim.**\n# 不混淆greenDao类\n-dontwarn de.greenrobot.dao.**\n-keep class de.greenrobot.dao.** { *;}\n-keepclassmembers class * extends de.greenrobot.dao.AbstractDao {\n    public static java.lang.String TABLENAME;\n}\n-keep class **$Properties\n# 不混淆async\n-dontwarn com.koushikdutta.async.**\n-keep class com.koushikdutta.async.** { *;}", 
            "title": "开发文档"
        }, 
        {
            "location": "/im/android/#1bmoboldim-sdk", 
            "text": "Android BmobIM SDK v2.0.0之前的版本统称为 BmobOldIM SDK  ，BmobOldIM SDK已经开源但不再进行维护，请开发者集成Android BmobNewIM SDK进行开发。     BmobOldIM SDK 问题      无法自定义消息类型    消息发送受限于BmobPushSDK    API设计不够合理规范且不易扩展    聊天消息出现接收延迟或丢失", 
            "title": "1、BmobOldIM SDK 回顾"
        }, 
        {
            "location": "/im/android/#2bmobnewim-sdk", 
            "text": "Android BmobIM SDK v2.0.0开始的版本统称为 BmobNewIM SDK ，BmobNewIM SDK采用全新架构，设计更加合理规范，API更加简单易用，扩展性强，但不兼容 Android BmobOldIM SDK。", 
            "title": "2、BmobNewIM SDK 介绍"
        }, 
        {
            "location": "/im/android/#21android-bmobnewim-sdk", 
            "text": "Android BmobNewIM SDK 特点  描述      与用户系统解耦  终端用户聊天的唯一标识是objectId，不再受限于Bmob的用户系统    支持多账号登录、跨平台  支持单个设备多个账号登录，支持与iOS互通聊天    支持多种格式的富媒体消息  支持文本、图片、音频和地理位置等多种格式的富媒体消息    允许开发者自定义消息  支持开发者自定义消息类型，方便开发者扩展本业务逻辑    API设计更加合理规范  全新的架构设计，API更加简单易用，较BmobOldIM SDK 进一步降低开发者使用成本", 
            "title": "2.1、Android BmobNewIM SDK 特点及其描述"
        }, 
        {
            "location": "/im/android/#22im-sdk-v205aardata-sdk", 
            "text": "IM SDK aar格式所包含文件  Data SDK 版本      BmobNewIM_(版本号)_(发布日期).jar  BmobNewIM的核心SDK    androidasync_2.1.6.jar  用于协议通讯", 
            "title": "2.2、自IM SDK v2.0.5版本开始提供aar格式远程发布包，可以自动集成并结合Data SDK进行开发"
        }, 
        {
            "location": "/im/android/#23im-sdkdata-sdk", 
            "text": "IM SDK 使用Data SDK的BmobFile用于图片、语音等文件消息的发送，因此必须导入特定版本的BmobSDK。     IM SDK 版本  Data SDK 版本      bmob-im:1.1.8  bmob-sdk:3.3.5    bmob-im:1.1.9  bmob-sdk:3.4.3    bmob-im:2.0.1  bmob-sdk:3.4.6-0304    bmob-im:2.0.2  bmob-sdk:3.4.6-0304    bmob-im:2.0.3  bmob-sdk:3.4.6    bmob-im:2.0.4  bmob-sdk:3.4.6    bmob-im:2.0.5  bmob-sdk:3.4.7-aar    bmob-im:2.0.6  bmob-sdk:3.5.5", 
            "title": "2.3、IM SDK和Data SDK的版本对应关系"
        }, 
        {
            "location": "/im/android/#3bmobnewim-sdk", 
            "text": "", 
            "title": "3、BmobNewIM SDK 集成"
        }, 
        {
            "location": "/im/android/#31", 
            "text": "", 
            "title": "3.1、手动集成"
        }, 
        {
            "location": "/im/android/#311android-bmobnewim-sdkdemo", 
            "text": "下载平台  下载地址      Bmob基于BmobNewIM SDK v2.0.6 的Demo  bmob-newim-demo    Github基于BmobNewIM SDK v2.0.5 的Demo  bmob-newim-demo     Github基于BmobNewIM SDK v2.0.6 的Demo  bmob-newim-demo", 
            "title": "3.1.1、下载Android BmobNewIM SDK开发包及其Demo"
        }, 
        {
            "location": "/im/android/#312android-bmobnewim-sdk", 
            "text": "文件  使用      libs  外部依赖库，拷贝于工程的libs文件夹；自Data SDK v3.4.7开始，加入libbmob.so文件；自Data SDK v3.5.2开始，加入libBmobStat.so文件。    NewIM_V2.x.x_Demo  开发示例，开发环境是Android Studio，功能是陌生人以及好友聊天", 
            "title": "3.1.2、解压Android BmobNewIM SDK开发包"
        }, 
        {
            "location": "/im/android/#313appbuildgradlejnisync-now", 
            "text": "android {\n    sourceSets {\n        main.jniLibs.srcDirs = ['libs']\n   }\n}", 
            "title": "3.1.3、在app下的build.gradle文件中设置jni依赖库的目录，设置后点击Sync Now同步配置"
        }, 
        {
            "location": "/im/android/#32", 
            "text": "", 
            "title": "3.2、自动集成"
        }, 
        {
            "location": "/im/android/#321projectbuildgradlebmobmaven", 
            "text": "buildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:1.3.0'\n    }\n}\n\nallprojects {\n    repositories {\n        jcenter()\n        //Bmob的maven仓库地址，必须填写\n        maven { url  https://raw.github.com/bmob/bmob-android-sdk/master  }\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}", 
            "title": "3.2.1、在Project下的build.gradle文件中添加Bmob的maven仓库地址"
        }, 
        {
            "location": "/im/android/#322appbuildgradledependenciessync-now", 
            "text": "dependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n        //bmob-im：特定版本的bmob-im依赖特定版本的bmob-sdk\n        compile 'cn.bmob.android:bmob-im:2.0.6@aar'\n        compile 'cn.bmob.android:bmob-sdk:3.5.5'\n    }", 
            "title": "3.2.2、在app下的build.gradle文件中添加dependencies外部依赖库，添加后点击Sync Now同步配置"
        }, 
        {
            "location": "/im/android/#33androidmanifestxml", 
            "text": "", 
            "title": "3.3、配置AndroidManifest.xml"
        }, 
        {
            "location": "/im/android/#331-bmob_app_key", 
            "text": "meta-data\n        android:name= Bmob_APP_KEY \n        android:value= Bmob平台的Application ID  /", 
            "title": "3.3.1、 添加Bmob_APP_KEY"
        }, 
        {
            "location": "/im/android/#332", 
            "text": "请注意在Android 6.0版本开始某些权限需要动态获取，详情请看Android Developwers官方文档， android-6.0-changes 和 android-7.0-changes 。       !--网络权限 -- \n     uses-permission android:name= android.permission.INTERNET  / \n     !-- 监听网络的变化 -- \n     uses-permission android:name= android.permission.ACCESS_NETWORK_STATE  / \n     uses-permission android:name= android.permission.CHANGE_NETWORK_STATE  / \n     !-- 设备休眠 -- \n     uses-permission android:name= android.permission.WAKE_LOCK  / \n     uses-permission android:name= android.permission.READ_PHONE_STATE  / \n     !-- sd卡存储-- \n     uses-permission android:name= android.permission.WRITE_EXTERNAL_STORAGE  / \n     uses-permission android:name= android.permission.READ_EXTERNAL_STORAGE  / \n     !--摄像头-- \n     uses-permission android:name= android.permission.CAMERA  / \n     !--录音-- \n     uses-permission android:name= android.permission.RECORD_AUDIO  / \n     !--通知震动-- \n     uses-permission android:name= android.permission.VIBRATE  /", 
            "title": "3.3.2、 添加权限"
        }, 
        {
            "location": "/im/android/#333-servicereceiver", 
            "text": "receiver android:name= cn.bmob.newim.core.ConnectChangeReceiver   \n         intent-filter \n             action android:name= cn.bmob.action.RECONNECT  / \n             action android:name= android.net.conn.CONNECTIVITY_CHANGE  / \n             action android:name= android.intent.action.BOOT_COMPLETED  / \n             action android:name= android.intent.action.USER_PRESENT  / \n         /intent-filter \n   /receiver \n   service\n    android:name= cn.bmob.newim.core.service.BmobIMService \n    android:process= :bmobcore  / \n   service\n    android:name= cn.bmob.newim.core.service.NotifyService \n    android:process= :bmobcore  / \n   service android:name= cn.bmob.newim.core.service.ReConnectService  / \n   service android:name= cn.bmob.newim.core.service.HeartBeatService  /   注：自v2.0.5版本开始，将原来的 BmobImService 名称更换为 BmobIMService ，请务必修改，否则将无法正常使用IM服务。", 
            "title": "3.3.3、 添加service、receiver标签："
        }, 
        {
            "location": "/im/android/#34", 
            "text": "", 
            "title": "3.4、代码配置"
        }, 
        {
            "location": "/im/android/#341", 
            "text": "", 
            "title": "3.4.1、注册消息接收器"
        }, 
        {
            "location": "/im/android/#3411newim_v202", 
            "text": "1、请自定义消息接收器继承自 BmobIMMessageHandler 来处理服务器发来的消息和离线消息。  public class DemoMessageHandler extends BmobIMMessageHandler{\n\n    @Override\n    public void onMessageReceive(final MessageEvent event) {\n        //当接收到服务器发来的消息时，此方法被调用\n    }\n\n    @Override\n    public void onOfflineReceive(final OfflineMessageEvent event) {\n        //每次调用connect方法时会查询一次离线消息，如果有，此方法会被调用\n    }\n}  2、在Application的onCreate方法中注册这个 DemoMessageHandler 。  \npublic class BmobIMApplication extends Application{\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //NewIM初始化\n        BmobIM.init(this);\n        //注册消息接收器\n        BmobIM.registerDefaultMessageHandler(new DemoMessageHandler(this));\n    }\n}", 
            "title": "3.4.1.1、如果你使用的是NewIM_V2.0.2及以后的版本"
        }, 
        {
            "location": "/im/android/#3412sdknewim_v201", 
            "text": "1、请创建一个广播消息接收器，用于接收服务器发来的消息。  \npublic class MessageReceiver extends BroadcastReceiver {\n\n    @Override\n    public void onReceive(final Context context, Intent intent) {\n        if(intent!=null){\n            final MessageEvent event =(MessageEvent)intent.getSerializableExtra( event );\n            //开发者可以在这里发应用通知\n    }\n}  2、在 AndroidManifest.xml 中注册此receiver。  receiver\n    android:name= 程序包名.MessageReceiver \n    android:enabled= true \n     intent-filter \n         action android:name= cn.bmob.im.action.MESSAGE / \n     /intent-filter  /receiver", 
            "title": "3.4.1.2、如果你使用的SDK版本是NewIM_V2.0.1"
        }, 
        {
            "location": "/im/android/#342bmobnewim-sdk", 
            "text": "在Application的onCreate方法中调用 BmobIM.init(context) 。  public class BmobIMApplication extends Application{\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //只有主进程运行的时候才需要初始化\n        if (getApplicationInfo().packageName.equals(getMyProcessName())){\n            //im初始化\n            BmobIM.init(this);\n            //注册消息接收器\n            BmobIM.registerDefaultMessageHandler(new DemoMessageHandler(this));\n        }\n    }\n\n    /**\n     * 获取当前运行的进程名\n     * @return\n     */\n    public static String getMyProcessName() {\n        try {\n            File file = new File( /proc/  + android.os.Process.myPid() +  /  +  cmdline );\n            BufferedReader mBufferedReader = new BufferedReader(new FileReader(file));\n            String processName = mBufferedReader.readLine().trim();\n            mBufferedReader.close();\n            return processName;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n}  注：   初始化方法包含了BmobSDK的初始化步骤，故无需再初始化BmobSDK。  在初始化的时候，最好做下判断：只有主进程运行的时候才开始初始化，避免资源浪费。", 
            "title": "3.4.2、初始化BmobNewIM SDK"
        }, 
        {
            "location": "/im/android/#4bmobnewim-sdk", 
            "text": "", 
            "title": "4、BmobNewIM SDK 使用"
        }, 
        {
            "location": "/im/android/#41", 
            "text": "", 
            "title": "4.1、服务器连接"
        }, 
        {
            "location": "/im/android/#411", 
            "text": "调用 connect 方法，需要传入唯一用户标示 clientId ，Demo使用的是Bmob的用户登录系统 objectId 。  User user = BmobUser.getCurrentUser(context,User.class);\nBmobIM.connect(user.getObjectId(), new ConnectListener() {\n    @Override\n    public void done(String uid, BmobException e) {\n        if (e == null) {\n            Logger.i( connect success );\n        } else {\n            Logger.e(e.getErrorCode() +  /  + e.getMessage());\n        }\n    }\n});", 
            "title": "4.1.1、连接"
        }, 
        {
            "location": "/im/android/#412", 
            "text": "调用 disConnect 方法，客户端会断开与服务器之间的连接，再次聊天需要重新调用 connect 方法完成与服务器之间的连接。  BmobIM.getInstance().disConnect();", 
            "title": "4.1.2、断开连接："
        }, 
        {
            "location": "/im/android/#413", 
            "text": "调用 setOnConnectStatusChangeListener 方法即可监听到当前长链接的连接状态。   BmobIM.getInstance().setOnConnectStatusChangeListener(new ConnectStatusChangeListener() {\n            @Override\n            public void onChange(ConnectionStatus status) {\n                Logger.i(  + status.getMsg());\n            }\n        });", 
            "title": "4.1.3、监听服务器连接状态"
        }, 
        {
            "location": "/im/android/#42", 
            "text": "", 
            "title": "4.2、会话"
        }, 
        {
            "location": "/im/android/#421", 
            "text": "BmobNewIM SDK 采用会话（ BmobIMConversation ）管理消息( BmobIMMessage )的方式，即消息的查询、发送和删除等操作均在指定会话下进行，因此需要获取指定会话信息并创建会话实例。目前创建会话有两种创建方式，分别是 暂态会话 和 常态会话 。", 
            "title": "4.2.1、创建会话"
        }, 
        {
            "location": "/im/android/#4211", 
            "text": "BmobNewIM SDK在 BmobIMMessage 类中新增 isTransient 属性来标识该条消息是否自动保存到 聊天对象 的本地DB中。   设置为 true ,表明为暂态消息，那么这条消息 并不会保存到聊天对象的本地db中 ，SDK只负责发送和接收。  设置为 false ,表明不为暂态消息，SDK会 自动保存该类型的消息到指定会话的数据库 中。", 
            "title": "4.2.1.1、暂态消息"
        }, 
        {
            "location": "/im/android/#4212", 
            "text": "该会话只提供消息发送功能，不可使用其他查询，删除等API， 不会自动创建会话 到本地DB中。一般用于 自定义消息的发送 ，比如，添加好友的请求，在对方还没有同意的情况下，你并不希望在自己的会话列表中显示该会话。 v2.0.4 版本的NewIM开始提供此种方式创建暂态会话  //开启私聊会话，isTransient可设置是否保存该会话到自己的本地会话表中\nstartPrivateConversation(BmobIMUserInfo info, boolean isTransient,ConversationListener listener)", 
            "title": "4.2.1.2、创建暂态会话"
        }, 
        {
            "location": "/im/android/#4213", 
            "text": "该会话提供消息查询、发送、删除等功能，SDK内部自动创建该会话。  //开启私聊会话，默认会保存该会话到自己的本地会话表中\nstartPrivateConversation(BmobIMUserInfo info, ConversationListener listener)", 
            "title": "4.2.1.3、创建常态会话"
        }, 
        {
            "location": "/im/android/#4213_1", 
            "text": "BmobIMUserInfo 类，是用户信息类，有三个属性需要开发者关注下：userId(用户唯一id)，name(用户名)，avatar（用户头像）。  //如果需要更新用户资料，开发者只需要传新的info进去就可以\nBmobIM.getInstance().startPrivateConversation(BmobIMUserInfo info, new ConversationListener() {\n    @Override\n    public void done(BmobIMConversation c, BmobException e) {\n        if(e==null){\n            //在此跳转到聊天页面\n            Bundle bundle = new Bundle();\n            bundle.putSerializable( c , c);\n            startActivity(ChatActivity.class, bundle, false);\n        }else{\n            toast(e.getMessage()+ ( +e.getErrorCode()+ ) );\n        }\n    }\n});", 
            "title": "4.2.1.3、创建会话示例"
        }, 
        {
            "location": "/im/android/#422", 
            "text": "BmobIM.getInstance().loadAllConversation()", 
            "title": "4.2.2、查询全部会话"
        }, 
        {
            "location": "/im/android/#423", 
            "text": "", 
            "title": "4.2.3、查询会话的未读消息数量"
        }, 
        {
            "location": "/im/android/#4231", 
            "text": "BmobIM.getInstance().getUnReadCount(String conversationId)", 
            "title": "4.2.3.1、查询指定会话下的未读消息数量"
        }, 
        {
            "location": "/im/android/#4232", 
            "text": "BmobIM.getInstance().getUnReadCount.getAllUnReadCount()", 
            "title": "4.2.3.2、查询全部会话的全部未读消息数"
        }, 
        {
            "location": "/im/android/#424", 
            "text": "//提供两种方式删除会话\nBmobIM.getInstance().deleteConversation(BmobIMConversation c);\nBmobIM.getInstance().deleteConversation(String conversationId);", 
            "title": "4.2.4、删除指定会话"
        }, 
        {
            "location": "/im/android/#425", 
            "text": "BmobIM.getInstance().clearAllConversation();", 
            "title": "4.2.5、清空全部会话"
        }, 
        {
            "location": "/im/android/#426", 
            "text": "由于BmobNewIM SDK并不包含与用户有关的逻辑，只负责存储用户信息并对外提供更新等方法,用来操作本地的用户信息。  在与人单聊时，需要更新会话标题和会话图标及用户信息，可调用如下方法在 DemoMessageHandler 的全局消息接收器中进行统一更新。  /**更新用户资料和会话资料\n * @param event\n * @param listener\n */\npublic void updateUserInfo(MessageEvent event,final UpdateCacheListener listener){\n    final BmobIMConversation conversation=event.getConversation();\n    final BmobIMUserInfo info =event.getFromUserInfo();\n    final BmobIMMessage msg =event.getMessage();\n    String username =info.getName();\n    String title =conversation.getConversationTitle();\n    //sdk内部，将新会话的会话标题用objectId表示，因此需要比对用户名和会话标题--单聊，后续会根据会话类型进行判断\n    if(!username.equals(title)) {\n        UserModel.getInstance().queryUserInfo(info.getUserId(), new QueryUserListener() {\n            @Override\n            public void done(User s, BmobException e) {\n                if(e==null){\n                    String name =s.getUsername();\n                    String avatar = s.getAvatar();\n                    conversation.setConversationIcon(avatar);\n                    conversation.setConversationTitle(name);\n                    info.setName(name);\n                    info.setAvatar(avatar);\n                    //更新用户资料\n                    BmobIM.getInstance().updateUserInfo(info);\n                   //更新会话资料-如果消息是暂态消息，则不更新会话资料\n                    if(!msg.isTransient()){\n                        BmobIM.getInstance().updateConversation(conversation);\n                    }\n                }else{\n                    Logger.e(e);\n                }\n                listener.done(null);\n            }\n        });\n    }else{\n        listener.internalDone(null);\n    }\n}", 
            "title": "4.2.6、更新会话标题、会话图标及用户信息"
        }, 
        {
            "location": "/im/android/#43", 
            "text": "消息( BmobIMMessage )是所有消息的基类，以下BmobNewIM SDK目前支持的消息类型。     消息类型  消息类名      文本  BmobIMTextMessage    文件  BmobIMFileMessage    图像  BmobIMImageMessage    音频  BmobIMAudioMessage    视频  BmobIMVideoMessage    地理位置  BmobIMLocationMessage", 
            "title": "4.3、消息"
        }, 
        {
            "location": "/im/android/#431", 
            "text": "BmobNewIM SDK采用会话（ BmobIMConversation ）管理消息( BmobIMMessage )的方式，即消息的查询、发送和删除等操作均在指定会话下进行，因此需要通过以下两个步骤来获取指定会话信息并创建会话实例。  1、 开启私聊  //如果需要更新用户资料，开发者只需要传新的info进去就可以\nBmobIM.getInstance().startPrivateConversation(BmobImUserInfo info, new ConversationListener() {\n    @Override\n    public void done(BmobIMConversation c, BmobException e) {\n        if(e==null){\n            //在此跳转到聊天页面\n            Bundle bundle = new Bundle();\n            bundle.putSerializable( c , c);\n            startActivity(ChatActivity.class, bundle, false);\n        }else{\n            toast(e.getMessage()+ ( +e.getErrorCode()+ ) );\n        }\n    }\n});  2、 创建会话实例  使用 BmobIMConversation.obtain(BmobIMClient client,BmobIMConversation conversation) 方法传入 BmobIMClient和BmobIMConversation的各自实例 就可以创建一个用于控制消息查询、发送和删除的会话实例。  BmobIMConversation c;\n//在聊天页面的onCreate方法中，通过如下方法创建新的会话实例,这个obtain方法才是真正创建一个管理消息发送的会话\nc=BmobIMConversation.obtain(BmobIMClient.getInstance(),(BmobIMConversation)getBundle().getSerializable( c ));  创建完成后，就可以使用这个会话实例 c 对消息进行各种操作啦，以下操作中的 c 都指的是该会话实例。  注：\n如果不调用BmobIMConversation的 obtain 方法是无法控制消息发送等操作的，会报 client disconnect 的错误。", 
            "title": "4.3.1、获取指定会话信息并创建会话实例"
        }, 
        {
            "location": "/im/android/#432", 
            "text": "//首次加载，可设置msg为null，\n//下拉刷新的时候，可用消息表的第一个msg作为刷新的起始时间点，默认按照消息时间的降序排列，limit由开发者控制\nc.queryMessages(msg, limit, new MessagesQueryListener() {\n            @Override\n            public void done(List BmobIMMessage  list, BmobException e) {\n                sw_refresh.setRefreshing(false);\n                if (e == null) {\n                    if (null != list   list.size()   0) {\n                        adapter.addMessages(list);\n                        adapter.notifyDataSetChanged();\n                        layoutManager.scrollToPositionWithOffset(list.size() - 1, 0);\n                    }\n                } else {\n                    toast(e.getMessage() +  (  + e.getErrorCode() +  ) );\n                }\n            }\n        });", 
            "title": "4.3.2、查询指定会话的聊天记录"
        }, 
        {
            "location": "/im/android/#433", 
            "text": "删除消息不同于删除会话，会直接清空本地的消息记录数据。  //删除指定聊天消息\nc.deleteMessage(BmobIMMessage msg)\n\n//删除一条或多条聊天消息\nc.deleteBatchMessage(List BmobIMMessage  msgs)\n\n//清空该会话下的聊天消息，允许保留会话（可选）\nc.clearMessage(boolean isKeepConversion,MessageListener listener)\n\n注：isKeepConversion 表示是否保留该会话消息。", 
            "title": "4.3.3、删除指定会话的聊天记录"
        }, 
        {
            "location": "/im/android/#434", 
            "text": "可以在 ChatActivity 的聊天页面的 onDestory 方法中调用如下方法 更新该会话的的所有消息为已读状态 ：  //更新此会话的所有消息为已读状态\nc.updateLocalCache();", 
            "title": "4.3.4、更新指定会话的所有消息为已读状态"
        }, 
        {
            "location": "/im/android/#44", 
            "text": "", 
            "title": "4.4、消息发送"
        }, 
        {
            "location": "/im/android/#441", 
            "text": "文本消息可以是纯文本，也可以是包含表情的文本消息，通过 BmobIMTextMessage 的 setContent 方法设置内容来构建 BmobIMTextMessage 实例，再调用 BmobIMConversation 的 sendMessage 方法发送。  BmobIMTextMessage msg =new BmobIMTextMessage();\nmsg.setContent(text);\n//可随意设置额外信息\nMap String,Object  map =new HashMap ();\nmap.put( level ,  1 );\nmsg.setExtraMap(map);\nc.sendMessage(msg, new MessageSendListener() {\n    @Override\n    public void onStart(BmobIMMessage msg) {\n        super.onStart(msg);\n        scrollToBottom();\n        adapter.addMessage(msg);\n        adapter.notifyDataSetChanged();\n    }\n\n    @Override\n    public void done(BmobIMMessage msg, BmobException e) {\n        scrollToBottom();\n        adapter.notifyDataSetChanged();\n        edit_msg.setText( );\n        if (e != null) {\n            toast(e.getMessage());\n        }\n    }\n});", 
            "title": "4.4.1、文本消息"
        }, 
        {
            "location": "/im/android/#442", 
            "text": "图片可以是通过系统拍照或本地相册中获取的本地图片地址，也可以使用网络上某个有效的图片地址。然后构造一个 BmobIMImageMessage 对象，再调用 BmobIMConversation 的 sendMessage 方法发送。", 
            "title": "4.4.2、图片消息"
        }, 
        {
            "location": "/im/android/#4421", 
            "text": "使用系统拍照功能或从本地相册中获取到本地图片地址( localPath )，然后调用构造方法 BmobIMImageMessage（String localPath） 来创建 BmobIMImageMessage 实例。  BmobIMImageMessage image =new BmobIMImageMessage(localPath);\nc.sendMessage(image, new MessageSendListener() {\n\n    @Override\n    public void onProgress(int value) {\n        super.onProgress(value);\n        //文件类型的消息才有进度值:do something\n        Logger.i( onProgress： +value);\n    }\n\n    @Override\n    public void onStart(BmobIMMessage msg) {\n        scrollToBottom();\n        adapter.addMessage(msg);\n        adapter.notifyDataSetChanged();\n    }\n\n    @Override\n    public void done(BmobIMMessage msg, BmobException e) {\n        scrollToBottom();\n        adapter.notifyDataSetChanged();\n        edit_msg.setText( );\n        if (e != null) {\n            toast(e.getMessage());\n        }\n    }\n});", 
            "title": "4.4.2.1、发送本地图片"
        }, 
        {
            "location": "/im/android/#4422url", 
            "text": "例如，从微博或QQ中获取到某个图片地址，然后调用BmobIMImageMessage的 setRemoteUrl 方法设置远程图片URL来创建 BmobIMImageMessage 实例。  BmobIMImageMessage image =new BmobIMImageMessage();\nimage.setRemoteUrl( http://img.lakalaec.com/ad/57ab6dc2-43f2-4087-81e2-b5ab5681642d.jpg );\nc.sendMessage(image, new MessageSendListener() {\n\n    @Override\n    public void onProgress(int value) {\n        super.onProgress(value);\n        //文件类型的消息才有进度值\n        Logger.i( onProgress： +value);\n    }\n\n    @Override\n    public void onStart(BmobIMMessage msg) {\n        scrollToBottom();\n        adapter.addMessage(msg);\n        adapter.notifyDataSetChanged();\n    }\n\n    @Override\n    public void done(BmobIMMessage msg, BmobException e) {\n        scrollToBottom();\n        adapter.notifyDataSetChanged();\n        edit_msg.setText( );\n        if (e != null) {\n            toast(e.getMessage());\n        }\n    }\n});", 
            "title": "4.4.2.2、发送远程图片URL"
        }, 
        {
            "location": "/im/android/#443", 
            "text": "语音可以是通过录制音频得到的本地音频地址，也可以使用网络上某个有效的音频地址。然后构造一个 BmobIMAudioMessage 对象，再调用 BmobIMConversation 的 sendMessage 方法发送。", 
            "title": "4.4.3、语音消息"
        }, 
        {
            "location": "/im/android/#4431", 
            "text": "BmobIMAudioMessage image =new BmobIMAudioMessage(localPath);\nc.sendMessage(image, new MessageSendListener() {\n\n    @Override\n    public void onProgress(int value) {\n        super.onProgress(value);\n        //文件类型的消息才有进度值:do something\n        Logger.i( onProgress： +value);\n    }\n\n    @Override\n    public void onStart(BmobIMMessage msg) {\n        scrollToBottom();\n        adapter.addMessage(msg);\n        adapter.notifyDataSetChanged();\n    }\n\n    @Override\n    public void done(BmobIMMessage msg, BmobException e) {\n        scrollToBottom();\n        adapter.notifyDataSetChanged();\n        edit_msg.setText( );\n        if (e != null) {\n            toast(e.getMessage());\n        }\n    }\n});", 
            "title": "4.4.3.1、发送本地音频文件："
        }, 
        {
            "location": "/im/android/#4432url", 
            "text": "同样的，语音消息也支持发送远程语音URL地址：  BmobIMAudioMessage image =new BmobIMAudioMessage();\nimage.setRemoteUrl( 远程语音地址 );\nc.sendMessage(image, new MessageSendListener() {\n\n    @Override\n    public void onProgress(int value) {\n        super.onProgress(value);\n        //文件类型的消息才有进度值\n        Logger.i( onProgress： +value);\n    }\n\n    @Override\n    public void onStart(BmobIMMessage msg) {\n        scrollToBottom();\n        adapter.addMessage(msg);\n        adapter.notifyDataSetChanged();\n    }\n\n    @Override\n    public void done(BmobIMMessage msg, BmobException e) {\n        scrollToBottom();\n        adapter.notifyDataSetChanged();\n        edit_msg.setText( );\n        if (e != null) {\n            toast(e.getMessage());\n        }\n    }\n});", 
            "title": "4.4.3.2、发送远程语音URL地址"
        }, 
        {
            "location": "/im/android/#444", 
            "text": "地理位置可以通过任意地图SDK获取到经纬度，详细地址等信息，然后调用 BmobIMLocationMessage(String address,double latitude,double longitude) 构造方法构建 BmobIMLocationMessage 实例，再调用 BmobIMConversation 的 sendMessage 方法发送。：  BmobIMLocationMessage location =new BmobIMLocationMessage( 广州番禺区 ,23.5,112.0);\nc.sendMessage(location,  new MessageSendListener() {\n\n    @Override\n    public void onStart(BmobIMMessage msg) {\n        scrollToBottom();\n        adapter.addMessage(msg);\n        adapter.notifyDataSetChanged();\n    }\n\n    @Override\n    public void done(BmobIMMessage msg, BmobException e) {\n        scrollToBottom();\n        adapter.notifyDataSetChanged();\n        edit_msg.setText( );\n        if (e != null) {\n            toast(e.getMessage());\n        }\n    }\n});", 
            "title": "4.4.4、地理位置消息"
        }, 
        {
            "location": "/im/android/#45", 
            "text": "", 
            "title": "4.5、消息接收"
        }, 
        {
            "location": "/im/android/#451", 
            "text": "", 
            "title": "4.5.1、自定义消息接收器"
        }, 
        {
            "location": "/im/android/#4511newim_v204newbmobim-sdk", 
            "text": "如果你使用的是 NewIM_V2.0.4以后(包含v2.0.4) 的SDK版本,那么不仅可以使用 BmobIMMessageHandler 方式来注册全局的消息接收器，还可以使用 MessageListHandler 为单个页面注册消息接收器，具体步骤如下：   在 Activity/Fragment 中实现 MessageListHandler 接口；  在 onResume 方法中添加页面消息监听器： BmobIM.getInstance().addMessageListHandler(this) ；  在 onPause 方法中移除页面消息监听器： BmobIM.getInstance().removeMessageListHandler(this) ；  在 MessageListHandler 接口的 onMessageReceive 方法中做相关的操作。   具体示例可查看NewIMDemo中的 ChatActivity 类：  @Override\npublic void onMessageReceive(List MessageEvent  list) {\n    //当注册页面消息监听时候，有消息（包含离线消息）到来时会回调该方法\n    for (int i=0;i list.size();i++){\n        //do something...\n    }\n}", 
            "title": "4.5.1.1、NewIM_V2.0.4及以后的NewBmobIM SDK版本"
        }, 
        {
            "location": "/im/android/#4512newim_v202newbmobim-sdk", 
            "text": "如果你使用的是 NewIM_V2.0.2以后(包含v2.0.2) 的SDK版本,那么只需要自定义消息接收器继承自 BmobIMMessageHandler 来处理服务器发来的消息和离线消息。  \npublic class DemoMessageHandler extends BmobIMMessageHandler{\n\n    private Context context;\n    public DemoMessageHandler(Context context) {\n        this.context = context;\n    }\n\n    @Override\n    public void onMessageReceive(final MessageEvent event) {\n        //当接收到服务器发来的消息时，此方法被调用\n        //可以统一在此检测更新会话及用户信息\n        UserModel.getInstance().updateUserInfo(event, new UpdateCacheListener() {\n            @Override\n            public void done(BmobException e) {\n                BmobIMMessage msg = event.getMessage();\n                //用户自定义的消息类型，其类型值均为0\n                if(BmobIMMessageType.getMessageTypeValue(msg.getMsgType())==0){\n                    //自行处理自定义消息类型\n                    Logger.i(msg.getMsgType() +  ,  + msg.getContent() +  ,  + msg.getExtra());\n                }else{//SDK内部内部支持的消息类型\n                    if (BmobNotificationManager.getInstance(context).isShowNotification()){\n                        //如果需要显示通知栏，可以使用BmobNotificationManager类提供的方法，也可以自己写通知栏显示方法\n                   }else{//直接发送消息事件\n                        Logger.i( 当前处于应用内，发送event );\n                        EventBus.getDefault().post(event);\n                    }\n                }\n            }\n        });\n    }\n\n    @Override\n    public void onOfflineReceive(final OfflineMessageEvent event) {\n        //每次调用connect方法时会查询一次离线消息，如果有，此方法会被调用\n        Map String,List MessageEvent  map =event.getEventMap();\n        Logger.i( 离线消息属于 +map.size()+ 个用户 );\n        for (Map.Entry String, List MessageEvent  entry : map.entrySet()) {\n            List MessageEvent  list =entry.getValue();\n            //挨个检测离线用户信息是否需要更新\n            UserModel.getInstance().updateUserInfo(list.get(0), new UpdateCacheListener() {\n                @Override\n                public void done(BmobException e) {\n                    EventBus.getDefault().post(event);\n                }\n            });\n        }\n    }\n}  同样，别忘记在Application的onCreate方法中注册这个 DemoMessageHandler ：  \npublic class BmobIMApplication extends Application{\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //注册消息接收器\n        BmobIM.registerDefaultMessageHandler(new DemoMessageHandler(this));\n    }\n}", 
            "title": "4.5.1.2、NewIM_V2.0.2及以后的NewBmobIM SDK版本"
        }, 
        {
            "location": "/im/android/#4513newim_v201newbmobim-sdk", 
            "text": "如果你使用的SDK版本是 NewIM_V2.0.1 ,那么你需要在应用中创建一个 BroadcastReceiver 广播消息接收器，用于接收服务器发来的消息。  public class MessageReceiver extends BroadcastReceiver {\n\n    @Override\n    public void onReceive(final Context context, Intent intent) {\n        if(intent!=null){\n            final MessageEvent event =(MessageEvent)intent.getSerializableExtra(\"event\");\n            //可以统一在此检测更新会话及用户信息\n            UserModel.getInstance().updateUserInfo(event, new UpdateCacheListener() {\n                @Override\n                public void done(BmobException e) {\n                    BmobIMMessage msg = event.getMessage();\n                    //用户自定义的消息类型，其类型值均为0\n                    if(BmobIMMessageType.getMessageTypeValue(msg.getMsgType())==0){\n                        //自行处理自定义消息类型\n                        Logger.i(msg.getMsgType() + \",\" + msg.getContent() + \",\" + msg.getExtra());\n                    }else{//SDK内部内部支持的消息类型\n                        if (BmobNotificationManager.getInstance(context).isShowNotification()){\n                            //如果需要显示通知栏，可以使用BmobNotificationManager类提供的方法，也可以自己写通知栏显示方法\n                       }else{//直接发送消息事件\n                            Logger.i(\"当前处于应用内，发送event\");\n                            EventBus.getDefault().post(event);\n                        }\n                    }\n                }\n            });\n    }\n}  别忘记在 AndroidManifest.xml 中注册这个receiver  receiver\n    android:name= 程序包名.MessageReceiver \n    android:enabled= true \n     intent-filter \n         action android:name= cn.bmob.im.action.MESSAGE / \n     /intent-filter  /receiver", 
            "title": "4.5.1.3、NewIM_V2.0.1的NewBmobIM SDK版本"
        }, 
        {
            "location": "/im/android/#452", 
            "text": "V2.0.1 的SDK内部集成EventBus库（ V2.0.2 SDK内部不再集成EventBus，开发者可以自行使用新版EventBus）来进行应用内消息的分发，故在应用内需要接收消息的地方注册和解注册EventBus即可。  SDK内部有两种事件： MessageEvent（聊天消息） 、 OfflineMessageEvent(离线消息) 。  1、注册EventBus  EventBus.getDefault().register(this);  2、解注册EventBus  EventBus.getDefault().unregister(this);  3、处理聊天消息  /**聊天消息接收事件\n * @param event\n */\npublic void onEventMainThread(MessageEvent event){\n    //处理聊天消息\n}  4、处理离线消息  \n/**离线消息接收事件\n * @param event\n */\npublic void onEventMainThread(OfflineMessageEvent event){\n    //处理离线消息\n}", 
            "title": "4.5.2、应用内消息接收"
        }, 
        {
            "location": "/im/android/#453", 
            "text": "SDK新增 BmobNotificationManager 类，并提供如下两个方法供开发者展示通知栏:   多个用户的多条消息合并成一条通知：有XX个联系人发来了XX条消息   /**显示通知：多个用户的多条消息合并显示一条通知\n * @param event 某个消息事件：包含消息、会话及发送用户的信息\n * @param intent 跳转intent\n */\n BmobNotificationManager.getInstance(context).showNotification(MessageEvent event,Intent pendingIntent);   自定义通知消息：始终只有一条通知，新消息覆盖旧消息    /**显示通知\n * @param largerIcon 通知栏图标 开发者可传应用图标，也可以将聊天头像转成bitmap\n * @param title 标题\n * @param content 内容\n * @param ticker 状态栏上显示的内容\n * @param intent 跳转的intent\n */\nBmobNotificationManager.getInstance(context).showNotification(Bitmap largerIcon,String title, String content, String ticker,Intent intent);  注：为了使SDK能够区分当前应用是否退出，开发者需进行以下几个步骤：  1、在会话和聊天的Activity类实现'ObseverListener'监听器；  2、在 onResume 方法中调用 BmobNotificationManager.getInstance(context).addObserver(this) 方法添加观察者；\n   在 onPause 方法中调用 BmobNotificationManager.getInstance(context).removeObserver(this) 方法移除观察者  3、在主Activity的 onDestroy 方法中调用 BmobNotificationManager.getInstance(context).clearObserver() 清空观察者。", 
            "title": "4.5.3、应用外通知栏提醒"
        }, 
        {
            "location": "/im/android/#46", 
            "text": "", 
            "title": "4.6、自定义消息"
        }, 
        {
            "location": "/im/android/#461", 
            "text": "有些时候，开发者需要在发送消息时携带一些额外信息，例如 发送方的设备类型、图片的拍摄地点或者音频的来源 等，那么开发者可以通过  BmobIMExtraMessage.extraMap 属性来解决，任何继承 BmobIMExtraMessage 类的消息均支持设置额外信息。      BmobIMAudioMessage audio =new BmobIMAudioMessage();\n    image.setRemoteUrl( 远程音频地址 );\n    //设置音频文件的来源\n    Map String,Object  map =new HashMap ();\n    map.put( from ,  优酷 );\n    audio.setExtraMap(map);\n    c.sendMessage(audio, listener);", 
            "title": "4.6.1、设置额外信息"
        }, 
        {
            "location": "/im/android/#462", 
            "text": "如果设置额外信息无法满足开发者的需求，那么开发者也可以自定义自己的消息类型。", 
            "title": "4.6.2、创建新的消息类型"
        }, 
        {
            "location": "/im/android/#4621", 
            "text": "继承自 BmobIMExtraMessage 类；  重写 getMsgType 方法，填写自定义的消息类型；  重写 isTransient 方法。       public class AddFriendMessage extends BmobIMExtraMessage{\n\n        @Override\n        public String getMsgType() {\n            return  add ;\n        }\n\n        @Override\n        public boolean isTransient() {\n            //设置为true,表明为暂态消息，那么这条消息并不会保存到对方的本地db中\n            //设置为false,则会保存到对方指定会话的本地数据库中\n            return true;\n        }\n\n        public AddFriendMessage(){}\n\n    }", 
            "title": "4.6.2.1、创建自定义消息"
        }, 
        {
            "location": "/im/android/#4622", 
            "text": "//启动一个会话，如果isTransient设置为true,则不会创建在本地会话表中创建该会话，\n    //设置isTransient设置为false,则会在本地数据库的会话列表中先创建（如果没有）与该用户的会话信息，且将用户信息存储到本地的用户表中\n    BmobIMConversation c = BmobIM.getInstance().startPrivateConversation(info, true,null);\n    //这个obtain方法才是真正创建一个管理消息发送的会话\n    BmobIMConversation conversation = BmobIMConversation.obtain(BmobIMClient.getInstance(), c);\n    AddFriendMessage msg =new AddFriendMessage();\n    User currentUser = BmobUser.getCurrentUser(this,User.class);\n    msg.setContent( 很高兴认识你，可以加个好友吗? );//给对方的一个留言信息\n    Map String,Object  map =new HashMap ();\n    map.put( name , currentUser.getUsername());//发送者姓名，这里只是举个例子，其实可以不需要传发送者的信息过去\n    map.put( avatar ,currentUser.getAvatar());//发送者的头像\n    map.put( uid ,currentUser.getObjectId());//发送者的uid\n    msg.setExtraMap(map);\n    conversation.sendMessage(msg, new MessageSendListener() {\n        @Override\n        public void done(BmobIMMessage msg, BmobException e) {\n            if (e == null) {//发送成功\n                toast( 好友请求发送成功，等待验证 );\n            } else {//发送失败\n                toast( 发送失败:  + e.getMessage());\n            }\n        }\n    });", 
            "title": "4.6.2.2、发送自定义消息"
        }, 
        {
            "location": "/im/android/#47", 
            "text": "BmobNewIM SDK只是即时通讯的消息收发渠道，本身并不提供用户体系。开发者可使用BmobSDK提供的用户管理方面功能，也可使用开发者自己的用户体系。  BmobNewIM SDK内部会自动创建本地用户表，并对外提供方法供开发者调用来操作本地用户表。开发者只需要调用 updateUserInfo 方法即可更新本地用户信息。", 
            "title": "4.7、用户管理"
        }, 
        {
            "location": "/im/android/#471bmobimuserinfo", 
            "text": "BmobNewIM SDK中用户的实体类为 BmobIMUserInfo ，其有四个属性，开发者只需要关心后三个即可。     属性名  属性含义      id  本地数据库用户表的id值，开发者无需关心    userId  用户唯一id（Demo中用的是BmobUser的objectId）    name  用户名 （Demo中是用的是BmobUser的username）    avatar  用户头像", 
            "title": "4.7.1、BmobIMUserInfo介绍"
        }, 
        {
            "location": "/im/android/#472", 
            "text": "以下两种情况需要更新用户信息：\n1. 当注册或登录成功后，需要更新下当前用户的信息到本地数据库的用户表中，这样才能通过getUserInfo方法获取到本地的用户信息。\n2. 当接收到某人消息的时候，同样需要更新A的用户信息到本地用户表中，否则在会话界面将默认显示的是用户的userId，也就是Demo中的BmobUser的objectId值。", 
            "title": "4.7.2、更新本地用户信息"
        }, 
        {
            "location": "/im/android/#4721", 
            "text": "BmobIM.getInstance().updateUserInfo(BmobIMUserInfo info)", 
            "title": "4.7.2.1、更新单一本地用户信息"
        }, 
        {
            "location": "/im/android/#4722", 
            "text": "BmobIM.getInstance().updateBatchUserInfo(List BmobIMUserInfo  list)", 
            "title": "4.7.2.2、批量更新本地用户信息"
        }, 
        {
            "location": "/im/android/#473", 
            "text": "BmobNewIM SDK内部会自动创建了一个本地数据库用来存储用户信息，开发者需要先调用 updateUserInfo 更新用户信息到本地数据库中，才能通过 getUserInfo(uid) 获取到本地用户信息。  BmobIM.getInstance().getUserInfo(String uid)", 
            "title": "4.7.3、获取本地用户信息"
        }, 
        {
            "location": "/im/android/#48", 
            "text": "BmobNewIM SDK中并没有集成好友管理相关的功能，为了方便开发者建立基于好友之间的聊天模式，在 v2.0.4 版本开始的Demo中使用Data SDK新建了 Friend 表来进行好友管理。  /**好友表\n * @author smile\n * @project Friend\n * @date 2016-04-26\n */\npublic class Friend extends BmobObject{\n\n    //用户\n    private User user;\n    //好友\n    private User friendUser;\n\n    //getter setter...\n}", 
            "title": "4.8、好友管理"
        }, 
        {
            "location": "/im/android/#481", 
            "text": "以下摘自 UserModel(cn.bmob.imdemo.model) 类：  /**\n * 查询好友\n * @param listener\n */\npublic void queryFriends(final FindListener Friend  listener){\n    BmobQuery Friend  query = new BmobQuery ();\n    User user =BmobUser.getCurrentUser(getContext(), User.class);\n    query.addWhereEqualTo( user , user);\n    query.include( friendUser );\n    query.order( -updatedAt );\n    query.findObjects(getContext(), new FindListener Friend () {\n        @Override\n        public void onSuccess(List Friend  list) {\n            if (list != null   list.size()   0) {\n                listener.onSuccess(list);\n            } else {\n                listener.onError(0,  暂无联系人 );\n            }\n        }\n\n        @Override\n        public void onError(int i, String s) {\n            listener.onError(i, s);\n        }\n    });\n}", 
            "title": "4.8.1、获取好友列表"
        }, 
        {
            "location": "/im/android/#482", 
            "text": "以下摘自 UserModel(cn.bmob.imdemo.model) 类：  /**\n * 删除好友\n * @param f\n * @param listener\n */\npublic void deleteFriend(Friend f,DeleteListener listener){\n    Friend friend =new Friend();\n    friend.delete(getContext(),f.getObjectId(),listener);\n}", 
            "title": "4.8.2、删除好友"
        }, 
        {
            "location": "/im/android/#483", 
            "text": "Demo中创建了一个 NewFriend 的本地数据库类用来存储所有的添加好友请求。  /**本地的好友请求表\n * @author :smile\n * @project:NewFriend\n * @date :2016-04-26-17:28\n */\npublic class NewFriend implements java.io.Serializable {\n\n    private Long id;\n    //用户uid\n    private String uid;\n    //留言消息\n    private String msg;\n    //用户名\n    private String name;\n    //头像\n    private String avatar;\n    //状态：未读、已读、已添加、已拒绝等\n    private Integer status;\n    //请求时间\n    private Long time;\n\n    //getter setter...\n\n}  Demo中创建了一个 AddFriendMessage 类来展示如何发送自定义的添加好友请求的消息。  /**添加好友请求-自定义消息类型\n * @author :smile\n * @project:AddFriendMessage\n * @date :2016-01-30-17:28\n */\npublic class AddFriendMessage extends BmobIMExtraMessage{\n\n    public AddFriendMessage(){}\n\n    @Override\n    public String getMsgType() {\n        //自定义一个`add`的消息类型\n        return  add ;\n    }\n\n    @Override\n    public boolean isTransient() {\n        //设置为true,表明为暂态消息，那么这条消息并不会保存到本地db中，SDK只负责发送出去\n        //设置为false,则会保存到指定会话的数据库中\n        return true;\n    }\n\n    ...\n\n}  Demo中创建了一个 AgreeAddFriendMessage 类来展示如何发送自定义的同意添加好友请求的消息，并在对方的本地会话表中新增消息类型。  /**同意添加好友请求-仅仅只用于发送同意添加好友的消息\n * @author smile\n * @project AgreeAddFriendMessage\n * @date 2016-03-04-10:41\n */\npublic class AgreeAddFriendMessage extends BmobIMExtraMessage{\n\n    //以下均是从extra里面抽离出来的字段，方便获取\n    private String uid;//最初的发送方\n    private Long time;\n    private String msg;//用于通知栏显示的内容\n\n    @Override\n    public String getMsgType() {\n        return  agree ;\n    }\n\n    @Override\n    public boolean isTransient() {\n        //如果需要在对方的会话表中新增一条该类型的消息，则设置为false，表明是非暂态会话\n        //此处将同意添加好友的请求设置为false，为了演示怎样向会话表和消息表中新增一个类型，在对方的会话列表中增加`我通过了你的好友验证请求，我们可以开始聊天了!`这样的类型\n        return false;\n    }\n\n    //getter setter...\n\n    ...\n}", 
            "title": "4.8.3、添加好友"
        }, 
        {
            "location": "/im/android/#484", 
            "text": "以下摘自 UserInfoActivity(cn.bmob.imdemo.ui) 类：  /**\n * 发送添加好友的请求\n */\nprivate void sendAddFriendMessage(){\n    //启动一个暂态会话，也就是isTransient为true,表明该会话仅执行发送消息的操作，不会保存会话和消息到本地数据库中，\n    BmobIMConversation c = BmobIM.getInstance().startPrivateConversation(info, true,null);\n    //这个obtain方法才是真正创建一个管理消息发送的会话\n    BmobIMConversation conversation = BmobIMConversation.obtain(BmobIMClient.getInstance(), c);\n    //新建一个添加好友的自定义消息实体\n    AddFriendMessage msg =new AddFriendMessage();\n    User currentUser = BmobUser.getCurrentUser(this,User.class);\n    msg.setContent( 很高兴认识你，可以加个好友吗? );//给对方的一个留言信息\n    Map String,Object  map =new HashMap ();\n    map.put( name , currentUser.getUsername());//发送者姓名，这里只是举个例子，其实可以不需要传发送者的信息过去\n    map.put( avatar ,currentUser.getAvatar());//发送者的头像\n    map.put( uid ,currentUser.getObjectId());//发送者的uid\n    msg.setExtraMap(map);\n    conversation.sendMessage(msg, new MessageSendListener() {\n        @Override\n        public void done(BmobIMMessage msg, BmobException e) {\n            if (e == null) {//发送成功\n                toast( 好友请求发送成功，等待验证 );\n            } else {//发送失败\n                toast( 发送失败:  + e.getMessage());\n            }\n        }\n    });\n}", 
            "title": "4.8.4、发送添加好友的请求"
        }, 
        {
            "location": "/im/android/#485", 
            "text": "以下摘自 NewFriendHolder(cn.bmob.imdemo.adapter) 类：  /**\n * 发送同意添加好友的请求\n */\nprivate void sendAgreeAddFriendMessage(final NewFriend add,final SaveListener listener){\n    //发给谁，就填谁的用户信息\n    BmobIMUserInfo info = new BmobIMUserInfo(add.getUid(), add.getName(), add.getAvatar());\n    //启动一个暂态会话，也就是isTransient为true,表明该会话仅执行发送消息的操作，不会保存会话和消息到本地数据库中，\n    BmobIMConversation c = BmobIM.getInstance().startPrivateConversation(info,true,null);\n    //这个obtain方法才是真正创建一个管理消息发送的会话\n    BmobIMConversation conversation = BmobIMConversation.obtain(BmobIMClient.getInstance(),c);\n    //而AgreeAddFriendMessage的isTransient设置为false，表明我希望在对方的会话数据库中保存该类型的消息\n    AgreeAddFriendMessage msg =new AgreeAddFriendMessage();\n    User currentUser = BmobUser.getCurrentUser(getContext(), User.class);\n    msg.setContent( 我通过了你的好友验证请求，我们可以开始聊天了! );//---这句话是直接存储到对方的消息表中的\n    Map String,Object  map =new HashMap ();\n    map.put( msg ,currentUser.getUsername()+ 同意添加你为好友 );//显示在通知栏上面的内容\n    map.put( uid ,add.getUid());//发送者的uid-方便请求添加的发送方找到该条添加好友的请求\n    map.put( time , add.getTime());//添加好友的请求时间\n    msg.setExtraMap(map);\n    conversation.sendMessage(msg, new MessageSendListener() {\n        @Override\n        public void done(BmobIMMessage msg, BmobException e){\n            if (e == null) {//发送成功\n                //修改本地的好友请求记录\n                NewFriendManager.getInstance(getContext()).updateNewFriend(add.getUid(),add.getTime(),Config.STATUS_VERIFIED);\n                listener.onSuccess();\n            } else {//发送失败\n                listener.onFailure(e.getErrorCode(),e.getMessage());\n            }\n        }\n    });\n}", 
            "title": "4.8.5、发送同意添加好友的请求"
        }, 
        {
            "location": "/im/android/#486", 
            "text": "以下摘自 DemoMessageHandler(cn.bmob.imdemo) 类：  /**\n * 处理自定义消息类型:用户自定义的消息类型，其类型值均为0\n * @param msg\n */\nprivate void processCustomMessage(BmobIMMessage msg,BmobIMUserInfo info){\n    String type =msg.getMsgType();\n    //发送页面刷新的广播\n    EventBus.getDefault().post(new RefreshEvent());\n    //处理消息\n    if(type.equals( add )){//接收到的添加好友的请求\n        NewFriend friend = AddFriendMessage.convert(msg);\n        //本地好友请求表做下校验，本地没有的才允许显示通知栏--有可能离线消息会有些重复\n        long id = NewFriendManager.getInstance(context).insertOrUpdateNewFriend(friend);\n        if(id 0){\n            showAddNotify(friend);\n        }\n    }else if(type.equals( agree )){//接收到的对方同意添加自己为好友,此时需要做的事情：1、添加对方为好友，2、显示通知\n        AgreeAddFriendMessage agree = AgreeAddFriendMessage.convert(msg);\n        addFriend(agree.getFromId());//添加消息的发送方为好友\n        //这里应该也需要做下校验--来检测下是否已经同意过该好友请求，我这里省略了\n        showAgreeNotify(info,agree);\n    }else{\n        Toast.makeText(context, 接收到的自定义消息： +msg.getMsgType() +  ,  + msg.getContent() +  ,  + msg.getExtra(),Toast.LENGTH_SHORT).show();\n    }\n}", 
            "title": "4.8.6、接收并处理好友相关的请求"
        }, 
        {
            "location": "/im/android/#487friend", 
            "text": "以下摘自 DemoMessageHandler(cn.bmob.imdemo) 类：  /**\n * 添加对方为自己的好友\n * @param uid\n */\nprivate void addFriend(String uid){\n    User user =new User();\n    user.setObjectId(uid);\n    //添加到Friend表中\n    UserModel.getInstance().agreeAddFriend(user, new SaveListener() {\n        @Override\n        public void onSuccess() {\n            Log.i( bmob ,  onSuccess );\n        }\n\n        @Override\n        public void onFailure(int i, String s) {\n            Log.i( bmob ,  onFailure: +s+ - +i);\n        }\n    });\n}", 
            "title": "4.8.7、添加到Friend表中"
        }, 
        {
            "location": "/im/android/#5", 
            "text": "# 不混淆im sdk\n-keep class cn.bmob.newim.**{*;}\n-dontwarn cn.bmob.newim.**\n# 不混淆greenDao类\n-dontwarn de.greenrobot.dao.**\n-keep class de.greenrobot.dao.** { *;}\n-keepclassmembers class * extends de.greenrobot.dao.AbstractDao {\n    public static java.lang.String TABLENAME;\n}\n-keep class **$Properties\n# 不混淆async\n-dontwarn com.koushikdutta.async.**\n-keep class com.koushikdutta.async.** { *;}", 
            "title": "5. 混淆"
        }, 
        {
            "location": "/im/android/class_doc/", 
            "text": "类库文档\n\n\n及时通讯类库文档：\nhttp://docs.bmob.cn/im/Android/i_doc/doc/index.html", 
            "title": "类库文档"
        }, 
        {
            "location": "/im/android/class_doc/#_1", 
            "text": "及时通讯类库文档： http://docs.bmob.cn/im/Android/i_doc/doc/index.html", 
            "title": "类库文档"
        }, 
        {
            "location": "/im/android/update_log/", 
            "text": "v2.0.6_Beta   2016年04月28日\n\n\n1、BmobNewIM_v2.0.6将所依赖的数据SDK提升为BmobSDK_v3.5.5。\n\n\nv2.0.5_Beta   2016年6月01日\n\n\n1、BmobImService更名为BmobIMService,请务必修改；\n2、自2.0.5版本开始，提供aar格式的NewIMSDK,包含BmobNewIM_xxxx.jar、androidasync_2.1.6.jar、bmob_im_notification_strings.xml，开发者不再需要导入以上文件；\n3、demo提供自定义会话类型的示例，并修复部分已知问题；\n4、操作本地会话及消息表时去除服务连接的检验，减少client disconnect的发生；\n5、与之配套使用的BmobSDK版本3.4.7。\n\n\nv2.0.4_Beta   2016年4月29日\n\n\n1、优化服务重连机制；\n2、优化核心进程保活；\n3、新增消息监听器MessageListHandler,允许为单一页面注册消息接收器；\n3、修复发送BmobIMVideoMessage视频消息时出现的类型转换异常；\n4、配套Demo中新增好友管理功能，包含添加好友，同意添加好友、查询好友、删除好友等功能。\n\n\nv2.0.3_Beta   2016年4月19日\n\n\n1、修复离线消息重复获取的问题；\n2、修复语音消息无法获取时长的问题；\n3、修复部分机型无法发送语音的问题；\n4、依赖BmobSDK_v3.4.6_0415。\n\n\nv2.0.2_Beta   2016年3月10日\n\n\n1、增加消息接收器（BmobIMMessageHandler），方便对消息进行统一管理；\n2、修复接收的消息无法使用isTransient属性来存储消息；\n3、修复通知栏显示网址的问题；\n4、修复锁屏期间接收的消息无法及时更新到聊天界面的问题；\n5、支持跨平台与iOS进行通讯；\n6、SDK内部不再集成EventBus库,方便开发者使用新版EventBus。\n\n\nv2.0.1_Beta   2016年3月04日\n\n\n1、新增支持图片消息（BmobIMImageMessage）、语音消息（BmobIMAudioMessage）、地理位置消息（BmobIMLocationMessage）；\n2、新增通知管理器（BmobNotificationManager）类，方便开发者显示通知栏；\n3、支持自定义消息类型，API使用更加简便；\n4、修复切换账号时无法正确显示对应账号下会话的问题；\n5、完善服务重连机制，优化服务性能。\n\n\nv2.0.0_Beta   2016年2月01日\n\n\n1、全新架构、接口设计更加人性化，降低开发者使用成本；2、支持文本发送；3、支持陌生人聊天。\n\n\nv1.1.9_Beta   2015年8月20日\n\n\n1、允许自定义好友查询的总数；\n2、配套使用的BmobSDK为V3.4.3_0820版本。\n\n\nv1.1.8_Beta   2015年4月08日\n\n\n1、完善服务重连机制，同步提升聊天稳定性和及时性；\n2、配套使用的BmobSDK为V3.3.5_0408版本。 \n---------------强烈建议更新-------------------\n\n\nv1.1.7_Beta   2015年3月18日\n\n\n1、兼容Android5.0系统，解决由Service Intent must be explicit的系统警告导致无法接收到聊天消息的问题；\n2、同步更新BmobSDK到3.3.4版本。\n\n\nv1.1.6_Beta   2015年2月04日\n\n\n1、允许开发者自定义通知栏提示语;\n2、修复由于聊天双方的本机时间不一致导致的聊天记录顺序错位的问题;\n3、与之配套使用的BmobSDK为BmobSDK_V3.3.2_0128.jar。\n\n\nv1.1.5_Beta   2015年1月05日\n\n\n1、修复发送图片或者语音时导致应用奔溃的问题；\n2、新增支持自定义聊天消息体。\n\n\nv1.1.4_Beta   2014年10月27日\n\n\n1、修复查询附近的人中无法过滤性别为女的用户的bug；\n2、优化导致推送延迟或无法接收到推送的问题。\n\n\nv1.1.3_Beta   2014年10月23日\n\n\n1、聊天消息和Tag标记的消息的时间单位保持一致，均为秒；\n2、解决聊天消息和好友验证消息多次提醒的问题；\n3、重写sendTagMessage方法，支持扩展MsgTag，\n4、新增支持查询当前用户所有的未读消息个数；\n5、解决多设备登录同一账号时无法下线的问题；\n6、优化由于推送服务频繁重启导致无法收发消息的bug。\n\n\nv1.1.2_Beta   2014年9月23日\n\n\n1、新增支持陌生人聊天，允许发送给非好友用户；\n2、新增支持自定义消息的发送，便于开发者扩展；\n3、新版本大幅度增加稳定性和及时性，保证实时到达率。\n4、排除web后端推送对客户端的影响。\n\n\nv1.1.1_Beta   2014年8月14日\n\n\n1、新增查询指定范围内的附近的人列表；\n2、添加用户的性别设置；\n3、附近的人新增额外属性查询：如查询性别为女的用户。\n\n\nv1.1.0_Beta   2014年8月01日\n\n\n1、解决接收语音（时间超过10s）播放不成功的问题;\n2、增加服务的稳定性，防止被杀死;\n3、当账号注销登陆后又未登陆其他设备时，该账号仍能接收来自其他账号的消息（再次登陆成功之后即可看见未读消息）。\n\n\nv1.0.9_Beta   2014年7月25日\n\n\n1、修复图片或语音发送较慢的问题；\n2、修复注册成功之后退出应用之后再次回到登陆页的问题；\n3、修复部分机型接收到的语音消息无法播放的问题\n4、修复好友头像更换后会话界面的好友头像无法及时更换的问题。\n5、修复当应用锁屏后在回到聊天页面时，新接收的消息重复显示的问题;\n\n\nv1.0.8_Beta   2014年7月17日\n\n\n1、支持跨平台聊天，与ios端完成互通，跨平台支持的消息类型：纯文字、表情、图片。\n2、解决多次登录之后，本地存储的昵称和头像均消失的问题;\n3、新增对通知的声音和震动的控制。\n\n\nv1.0.7_Beta   2014年7月14日\n\n\n解决用户注册账户时报错的bug。\n\n\nv1.0.6_Beta   2014年7月11日\n\n\n1、解决当应用锁屏后在回到聊天页面时，新接收的消息不能显示的问题;\n2、解决频繁接收到不属于本人好友的消息而导致页面不断刷新的问题；\n3、解决播放语音过程中出现的播放错误的问题;\n4、修正发送图片的方式，重构部分代码。\n\n\nv1.0.5_Beta   2014年7月04日\n\n\n1、新增对单一用户的语音消息的发送;\n2、修复分页查询附近的人和好友列表时出现重复数据的问题;\n3、修复其他bug。\n\n\nv1.0.4_Beta   2014年6月27日\n\n\n1、新增地理位置交友.可查看附近的人列表; 2、支持分页列表的分页查询;\n3、修改其他bug。\n\n\nv1.0.3_Beta   2014年6月25日\n\n\n1、新增对单一用户的位置类型的消息的发送;\n2、支持黑名单管理功能;\n3、修改其他bug。\n\n\nv1.0.2_Beta   2014年6月23日\n\n\n解决用户注册或登录成功之后，无法收发消息的问题。\n\n\nv1.0.1_beta   2014年6月20日\n\n\n1、新增对单一用户的聊天图片（本地相册和拍照）发送;\n2、新增消息回执发送：已发送、已阅读两种状态;\n3、修改添加好友时出现的发送好友验证失败的bug;\n4、解决多账户登陆同一设备时，非当前登陆账号接收不到消息的bug。\n\n\nv1.0.0_Beta   2014年6月13日\n\n\n1、提供完整的好友管理功能，包括添加好友、删除好友、好友列表，也可以与你已有的用户系统完全解耦;\n2、支持单一用户的文字和表情聊天;\n3、支持会话的本地化存储;\n4、自定义消息接受机制;\n5、同一账号多处登陆强制下线。", 
            "title": "更新日志"
        }, 
        {
            "location": "/im/android/update_log/#v206_beta-20160428", 
            "text": "1、BmobNewIM_v2.0.6将所依赖的数据SDK提升为BmobSDK_v3.5.5。", 
            "title": "v2.0.6_Beta   2016年04月28日"
        }, 
        {
            "location": "/im/android/update_log/#v205_beta-2016601", 
            "text": "1、BmobImService更名为BmobIMService,请务必修改；\n2、自2.0.5版本开始，提供aar格式的NewIMSDK,包含BmobNewIM_xxxx.jar、androidasync_2.1.6.jar、bmob_im_notification_strings.xml，开发者不再需要导入以上文件；\n3、demo提供自定义会话类型的示例，并修复部分已知问题；\n4、操作本地会话及消息表时去除服务连接的检验，减少client disconnect的发生；\n5、与之配套使用的BmobSDK版本3.4.7。", 
            "title": "v2.0.5_Beta   2016年6月01日"
        }, 
        {
            "location": "/im/android/update_log/#v204_beta-2016429", 
            "text": "1、优化服务重连机制；\n2、优化核心进程保活；\n3、新增消息监听器MessageListHandler,允许为单一页面注册消息接收器；\n3、修复发送BmobIMVideoMessage视频消息时出现的类型转换异常；\n4、配套Demo中新增好友管理功能，包含添加好友，同意添加好友、查询好友、删除好友等功能。", 
            "title": "v2.0.4_Beta   2016年4月29日"
        }, 
        {
            "location": "/im/android/update_log/#v203_beta-2016419", 
            "text": "1、修复离线消息重复获取的问题；\n2、修复语音消息无法获取时长的问题；\n3、修复部分机型无法发送语音的问题；\n4、依赖BmobSDK_v3.4.6_0415。", 
            "title": "v2.0.3_Beta   2016年4月19日"
        }, 
        {
            "location": "/im/android/update_log/#v202_beta-2016310", 
            "text": "1、增加消息接收器（BmobIMMessageHandler），方便对消息进行统一管理；\n2、修复接收的消息无法使用isTransient属性来存储消息；\n3、修复通知栏显示网址的问题；\n4、修复锁屏期间接收的消息无法及时更新到聊天界面的问题；\n5、支持跨平台与iOS进行通讯；\n6、SDK内部不再集成EventBus库,方便开发者使用新版EventBus。", 
            "title": "v2.0.2_Beta   2016年3月10日"
        }, 
        {
            "location": "/im/android/update_log/#v201_beta-2016304", 
            "text": "1、新增支持图片消息（BmobIMImageMessage）、语音消息（BmobIMAudioMessage）、地理位置消息（BmobIMLocationMessage）；\n2、新增通知管理器（BmobNotificationManager）类，方便开发者显示通知栏；\n3、支持自定义消息类型，API使用更加简便；\n4、修复切换账号时无法正确显示对应账号下会话的问题；\n5、完善服务重连机制，优化服务性能。", 
            "title": "v2.0.1_Beta   2016年3月04日"
        }, 
        {
            "location": "/im/android/update_log/#v200_beta-2016201", 
            "text": "1、全新架构、接口设计更加人性化，降低开发者使用成本；2、支持文本发送；3、支持陌生人聊天。", 
            "title": "v2.0.0_Beta   2016年2月01日"
        }, 
        {
            "location": "/im/android/update_log/#v119_beta-2015820", 
            "text": "1、允许自定义好友查询的总数；\n2、配套使用的BmobSDK为V3.4.3_0820版本。", 
            "title": "v1.1.9_Beta   2015年8月20日"
        }, 
        {
            "location": "/im/android/update_log/#v118_beta-2015408", 
            "text": "1、完善服务重连机制，同步提升聊天稳定性和及时性；\n2、配套使用的BmobSDK为V3.3.5_0408版本。 \n---------------强烈建议更新-------------------", 
            "title": "v1.1.8_Beta   2015年4月08日"
        }, 
        {
            "location": "/im/android/update_log/#v117_beta-2015318", 
            "text": "1、兼容Android5.0系统，解决由Service Intent must be explicit的系统警告导致无法接收到聊天消息的问题；\n2、同步更新BmobSDK到3.3.4版本。", 
            "title": "v1.1.7_Beta   2015年3月18日"
        }, 
        {
            "location": "/im/android/update_log/#v116_beta-2015204", 
            "text": "1、允许开发者自定义通知栏提示语;\n2、修复由于聊天双方的本机时间不一致导致的聊天记录顺序错位的问题;\n3、与之配套使用的BmobSDK为BmobSDK_V3.3.2_0128.jar。", 
            "title": "v1.1.6_Beta   2015年2月04日"
        }, 
        {
            "location": "/im/android/update_log/#v115_beta-2015105", 
            "text": "1、修复发送图片或者语音时导致应用奔溃的问题；\n2、新增支持自定义聊天消息体。", 
            "title": "v1.1.5_Beta   2015年1月05日"
        }, 
        {
            "location": "/im/android/update_log/#v114_beta-20141027", 
            "text": "1、修复查询附近的人中无法过滤性别为女的用户的bug；\n2、优化导致推送延迟或无法接收到推送的问题。", 
            "title": "v1.1.4_Beta   2014年10月27日"
        }, 
        {
            "location": "/im/android/update_log/#v113_beta-20141023", 
            "text": "1、聊天消息和Tag标记的消息的时间单位保持一致，均为秒；\n2、解决聊天消息和好友验证消息多次提醒的问题；\n3、重写sendTagMessage方法，支持扩展MsgTag，\n4、新增支持查询当前用户所有的未读消息个数；\n5、解决多设备登录同一账号时无法下线的问题；\n6、优化由于推送服务频繁重启导致无法收发消息的bug。", 
            "title": "v1.1.3_Beta   2014年10月23日"
        }, 
        {
            "location": "/im/android/update_log/#v112_beta-2014923", 
            "text": "1、新增支持陌生人聊天，允许发送给非好友用户；\n2、新增支持自定义消息的发送，便于开发者扩展；\n3、新版本大幅度增加稳定性和及时性，保证实时到达率。\n4、排除web后端推送对客户端的影响。", 
            "title": "v1.1.2_Beta   2014年9月23日"
        }, 
        {
            "location": "/im/android/update_log/#v111_beta-2014814", 
            "text": "1、新增查询指定范围内的附近的人列表；\n2、添加用户的性别设置；\n3、附近的人新增额外属性查询：如查询性别为女的用户。", 
            "title": "v1.1.1_Beta   2014年8月14日"
        }, 
        {
            "location": "/im/android/update_log/#v110_beta-2014801", 
            "text": "1、解决接收语音（时间超过10s）播放不成功的问题;\n2、增加服务的稳定性，防止被杀死;\n3、当账号注销登陆后又未登陆其他设备时，该账号仍能接收来自其他账号的消息（再次登陆成功之后即可看见未读消息）。", 
            "title": "v1.1.0_Beta   2014年8月01日"
        }, 
        {
            "location": "/im/android/update_log/#v109_beta-2014725", 
            "text": "1、修复图片或语音发送较慢的问题；\n2、修复注册成功之后退出应用之后再次回到登陆页的问题；\n3、修复部分机型接收到的语音消息无法播放的问题\n4、修复好友头像更换后会话界面的好友头像无法及时更换的问题。\n5、修复当应用锁屏后在回到聊天页面时，新接收的消息重复显示的问题;", 
            "title": "v1.0.9_Beta   2014年7月25日"
        }, 
        {
            "location": "/im/android/update_log/#v108_beta-2014717", 
            "text": "1、支持跨平台聊天，与ios端完成互通，跨平台支持的消息类型：纯文字、表情、图片。\n2、解决多次登录之后，本地存储的昵称和头像均消失的问题;\n3、新增对通知的声音和震动的控制。", 
            "title": "v1.0.8_Beta   2014年7月17日"
        }, 
        {
            "location": "/im/android/update_log/#v107_beta-2014714", 
            "text": "解决用户注册账户时报错的bug。", 
            "title": "v1.0.7_Beta   2014年7月14日"
        }, 
        {
            "location": "/im/android/update_log/#v106_beta-2014711", 
            "text": "1、解决当应用锁屏后在回到聊天页面时，新接收的消息不能显示的问题;\n2、解决频繁接收到不属于本人好友的消息而导致页面不断刷新的问题；\n3、解决播放语音过程中出现的播放错误的问题;\n4、修正发送图片的方式，重构部分代码。", 
            "title": "v1.0.6_Beta   2014年7月11日"
        }, 
        {
            "location": "/im/android/update_log/#v105_beta-2014704", 
            "text": "1、新增对单一用户的语音消息的发送;\n2、修复分页查询附近的人和好友列表时出现重复数据的问题;\n3、修复其他bug。", 
            "title": "v1.0.5_Beta   2014年7月04日"
        }, 
        {
            "location": "/im/android/update_log/#v104_beta-2014627", 
            "text": "1、新增地理位置交友.可查看附近的人列表; 2、支持分页列表的分页查询;\n3、修改其他bug。", 
            "title": "v1.0.4_Beta   2014年6月27日"
        }, 
        {
            "location": "/im/android/update_log/#v103_beta-2014625", 
            "text": "1、新增对单一用户的位置类型的消息的发送;\n2、支持黑名单管理功能;\n3、修改其他bug。", 
            "title": "v1.0.3_Beta   2014年6月25日"
        }, 
        {
            "location": "/im/android/update_log/#v102_beta-2014623", 
            "text": "解决用户注册或登录成功之后，无法收发消息的问题。", 
            "title": "v1.0.2_Beta   2014年6月23日"
        }, 
        {
            "location": "/im/android/update_log/#v101_beta-2014620", 
            "text": "1、新增对单一用户的聊天图片（本地相册和拍照）发送;\n2、新增消息回执发送：已发送、已阅读两种状态;\n3、修改添加好友时出现的发送好友验证失败的bug;\n4、解决多账户登陆同一设备时，非当前登陆账号接收不到消息的bug。", 
            "title": "v1.0.1_beta   2014年6月20日"
        }, 
        {
            "location": "/im/android/update_log/#v100_beta-2014613", 
            "text": "1、提供完整的好友管理功能，包括添加好友、删除好友、好友列表，也可以与你已有的用户系统完全解耦;\n2、支持单一用户的文字和表情聊天;\n3、支持会话的本地化存储;\n4、自定义消息接受机制;\n5、同一账号多处登陆强制下线。", 
            "title": "v1.0.0_Beta   2014年6月13日"
        }, 
        {
            "location": "/im/ios/", 
            "text": "下载iOS_Demo\n\n\n点击这里下载demo（iOS）源码\n\n\nBmob即时聊天demo包含了一个完整的即时通讯的App，功能包括：\n\n\n\n\n支持好友管理功能，包括添加好友、删除好友、获取好友列表，也可以与你已有的用户系统完全解耦；\n\n\n支持的消息类型：纯文本,语音,图片,自定义消息\n\n\n支持会话的本地化存储；\n\n\n\n\niOS界面效果\n\n\niOS联系人页面\n\n\n\n\niOS会话页面\n\n\n\n\niOS聊天页面\n\n\n\n\niOS搜索联系人页面\n\n\n\n\niOS设置页面\n\n\n\n\niOSIM快速入门\n\n\n下载安装BmobIMSDK\n\n\n\n\n通过官网下载新的BmobIMSDK\n\n\n新建项目将BmobIMSDK 复制到新的项目工程\n\n\n具体可以参照\nDemo\n\n\n\n\n配置相关服务\n\n\n如果需要用到推送服务，所以需要在管理后台上传对应Bundle ID的p12文件，请勿加密，\n详细详细请参照：http://docs.bmob.cn/iospush/index.html?menukey=otherdoc\nkey=iospush\n\n\n引入相关的库文件\n\n\n如果项目中已包含BmobSDK数据服务SDK的话，可以不添加新的框架，如果没有则需添加SystemConfiguration.framework、CoreFoundation.framework、Foundation.framework、CFNetwork.framwork、CoreGraphics.framework、sqlite3.tbd\n\n\n初始化\n\n\n在你的XCode工程中的AppDelegate.m文件中,引入相关的头文件， 填入申请的授权Key（SDK使用的是应用密钥里的Application ID），示例如下：\n\n\n#import \nBmobIMSDK/BmobIMSDK.h\n\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    // Override point for customization after application launch.\n    //这里使用的是BmobSDK提供的用户系统，所以需要初始化BmobSDK\n    [Bmob registerWithAppKey:@\nApplication ID\n];\n\n    self.sharedIM = [BmobIM sharedBmobIM];\n\n    [self.sharedIM registerWithAppKey:@\nApplication ID\n];\n\n    [UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent;\n\n    BmobUser *user = [BmobUser getCurrentUser];\n    //如果有用户了，不需要推送服务来推送消息的话，可以直接连接服务器\n    if (user) {\n        self.userId = user.objectId;\n        [self connectToServer];\n    }else{\n        //如果用户还未登录，则监听对应的通知，再进行处理\n        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(userLogin:) name:@\nLogin\n object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(userLogout:) name:@\nLogout\n object:nil];\n    }\n\n    self.sharedIM.delegate = self;\n\n\n\n\n    return YES;\n}\n\n\n\n\n如果需要推送服务的话，可以在其相关代理那里设置调用 [self.sharedIM setupDeviceToken:@\"xxxx\"]的方法后，在连接服务器\n\n\n-(void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(nonnull NSError *)error{\n    BmobUser *user = [BmobUser getCurrentUser];\n    if (user) {\n        [self connectToServer];\n    }\n\n}\n\n\n\n\n-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken{\n        BmobUser *user = [BmobUser getCurrentUser];\n    if (user) {\n        //开发者自己将deviceToken转成字符串\n        NSString *string = [[NSString alloc] initWithData:deviceToken encoding:NSUTF8StringEncoding];\n        self.token = [[[string stringByReplacingOccurrencesOfString:@\n \n withString:@\n] stringByReplacingOccurrencesOfString:@\n withString:@\n] stringByReplacingOccurrencesOfString:@\n withString:@\n];\n        [self connectToServer];         \n    }\n}\n\n\n\n\n登录的对应处理是\n\n\n-(void)userLogin:(NSNotification *)noti{\n    NSString *userId = noti.object;\n    self.userId = userId;\n    [self connectToServer];\n}\n\n\n\n\n退出登录的时候需要断开连接\n\n\n-(void)userLogout:(NSNotification *)noti{\n    [self.sharedIM disconnect];\n}\n\n\n\n\n连接服务器\n\n\n-(void)connectToServer{\n    [self.sharedIM setupBelongId:self.userId];\n    [self.sharedIM setupDeviceToken:self.token];\n    [self.sharedIM connect];\n}\n\n\n\n\n在应用进入前台或者后台的时候可以重新进行连接或者断开连接\n\n\n进入前台\n\n\n- (void)applicationWillEnterForeground:(UIApplication *)application {\n    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.\n\n    if (self.userId \n self.userId.length \n 0) {\n        [self connectToServer];\n    }\n}\n\n\n\n\n\n进入后台\n\n\n- (void)applicationDidEnterBackground:(UIApplication *)application {\n    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.\n    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.\n    if ([self.sharedIM isConnected]) {\n        [self.sharedIM disconnect];\n    }\n\n\n\n\n需要说明的是，连接服务器建立一次即可，开发者自己控制连接服务器的时机。建立连接之前必须设置appKey和belongId，不然会抛出异常\n\n\n注册推送\n\n\n可以在函数 \n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n 添加推送的相关代码\n\n\n\n   if (IS_iOS8) {\n        //iOS8推送\n        UIMutableUserNotificationCategory*categorys = [[UIMutableUserNotificationCategory alloc]init];\n        categorys.identifier=@\nBmobIMDemo\n;\n        UIUserNotificationSettings*userNotifiSetting = [UIUserNotificationSettings settingsForTypes:(UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound)\n                                                                                         categories:[NSSet setWithObjects:categorys,nil]];\n        [[UIApplication sharedApplication]registerUserNotificationSettings:userNotifiSetting];\n        [[UIApplication sharedApplication]registerForRemoteNotifications];\n    }else{\n        [application registerForRemoteNotificationTypes:UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound];\n    }\n\n\n\n\n\n接收消息\n\n\n在初始化的部分，我们已经设置了self.sharedIM的delegate，我们只需要在对应的代理函数那里处理相关的应用逻辑即可。\n在应用连接服务器的时候，SDK会主动的获取离线消息，并保存到本地数据库里面。在这里，开发者可能需要知道哪些人发来了消息，并且去下载相关人物信息。\n\n\n-(void)didGetOfflineMessagesWithIM:(BmobIM *)im{\n    //获取哪些人的消息还未读\n    NSArray *objectIds = [self.sharedIM allConversationUsersIds];\n    if (objectIds \n objectIds.count \n 0) {\n        //Demo里面的方法去查找服务器相关人物的信息\n        [UserService loadUsersWithUserIds:objectIds completion:^(NSArray *array, NSError *error) {\n            if (array \n array.count \n 0) {\n                //保存到本地数据库\n                [self.sharedIM saveUserInfos:array];\n                //发新用户的通知\n                [[NSNotificationCenter defaultCenter] postNotificationName:kNewMessageFromer object:nil];\n            }\n        }];\n    }\n}\n\n\n\n\n另一方面，已经连接到服务器上了，就可以收到别人发送过来的消息，这是需要在另一个方法处理\n\n\n-(void)didRecieveMessage:(BmobIMMessage *)message withIM:(BmobIM *)im{\n    //查看本地有无这个用户的信息\n    BmobIMUserInfo *userInfo = [self.sharedIM userInfoWithUserId:message.fromId];\n    if (!userInfo) {\n          //如果没有则去下载\n        [UserService loadUserWithUserId:message.fromId completion:^(BmobIMUserInfo *result, NSError *error) {\n            if (result) {\n                //保存到本地数据库\n                [self.sharedIM saveUserInfo:result];\n                //发新用户的通知\n                [[NSNotificationCenter defaultCenter] postNotificationName:kNewMessageFromer object:nil];\n            }\n            //发接收到新信息的通知\n            [[NSNotificationCenter defaultCenter] postNotificationName:kNewMessagesNotifacation object:message];\n        }];\n    }else{\n          //发接收到新信息的通知\n        [[NSNotificationCenter defaultCenter] postNotificationName:kNewMessagesNotifacation object:message];\n    }\n    }\n\n\n\n\n用户管理\n\n\n注册\n\n\n当用户还未进行注册的时候可以通过调用方法来进行简单的注册\n\n\n    BmobUser *user = [[BmobUser alloc] init];\n    user.username = self.usernameTextField.text;\n    user.password = self.passwordTextField.text;\n\n\n    [user signUpInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            [[NSNotificationCenter defaultCenter] postNotificationName:@\nLogin\n object:user.objectId];\n            [self dismissViewControllerAnimated:YES completion:nil];\n        }else{\n            [self showInfomation:error.description];\n        }\n    }];\n\n\n\n\n登录\n\n\n用户已经注册了，想要在此应用登录的话，可以直接调用登录的方法\n\n\n    [self showLoading];\n    [BmobUser loginWithUsernameInBackground:self.usernameTextField.text password:self.passwordTextField.text block:^(BmobUser *user, NSError *error) {\n        if (user) {\n            [self hideLoading];\n            [[NSNotificationCenter defaultCenter] postNotificationName:@\nLogin\n object:user.objectId];\n            [self dismissViewControllerAnimated:YES completion:nil];\n        }else{\n            [self showInfomation:error.description];\n        }\n    }];\n\n\n\n\n获取好友列表\n\n\n-(void)loadUserFriends{\n    [UserService friendsWithCompletion:^(NSArray *array, NSError *error) {\n        if (error) {\n            [self showInfomation:error.localizedDescription];\n        }else{\n            BmobUser *loginUser = [BmobUser getCurrentUser];\n            NSMutableArray *result  = [NSMutableArray array];\n            for (BmobObject *obj in array) {\n\n                BmobUser *friend = nil;\n                if ([[(BmobUser *)[obj objectForKey:@\nuser\n] objectId] isEqualToString:loginUser.objectId]) {\n                    friend = [obj objectForKey:@\nfriendUser\n];\n                }else{\n                    friend = [obj objectForKey:@\nuser\n];\n                }\n                BmobIMUserInfo *info = [BmobIMUserInfo userInfoWithBmobUser:friend];\n\n                [result addObject:info];\n            }\n            if (result \n result.count \n 0) {\n                [self.userArray setArray:result];\n                [self.tableView reloadData];\n\n            }\n\n        }\n    }];\n}\n\n\n\n\n添加好友\n\n\n-(void)addFriend{\n    [UserService addFriendNoticeWithUserId:self.userInfo.userId completion:^(BOOL isSuccessful, NSError *error) {\n        if (error) {\n            [self showInfomation:error.localizedDescription];\n        }else{\n            [self showInfomation:@\n已发送添加好友请求\n];\n        }\n    }];\n}\n\n\n\n\n消息发送\n\n\n通过IMSDK，用户可以与陌生人聊天，也可以与好友聊天，这个由开发者自由控制。当需要发起聊天的时候，需要建立起一个BmobIMConversation对象来进行管理，SDK提供了方法来快速构建BmobIMConversation对象。\n\n\n//\nBmobIMConversation *conversation = [BmobIMConversation conversationWithId:self.userInfo.userId conversationType:BmobIMConversationTypeSingle];\nconversation.conversationTitle = self.userInfo.name;\n\n\n\n\n查看聊天记录\n\n\n进入聊天页面是，开发者可能需要让用户查看最近的聊天记录，这个时候可以通过BmobIMConversation 类提供的\n\n\n-(NSArray *)queryMessagesWithMessage:(BmobIMMessage *)message  limit:(int)limit;\n来处理这个需求。\n\n\n例如，加载第一页数据的时候，只需要将message设置为nil，即可获取到\n\n\n-(void)loadMessageRecords{\n    NSArray *array = [self.conversation queryMessagesWithMessage:nil limit:10];\n\n    if (array \n array.count \n 0) {\n        //排序\n        NSArray *result = [array sortedArrayUsingComparator:^NSComparisonResult(BmobIMMessage *obj1, BmobIMMessage *obj2) {\n            if (obj1.updatedTime \n obj2.updatedTime) {\n                return NSOrderedDescending;\n            }else if(obj1.updatedTime \n  obj2.updatedTime) {\n                return NSOrderedAscending;\n            }else{\n                return NSOrderedSame;\n            }\n\n        }];\n        [self.messagesArray setArray:result];\n        [self.tableView reloadData];\n\n        [self.tableView scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:self.messagesArray.count-1 inSection:0] atScrollPosition:UITableViewScrollPositionBottom animated:YES];\n    }\n}\n\n\n\n\n加载之前的历史消息记录，可以通过将message参数设置为时间为最后一条消息即可\n\n\n-(void)loadMoreRecords{\n    if (!self.finished) {\n        self.page ++;\n        [self.freshControl beginRefreshing];\n\n        if (self.messagesArray.count \n= 0) {\n            [self.freshControl endRefreshing];\n            return;\n        }\n        BmobIMMessage *msg = [self.messagesArray firstObject];\n\n        NSArray *array = [self.conversation queryMessagesWithMessage:msg limit:10];\n\n        if (array \n array.count \n 0) {\n            NSMutableArray *messages = [NSMutableArray arrayWithArray:self.messagesArray];\n            [messages addObjectsFromArray:array];\n            //排序\n            NSArray *result = [messages sortedArrayUsingComparator:^NSComparisonResult(BmobIMMessage *obj1, BmobIMMessage *obj2) {\n                if (obj1.updatedTime \n obj2.updatedTime) {\n                    return NSOrderedDescending;\n                }else if(obj1.updatedTime \n  obj2.updatedTime) {\n                    return NSOrderedAscending;\n                }else{\n                    return NSOrderedSame;\n                }\n\n            }];\n            [self.messagesArray setArray:result];\n            [self.tableView reloadData];\n        }else{\n            self.finished = YES;\n            [self showInfomation:@\n没有更多的历史消息\n];\n        }\n\n    }else{\n        [self showInfomation:@\n没有更多的历史消息\n];\n    }\n\n    [self.freshControl endRefreshing];\n}\n\n\n\n\n发送消息\n\n\n发送文本消息\n\n\n-(void)sendTextWithTextField:(UITextField *)textField{\n    if (textField.text.length == 0) {\n        [self showInfomation:@\n请输入内容\n];\n    }else{\n        //创建BmobIMTextMessage对象\n        BmobIMTextMessage *message = [BmobIMTextMessage messageWithText:textField.text attributes:nil];\n         //聊天类型设置为单聊\n        message.conversationType =  BmobIMConversationTypeSingle;\n        message.createdTime = (uint64_t)([[NSDate date] timeIntervalSince1970] * 1000);\n        message.updatedTime = message.createdTime;\n        [self.messagesArray addObject:message];\n        [self.tableView reloadData];\n        self.bottomView.textField.text = nil;\n        [self.tableView scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:self.messagesArray.count-1 inSection:0] atScrollPosition:UITableViewScrollPositionBottom animated:YES];\n        __weak typeof(self)weakSelf = self;\n        [self.conversation sendMessage:message completion:^(BOOL isSuccessful, NSError *error) {\n            [weakSelf.tableView reloadRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:self.messagesArray.count-1 inSection:0]] withRowAnimation:UITableViewRowAnimationFade];\n\n        }];\n\n    }\n}\n\n\n\n\n发送图片\n\n\n发送图片消息的流程是通过把拍照或者图片的内容，转成Data，然后通过Bmob文件上传接口来上传文件，获取到相关的信息（文件地址之类的），再构造对应的BmobIMImageMessage对象来发送消息。\n\n\nDemo封装了一个直接传入image就能发送图片的方法\n\n\n+(void)uploadImage:(UIImage *)image\n        completion:(uploadBlock)block\n          progress:(BmobProgressBlock)progressBlock;\n\n\n\n\n然后可以直接调用方法来发送图片，并在当前页显示出来\n\n\n[MessageService uploadImage:resizeImage completion:^(BmobIMImageMessage *message, NSError *error) {\n        if (!error) {\n            [self.messagesArray addObject:message];\n            [self scrollToBottom];\n             __weak typeof(self)weakSelf = self;\n\n            [self.conversation sendMessage:message completion:^(BOOL isSuccessful, NSError *error) {\n                [weakSelf reloadLastRow];\n            }];\n        }else{\n            [self showInfomation:error.localizedDescription];\n        }\n    } progress:^(CGFloat progress) {\n        [self showProgress:progress];\n    }];\n\n\n\n\n\n发送语音文件\n\n\n发送语音消息的流程是把录音下载的Data转成AMR格式，保存在本地，然后通过Bmob文件上传接口来上传文件，获取到相关的信息（文件地址之类的），再构造对应的BmobIMAudioMessage对象来发送消息。\n\n\nDemo封装了一个直接传入NSData就能发送语音文件的方法\n\n\n+(void)uploadAudio:(NSData *)data\n                          duration:(CGFloat)duration\n                        completion:(uploadBlock)block\n                          progress:(BmobProgressBlock)progressBlock\n\n\n\n\n直接调用这个方法就能发送语音文件\n\n\n[MessageService uploadAudio:data\n                           duration:duration\n                         completion:^(BmobIMAudioMessage *message, NSError *error) {\n                             if (!error) {\n\n                                 [self.messagesArray addObject:message];\n                                 [self scrollToBottom];\n                                 __weak typeof(self)weakSelf = self;\n                                 [self.conversation sendMessage:message completion:^(BOOL isSuccessful, NSError *error) {\n                                     [weakSelf reloadLastRow];\n                                 }];\n                             }\n                         } progress:nil];\n\n\n\n\n发送其他文件消息\n\n\n当开发者需要发送其他类型的文件消息的时候，先要继承BmobIMFileMessage类，通过BmobSDK提供的文件上传接口，把文件上传至服务器上，获取到url，再去创建对应的对象。\n这里的流程可以参照发送图片，发送语音的相关源代码。当然了，开发者也必须指定其msgType属性，好让应用可以根据这个属性来显示相应的视图。\n\n\n发送位置\n\n\nBmobIMLocationMessage *message = [BmobIMLocationMessage messageWithAddress:@\n广州大学城\n attributes:@{KEY_METADATA:@{KEY_LATITUDE:@(23.039),KEY_LONGITUDE:@(113.388)}}];\n    message.conversationType =  BmobIMConversationTypeSingle;\n    message.createdTime = (uint64_t)([[NSDate date] timeIntervalSince1970] * 1000);\n    message.updatedTime = message.createdTime;\n    [self.messagesArray addObject:message];\n    [self scrollToBottom];\n\n    __weak typeof(self)weakSelf = self;\n\n    [self.conversation sendMessage:message completion:^(BOOL isSuccessful, NSError *error) {\n        [weakSelf reloadLastRow];\n    }];\n\n\n\n\n发送自定义消息\n\n\n开发者也可以发送自定义消息(需继承BmobIMMessage)，例如添加好友的请求，当前聊天对象正在输入之类的消息，这种暂态的消息是不需要存储在数据库的，需要设置extra{KEY_IS_TRANSIENT:@(YES),...}。其他额外信息开发者可以自由设置\n\n\n例如发送添加好友通知，这种消息是暂时的，不需要保存到数据库里面，可以这样构造\n\n\n    BmobIMMessage *message = [[BmobIMMessage alloc] init];\n    message.msgType = @\nnotice\n;\n    message.conversationType = BmobIMConversationTypeSingle;\n    message.extra = @{KEY_IS_TRANSIENT:@(YES)};\n    message.content = @\n添加好友\n;\n    [self.conversation sendMessage:message completion:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@\nerror %@\n,error.localizedDescription);\n    }];\n\n\n\n\n接收消息\n\n\n在上一个大章节 接收消息 那里，我们已经把接收到的消息用通知的形式广播出来，我们只需要在聊天页面添加观察者来监听通知就行了。\n在Demo里在函数\n- (void)viewDidLoad\n\n\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(receiveMessage:) name:kNewMessagesNotifacation object:nil];\n\n\n\n\n在\n-(void)receiveMessage:(NSNotification *)noti\n进行对应的处理\n\n\n-(void)receiveMessage:(NSNotification *)noti{\n    BmobIMMessage *message = noti.object;\n    //如果是消息来源是当前聊天用户，就将其加载到内存里并显示出来\n    if ([message.fromId isEqualToString:self.conversation.conversationId]) {\n        [self.messagesArray addObject:message];\n        [self.tableView reloadData];\n        [self.tableView scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:self.messagesArray.count-1 inSection:0] atScrollPosition:UITableViewScrollPositionBottom animated:YES];\n    }\n\n}", 
            "title": "开发文档"
        }, 
        {
            "location": "/im/ios/#ios_demo", 
            "text": "点击这里下载demo（iOS）源码  Bmob即时聊天demo包含了一个完整的即时通讯的App，功能包括：   支持好友管理功能，包括添加好友、删除好友、获取好友列表，也可以与你已有的用户系统完全解耦；  支持的消息类型：纯文本,语音,图片,自定义消息  支持会话的本地化存储；", 
            "title": "下载iOS_Demo"
        }, 
        {
            "location": "/im/ios/#ios", 
            "text": "", 
            "title": "iOS界面效果"
        }, 
        {
            "location": "/im/ios/#ios_1", 
            "text": "", 
            "title": "iOS联系人页面"
        }, 
        {
            "location": "/im/ios/#ios_2", 
            "text": "", 
            "title": "iOS会话页面"
        }, 
        {
            "location": "/im/ios/#ios_3", 
            "text": "", 
            "title": "iOS聊天页面"
        }, 
        {
            "location": "/im/ios/#ios_4", 
            "text": "", 
            "title": "iOS搜索联系人页面"
        }, 
        {
            "location": "/im/ios/#ios_5", 
            "text": "", 
            "title": "iOS设置页面"
        }, 
        {
            "location": "/im/ios/#iosim", 
            "text": "", 
            "title": "iOSIM快速入门"
        }, 
        {
            "location": "/im/ios/#bmobimsdk", 
            "text": "通过官网下载新的BmobIMSDK  新建项目将BmobIMSDK 复制到新的项目工程  具体可以参照 Demo", 
            "title": "下载安装BmobIMSDK"
        }, 
        {
            "location": "/im/ios/#_1", 
            "text": "如果需要用到推送服务，所以需要在管理后台上传对应Bundle ID的p12文件，请勿加密，\n详细详细请参照：http://docs.bmob.cn/iospush/index.html?menukey=otherdoc key=iospush", 
            "title": "配置相关服务"
        }, 
        {
            "location": "/im/ios/#_2", 
            "text": "如果项目中已包含BmobSDK数据服务SDK的话，可以不添加新的框架，如果没有则需添加SystemConfiguration.framework、CoreFoundation.framework、Foundation.framework、CFNetwork.framwork、CoreGraphics.framework、sqlite3.tbd", 
            "title": "引入相关的库文件"
        }, 
        {
            "location": "/im/ios/#_3", 
            "text": "在你的XCode工程中的AppDelegate.m文件中,引入相关的头文件， 填入申请的授权Key（SDK使用的是应用密钥里的Application ID），示例如下：  #import  BmobIMSDK/BmobIMSDK.h  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    // Override point for customization after application launch.\n    //这里使用的是BmobSDK提供的用户系统，所以需要初始化BmobSDK\n    [Bmob registerWithAppKey:@ Application ID ];\n\n    self.sharedIM = [BmobIM sharedBmobIM];\n\n    [self.sharedIM registerWithAppKey:@ Application ID ];\n\n    [UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent;\n\n    BmobUser *user = [BmobUser getCurrentUser];\n    //如果有用户了，不需要推送服务来推送消息的话，可以直接连接服务器\n    if (user) {\n        self.userId = user.objectId;\n        [self connectToServer];\n    }else{\n        //如果用户还未登录，则监听对应的通知，再进行处理\n        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(userLogin:) name:@ Login  object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(userLogout:) name:@ Logout  object:nil];\n    }\n\n    self.sharedIM.delegate = self;\n\n\n\n\n    return YES;\n}  如果需要推送服务的话，可以在其相关代理那里设置调用 [self.sharedIM setupDeviceToken:@\"xxxx\"]的方法后，在连接服务器  -(void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(nonnull NSError *)error{\n    BmobUser *user = [BmobUser getCurrentUser];\n    if (user) {\n        [self connectToServer];\n    }\n\n}  -(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken{\n        BmobUser *user = [BmobUser getCurrentUser];\n    if (user) {\n        //开发者自己将deviceToken转成字符串\n        NSString *string = [[NSString alloc] initWithData:deviceToken encoding:NSUTF8StringEncoding];\n        self.token = [[[string stringByReplacingOccurrencesOfString:@    withString:@ ] stringByReplacingOccurrencesOfString:@  withString:@ ] stringByReplacingOccurrencesOfString:@  withString:@ ];\n        [self connectToServer];         \n    }\n}  登录的对应处理是  -(void)userLogin:(NSNotification *)noti{\n    NSString *userId = noti.object;\n    self.userId = userId;\n    [self connectToServer];\n}  退出登录的时候需要断开连接  -(void)userLogout:(NSNotification *)noti{\n    [self.sharedIM disconnect];\n}  连接服务器  -(void)connectToServer{\n    [self.sharedIM setupBelongId:self.userId];\n    [self.sharedIM setupDeviceToken:self.token];\n    [self.sharedIM connect];\n}  在应用进入前台或者后台的时候可以重新进行连接或者断开连接  进入前台  - (void)applicationWillEnterForeground:(UIApplication *)application {\n    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.\n\n    if (self.userId   self.userId.length   0) {\n        [self connectToServer];\n    }\n}  进入后台  - (void)applicationDidEnterBackground:(UIApplication *)application {\n    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.\n    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.\n    if ([self.sharedIM isConnected]) {\n        [self.sharedIM disconnect];\n    }  需要说明的是，连接服务器建立一次即可，开发者自己控制连接服务器的时机。建立连接之前必须设置appKey和belongId，不然会抛出异常", 
            "title": "初始化"
        }, 
        {
            "location": "/im/ios/#_4", 
            "text": "可以在函数  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions  添加推送的相关代码  \n   if (IS_iOS8) {\n        //iOS8推送\n        UIMutableUserNotificationCategory*categorys = [[UIMutableUserNotificationCategory alloc]init];\n        categorys.identifier=@ BmobIMDemo ;\n        UIUserNotificationSettings*userNotifiSetting = [UIUserNotificationSettings settingsForTypes:(UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound)\n                                                                                         categories:[NSSet setWithObjects:categorys,nil]];\n        [[UIApplication sharedApplication]registerUserNotificationSettings:userNotifiSetting];\n        [[UIApplication sharedApplication]registerForRemoteNotifications];\n    }else{\n        [application registerForRemoteNotificationTypes:UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound];\n    }", 
            "title": "注册推送"
        }, 
        {
            "location": "/im/ios/#_5", 
            "text": "在初始化的部分，我们已经设置了self.sharedIM的delegate，我们只需要在对应的代理函数那里处理相关的应用逻辑即可。\n在应用连接服务器的时候，SDK会主动的获取离线消息，并保存到本地数据库里面。在这里，开发者可能需要知道哪些人发来了消息，并且去下载相关人物信息。  -(void)didGetOfflineMessagesWithIM:(BmobIM *)im{\n    //获取哪些人的消息还未读\n    NSArray *objectIds = [self.sharedIM allConversationUsersIds];\n    if (objectIds   objectIds.count   0) {\n        //Demo里面的方法去查找服务器相关人物的信息\n        [UserService loadUsersWithUserIds:objectIds completion:^(NSArray *array, NSError *error) {\n            if (array   array.count   0) {\n                //保存到本地数据库\n                [self.sharedIM saveUserInfos:array];\n                //发新用户的通知\n                [[NSNotificationCenter defaultCenter] postNotificationName:kNewMessageFromer object:nil];\n            }\n        }];\n    }\n}  另一方面，已经连接到服务器上了，就可以收到别人发送过来的消息，这是需要在另一个方法处理  -(void)didRecieveMessage:(BmobIMMessage *)message withIM:(BmobIM *)im{\n    //查看本地有无这个用户的信息\n    BmobIMUserInfo *userInfo = [self.sharedIM userInfoWithUserId:message.fromId];\n    if (!userInfo) {\n          //如果没有则去下载\n        [UserService loadUserWithUserId:message.fromId completion:^(BmobIMUserInfo *result, NSError *error) {\n            if (result) {\n                //保存到本地数据库\n                [self.sharedIM saveUserInfo:result];\n                //发新用户的通知\n                [[NSNotificationCenter defaultCenter] postNotificationName:kNewMessageFromer object:nil];\n            }\n            //发接收到新信息的通知\n            [[NSNotificationCenter defaultCenter] postNotificationName:kNewMessagesNotifacation object:message];\n        }];\n    }else{\n          //发接收到新信息的通知\n        [[NSNotificationCenter defaultCenter] postNotificationName:kNewMessagesNotifacation object:message];\n    }\n    }", 
            "title": "接收消息"
        }, 
        {
            "location": "/im/ios/#_6", 
            "text": "", 
            "title": "用户管理"
        }, 
        {
            "location": "/im/ios/#_7", 
            "text": "当用户还未进行注册的时候可以通过调用方法来进行简单的注册      BmobUser *user = [[BmobUser alloc] init];\n    user.username = self.usernameTextField.text;\n    user.password = self.passwordTextField.text;\n\n\n    [user signUpInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            [[NSNotificationCenter defaultCenter] postNotificationName:@ Login  object:user.objectId];\n            [self dismissViewControllerAnimated:YES completion:nil];\n        }else{\n            [self showInfomation:error.description];\n        }\n    }];", 
            "title": "注册"
        }, 
        {
            "location": "/im/ios/#_8", 
            "text": "用户已经注册了，想要在此应用登录的话，可以直接调用登录的方法      [self showLoading];\n    [BmobUser loginWithUsernameInBackground:self.usernameTextField.text password:self.passwordTextField.text block:^(BmobUser *user, NSError *error) {\n        if (user) {\n            [self hideLoading];\n            [[NSNotificationCenter defaultCenter] postNotificationName:@ Login  object:user.objectId];\n            [self dismissViewControllerAnimated:YES completion:nil];\n        }else{\n            [self showInfomation:error.description];\n        }\n    }];", 
            "title": "登录"
        }, 
        {
            "location": "/im/ios/#_9", 
            "text": "-(void)loadUserFriends{\n    [UserService friendsWithCompletion:^(NSArray *array, NSError *error) {\n        if (error) {\n            [self showInfomation:error.localizedDescription];\n        }else{\n            BmobUser *loginUser = [BmobUser getCurrentUser];\n            NSMutableArray *result  = [NSMutableArray array];\n            for (BmobObject *obj in array) {\n\n                BmobUser *friend = nil;\n                if ([[(BmobUser *)[obj objectForKey:@ user ] objectId] isEqualToString:loginUser.objectId]) {\n                    friend = [obj objectForKey:@ friendUser ];\n                }else{\n                    friend = [obj objectForKey:@ user ];\n                }\n                BmobIMUserInfo *info = [BmobIMUserInfo userInfoWithBmobUser:friend];\n\n                [result addObject:info];\n            }\n            if (result   result.count   0) {\n                [self.userArray setArray:result];\n                [self.tableView reloadData];\n\n            }\n\n        }\n    }];\n}", 
            "title": "获取好友列表"
        }, 
        {
            "location": "/im/ios/#_10", 
            "text": "-(void)addFriend{\n    [UserService addFriendNoticeWithUserId:self.userInfo.userId completion:^(BOOL isSuccessful, NSError *error) {\n        if (error) {\n            [self showInfomation:error.localizedDescription];\n        }else{\n            [self showInfomation:@ 已发送添加好友请求 ];\n        }\n    }];\n}", 
            "title": "添加好友"
        }, 
        {
            "location": "/im/ios/#_11", 
            "text": "通过IMSDK，用户可以与陌生人聊天，也可以与好友聊天，这个由开发者自由控制。当需要发起聊天的时候，需要建立起一个BmobIMConversation对象来进行管理，SDK提供了方法来快速构建BmobIMConversation对象。  //\nBmobIMConversation *conversation = [BmobIMConversation conversationWithId:self.userInfo.userId conversationType:BmobIMConversationTypeSingle];\nconversation.conversationTitle = self.userInfo.name;", 
            "title": "消息发送"
        }, 
        {
            "location": "/im/ios/#_12", 
            "text": "进入聊天页面是，开发者可能需要让用户查看最近的聊天记录，这个时候可以通过BmobIMConversation 类提供的  -(NSArray *)queryMessagesWithMessage:(BmobIMMessage *)message  limit:(int)limit; 来处理这个需求。  例如，加载第一页数据的时候，只需要将message设置为nil，即可获取到  -(void)loadMessageRecords{\n    NSArray *array = [self.conversation queryMessagesWithMessage:nil limit:10];\n\n    if (array   array.count   0) {\n        //排序\n        NSArray *result = [array sortedArrayUsingComparator:^NSComparisonResult(BmobIMMessage *obj1, BmobIMMessage *obj2) {\n            if (obj1.updatedTime   obj2.updatedTime) {\n                return NSOrderedDescending;\n            }else if(obj1.updatedTime    obj2.updatedTime) {\n                return NSOrderedAscending;\n            }else{\n                return NSOrderedSame;\n            }\n\n        }];\n        [self.messagesArray setArray:result];\n        [self.tableView reloadData];\n\n        [self.tableView scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:self.messagesArray.count-1 inSection:0] atScrollPosition:UITableViewScrollPositionBottom animated:YES];\n    }\n}  加载之前的历史消息记录，可以通过将message参数设置为时间为最后一条消息即可  -(void)loadMoreRecords{\n    if (!self.finished) {\n        self.page ++;\n        [self.freshControl beginRefreshing];\n\n        if (self.messagesArray.count  = 0) {\n            [self.freshControl endRefreshing];\n            return;\n        }\n        BmobIMMessage *msg = [self.messagesArray firstObject];\n\n        NSArray *array = [self.conversation queryMessagesWithMessage:msg limit:10];\n\n        if (array   array.count   0) {\n            NSMutableArray *messages = [NSMutableArray arrayWithArray:self.messagesArray];\n            [messages addObjectsFromArray:array];\n            //排序\n            NSArray *result = [messages sortedArrayUsingComparator:^NSComparisonResult(BmobIMMessage *obj1, BmobIMMessage *obj2) {\n                if (obj1.updatedTime   obj2.updatedTime) {\n                    return NSOrderedDescending;\n                }else if(obj1.updatedTime    obj2.updatedTime) {\n                    return NSOrderedAscending;\n                }else{\n                    return NSOrderedSame;\n                }\n\n            }];\n            [self.messagesArray setArray:result];\n            [self.tableView reloadData];\n        }else{\n            self.finished = YES;\n            [self showInfomation:@ 没有更多的历史消息 ];\n        }\n\n    }else{\n        [self showInfomation:@ 没有更多的历史消息 ];\n    }\n\n    [self.freshControl endRefreshing];\n}", 
            "title": "查看聊天记录"
        }, 
        {
            "location": "/im/ios/#_13", 
            "text": "发送文本消息  -(void)sendTextWithTextField:(UITextField *)textField{\n    if (textField.text.length == 0) {\n        [self showInfomation:@ 请输入内容 ];\n    }else{\n        //创建BmobIMTextMessage对象\n        BmobIMTextMessage *message = [BmobIMTextMessage messageWithText:textField.text attributes:nil];\n         //聊天类型设置为单聊\n        message.conversationType =  BmobIMConversationTypeSingle;\n        message.createdTime = (uint64_t)([[NSDate date] timeIntervalSince1970] * 1000);\n        message.updatedTime = message.createdTime;\n        [self.messagesArray addObject:message];\n        [self.tableView reloadData];\n        self.bottomView.textField.text = nil;\n        [self.tableView scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:self.messagesArray.count-1 inSection:0] atScrollPosition:UITableViewScrollPositionBottom animated:YES];\n        __weak typeof(self)weakSelf = self;\n        [self.conversation sendMessage:message completion:^(BOOL isSuccessful, NSError *error) {\n            [weakSelf.tableView reloadRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:self.messagesArray.count-1 inSection:0]] withRowAnimation:UITableViewRowAnimationFade];\n\n        }];\n\n    }\n}  发送图片  发送图片消息的流程是通过把拍照或者图片的内容，转成Data，然后通过Bmob文件上传接口来上传文件，获取到相关的信息（文件地址之类的），再构造对应的BmobIMImageMessage对象来发送消息。  Demo封装了一个直接传入image就能发送图片的方法  +(void)uploadImage:(UIImage *)image\n        completion:(uploadBlock)block\n          progress:(BmobProgressBlock)progressBlock;  然后可以直接调用方法来发送图片，并在当前页显示出来  [MessageService uploadImage:resizeImage completion:^(BmobIMImageMessage *message, NSError *error) {\n        if (!error) {\n            [self.messagesArray addObject:message];\n            [self scrollToBottom];\n             __weak typeof(self)weakSelf = self;\n\n            [self.conversation sendMessage:message completion:^(BOOL isSuccessful, NSError *error) {\n                [weakSelf reloadLastRow];\n            }];\n        }else{\n            [self showInfomation:error.localizedDescription];\n        }\n    } progress:^(CGFloat progress) {\n        [self showProgress:progress];\n    }];  发送语音文件  发送语音消息的流程是把录音下载的Data转成AMR格式，保存在本地，然后通过Bmob文件上传接口来上传文件，获取到相关的信息（文件地址之类的），再构造对应的BmobIMAudioMessage对象来发送消息。  Demo封装了一个直接传入NSData就能发送语音文件的方法  +(void)uploadAudio:(NSData *)data\n                          duration:(CGFloat)duration\n                        completion:(uploadBlock)block\n                          progress:(BmobProgressBlock)progressBlock  直接调用这个方法就能发送语音文件  [MessageService uploadAudio:data\n                           duration:duration\n                         completion:^(BmobIMAudioMessage *message, NSError *error) {\n                             if (!error) {\n\n                                 [self.messagesArray addObject:message];\n                                 [self scrollToBottom];\n                                 __weak typeof(self)weakSelf = self;\n                                 [self.conversation sendMessage:message completion:^(BOOL isSuccessful, NSError *error) {\n                                     [weakSelf reloadLastRow];\n                                 }];\n                             }\n                         } progress:nil];  发送其他文件消息  当开发者需要发送其他类型的文件消息的时候，先要继承BmobIMFileMessage类，通过BmobSDK提供的文件上传接口，把文件上传至服务器上，获取到url，再去创建对应的对象。\n这里的流程可以参照发送图片，发送语音的相关源代码。当然了，开发者也必须指定其msgType属性，好让应用可以根据这个属性来显示相应的视图。  发送位置  BmobIMLocationMessage *message = [BmobIMLocationMessage messageWithAddress:@ 广州大学城  attributes:@{KEY_METADATA:@{KEY_LATITUDE:@(23.039),KEY_LONGITUDE:@(113.388)}}];\n    message.conversationType =  BmobIMConversationTypeSingle;\n    message.createdTime = (uint64_t)([[NSDate date] timeIntervalSince1970] * 1000);\n    message.updatedTime = message.createdTime;\n    [self.messagesArray addObject:message];\n    [self scrollToBottom];\n\n    __weak typeof(self)weakSelf = self;\n\n    [self.conversation sendMessage:message completion:^(BOOL isSuccessful, NSError *error) {\n        [weakSelf reloadLastRow];\n    }];  发送自定义消息  开发者也可以发送自定义消息(需继承BmobIMMessage)，例如添加好友的请求，当前聊天对象正在输入之类的消息，这种暂态的消息是不需要存储在数据库的，需要设置extra{KEY_IS_TRANSIENT:@(YES),...}。其他额外信息开发者可以自由设置  例如发送添加好友通知，这种消息是暂时的，不需要保存到数据库里面，可以这样构造      BmobIMMessage *message = [[BmobIMMessage alloc] init];\n    message.msgType = @ notice ;\n    message.conversationType = BmobIMConversationTypeSingle;\n    message.extra = @{KEY_IS_TRANSIENT:@(YES)};\n    message.content = @ 添加好友 ;\n    [self.conversation sendMessage:message completion:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@ error %@ ,error.localizedDescription);\n    }];", 
            "title": "发送消息"
        }, 
        {
            "location": "/im/ios/#_14", 
            "text": "在上一个大章节 接收消息 那里，我们已经把接收到的消息用通知的形式广播出来，我们只需要在聊天页面添加观察者来监听通知就行了。\n在Demo里在函数 - (void)viewDidLoad  [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(receiveMessage:) name:kNewMessagesNotifacation object:nil];  在 -(void)receiveMessage:(NSNotification *)noti 进行对应的处理  -(void)receiveMessage:(NSNotification *)noti{\n    BmobIMMessage *message = noti.object;\n    //如果是消息来源是当前聊天用户，就将其加载到内存里并显示出来\n    if ([message.fromId isEqualToString:self.conversation.conversationId]) {\n        [self.messagesArray addObject:message];\n        [self.tableView reloadData];\n        [self.tableView scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:self.messagesArray.count-1 inSection:0] atScrollPosition:UITableViewScrollPositionBottom animated:YES];\n    }\n\n}", 
            "title": "接收消息"
        }, 
        {
            "location": "/im/ios/update_log/", 
            "text": "v2.0.1_Beta   2016年3月11日\n\n\n\n\n增加BmobIMFileMessage,BmobIMLocationMessage\n\n\n修改BmobIMImageMessage跟BmobIMAudioMessage集成自BmobIMFileMessage\n\n\n修改BmobIMMessage的msgType属性为字符串类型 4.支持用户自定义消息类型 5.数据库方面SDK已做兼容  \n\n\n\n\nv2.0.0_Beta   2016年2月02日\n\n\n\n\n用全新的架构来设计IMSDK，通过tcp协议进行通信，支持单聊（发送文本消息，图片，声音文件）\n\n\n自动发送推送，当用户断开连接后，如果用户允许推送了（已设置好推送配置等），可以发送推送给用户\n\n\nSDK内部已实现自动拉取消息，不用开发者自己设定定时器去获取，保证消息抵达率\n\n\n\n\nv1.0.2_Beta   2015年5月12日\n\n\n\n\nDemo兼容iOS8 \n\n\n修复bug \n\n\n更换了百度地图的SDK \n\n\n\n\nv1.0.1_Beta   2014年7月28日\n\n\n\n\n添加发送图片功能 \n\n\n添加发送地理位置功能 \n\n\n添加查找附近的人功能 \n\n\n做了兼容处理，可以与Android进行聊天 \n\n\n\n\n需要注意的几点：\n\n\n\n\nV1.0.1的BmobIM是基于推送服务的，所以需要开发者自己在bmob后端添加证书。 \n\n\n由于模拟器接收不了推送，所以需要真机测试 \n\n\nBmobIM用到数据库，所以除了需要添加BmobSDK所依赖的库之外，还需要添加libsqlite3.dylib \n\n\n因为地理位置那块使用了百度地图的SDK，所以开发者用那块的服务时，需要添加百度地图的依赖库。 \n\n\nDemo基于iOS6.0 ＋，使用ARC \n\n\n\n\nv1.0.0_Beta   2014年6月30日\n\n\n\n\n提供完整的好友管理功能，包括添加好友、删除好友、好友列表，也可以与你已有的用户系统完全解耦; \n\n\n支持单一用户的文字和表情聊天; \n\n\n支持会话的本地化存储；", 
            "title": "更新日志"
        }, 
        {
            "location": "/im/ios/update_log/#v201_beta-2016311", 
            "text": "增加BmobIMFileMessage,BmobIMLocationMessage  修改BmobIMImageMessage跟BmobIMAudioMessage集成自BmobIMFileMessage  修改BmobIMMessage的msgType属性为字符串类型 4.支持用户自定义消息类型 5.数据库方面SDK已做兼容", 
            "title": "v2.0.1_Beta   2016年3月11日"
        }, 
        {
            "location": "/im/ios/update_log/#v200_beta-2016202", 
            "text": "用全新的架构来设计IMSDK，通过tcp协议进行通信，支持单聊（发送文本消息，图片，声音文件）  自动发送推送，当用户断开连接后，如果用户允许推送了（已设置好推送配置等），可以发送推送给用户  SDK内部已实现自动拉取消息，不用开发者自己设定定时器去获取，保证消息抵达率", 
            "title": "v2.0.0_Beta   2016年2月02日"
        }, 
        {
            "location": "/im/ios/update_log/#v102_beta-2015512", 
            "text": "Demo兼容iOS8   修复bug   更换了百度地图的SDK", 
            "title": "v1.0.2_Beta   2015年5月12日"
        }, 
        {
            "location": "/im/ios/update_log/#v101_beta-2014728", 
            "text": "添加发送图片功能   添加发送地理位置功能   添加查找附近的人功能   做了兼容处理，可以与Android进行聊天    需要注意的几点：   V1.0.1的BmobIM是基于推送服务的，所以需要开发者自己在bmob后端添加证书。   由于模拟器接收不了推送，所以需要真机测试   BmobIM用到数据库，所以除了需要添加BmobSDK所依赖的库之外，还需要添加libsqlite3.dylib   因为地理位置那块使用了百度地图的SDK，所以开发者用那块的服务时，需要添加百度地图的依赖库。   Demo基于iOS6.0 ＋，使用ARC", 
            "title": "v1.0.1_Beta   2014年7月28日"
        }, 
        {
            "location": "/im/ios/update_log/#v100_beta-2014630", 
            "text": "提供完整的好友管理功能，包括添加好友、删除好友、好友列表，也可以与你已有的用户系统完全解耦;   支持单一用户的文字和表情聊天;   支持会话的本地化存储；", 
            "title": "v1.0.0_Beta   2014年6月30日"
        }, 
        {
            "location": "/push/android/", 
            "text": "消息推送简介\n\n\n推送通知是让用户及时被通知、和你的应用保持联系的一种非常棒的方式，你可以快速而有效地通知到所有的用户，下面这个教程将会教你如何使用Bmob来推送消息。\n\n\n消息推送快速入门\n\n\n一、在Bmob官方网站的下载界面中，选择下载\nAndroid推送SDK\n，将下载的zip压缩包进行解压，得到\nBmob_Push_v(版本号)_日期.jar\n，然后将它放在你项目根目录下的\"libs\"目录中。\n\n\n二、在您的应用程序AndroidManifest.xml文件中添加相应的权限：\n\n\n    \n!--BmobSDK所需的权限 --\n\n    \nuses-permission android:name=\nandroid.permission.INTERNET\n /\n\n    \nuses-permission android:name=\nandroid.permission.ACCESS_NETWORK_STATE\n /\n\n    \nuses-permission android:name=\nandroid.permission.ACCESS_WIFI_STATE\n /\n\n    \nuses-permission android:name=\nandroid.permission.READ_PHONE_STATE\n /\n\n    \nuses-permission android:name=\nandroid.permission.WRITE_EXTERNAL_STORAGE\n /\n\n    \n!--推送所需的权限--\n\n    \nuses-permission android:name=\nandroid.permission.RECEIVE_USER_PRESENT\n /\n\n    \nuses-permission android:name=\nandroid.permission.RECEIVE_BOOT_COMPLETED\n /\n\n\n\n\n\n三、在您的应用程序AndroidManifest.xml文件中注册BmobPush SDK运行所需的推送服务和消息接收器：\n\n\n    \nservice\n        android:label=\nPushService\n\n        android:name=\ncn.bmob.push.lib.service.PushService\n\n        android:process=\n:bmobpush\n\n        android:exported=\ntrue\n\n         \nintent-filter\n\n             \naction android:name=\ncn.bmob.push.lib.service.PushService\n/\n\n         \n/intent-filter\n\n    \n/service\n\n\n    \n!-- 用于进程保活 --\n\n    \nservice\n        android:name=\ncn.bmob.push.lib.service.PushNotifyService\n\n        android:process=\n:bmobpush\n \n\n    \n/service\n\n\n    \nreceiver android:name=\ncn.bmob.push.PushReceiver\n \n\n        \nintent-filter\n\n            \n!-- 系统启动完成后会调用 --\n\n            \naction android:name=\nandroid.intent.action.BOOT_COMPLETED\n /\n               \n            \n!-- 解锁完成后会调用 --\n\n            \naction android:name=\nandroid.intent.action.USER_PRESENT\n /\n\n            \n!-- 监听网络连通性 --\n\n            \naction android:name=\nandroid.net.conn.CONNECTIVITY_CHANGE\n /\n               \n        \n/intent-filter\n\n    \n/receiver\n\n\n    \n!-- 第四部中创建的消息接收器，在这里进行注册 --\n\n    \nreceiver android:name=\nyour.package.MyPushMessageReceiver\n\n         \nintent-filter \n\n              \naction android:name=\ncn.bmob.push.action.MESSAGE\n/\n\n         \n/intent-filter\n\n    \n/receiver\n\n\n    \n!-- 接收心跳和唤醒的广播，要和PushService运行在同个进程 --\n\n    \nreceiver\n         android:name=\ncn.bmob.push.PushNotifyReceiver\n\n         android:process=\n:bmobpush\n \n\n         \nintent-filter\n\n             \n!-- 接收心跳广播的action --\n\n             \naction android:name=\ncn.bmob.push.action.HEARTBEAT\n /\n\n             \n!-- 接收唤醒广播的action --\n\n             \naction android:name=\ncn.bmob.push.action.NOTIFY\n /\n\n         \n/intent-filter\n\n    \n/receiver\n\n\n\n\n\n四、在你的应用程序中创建一个消息接收器。\n\n\nPush消息通过\naction=cn.bmob.push.action.MESSAGE\n的Intent把数据发送给客户端\nyour.package.MyPushMessageReceiver\n,消息格式由应用自己决定，PushService只负责把服务器下发的消息以字符串格式透传给客户端。\n\n\nyour.package.MyPushMessageReceiver\n的代码示例如下：\n\n\npublic class MyPushMessageReceiver extends BroadcastReceiver{\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // TODO Auto-generated method stub\n        if(intent.getAction().equals(PushConstants.ACTION_MESSAGE)){\n            Log.d(\nbmob\n, \n客户端收到推送内容：\n+intent.getStringExtra(\nmsg\n));\n        }\n    }\n\n}\n\n\n\n\n五、启动推送服务\n\n\n在你的应用程序主Activity中调用如下方法：\n\n\n    // 初始化BmobSDK\n    Bmob.initialize(this, \n你的AppKey\n);\n    // 使用推送服务时的初始化操作\n    BmobInstallation.getCurrentInstallation().save();\n    // 启动推送服务\n    BmobPush.startWork(this);\n\n\n\n\n代码中的\"你的Application Id\"就是你在Bmob后台中创建的应用程序的Application Id，如果你不知道这是什么，可以参考\n快速入门文档\n中的注册Bmob账号部分。\n\n\n六、在web端进行推送设置\n\n\n在应用面板--\n消息推送--\n推送设置界面中填写包名进行保存。\n\n\n\n七、在web端推送消息\n\n\n完成以上步骤后，你可以运行应用程序，从web推送一条消息给客户端。\n\n\n\n在后台推送消息给Android和iOS两个平台的时候，有一些需要注意的：\n1、由于Android和iOS的提送机制不同，iOS要经过APNS，Android的推送完全是走Bmob的长连接服务，为兼容这个问题，如果你选择发送格式为“json”格式时，需要添加APNS兼容头部（见下面json的aps部分），推送内容格式如下：\n\n\n{\n    \naps\n: {\n    \nsound\n: \ncheering.caf\n, \n    \nalert\n: \n这个是通知栏上显示的内容\n, \n    \nbadge\n: 0 \n    }, \n    \nxx\n : \njson的key-value对，你可以根据情况添加更多的，客户端进行解析获取\n, \n}\n\n\n\n\n其中，sound是iOS接收时的声音，badge是iOS通知栏的累计消息数。\n\n\n2、如果你选择发送格式为“text”时，推送内容为“推送消息测试。。。。”，Bmob会自动添加aps部分发送给APNS，，相当于自动生成如下的json格式的推送内容：\n\n\n{\n    \naps\n: {\n        \nalert\n: \n推送消息测试。。。。\n, \n    }\n}\n\n\n\n\n同时，也会发送给Android端，相当于自动生成如下的json格式的推送内容：\n\n\n{\n    \nalert\n : \n推送消息测试。。。。\n, \n}\n\n\n\n\n3、如果只是发送给Android端，大家可以自定义json格式的数据。\n\n\n4、由于iOS的APNS的推送的大小是有限制的，默认最多256bytes，因此,如果你需要跨平台互通的话，需注意推送的内容不要太长。\n\n\n5、想要更多了解Bmob的推送格式的朋友，如即时聊天，可以查看我们在问答社区中的回答：\nhttp://wenda.bmob.cn//?/question/204\n\n\n八、源码下载\n\n\n为了更好的让开发者朋友正确的集成和使用Bmob推送功能，我们还提供了一个关于Bmob推送功能的简单Demo以供大家参考，有需要的朋友可以到如下地址进行源码的下载。\nhttps://github.com/bmob/bmob-android-demo-push\n,\n\n0.9版本或以上的Demo\n\n\n消息推送的视频教程和Demo\n\n\nBmob官方为大家准备了消息推送的视频教程，有需要的朋友可以移步浏览视频教程：\n\n\n客户端推送消息：\nhttp://v.youku.com/v_show/id_XNzQ4ODczOTc2.html\n\n\n集成BmobPushSDK：\nhttp://v.youku.com/v_show/id_XNzQ4ODczOTc2.html\n\n\n其他相关说明\n\n\n以上文档仅仅介绍了如何实现消息的一次性推送，如果你还需要用到其他的推送方法，如组播、广播等，还需要详细阅读下面的相关知识。\n\n\n安装消息推送服务\n\n\n每一个Bmob的App被安装在用户的设备上后，如果要使用消息推送功能，Bmob SDK会自动生成一个Installation对象。Installation对象包含了推送所需要的所有信息。举例：一个棒球的App，你可以让用户订阅感兴趣的棒球队，然后及时将这个球队的消息推送给用户 。\n您可以使用 BmobSDK，通过 \nBmobInstallation\n 对象进行一系列操作，就像你存储和获取其他的普通对象一样，比如BmobObject对象。\n\n\nBmobInstallation对象有几个系统默认的特殊字段来帮助你进行设备定位等管理：\n- \nchannels\n : 当前这个设备订阅的渠道名称数组\n- \ntimeZone\n : 设备所在位置的时区， 如Asia/Shanghai，这个会在每个BmobInstallation对象更新时同步（只读）\n- \ndeviceType\n : 设备的的类型, 值为：\"ios\" 或 \"android\" (只读)\n- \ninstallationId\n : Bmob使用的设备唯一号 (只读)\n\n\n保存 installation\n\n\n使用消息推送前，首先需要保存设备信息。\n\n\nBmobInstallation.getCurrentInstallation().save();\n\n\n\n\n自定义Installation表\n\n\n开发者如果想要为设备信息表增加其他属性，则可以通过继承BmobInstallation类的方式来完成，用来定制更通用的推送。\n\n\n举例：\n\n\npublic class MyBmobInstallation extends BmobInstallation {\n\n    /**  \n     * 用户id-这样可以将设备与用户之间进行绑定\n     */  \n    private String uid;\n\n    public MyBmobInstallation(Context context) {\n        super(context);\n    }\n\n    public String getUid() {\n        return uid;\n    }\n\n    public void setUid(String uid) {\n        this.uid = uid;\n    }\n\n}\n\n\n\n\n那么如何更新增加的\nuid\n字段的值呢？\n\n\n具体思路：先将当前设备查询出来，之后调用\nupdate\n方法更新该值\n\n\n示例如下：\n\n\nBmobQuery\nMyBmobInstallation\n query = new BmobQuery\nMyBmobInstallation\n();\nquery.addWhereEqualTo(\ninstallationId\n, BmobInstallation.getInstallationId(this));\nquery.findObjects(this, new FindListener\nMyBmobInstallation\n() {\n\n    @Override\n    public void onSuccess(List\nMyBmobInstallation\n object) {\n        // TODO Auto-generated method stub\n        if(object.size() \n 0){\n            MyBmobInstallation mbi = object.get(0);\n            mbi.setUid(\n用户id\n);\n            mbi.update(context,new UpdateListener() {\n\n                @Override\n                public void onSuccess() {\n                    // TODO Auto-generated method stub\n                    Log.i(\nbmob\n,\n设备信息更新成功\n);\n                }\n\n                @Override\n                public void onFailure(int code, String msg) {\n                    // TODO Auto-generated method stub\n                    Log.i(\nbmob\n,\n设备信息更新失败:\n+msg);\n                }\n            });\n        }else{\n        }\n    }\n\n    @Override\n    public void onError(int code, String msg) {\n        // TODO Auto-generated method stub\n    }\n});\n\n\n\n\n\n注：\n\n\n不能调用\nsave\n方法保存，因为之前调用BmobInstallation.getCurrentInstallation(this).save()方法已经将该设备信息保存到设备表中。\n\n\n订阅频道和退订\n\n\n订阅频道\n\n\n订阅频道可使用 \nsubscribe\n 方法\n\n\nBmobInstallation installation = BmobInstallation.getCurrentInstallation();\ninstallation.subscribe(\nGiants\n);\ninstallation.subscribe(\nMets\n);\ninstallation.save();\n\n\n\n\n注：\nV3.4.3\n版本的Bmob SDK对频道订阅增加去重操作，也就是说：即使你调用subscribe方法订阅了多个相同的频道，Bmob只会记录一个频道。\n\n\n退订频道\n\n\n退订频道可使用 \nunsubscribe\n 方法\n\n\nBmobInstallation installation = BmobInstallation.getCurrentInstallation();\ninstallation.unsubscribe(\nGiants\n);\ninstallation.save();\n\n\n\n\n广播推送消息\n\n\n在客户端实现推送消息的功能，通过 \nBmobPushManager\n 对象来完成，比如给所有设备推送一条消息，如下：\n\n\nBmobPushManager bmobPush = new BmobPushManager();\nbmobPush.pushMessageAll(\nHello Bmob.\n);\n\n\n\n\n组播推送消息\n\n\n发送消息给订阅了Giants频道的用户\n\n\nBmobPushManager bmobPush = new BmobPushManager();\nBmobQuery\nBmobInstallation\n query = BmobInstallation.getQuery();\nList\nString\n channels = new ArrayList\nString\n();\nchannels.add(\nGiants\n);\n\nquery.addWhereEqualTo(\nchannels\n, channels);\nbmobPush.setQuery(query);\nbmobPush.pushMessage(\n消息内容\n);\n\n\n\n\n同时发送消息给多个频道时，可以将其他频道添加在channels中。\n\n\n多播推送消息\n\n\n推送给不活跃的用户\n\n\nBmobPushManager bmobPush = new BmobPushManager();\nBmobQuery\nBmobInstallation\n query = BmobInstallation.getQuery();\nquery.addWhereLessThan(\nupdatedAt\n, new BmobDate(new Date()));\nbmobPush.setQuery(query);\nbmobPush.pushMessage(\n消息内容\n);\n\n\n\n\n根据查询条件做推送\n\n\nBmobPushManager bmobPush = new BmobPushManager();\nBmobQuery\nBmobInstallation\n query = BmobInstallation.getQuery();\nquery.addWhereEqualTo(\nscore\n, 80);\nbmobPush.setQuery(query);\nbmobPush.pushMessage(\n消息内容\n);\n\n\n\n\n请注意，where 条件查询的都是 installations 表。这里是假设 installations 表存储了 score 的Number属性，你可以像查询普通对象一样构造where查询\n\n\n根据平台做推送\n\n\n给Android平台的终端推送\n\n\nBmobPushManager bmobPush = new BmobPushManager();\nBmobQuery\nBmobInstallation\n query = BmobInstallation.getQuery();\nquery.addWhereEqualTo(\ndeviceType\n, \nandroid\n);\nbmobPush.setQuery(query);\nbmobPush.pushMessage(\n消息内容\n);\n\n\n\n\n给IOS平台的终端推送\n\n\nBmobPushManager bmobPush = new BmobPushManager();\nBmobQuery\nBmobInstallation\n query = BmobInstallation.getQuery();\nquery.addWhereEqualTo(\ndeviceType\n, \nios\n);\nbmobPush.setQuery(query);\nbmobPush.pushMessage(\n消息内容\n);\n\n\n\n\n根据地理位置信息做推送\n\n\nBmobPushManager bmobPush = new BmobPushManager();\nBmobQuery\nBmobInstallation\n query = BmobInstallation.getQuery();\nquery.addWhereWithinRadians(\nlocation\n, new BmobGeoPoint(112.934755, 24.52065), 1.0);\nbmobPush.setQuery(query);\nbmobPush.pushMessage(\n消息内容\n);\n\n\n\n\n上面的例子假设 installation 表中有个 location 属性是 GeoPoint 类型，我们就可以根据地理信息位置做推送。\n\n\n点播推送消息\n\n\n发送给Android单个客户端\n\n\nString installationId = \n客户端installationId\n;\nBmobPushManager bmobPush = new BmobPushManager();\nBmobQuery\nBmobInstallation\n query = BmobInstallation.getQuery();\nquery.addWhereEqualTo(\ninstallationId\n, installationId);\nbmobPush.setQuery(query);\nbmobPush.pushMessage(\n消息内容\n);\n\n\n\n\n发送给iOS单个客户端\n\n\nString deviceToken = \n客户端deviceToken\n;\nBmobPushManager bmobPush = new BmobPushManager();\nBmobQuery\nBmobInstallation\n query = BmobInstallation.getQuery();\nquery.addWhereEqualTo(\ndeviceToken\n, deviceToken);\nbmobPush.setQuery(query);\nbmobPush.pushMessage(\n消息内容\n);", 
            "title": "开发文档"
        }, 
        {
            "location": "/push/android/#_1", 
            "text": "推送通知是让用户及时被通知、和你的应用保持联系的一种非常棒的方式，你可以快速而有效地通知到所有的用户，下面这个教程将会教你如何使用Bmob来推送消息。", 
            "title": "消息推送简介"
        }, 
        {
            "location": "/push/android/#_2", 
            "text": "一、在Bmob官方网站的下载界面中，选择下载 Android推送SDK ，将下载的zip压缩包进行解压，得到 Bmob_Push_v(版本号)_日期.jar ，然后将它放在你项目根目录下的\"libs\"目录中。  二、在您的应用程序AndroidManifest.xml文件中添加相应的权限：       !--BmobSDK所需的权限 -- \n     uses-permission android:name= android.permission.INTERNET  / \n     uses-permission android:name= android.permission.ACCESS_NETWORK_STATE  / \n     uses-permission android:name= android.permission.ACCESS_WIFI_STATE  / \n     uses-permission android:name= android.permission.READ_PHONE_STATE  / \n     uses-permission android:name= android.permission.WRITE_EXTERNAL_STORAGE  / \n     !--推送所需的权限-- \n     uses-permission android:name= android.permission.RECEIVE_USER_PRESENT  / \n     uses-permission android:name= android.permission.RECEIVE_BOOT_COMPLETED  /   三、在您的应用程序AndroidManifest.xml文件中注册BmobPush SDK运行所需的推送服务和消息接收器：       service\n        android:label= PushService \n        android:name= cn.bmob.push.lib.service.PushService \n        android:process= :bmobpush \n        android:exported= true \n          intent-filter \n              action android:name= cn.bmob.push.lib.service.PushService / \n          /intent-filter \n     /service \n\n     !-- 用于进程保活 -- \n     service\n        android:name= cn.bmob.push.lib.service.PushNotifyService \n        android:process= :bmobpush   \n     /service \n\n     receiver android:name= cn.bmob.push.PushReceiver   \n         intent-filter \n             !-- 系统启动完成后会调用 -- \n             action android:name= android.intent.action.BOOT_COMPLETED  /                \n             !-- 解锁完成后会调用 -- \n             action android:name= android.intent.action.USER_PRESENT  / \n             !-- 监听网络连通性 -- \n             action android:name= android.net.conn.CONNECTIVITY_CHANGE  /                \n         /intent-filter \n     /receiver \n\n     !-- 第四部中创建的消息接收器，在这里进行注册 -- \n     receiver android:name= your.package.MyPushMessageReceiver \n          intent-filter  \n               action android:name= cn.bmob.push.action.MESSAGE / \n          /intent-filter \n     /receiver \n\n     !-- 接收心跳和唤醒的广播，要和PushService运行在同个进程 -- \n     receiver\n         android:name= cn.bmob.push.PushNotifyReceiver \n         android:process= :bmobpush   \n          intent-filter \n              !-- 接收心跳广播的action -- \n              action android:name= cn.bmob.push.action.HEARTBEAT  / \n              !-- 接收唤醒广播的action -- \n              action android:name= cn.bmob.push.action.NOTIFY  / \n          /intent-filter \n     /receiver   四、在你的应用程序中创建一个消息接收器。  Push消息通过 action=cn.bmob.push.action.MESSAGE 的Intent把数据发送给客户端 your.package.MyPushMessageReceiver ,消息格式由应用自己决定，PushService只负责把服务器下发的消息以字符串格式透传给客户端。  your.package.MyPushMessageReceiver 的代码示例如下：  public class MyPushMessageReceiver extends BroadcastReceiver{\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // TODO Auto-generated method stub\n        if(intent.getAction().equals(PushConstants.ACTION_MESSAGE)){\n            Log.d( bmob ,  客户端收到推送内容： +intent.getStringExtra( msg ));\n        }\n    }\n\n}  五、启动推送服务  在你的应用程序主Activity中调用如下方法：      // 初始化BmobSDK\n    Bmob.initialize(this,  你的AppKey );\n    // 使用推送服务时的初始化操作\n    BmobInstallation.getCurrentInstallation().save();\n    // 启动推送服务\n    BmobPush.startWork(this);  代码中的\"你的Application Id\"就是你在Bmob后台中创建的应用程序的Application Id，如果你不知道这是什么，可以参考 快速入门文档 中的注册Bmob账号部分。  六、在web端进行推送设置  在应用面板-- 消息推送-- 推送设置界面中填写包名进行保存。  七、在web端推送消息  完成以上步骤后，你可以运行应用程序，从web推送一条消息给客户端。  在后台推送消息给Android和iOS两个平台的时候，有一些需要注意的：\n1、由于Android和iOS的提送机制不同，iOS要经过APNS，Android的推送完全是走Bmob的长连接服务，为兼容这个问题，如果你选择发送格式为“json”格式时，需要添加APNS兼容头部（见下面json的aps部分），推送内容格式如下：  {\n     aps : {\n     sound :  cheering.caf , \n     alert :  这个是通知栏上显示的内容 , \n     badge : 0 \n    }, \n     xx  :  json的key-value对，你可以根据情况添加更多的，客户端进行解析获取 , \n}  其中，sound是iOS接收时的声音，badge是iOS通知栏的累计消息数。  2、如果你选择发送格式为“text”时，推送内容为“推送消息测试。。。。”，Bmob会自动添加aps部分发送给APNS，，相当于自动生成如下的json格式的推送内容：  {\n     aps : {\n         alert :  推送消息测试。。。。 , \n    }\n}  同时，也会发送给Android端，相当于自动生成如下的json格式的推送内容：  {\n     alert  :  推送消息测试。。。。 , \n}  3、如果只是发送给Android端，大家可以自定义json格式的数据。  4、由于iOS的APNS的推送的大小是有限制的，默认最多256bytes，因此,如果你需要跨平台互通的话，需注意推送的内容不要太长。  5、想要更多了解Bmob的推送格式的朋友，如即时聊天，可以查看我们在问答社区中的回答： http://wenda.bmob.cn//?/question/204  八、源码下载  为了更好的让开发者朋友正确的集成和使用Bmob推送功能，我们还提供了一个关于Bmob推送功能的简单Demo以供大家参考，有需要的朋友可以到如下地址进行源码的下载。 https://github.com/bmob/bmob-android-demo-push , 0.9版本或以上的Demo", 
            "title": "消息推送快速入门"
        }, 
        {
            "location": "/push/android/#demo", 
            "text": "Bmob官方为大家准备了消息推送的视频教程，有需要的朋友可以移步浏览视频教程：  客户端推送消息： http://v.youku.com/v_show/id_XNzQ4ODczOTc2.html  集成BmobPushSDK： http://v.youku.com/v_show/id_XNzQ4ODczOTc2.html", 
            "title": "消息推送的视频教程和Demo"
        }, 
        {
            "location": "/push/android/#_3", 
            "text": "以上文档仅仅介绍了如何实现消息的一次性推送，如果你还需要用到其他的推送方法，如组播、广播等，还需要详细阅读下面的相关知识。", 
            "title": "其他相关说明"
        }, 
        {
            "location": "/push/android/#_4", 
            "text": "每一个Bmob的App被安装在用户的设备上后，如果要使用消息推送功能，Bmob SDK会自动生成一个Installation对象。Installation对象包含了推送所需要的所有信息。举例：一个棒球的App，你可以让用户订阅感兴趣的棒球队，然后及时将这个球队的消息推送给用户 。\n您可以使用 BmobSDK，通过  BmobInstallation  对象进行一系列操作，就像你存储和获取其他的普通对象一样，比如BmobObject对象。  BmobInstallation对象有几个系统默认的特殊字段来帮助你进行设备定位等管理：\n-  channels  : 当前这个设备订阅的渠道名称数组\n-  timeZone  : 设备所在位置的时区， 如Asia/Shanghai，这个会在每个BmobInstallation对象更新时同步（只读）\n-  deviceType  : 设备的的类型, 值为：\"ios\" 或 \"android\" (只读)\n-  installationId  : Bmob使用的设备唯一号 (只读)", 
            "title": "安装消息推送服务"
        }, 
        {
            "location": "/push/android/#installation", 
            "text": "使用消息推送前，首先需要保存设备信息。  BmobInstallation.getCurrentInstallation().save();", 
            "title": "保存 installation"
        }, 
        {
            "location": "/push/android/#installation_1", 
            "text": "开发者如果想要为设备信息表增加其他属性，则可以通过继承BmobInstallation类的方式来完成，用来定制更通用的推送。  举例：  public class MyBmobInstallation extends BmobInstallation {\n\n    /**  \n     * 用户id-这样可以将设备与用户之间进行绑定\n     */  \n    private String uid;\n\n    public MyBmobInstallation(Context context) {\n        super(context);\n    }\n\n    public String getUid() {\n        return uid;\n    }\n\n    public void setUid(String uid) {\n        this.uid = uid;\n    }\n\n}  那么如何更新增加的 uid 字段的值呢？  具体思路：先将当前设备查询出来，之后调用 update 方法更新该值  示例如下：  BmobQuery MyBmobInstallation  query = new BmobQuery MyBmobInstallation ();\nquery.addWhereEqualTo( installationId , BmobInstallation.getInstallationId(this));\nquery.findObjects(this, new FindListener MyBmobInstallation () {\n\n    @Override\n    public void onSuccess(List MyBmobInstallation  object) {\n        // TODO Auto-generated method stub\n        if(object.size()   0){\n            MyBmobInstallation mbi = object.get(0);\n            mbi.setUid( 用户id );\n            mbi.update(context,new UpdateListener() {\n\n                @Override\n                public void onSuccess() {\n                    // TODO Auto-generated method stub\n                    Log.i( bmob , 设备信息更新成功 );\n                }\n\n                @Override\n                public void onFailure(int code, String msg) {\n                    // TODO Auto-generated method stub\n                    Log.i( bmob , 设备信息更新失败: +msg);\n                }\n            });\n        }else{\n        }\n    }\n\n    @Override\n    public void onError(int code, String msg) {\n        // TODO Auto-generated method stub\n    }\n});  注：  不能调用 save 方法保存，因为之前调用BmobInstallation.getCurrentInstallation(this).save()方法已经将该设备信息保存到设备表中。", 
            "title": "自定义Installation表"
        }, 
        {
            "location": "/push/android/#_5", 
            "text": "", 
            "title": "订阅频道和退订"
        }, 
        {
            "location": "/push/android/#_6", 
            "text": "订阅频道可使用  subscribe  方法  BmobInstallation installation = BmobInstallation.getCurrentInstallation();\ninstallation.subscribe( Giants );\ninstallation.subscribe( Mets );\ninstallation.save();  注： V3.4.3 版本的Bmob SDK对频道订阅增加去重操作，也就是说：即使你调用subscribe方法订阅了多个相同的频道，Bmob只会记录一个频道。", 
            "title": "订阅频道"
        }, 
        {
            "location": "/push/android/#_7", 
            "text": "退订频道可使用  unsubscribe  方法  BmobInstallation installation = BmobInstallation.getCurrentInstallation();\ninstallation.unsubscribe( Giants );\ninstallation.save();", 
            "title": "退订频道"
        }, 
        {
            "location": "/push/android/#_8", 
            "text": "在客户端实现推送消息的功能，通过  BmobPushManager  对象来完成，比如给所有设备推送一条消息，如下：  BmobPushManager bmobPush = new BmobPushManager();\nbmobPush.pushMessageAll( Hello Bmob. );", 
            "title": "广播推送消息"
        }, 
        {
            "location": "/push/android/#_9", 
            "text": "发送消息给订阅了Giants频道的用户  BmobPushManager bmobPush = new BmobPushManager();\nBmobQuery BmobInstallation  query = BmobInstallation.getQuery();\nList String  channels = new ArrayList String ();\nchannels.add( Giants );\n\nquery.addWhereEqualTo( channels , channels);\nbmobPush.setQuery(query);\nbmobPush.pushMessage( 消息内容 );  同时发送消息给多个频道时，可以将其他频道添加在channels中。", 
            "title": "组播推送消息"
        }, 
        {
            "location": "/push/android/#_10", 
            "text": "", 
            "title": "多播推送消息"
        }, 
        {
            "location": "/push/android/#_11", 
            "text": "BmobPushManager bmobPush = new BmobPushManager();\nBmobQuery BmobInstallation  query = BmobInstallation.getQuery();\nquery.addWhereLessThan( updatedAt , new BmobDate(new Date()));\nbmobPush.setQuery(query);\nbmobPush.pushMessage( 消息内容 );", 
            "title": "推送给不活跃的用户"
        }, 
        {
            "location": "/push/android/#_12", 
            "text": "BmobPushManager bmobPush = new BmobPushManager();\nBmobQuery BmobInstallation  query = BmobInstallation.getQuery();\nquery.addWhereEqualTo( score , 80);\nbmobPush.setQuery(query);\nbmobPush.pushMessage( 消息内容 );  请注意，where 条件查询的都是 installations 表。这里是假设 installations 表存储了 score 的Number属性，你可以像查询普通对象一样构造where查询", 
            "title": "根据查询条件做推送"
        }, 
        {
            "location": "/push/android/#_13", 
            "text": "给Android平台的终端推送  BmobPushManager bmobPush = new BmobPushManager();\nBmobQuery BmobInstallation  query = BmobInstallation.getQuery();\nquery.addWhereEqualTo( deviceType ,  android );\nbmobPush.setQuery(query);\nbmobPush.pushMessage( 消息内容 );  给IOS平台的终端推送  BmobPushManager bmobPush = new BmobPushManager();\nBmobQuery BmobInstallation  query = BmobInstallation.getQuery();\nquery.addWhereEqualTo( deviceType ,  ios );\nbmobPush.setQuery(query);\nbmobPush.pushMessage( 消息内容 );", 
            "title": "根据平台做推送"
        }, 
        {
            "location": "/push/android/#_14", 
            "text": "BmobPushManager bmobPush = new BmobPushManager();\nBmobQuery BmobInstallation  query = BmobInstallation.getQuery();\nquery.addWhereWithinRadians( location , new BmobGeoPoint(112.934755, 24.52065), 1.0);\nbmobPush.setQuery(query);\nbmobPush.pushMessage( 消息内容 );  上面的例子假设 installation 表中有个 location 属性是 GeoPoint 类型，我们就可以根据地理信息位置做推送。", 
            "title": "根据地理位置信息做推送"
        }, 
        {
            "location": "/push/android/#_15", 
            "text": "发送给Android单个客户端  String installationId =  客户端installationId ;\nBmobPushManager bmobPush = new BmobPushManager();\nBmobQuery BmobInstallation  query = BmobInstallation.getQuery();\nquery.addWhereEqualTo( installationId , installationId);\nbmobPush.setQuery(query);\nbmobPush.pushMessage( 消息内容 );  发送给iOS单个客户端  String deviceToken =  客户端deviceToken ;\nBmobPushManager bmobPush = new BmobPushManager();\nBmobQuery BmobInstallation  query = BmobInstallation.getQuery();\nquery.addWhereEqualTo( deviceToken , deviceToken);\nbmobPush.setQuery(query);\nbmobPush.pushMessage( 消息内容 );", 
            "title": "点播推送消息"
        }, 
        {
            "location": "/push/ios/", 
            "text": "推送证书设置指南\n\n\n创建应用\n\n\n1.进入并登录\napple member center\n\n\n2.点击进入Certificates, Identifiers \n Profiles\n\n\n\n\n3.点击进入iOS Apps下面的Provisioning Portal\n\n\n\n\n4.点击App IDs栏目中的加号，根据提示创建应用ID(图1)，如图2所示，在创建过程中勾选Push Notification服务；\n\n\n图1\n\n\n\n\n\n\n图2\n\n\n\n\n创建和上传证书\n\n\n1.创建完成后再次点击应用，点击Edit；\n\n\n\n\n2.点击创建证书（图1）,并根据提示创建证书（图2）， \n\n\n图1\n\n\n\n\n图2\n\n\n\n\n3.生成证书后点击一下步，并上传刚刚创建好的证书，点击生成\n\n\n\n\n4.如图所示，点击Download下载APNs，完成后点击Done。\n\n\n\n\n5.导出.p12文件\n\n\n\n\n双击刚刚生成的.cer文件；\n\n\n\n\n\n\n\n\n进入\"钥匙串访问\"，选中刚刚导入的证书；\n\n\n\n\n\n\n\n\n选择导出项目（图1），导出.12文件，可以修改文件保存位置为桌面，方便后续上传（图2）；\n\n\n\n\n图1\n\n\n\n\n图2\n\n\n\n\n\n\n点击存储，会提示设置密码，此处密码需为空，点击“好”，根据提示输入登录密码即可导出。\n\n\n\n\n\n\n6.按照1~5步创建开发证书\n\n\n\n\n7.进入Bmob后台，在消息推送的推送设置处上传刚刚生成的两个.p12文件，并且选择目前是开发状态还是生产状态（图1）。\n证书是具有有效时间的，需要注意在过期后重新生成\n\n\n图1\n\n\n\n\n图2\n\n\n\n\n推送使用\n\n\n使用Bmob的推送服务，需要添加BmobSDK及其依赖库，具体可以参考\nBmobSDK iOS快速入门\n\n\n推送消息接收\n\n\n接收推送消息需要做两件事情，一是注册远程推送，一是将注册后得到的Token值保存至服务器。\n\n\n1.注册远程推送，在AppDelegate.m中的\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n中使用以下代码\n\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    [Bmob registerWithAppKey:@\nyour appkey\n];\n\n    // Override point for customization after application launch.\n    //注册推送，iOS 8的推送机制与iOS 7有所不同，这里需要分别设置\n    if ([[[UIDevice currentDevice] systemVersion] floatValue] \n= 8.0) {\n        UIMutableUserNotificationCategory *categorys = [[UIMutableUserNotificationCategory alloc]init];\n        //注意：此处的Bundle ID要与你申请证书时填写的一致。\n        categorys.identifier=@\ncom.bmob.bmobpushdemo\n;\n\n        UIUserNotificationSettings *userNotifiSetting = [UIUserNotificationSettings settingsForTypes:(UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound) categories:[NSSet setWithObjects:categorys,nil]];\n\n        [[UIApplication sharedApplication] registerUserNotificationSettings:userNotifiSetting];\n\n        [[UIApplication sharedApplication] registerForRemoteNotifications];\n    }else {\n        //注册远程推送\n        UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge|UIRemoteNotificationTypeAlert|UIRemoteNotificationTypeSound;\n        [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes];\n    }\n    return YES;\n}\n\n\n\n\n\n2.在AppDelegate.m中添加以下代码，上传Token至服务器\n\n\n-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken{\n\n    //注册成功后上传Token至服务器\n    BmobInstallation  *currentIntallation = [BmobInstallation installation];\n    [currentIntallation setDeviceTokenFromData:deviceToken];\n    [currentIntallation saveInBackground];\n}\n\n\n\n\n至此就可以接收到通知消息了。\n\n\n注意\n\n\n\n\n\n\niOS的推送只能在真机上使用，因此测试只能在真机上进行。\n\n\n\n\n\n\n项目一般需要设置自己的 \nProvisioning Profile\n ，如果是第一次跑该应用程序，可能会遇到以下问题，这是没有设置 \nProvisioning Profile\n 导致的。\n\n\n\n\n\n\nDomain=NSCocoaErrorDomain Code=3000 \n未找到应用程序的“aps-environment”的权利字符串\n\n\n\n\n\n解决过程如下：\n1）添加一个新的许可文件（如下图），将你要测试的设备添加入许可文件，并将该文件下载下来，双击安装至xcode;\n\n\n\n\n2）在Build Settings/Code Signing/Prvisioning Profile中选择刚刚导入至xcode的许可文件。\n\n\n\n\n3）在info.plist的Bundle identifier中填入Bundle ID即可，注意：此处的Bundle ID要与你申请证书时填写的一致。\n\n\n\n\n完成上述内容后，如果你的应用不是在运行状态，苹果的服务器就会发送推送至用户的设备上，并且由操作系统显示给用户，并不需要开发者做任何操作。如果推送到达时，应用是处于前台运行状态，开发者可以解析这条推送的内容。代码如下：\n\n\n- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo{\n    // 处理推送消息\n    NSLog(@\nuserinfo:%@\n,userInfo);\n   \n    NSLog(@\n收到推送消息:%@\n,[[userInfo objectForKey:@\naps\n] objectForKey:@\nalert\n]);\n｝\n\n\n\n\n推送消息发送\n\n\n推送消息一种是直接在Web端进行发送，另外一种则是在app端进行发送。\n\n\nWeb端发送\n\n\n完成以上步骤后，你可以运行应用程序，从web推送一条消息给客户端。\n\n\n\n\n在后台推送消息给Android和iOS两个平台的时候，有一些需要注意的：\n\n\n1、由于Android和iOS的提送机制不同，iOS要经过APNS，Android的推送完全是走Bmob的长连接服务，为兼容这个问题，如果你选择发送格式为“json”格式时，需要添加APNS兼容头部（见下面json的aps部分），推送内容格式如下：\n\n\n{\n    \naps\n: {\n    \nsound\n: \ncheering.caf\n, \n    \nalert\n: \n这个是通知栏上显示的内容\n, \n    \nbadge\n: 0 \n    }, \n    \nxx\n : \njson的key-value对，你可以根据情况添加更多的，客户端进行解析获取\n, \n}\n\n\n\n\n其中，sound是iOS接收时的声音，badge是iOS通知栏的累计消息数(\n目前该值服务器并没有主动处理，需要开发者自行维护该值\n)。\n\n\n2、如果你选择发送格式为“text”时，推送内容为“推送消息测试。。。。”，Bmob会自动添加aps部分发送给APNS，，相当于自动生成如下的json格式的推送内容：\n\n\n{\n    \naps\n: {\n        \nalert\n: \n推送消息测试。。。。\n, \n    }\n}\n\n\n\n\n同时，也会发送给Android端，相当于自动生成如下的json格式的推送内容：\n\n\n{\n    \nalert\n : \n推送消息测试。。。。\n, \n}\n\n\n\n\n3、如果只是发送给Android端，大家可以自定义json格式的数据。\n\n\n4、由于iOS的APNS的推送的大小是有限制的，默认最多256bytes，因此,如果你需要跨平台互通的话，需注意推送的内容不要太长。\n\n\n5、想要更多了解Bmob的推送格式的朋友，如即时聊天，可以查看我们在问答社区中的回答：\nhttp://wenda.bmob.cn//?/question/204\n\n\napp端发送\n\n\napp端推送我们可以有以下类型\n\n\n\n\n广播推送，即给所有安装了该应用的设备发送推送\n\n\n组播推送，即给特定用户群发送推送\n\n\n点播推送，即给特定某一用户发送推送\n\n\n\n\n广播推送\n\n\n采用以下代码\n\n\nBmobPush *push = [BmobPush push];\n//设置推送消息\n[push setMessage:@\n所有人的推送的消息\n];\n//发送推送\n[push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@\nerror %@\n,[error description]);\n}];\n\n\n\n\n组播推送\n\n\n可以自定义筛选条件给特定的用户群进行推送，这里我们将通过案例来说明如何使用组播推送。\n\n\n1.根据订阅频道推送\n\n\n如我们做电台应用，只希望给订阅了特定频道的用户进行推送，我们可以使用利用在Intallation表中定义了的\nchannels\n字段，我们可以设置该字段，然后只给订阅了特定channels的用户推送消息。首先，来看看如何设置该字段。\n\n\n覆盖已订阅的频道：\n\n\nBmobInstallation  *currentIntallation = [BmobInstallation objectWithoutDatatWithClassName:nil objectId:@\nszK8444I\n];\n[currentIntallation setObject:@[@\nGiants\n,@\nMets\n] forKey:@\nchannels\n];\n[currentIntallation updateInBackground];\n\n\n\n\n订阅一个新频道，不覆盖已订阅的频道:\n\n\nBmobInstallation  *currentIntallation = [BmobInstallation objectWithoutDatatWithClassName:nil objectId:@\nszK8444I\n];\n[currentIntallation subscribeFromChannels:@[@\nGiants\n]];\n[currentIntallation updateInBackground];\n\n\n\n\n退订一个订阅频道\n\n\nBmobInstallation  *currentIntallation = [BmobInstallation objectWithoutDatatWithClassName:nil objectId:@\nszK8444I\n];\n[currentIntallation unsubscribeFromChannels:@[@\nGiants\n]];\n[currentIntallation updateInBackground];\n\n\n\n\n设置好订阅频道后我们可以给订阅了特定频道的用户推送消息，代码如下：\n\n\nBmobPush *push = [BmobPush push];\n[push setMessage:@\n推送给订阅了体育频道的用户\n];\n[push setChannel:@\nSports\n];\n[push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@\nerror %@\n,[error description]);\n}];\n\n\n\n\n2.根据特定的查询条件进行推送\n\n\n我们可以设置查询条件，然后给符合条件的用户进行推送，样例如下：\n\n\nBmobQuery *query = [BmobInstallation query];\n//设置查询条件\n...\n\nBmobPush *push = [BmobPush push];\n[push setQuery:query];\n[push setMessage:@\n推送给满足条件的用户\n];\n[push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n    NSLog(@\nerror %@\n,[error description]);\n}];\n\n\n\n\n如我们可以根据平台进行推送\n\n\n1）推送给安卓用户\n\n\nBmobPush *push = [BmobPush push];\nBmobQuery *query = [BmobInstallation query];\n[query whereKey:@\ndeviceType\n equalTo:@\nandroid\n];\n[push setQuery:query];\n[push setMessage:@\n推送给安卓用户的消息\n];\n[push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n    NSLog(@\nerror %@\n,[error description]);\n}];\n\n\n\n\n2）推送给苹果用户\n\n\nBmobPush *push = [BmobPush push];\nBmobQuery *query = [BmobInstallation query];\n[query whereKey:@\ndeviceType\n equalTo:@\nios\n];\n[push setQuery:query];\npush setMessage:@\n推送给苹果用户的消息\n];\n[push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@\nerror %@\n,[error description]);\n}];\n\n\n\n\n点播推送\n\n\n给特定的用户发送信息，推送给安卓用户与推送给苹果用户有所区别，样例如下：\n\n\n1、发送给单个安卓用户\n\n\nBmobPush *push = [BmobPush push];\nBmobQuery *query = [BmobInstallation query];\n[query whereKey:@\ninstallationId\n equalTo:@\nxxxxxxxxxxxxxxxx\n];\n[push setQuery:query];\n[push setMessage:@\n推送给某个安卓用户的消息\n]\n[push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@\nerror %@\n,[error description]);\n}];\n\n\n\n\n2、推送给单个苹果用户\n\n\nBmobPush *push = [BmobPush push];\nBmobQuery *query = [BmobInstallation query];\n[query whereKey:@\ndeviceToken\n equalTo:@\nxxxxxxxxxxxxxxxx\n];\n[push setQuery:query];\n[push setMessage:@\n推送给某个苹果用户的消息\n]\n[push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@\nerror %@\n,[error description]);\n}];", 
            "title": "开发文档"
        }, 
        {
            "location": "/push/ios/#_1", 
            "text": "", 
            "title": "推送证书设置指南"
        }, 
        {
            "location": "/push/ios/#_2", 
            "text": "1.进入并登录 apple member center  2.点击进入Certificates, Identifiers   Profiles   3.点击进入iOS Apps下面的Provisioning Portal   4.点击App IDs栏目中的加号，根据提示创建应用ID(图1)，如图2所示，在创建过程中勾选Push Notification服务；  图1    图2", 
            "title": "创建应用"
        }, 
        {
            "location": "/push/ios/#_3", 
            "text": "1.创建完成后再次点击应用，点击Edit；   2.点击创建证书（图1）,并根据提示创建证书（图2），   图1   图2   3.生成证书后点击一下步，并上传刚刚创建好的证书，点击生成   4.如图所示，点击Download下载APNs，完成后点击Done。   5.导出.p12文件   双击刚刚生成的.cer文件；     进入\"钥匙串访问\"，选中刚刚导入的证书；     选择导出项目（图1），导出.12文件，可以修改文件保存位置为桌面，方便后续上传（图2）；   图1   图2    点击存储，会提示设置密码，此处密码需为空，点击“好”，根据提示输入登录密码即可导出。    6.按照1~5步创建开发证书   7.进入Bmob后台，在消息推送的推送设置处上传刚刚生成的两个.p12文件，并且选择目前是开发状态还是生产状态（图1）。 证书是具有有效时间的，需要注意在过期后重新生成  图1   图2", 
            "title": "创建和上传证书"
        }, 
        {
            "location": "/push/ios/#_4", 
            "text": "使用Bmob的推送服务，需要添加BmobSDK及其依赖库，具体可以参考 BmobSDK iOS快速入门", 
            "title": "推送使用"
        }, 
        {
            "location": "/push/ios/#_5", 
            "text": "接收推送消息需要做两件事情，一是注册远程推送，一是将注册后得到的Token值保存至服务器。  1.注册远程推送，在AppDelegate.m中的 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 中使用以下代码  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    [Bmob registerWithAppKey:@ your appkey ];\n\n    // Override point for customization after application launch.\n    //注册推送，iOS 8的推送机制与iOS 7有所不同，这里需要分别设置\n    if ([[[UIDevice currentDevice] systemVersion] floatValue]  = 8.0) {\n        UIMutableUserNotificationCategory *categorys = [[UIMutableUserNotificationCategory alloc]init];\n        //注意：此处的Bundle ID要与你申请证书时填写的一致。\n        categorys.identifier=@ com.bmob.bmobpushdemo ;\n\n        UIUserNotificationSettings *userNotifiSetting = [UIUserNotificationSettings settingsForTypes:(UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound) categories:[NSSet setWithObjects:categorys,nil]];\n\n        [[UIApplication sharedApplication] registerUserNotificationSettings:userNotifiSetting];\n\n        [[UIApplication sharedApplication] registerForRemoteNotifications];\n    }else {\n        //注册远程推送\n        UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge|UIRemoteNotificationTypeAlert|UIRemoteNotificationTypeSound;\n        [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes];\n    }\n    return YES;\n}  2.在AppDelegate.m中添加以下代码，上传Token至服务器  -(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken{\n\n    //注册成功后上传Token至服务器\n    BmobInstallation  *currentIntallation = [BmobInstallation installation];\n    [currentIntallation setDeviceTokenFromData:deviceToken];\n    [currentIntallation saveInBackground];\n}  至此就可以接收到通知消息了。  注意    iOS的推送只能在真机上使用，因此测试只能在真机上进行。    项目一般需要设置自己的  Provisioning Profile  ，如果是第一次跑该应用程序，可能会遇到以下问题，这是没有设置  Provisioning Profile  导致的。    Domain=NSCocoaErrorDomain Code=3000  未找到应用程序的“aps-environment”的权利字符串   解决过程如下：\n1）添加一个新的许可文件（如下图），将你要测试的设备添加入许可文件，并将该文件下载下来，双击安装至xcode;   2）在Build Settings/Code Signing/Prvisioning Profile中选择刚刚导入至xcode的许可文件。   3）在info.plist的Bundle identifier中填入Bundle ID即可，注意：此处的Bundle ID要与你申请证书时填写的一致。   完成上述内容后，如果你的应用不是在运行状态，苹果的服务器就会发送推送至用户的设备上，并且由操作系统显示给用户，并不需要开发者做任何操作。如果推送到达时，应用是处于前台运行状态，开发者可以解析这条推送的内容。代码如下：  - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo{\n    // 处理推送消息\n    NSLog(@ userinfo:%@ ,userInfo);\n   \n    NSLog(@ 收到推送消息:%@ ,[[userInfo objectForKey:@ aps ] objectForKey:@ alert ]);\n｝", 
            "title": "推送消息接收"
        }, 
        {
            "location": "/push/ios/#_6", 
            "text": "推送消息一种是直接在Web端进行发送，另外一种则是在app端进行发送。", 
            "title": "推送消息发送"
        }, 
        {
            "location": "/push/ios/#web", 
            "text": "完成以上步骤后，你可以运行应用程序，从web推送一条消息给客户端。   在后台推送消息给Android和iOS两个平台的时候，有一些需要注意的：  1、由于Android和iOS的提送机制不同，iOS要经过APNS，Android的推送完全是走Bmob的长连接服务，为兼容这个问题，如果你选择发送格式为“json”格式时，需要添加APNS兼容头部（见下面json的aps部分），推送内容格式如下：  {\n     aps : {\n     sound :  cheering.caf , \n     alert :  这个是通知栏上显示的内容 , \n     badge : 0 \n    }, \n     xx  :  json的key-value对，你可以根据情况添加更多的，客户端进行解析获取 , \n}  其中，sound是iOS接收时的声音，badge是iOS通知栏的累计消息数( 目前该值服务器并没有主动处理，需要开发者自行维护该值 )。  2、如果你选择发送格式为“text”时，推送内容为“推送消息测试。。。。”，Bmob会自动添加aps部分发送给APNS，，相当于自动生成如下的json格式的推送内容：  {\n     aps : {\n         alert :  推送消息测试。。。。 , \n    }\n}  同时，也会发送给Android端，相当于自动生成如下的json格式的推送内容：  {\n     alert  :  推送消息测试。。。。 , \n}  3、如果只是发送给Android端，大家可以自定义json格式的数据。  4、由于iOS的APNS的推送的大小是有限制的，默认最多256bytes，因此,如果你需要跨平台互通的话，需注意推送的内容不要太长。  5、想要更多了解Bmob的推送格式的朋友，如即时聊天，可以查看我们在问答社区中的回答： http://wenda.bmob.cn//?/question/204", 
            "title": "Web端发送"
        }, 
        {
            "location": "/push/ios/#app", 
            "text": "app端推送我们可以有以下类型   广播推送，即给所有安装了该应用的设备发送推送  组播推送，即给特定用户群发送推送  点播推送，即给特定某一用户发送推送", 
            "title": "app端发送"
        }, 
        {
            "location": "/push/ios/#_7", 
            "text": "采用以下代码  BmobPush *push = [BmobPush push];\n//设置推送消息\n[push setMessage:@ 所有人的推送的消息 ];\n//发送推送\n[push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@ error %@ ,[error description]);\n}];", 
            "title": "广播推送"
        }, 
        {
            "location": "/push/ios/#_8", 
            "text": "可以自定义筛选条件给特定的用户群进行推送，这里我们将通过案例来说明如何使用组播推送。", 
            "title": "组播推送"
        }, 
        {
            "location": "/push/ios/#1", 
            "text": "如我们做电台应用，只希望给订阅了特定频道的用户进行推送，我们可以使用利用在Intallation表中定义了的 channels 字段，我们可以设置该字段，然后只给订阅了特定channels的用户推送消息。首先，来看看如何设置该字段。  覆盖已订阅的频道：  BmobInstallation  *currentIntallation = [BmobInstallation objectWithoutDatatWithClassName:nil objectId:@ szK8444I ];\n[currentIntallation setObject:@[@ Giants ,@ Mets ] forKey:@ channels ];\n[currentIntallation updateInBackground];  订阅一个新频道，不覆盖已订阅的频道:  BmobInstallation  *currentIntallation = [BmobInstallation objectWithoutDatatWithClassName:nil objectId:@ szK8444I ];\n[currentIntallation subscribeFromChannels:@[@ Giants ]];\n[currentIntallation updateInBackground];  退订一个订阅频道  BmobInstallation  *currentIntallation = [BmobInstallation objectWithoutDatatWithClassName:nil objectId:@ szK8444I ];\n[currentIntallation unsubscribeFromChannels:@[@ Giants ]];\n[currentIntallation updateInBackground];  设置好订阅频道后我们可以给订阅了特定频道的用户推送消息，代码如下：  BmobPush *push = [BmobPush push];\n[push setMessage:@ 推送给订阅了体育频道的用户 ];\n[push setChannel:@ Sports ];\n[push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@ error %@ ,[error description]);\n}];", 
            "title": "1.根据订阅频道推送"
        }, 
        {
            "location": "/push/ios/#2", 
            "text": "我们可以设置查询条件，然后给符合条件的用户进行推送，样例如下：  BmobQuery *query = [BmobInstallation query];\n//设置查询条件\n...\n\nBmobPush *push = [BmobPush push];\n[push setQuery:query];\n[push setMessage:@ 推送给满足条件的用户 ];\n[push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n    NSLog(@ error %@ ,[error description]);\n}];  如我们可以根据平台进行推送  1）推送给安卓用户  BmobPush *push = [BmobPush push];\nBmobQuery *query = [BmobInstallation query];\n[query whereKey:@ deviceType  equalTo:@ android ];\n[push setQuery:query];\n[push setMessage:@ 推送给安卓用户的消息 ];\n[push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n    NSLog(@ error %@ ,[error description]);\n}];  2）推送给苹果用户  BmobPush *push = [BmobPush push];\nBmobQuery *query = [BmobInstallation query];\n[query whereKey:@ deviceType  equalTo:@ ios ];\n[push setQuery:query];\npush setMessage:@ 推送给苹果用户的消息 ];\n[push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@ error %@ ,[error description]);\n}];", 
            "title": "2.根据特定的查询条件进行推送"
        }, 
        {
            "location": "/push/ios/#_9", 
            "text": "给特定的用户发送信息，推送给安卓用户与推送给苹果用户有所区别，样例如下：  1、发送给单个安卓用户  BmobPush *push = [BmobPush push];\nBmobQuery *query = [BmobInstallation query];\n[query whereKey:@ installationId  equalTo:@ xxxxxxxxxxxxxxxx ];\n[push setQuery:query];\n[push setMessage:@ 推送给某个安卓用户的消息 ]\n[push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@ error %@ ,[error description]);\n}];  2、推送给单个苹果用户  BmobPush *push = [BmobPush push];\nBmobQuery *query = [BmobInstallation query];\n[query whereKey:@ deviceToken  equalTo:@ xxxxxxxxxxxxxxxx ];\n[push setQuery:query];\n[push setMessage:@ 推送给某个苹果用户的消息 ]\n[push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@ error %@ ,[error description]);\n}];", 
            "title": "点播推送"
        }, 
        {
            "location": "/push/javascript/", 
            "text": "开发文档\n\n\n向移动设备发送通知消息的示例代码如下：\n\n\n//向订阅了public频道的设备推送通知\nBmob.Push.send({\n  channels: [ \nPublic\n ],\n  data: {\n     alert: \nPublic message\n\n  }\n});\n\n\n\n\n大家可以查看文档：\nBmob消息推送\n 获取更详细的信息。", 
            "title": "开发文档"
        }, 
        {
            "location": "/push/javascript/#_1", 
            "text": "向移动设备发送通知消息的示例代码如下：  //向订阅了public频道的设备推送通知\nBmob.Push.send({\n  channels: [  Public  ],\n  data: {\n     alert:  Public message \n  }\n});  大家可以查看文档： Bmob消息推送  获取更详细的信息。", 
            "title": "开发文档"
        }, 
        {
            "location": "/push/php/", 
            "text": "消息推送简介\n\n\n推送通知是让用户及时被通知、和你的应用保持联系的一种非常棒的方式，你可以快速而有效地通知到所有的用户，下面这个教程将会教你如何使用Bmob来推送消息。\n\n\n安装消息推送服务\n\n\n每一个Bmob的App被安装在用户的设备上后，如果要使用消息推送功能，Bmob SDK会自动生成一个Installation对象。Installation对象包含了推送所需要的所有信息。举例：一个棒球的App，你可以让用户订阅感兴趣的棒球队，然后及时将这个球队的消息推送给用户 。\n你可以使用 REST API，通过请求URL \n/1/installations\n 对Installation对象进行一系列操作，就像你存储和获取其他的普通对象，如GameScore对象一样。\n注意Installation对象一般只在Client SDK中进行修改，但REST API对于大量导入或导出订阅数据的Installation对象是极其有用的。\n\n\nInstallation对象有几个系统默认的特殊字段来帮助你进行定位到设备等管理：\n- \nbadge\n : iOS应用中右上角的图标标识，这不会在服务端进行自增，需要开发者自己实现自增统计\n- \nchannels\n : 当前这个设备订阅的渠道名称数组\n- \ntimeZone\n : 设备所在位置的时区， 如Asia/Shanghai，这个会在每个Installation对象更新时同步（只读）\n- \ndeviceType\n : 设备的类型, 值为：\"ios\" 或 \"android\" (只读)\n- \ninstallationId\n : Bmob使用的设备唯一号，Android设备是必须的，iOS可选 (只读)\n- \ndeviceToken\n : iOS设备由Apple APNS生成的唯一性token标识 (只读)\n- \nnotificationUri\n : Windows Phone设备由Windows Push Center生成的唯一性token标识\n\n\n保存 installation\n\n\n保存iOS设备的deviceToken\n\n\niOS设备通常使用deviceToken来对一台设备进行惟一标识。\n\n\n$bmobPush = new BmobPush();\n$data=array(    \n    \ndeviceType\n=\nios\n,\n    \ndeviceToken\n=\nabcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789\n,\n    \nchannels\n=\narray(\nGiants\n)\n);\n$res = $bmobPush-\naddInstallations($data);\n\n\n\n\n\n保存Android设备的 installationId\n\n\n对于Android设备，\nBmob\nSDK会自动生成uuid作为installationId保存到 Bmob。 你可以使用以下REST API保存Android设备的installation ID。\n\n\n\n$bmobPush = new BmobPush();\n$data=array(    \n    \ndeviceType\n=\nandroid\n,\n    \ninstallationId\n=\n12345678-4312-1234-1234-1234567890ab\n,\n    \nchannels\n=\narray(\nGiants\n)\n);\n$res = $bmobPush-\naddInstallations($data);\n\n\n\n\n\n你还可以更新Installation对象的更多属性，用来查询installationId，定制更通用的推送\n\n\n$res = $bmobPush-\nupdateInstallations(\nfdcc6a94c6\n,array(\ninjuryReports\n=\ntrue)); //更新设备表\n\n\n\n\n\n保存Windows Phone设备的 notificationUri\n\n\n对于Windows Phone设备，\nBmob\nSDK会自动从Windows Push Center获取到notificationUri并保存到 Bmob。 你可以使用以下php sdk保存Windows Phone设备的notificationUri。\n\n\n$data=array(    \n    \ndeviceType\n=\nwindows phone\n,\n    \nnotificationUri\n=\nhttps://hk1.notify.live.net/unthrottledthirdparty/01.00/AQHgHh6EuwNtTa1TbwvaAjnmAgAAAAADEAAAAAQUZm52OkZDM0U5RDkxQzIzREJBNDYFBkFTRUEwMQ\n,\n    \nchannels\n=\narray(\nGiants\n)\n);\n    $res = $bmobPush-\naddInstallations($data);\n\n\n\n\n订阅频道和退订\n\n\n订阅频道\n\n\n覆盖已订阅的频道：\n\n\n$res = $bmobPush-\nupdateInstallations(\nfdcc6a94c6\n,array(\nchannels\n=\narray(\nGiants\n)))\n\n\n\n\n订阅一个新频道，不覆盖已订阅的频道：\n\n\n$data = array(\n    \nchannels\n=\narray(\n        \n__op\n=\nAddUnique\n,\n        \nobjects\n=\narray(\nGiants\n),\n    )\n);\n$res = $bmobPush-\nupdateInstallations(\nfdcc6a94c6\n, $data);\n\n\n\n\n退订频道\n\n\n$data = array(\n    \nchannels\n=\narray(\n        \n__op\n=\nRemove\n,\n        \nobjects\n=\narray(\nGiants\n),\n    )\n);\n$res = $bmobPush-\nupdateInstallations(\nfdcc6a94c6\n, $data);\n\n\n\n\n广播推送消息\n\n\n$res = $bmobPush-\npush(array(\ndata\n=\narray(\nalert\n=\nhello\n))); \n\n\n\n\n组播推送消息\n\n\n发送给订阅了Giants频道的用户\n\n\n $res = $bmobPush-\npush(array(\ndata\n=\narray(\nalert\n=\nhello\n),\nwhere\n=\narray(\nchannels\n=\narray(\nGiants\n)))); \n\n\n\n\n或者更简便的方式\n\n\n$res = $bmobPush-\npush(array(\ndata\n=\narray(\nalert\n=\nhello\n),\nchannels\n=\narray(\nGiants\n))); \n\n\n\n\n多播推送消息\n\n\n推送给不活跃的用户\n\n\n$data = array(\n    \ndata\n=\narray(\nalert\n=\nhello\n),\n    \nwhere\n=\narray(\nupdatedAt\n=\narray(\n                \n$lt\n=\narray(\n__type\n=\nDate\n,\niso\n=\n2012-01-29 11:33:53\n))\n             )\n);\n\n$res = $bmobPush-\npush($data); \n\n\n\n\n根据查询条件做推送\n\n\n$res = $bmobPush-\npush(array(\ndata\n=\narray(\nalert\n=\nhello\n),\nwhere\n=\narray(\nscores\n=\ntrue))); \n\n\n\n\n请注意，where 条件查询的都是 installations 表。这里是假设 installations 表存储了 scores 的布尔属性，你可以像查询普通对象一样构造where查询\n\n\n根据平台做推送\n\n\n$res = $bmobPush-\npush(array(\ndata\n=\narray(\nalert\n=\nhello\n),\nwhere\n=\narray(\ndeviceType\n=\nandroid\n))); \n\n\n\n\n$res = $bmobPush-\npush(array(\ndata\n=\narray(\nalert\n=\nhello\n),\nwhere\n=\narray(\ndeviceType\n=\nios\n))); \n\n\n\n\nWindows Phone平台的推送分三种格式：\n\n\na.推送Raw通知(\n默认\n)：\n\n\n$data = array(\n    \ndata\n=\narray(\nalert\n=\nhello\n, \nwpAlert\n=\nTextBoxValue2\n),\n    \nwhere\n=\narray(\ndeviceType\n=\nwindows phone\n)\n);\n\n$res = $bmobPush-\npush($data); \n\n\n\n\nb.推送Toast通知：\n\n\n$data = array(\n    \ndata\n=\narray(\nalert\n=\nhello\n,\n                  \nwpAlert\n=\nTextBoxValue2\n,\n                   \nwp\n=\n 2),\n    \nwhere\n=\narray(\ndeviceType\n=\nwindows phone\n)\n);\n\n$res = $bmobPush-\npush($data); \n\n\n\n\n\nc.推送磁贴通知：\n\n\n$data = array(\n    \ndata\n=\narray(\nalert\n=\nhello\n,\n                  \nbackgroundImage\n=\nbackgroundImage\n,\n                  \ncount\n=\n 2,\n                  \nbackBackgroundImage\n=\nbackBackgroundImage\n,             \n                  \nbackTitle\n=\nbackTitle\n,\n                  \nbackContent\n=\nbackContent\n,\n                  \nwp\n=\n1,\n                ),\n    \nwhere\n=\narray(\ndeviceType\n=\nwindows phone\n)\n);\n\n$res = $bmobPush-\npush($data); \n\n\n\n\n根据地理信息位置做推送\n\n\n\n$data = array(\n    \ndata\n=\narray(\nalert\n=\nhello\n),\n    \nwhere\n=\narray(\nuser\n=\narray(\n                             \n$inQuery\n=\narray(\n                                    \nlocation\n=\narray(\n$nearSphere\n=\narray(\n                                                                                                                                                                \n__type\n=\nGeoPoint\n,\n                                                            \nlatitude\n=\n30.0,\n                                                            \nlongitude\n=\n-20.0,\n                                                                                ),\n                                                     \n$maxDistanceInMiles\n=\n1.0\n                                                    )\n                                    )\n                           )\n                   )\n);\n\n$res = $bmobPush-\npush($data); \n\n\n\n\n\n上面的例子假设 installation 有个 user 属性指向_User 表的记录，并且用户有个 location 属性是 GeoPoint 类型，我们就可以根据地理信息位置做推送。\n\n\n点播推送消息\n\n\n发送给Android单个客户端\n\n\n$data = array(\n    \ndata\n=\narray(\nalert\n=\nhello\n),\n    \nwhere\n=\narray(\ninstallationId\n=\n57234d4c-752f-4e78-81ad-a6d14048020d\n)\n);\n\n$res = $bmobPush-\npush($data); \n\n\n\n\n\n发送给iOS单个客户端\n\n\n$data = array(\n    \ndata\n=\narray(\naps\n=\narray(\nalert\n=\ncashi\n,\nbadge\n=\n1,\nsound\n=\ndefault\n)),\n    \nwhere\n=\narray(\ndeviceToken\n=\nabcdef0123456789abcdef0123456789abcdef0123456789abcdef012345678\n)\n);\n\n$res = $bmobPush-\npush($data); \n\n\n\n\n发送给Windows Phone单个客户端Toast通知\n\n\n$data = array(\n    \ndata\n=\narray(\nalert\n=\ncashi\n,\nwpAlert\n=\nbmob\n,\nwp\n=\n2),\n    \nwhere\n=\narray(\nnotificationUri\n=\nhttps://hk1.notify.live.net/unthrottledthirdparty/01.00/AQHgHh6EuwNtTa1TbwvaAjnmAgAAAAADEAAAAAQUZm52OkZDM0U5RDkxQzIzREJBNDYFBkFTRUEwMQ\n)\n);\n\n$res = $bmobPush-\npush($data); \n\n\n\n\n发送选项设置\n\n\n推送通知不仅仅可以用来发送消息，iOS中，推送内容还可以包含要播放的声音和要显示的badge数字值,还可以定制任何你想发送的内容，对于Android，你甚至可以指定Intent应用于接收消息，对于时效有要求的消息你还可以设置一个消息过期时间。\n\n\n定制你的通知\n\n\n如果你想发送更多的消息，你可以在data的字典对象中设置其他字段，下面这些保留的字段有其特殊的意义：\n- \nalert\n : 通知的消息内容\n- \nbadge\n : (仅iOS)一个数字值将会高亮显示在应用图标的右上角。\n- \nsound\n : (仅iOS)应用绑定包中的声音\n- \ncontent-available\n : (仅iOS)如果你的应用是新闻类的，或者你的应用正在使用iOS7的Remote Notification Background Mode，设定这个值为1将会触发离线下载功能。\n- \naction\n : (仅Android)接收到推送消息时应用Intent，如果没有指定title或alert，Intent将被应用，但是没有通知呈现给用户。\n- \ntitle\n : (仅Android)这个值将显示在系统通知栏\n- \nwp\n : (仅Windows Phone)通知类型 0-Raw(默认) 1-Toast 2-磁贴\n- \nwpAlert\n : (仅Windows Phone)这个值将在Raw 和 Toast两种通知中有用，相对alert，作为子标题\n- \nbackgroundImage\n : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n- \ncount\n : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n- \nbackBackgroundImage\n : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n- \nbackTitle\n : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n- \nbackContent\n : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n\n\n例如，推送一条通知，将当前的badge值设置为一个数字值,并且播放iOS设备上定制的音乐，对于Android用户，将在系统通知栏中显示特殊的标题，其请求如下：\n\n\n$data = array(\n    \ndata\n=\narray(\nalert\n=\ncashi\n,\nbadge\n=\n10,\nsound\n=\ncheering.caf\n,\ntitle\n=\nMets Score!\n),\n    \nchannels\n=\narray(\nMets\n)\n);\n\n$res = $bmobPush-\npush($data); \n\n\n\n\n当然，你也可以在data字典对象中定制自己的字段来推送消息，但推送到消息不显示在 Andoid 系统的通知栏中，而是执行应用程序预定义的逻辑，Android或iOS的接收消息文档中对此有说明，iOS只有当用户从通知中打开应用，才能访问data的数据，Android将提供这个数据在action Intent应用之后将提供这个数据,\n\n\n$data = array(\n    \ndata\n=\narray(\nalert\n=\ncashi\n,\naction\n=\ncom.example.UPDATE_STATUS\n,\nname\n=\nVaughn\n),\n    \nchannels\n=\narray(\nMets\n)\n);\n\n$res = $bmobPush-\npush($data); \n\n\n\n\n\n设置消息过期时间\n\n\n过期时间，可以是绝对时间：\n\n\n$data = array(\n    \ndata\n=\narray(\nalert\n=\ncashi\n),\n    \nexpiration_time\n=\n2013-12-04 00:51:13\n\n);\n\n$res = $bmobPush-\npush($data); \n\n\n\n\n也可以是相对时间（根据push_time做定期推送，从push_time时间开始算起，直到expiration_interval时间后过期），下面的请求表示消息将在2012-01-28 00:51:13这个时间点开始推送，直到7天后过期:\n\n\n$data = array(\n    \ndata\n=\narray(\nalert\n=\ncashi\n),\n    \npush_time\n=\n2012-01-28 00:51:13\n,\n    \nexpiration_interval\n=\n518400,\n);\n\n$res = $bmobPush-\npush($data);", 
            "title": "开发文档"
        }, 
        {
            "location": "/push/php/#_1", 
            "text": "推送通知是让用户及时被通知、和你的应用保持联系的一种非常棒的方式，你可以快速而有效地通知到所有的用户，下面这个教程将会教你如何使用Bmob来推送消息。", 
            "title": "消息推送简介"
        }, 
        {
            "location": "/push/php/#_2", 
            "text": "每一个Bmob的App被安装在用户的设备上后，如果要使用消息推送功能，Bmob SDK会自动生成一个Installation对象。Installation对象包含了推送所需要的所有信息。举例：一个棒球的App，你可以让用户订阅感兴趣的棒球队，然后及时将这个球队的消息推送给用户 。\n你可以使用 REST API，通过请求URL  /1/installations  对Installation对象进行一系列操作，就像你存储和获取其他的普通对象，如GameScore对象一样。\n注意Installation对象一般只在Client SDK中进行修改，但REST API对于大量导入或导出订阅数据的Installation对象是极其有用的。  Installation对象有几个系统默认的特殊字段来帮助你进行定位到设备等管理：\n-  badge  : iOS应用中右上角的图标标识，这不会在服务端进行自增，需要开发者自己实现自增统计\n-  channels  : 当前这个设备订阅的渠道名称数组\n-  timeZone  : 设备所在位置的时区， 如Asia/Shanghai，这个会在每个Installation对象更新时同步（只读）\n-  deviceType  : 设备的类型, 值为：\"ios\" 或 \"android\" (只读)\n-  installationId  : Bmob使用的设备唯一号，Android设备是必须的，iOS可选 (只读)\n-  deviceToken  : iOS设备由Apple APNS生成的唯一性token标识 (只读)\n-  notificationUri  : Windows Phone设备由Windows Push Center生成的唯一性token标识", 
            "title": "安装消息推送服务"
        }, 
        {
            "location": "/push/php/#installation", 
            "text": "", 
            "title": "保存 installation"
        }, 
        {
            "location": "/push/php/#iosdevicetoken", 
            "text": "iOS设备通常使用deviceToken来对一台设备进行惟一标识。  $bmobPush = new BmobPush();\n$data=array(    \n     deviceType = ios ,\n     deviceToken = abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789 ,\n     channels = array( Giants )\n);\n$res = $bmobPush- addInstallations($data);", 
            "title": "保存iOS设备的deviceToken"
        }, 
        {
            "location": "/push/php/#android-installationid", 
            "text": "对于Android设备， Bmob SDK会自动生成uuid作为installationId保存到 Bmob。 你可以使用以下REST API保存Android设备的installation ID。  \n$bmobPush = new BmobPush();\n$data=array(    \n     deviceType = android ,\n     installationId = 12345678-4312-1234-1234-1234567890ab ,\n     channels = array( Giants )\n);\n$res = $bmobPush- addInstallations($data);  你还可以更新Installation对象的更多属性，用来查询installationId，定制更通用的推送  $res = $bmobPush- updateInstallations( fdcc6a94c6 ,array( injuryReports = true)); //更新设备表", 
            "title": "保存Android设备的 installationId"
        }, 
        {
            "location": "/push/php/#windows-phone-notificationuri", 
            "text": "对于Windows Phone设备， Bmob SDK会自动从Windows Push Center获取到notificationUri并保存到 Bmob。 你可以使用以下php sdk保存Windows Phone设备的notificationUri。  $data=array(    \n     deviceType = windows phone ,\n     notificationUri = https://hk1.notify.live.net/unthrottledthirdparty/01.00/AQHgHh6EuwNtTa1TbwvaAjnmAgAAAAADEAAAAAQUZm52OkZDM0U5RDkxQzIzREJBNDYFBkFTRUEwMQ ,\n     channels = array( Giants )\n);\n    $res = $bmobPush- addInstallations($data);", 
            "title": "保存Windows Phone设备的 notificationUri"
        }, 
        {
            "location": "/push/php/#_3", 
            "text": "", 
            "title": "订阅频道和退订"
        }, 
        {
            "location": "/push/php/#_4", 
            "text": "覆盖已订阅的频道：  $res = $bmobPush- updateInstallations( fdcc6a94c6 ,array( channels = array( Giants )))  订阅一个新频道，不覆盖已订阅的频道：  $data = array(\n     channels = array(\n         __op = AddUnique ,\n         objects = array( Giants ),\n    )\n);\n$res = $bmobPush- updateInstallations( fdcc6a94c6 , $data);", 
            "title": "订阅频道"
        }, 
        {
            "location": "/push/php/#_5", 
            "text": "$data = array(\n     channels = array(\n         __op = Remove ,\n         objects = array( Giants ),\n    )\n);\n$res = $bmobPush- updateInstallations( fdcc6a94c6 , $data);", 
            "title": "退订频道"
        }, 
        {
            "location": "/push/php/#_6", 
            "text": "$res = $bmobPush- push(array( data = array( alert = hello )));", 
            "title": "广播推送消息"
        }, 
        {
            "location": "/push/php/#_7", 
            "text": "发送给订阅了Giants频道的用户   $res = $bmobPush- push(array( data = array( alert = hello ), where = array( channels = array( Giants ))));   或者更简便的方式  $res = $bmobPush- push(array( data = array( alert = hello ), channels = array( Giants )));", 
            "title": "组播推送消息"
        }, 
        {
            "location": "/push/php/#_8", 
            "text": "", 
            "title": "多播推送消息"
        }, 
        {
            "location": "/push/php/#_9", 
            "text": "$data = array(\n     data = array( alert = hello ),\n     where = array( updatedAt = array(\n                 $lt = array( __type = Date , iso = 2012-01-29 11:33:53 ))\n             )\n);\n\n$res = $bmobPush- push($data);", 
            "title": "推送给不活跃的用户"
        }, 
        {
            "location": "/push/php/#_10", 
            "text": "$res = $bmobPush- push(array( data = array( alert = hello ), where = array( scores = true)));   请注意，where 条件查询的都是 installations 表。这里是假设 installations 表存储了 scores 的布尔属性，你可以像查询普通对象一样构造where查询", 
            "title": "根据查询条件做推送"
        }, 
        {
            "location": "/push/php/#_11", 
            "text": "$res = $bmobPush- push(array( data = array( alert = hello ), where = array( deviceType = android )));   $res = $bmobPush- push(array( data = array( alert = hello ), where = array( deviceType = ios )));   Windows Phone平台的推送分三种格式：  a.推送Raw通知( 默认 )：  $data = array(\n     data = array( alert = hello ,  wpAlert = TextBoxValue2 ),\n     where = array( deviceType = windows phone )\n);\n\n$res = $bmobPush- push($data);   b.推送Toast通知：  $data = array(\n     data = array( alert = hello ,\n                   wpAlert = TextBoxValue2 ,\n                    wp =  2),\n     where = array( deviceType = windows phone )\n);\n\n$res = $bmobPush- push($data);   c.推送磁贴通知：  $data = array(\n     data = array( alert = hello ,\n                   backgroundImage = backgroundImage ,\n                   count =  2,\n                   backBackgroundImage = backBackgroundImage ,             \n                   backTitle = backTitle ,\n                   backContent = backContent ,\n                   wp = 1,\n                ),\n     where = array( deviceType = windows phone )\n);\n\n$res = $bmobPush- push($data);", 
            "title": "根据平台做推送"
        }, 
        {
            "location": "/push/php/#_12", 
            "text": "$data = array(\n     data = array( alert = hello ),\n     where = array( user = array(\n                              $inQuery = array(\n                                     location = array( $nearSphere = array(\n                                                                                                                                                                 __type = GeoPoint ,\n                                                             latitude = 30.0,\n                                                             longitude = -20.0,\n                                                                                ),\n                                                      $maxDistanceInMiles = 1.0\n                                                    )\n                                    )\n                           )\n                   )\n);\n\n$res = $bmobPush- push($data);   上面的例子假设 installation 有个 user 属性指向_User 表的记录，并且用户有个 location 属性是 GeoPoint 类型，我们就可以根据地理信息位置做推送。", 
            "title": "根据地理信息位置做推送"
        }, 
        {
            "location": "/push/php/#_13", 
            "text": "发送给Android单个客户端  $data = array(\n     data = array( alert = hello ),\n     where = array( installationId = 57234d4c-752f-4e78-81ad-a6d14048020d )\n);\n\n$res = $bmobPush- push($data);   发送给iOS单个客户端  $data = array(\n     data = array( aps = array( alert = cashi , badge = 1, sound = default )),\n     where = array( deviceToken = abcdef0123456789abcdef0123456789abcdef0123456789abcdef012345678 )\n);\n\n$res = $bmobPush- push($data);   发送给Windows Phone单个客户端Toast通知  $data = array(\n     data = array( alert = cashi , wpAlert = bmob , wp = 2),\n     where = array( notificationUri = https://hk1.notify.live.net/unthrottledthirdparty/01.00/AQHgHh6EuwNtTa1TbwvaAjnmAgAAAAADEAAAAAQUZm52OkZDM0U5RDkxQzIzREJBNDYFBkFTRUEwMQ )\n);\n\n$res = $bmobPush- push($data);", 
            "title": "点播推送消息"
        }, 
        {
            "location": "/push/php/#_14", 
            "text": "推送通知不仅仅可以用来发送消息，iOS中，推送内容还可以包含要播放的声音和要显示的badge数字值,还可以定制任何你想发送的内容，对于Android，你甚至可以指定Intent应用于接收消息，对于时效有要求的消息你还可以设置一个消息过期时间。", 
            "title": "发送选项设置"
        }, 
        {
            "location": "/push/php/#_15", 
            "text": "如果你想发送更多的消息，你可以在data的字典对象中设置其他字段，下面这些保留的字段有其特殊的意义：\n-  alert  : 通知的消息内容\n-  badge  : (仅iOS)一个数字值将会高亮显示在应用图标的右上角。\n-  sound  : (仅iOS)应用绑定包中的声音\n-  content-available  : (仅iOS)如果你的应用是新闻类的，或者你的应用正在使用iOS7的Remote Notification Background Mode，设定这个值为1将会触发离线下载功能。\n-  action  : (仅Android)接收到推送消息时应用Intent，如果没有指定title或alert，Intent将被应用，但是没有通知呈现给用户。\n-  title  : (仅Android)这个值将显示在系统通知栏\n-  wp  : (仅Windows Phone)通知类型 0-Raw(默认) 1-Toast 2-磁贴\n-  wpAlert  : (仅Windows Phone)这个值将在Raw 和 Toast两种通知中有用，相对alert，作为子标题\n-  backgroundImage  : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n-  count  : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n-  backBackgroundImage  : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n-  backTitle  : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n-  backContent  : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用  例如，推送一条通知，将当前的badge值设置为一个数字值,并且播放iOS设备上定制的音乐，对于Android用户，将在系统通知栏中显示特殊的标题，其请求如下：  $data = array(\n     data = array( alert = cashi , badge = 10, sound = cheering.caf , title = Mets Score! ),\n     channels = array( Mets )\n);\n\n$res = $bmobPush- push($data);   当然，你也可以在data字典对象中定制自己的字段来推送消息，但推送到消息不显示在 Andoid 系统的通知栏中，而是执行应用程序预定义的逻辑，Android或iOS的接收消息文档中对此有说明，iOS只有当用户从通知中打开应用，才能访问data的数据，Android将提供这个数据在action Intent应用之后将提供这个数据,  $data = array(\n     data = array( alert = cashi , action = com.example.UPDATE_STATUS , name = Vaughn ),\n     channels = array( Mets )\n);\n\n$res = $bmobPush- push($data);", 
            "title": "定制你的通知"
        }, 
        {
            "location": "/push/php/#_16", 
            "text": "过期时间，可以是绝对时间：  $data = array(\n     data = array( alert = cashi ),\n     expiration_time = 2013-12-04 00:51:13 \n);\n\n$res = $bmobPush- push($data);   也可以是相对时间（根据push_time做定期推送，从push_time时间开始算起，直到expiration_interval时间后过期），下面的请求表示消息将在2012-01-28 00:51:13这个时间点开始推送，直到7天后过期:  $data = array(\n     data = array( alert = cashi ),\n     push_time = 2012-01-28 00:51:13 ,\n     expiration_interval = 518400,\n);\n\n$res = $bmobPush- push($data);", 
            "title": "设置消息过期时间"
        }, 
        {
            "location": "/push/restful/", 
            "text": "消息推送简介\n\n\n推送通知是让用户及时被通知、和你的应用保持联系的一种非常棒的方式，你可以快速而有效地通知到所有的用户，下面这个教程将会教你如何使用Bmob来推送消息。\n\n\n安装消息推送服务\n\n\n每一个Bmob的App被安装在用户的设备上后，如果要使用消息推送功能，Bmob SDK会自动生成一个Installation对象。Installation对象包含了推送所需要的所有信息。举例：一个棒球的App，你可以让用户订阅感兴趣的棒球队，然后及时将这个球队的消息推送给用户 。\n你可以使用 REST API，通过请求URL \n/1/installations\n 对Installation对象进行一系列操作，就像你存储和获取其他的普通对象，如GameScore对象一样。\n注意Installation对象一般只在Client SDK中进行修改，但REST API对于大量导入或导出订阅数据的Installation对象是极其有用的。\n\n\nInstallation对象有几个系统默认的特殊字段来帮助你进行定位到设备等管理：\n- \nbadge\n : iOS应用中右上角的图标标识，这不会在服务端进行自增，需要开发者自己实现自增统计\n- \nchannels\n : 当前这个设备订阅的渠道名称数组\n- \ntimeZone\n : 设备所在位置的时区， 如Asia/Shanghai，这个会在每个Installation对象更新时同步（只读）\n- \ndeviceType\n : 设备的类型, 值为：\"ios\" 或 \"android\" (只读)\n- \ninstallationId\n : Bmob使用的设备唯一号，Android设备是必须的，iOS可选 (只读)\n- \ndeviceToken\n : iOS设备由Apple APNS生成的唯一性token标识 (只读)\n- \nnotificationUri\n : Windows Phone设备由Windows Push Center生成的唯一性token标识\n\n\n保存 installation\n\n\n根据设备的不同往设备表中添加不同的值，body格式如下\n\n\n{\n  \ndeviceType\n: deviceType (\niOS\n,\nandroid\n, \nwindows phone\n)\n  \ndeviceToken\n: iOS需填\n  \ninstallationId\n:android需填\n  \nnotificationUri\n:wp需填\n}\n\n\n\n\n下面将针对具体平台分别举例。\n\n\n保存iOS设备的deviceToken\n\n\niOS设备通常使用deviceToken来对一台设备进行惟一标识。\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \ndeviceType\n: \nios\n,\n        \ndeviceToken\n: \nabcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789\n\n      }' \\\n  https://api.bmob.cn/1/installations\n\n\n\n\n保存Android设备的 installationId\n\n\n对于Android设备，\nBmob\nSDK会自动生成uuid作为installationId保存到 Bmob。 你可以使用以下REST API保存Android设备的installation ID。\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \ndeviceType\n: \nandroid\n,\n        \ninstallationId\n: \n12345678-4312-1234-1234-1234567890ab\n\n      }' \\\n  https://api.bmob.cn/1/installations\n\n\n\n\n保存Windows Phone设备的 notificationUri\n\n\n对于Windows Phone设备，\nBmob\nSDK会自动从Windows Push Center获取到notificationUri并保存到 Bmob。 你可以使用以下REST API保存Windows Phone设备的notificationUri。\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \ndeviceType\n: \nwindows phone\n,\n        \nnotificationUri\n: \nhttps://hk1.notify.live.net/unthrottledthirdparty/01.00/AQHgHh6EuwNtTa1TbwvaAjnmAgAAAAADEAAAAAQUZm52OkZDM0U5RDkxQzIzREJBNDYFBkFTRUEwMQ\n\n      }' \\\n  https://api.bmob.cn/1/installations\n\n\n\n\n订阅频道和退订\n\n\n频道列的本质是一个数组，因此其操作与数组一致，具体可查看以下举例。\n\n\n订阅频道\n\n\n覆盖已订阅的频道：\n\n\ncurl -X PUT \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nchannels\n: [\n          \nGiants\n,\n          \nMets\n\n        ]\n      }' \\\n  https://api.bmob.cn/1/installations/mrmBZvsErB\n\n\n\n\n订阅一个新频道，不覆盖已订阅的频道：\n\n\ncurl -X PUT \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\nchannels\n:{\n__op\n:\nAddUnique\n,\nobjects\n:[\nGiants\n]}}' \\\n  https://api.bmob.cn/1/installations/mrmBZvsErB\n\n\n\n\n退订频道\n\n\ncurl -X PUT \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\nchannels\n:{\n__op\n:\nRemove\n,\nobjects\n:[\nGiants\n，\nMets\n]}}' \\\n  https://api.bmob.cn/1/installations/mrmBZvsErB\n\n\n\n\n推送消息\n\n\n请求描述\n\n\n使用推送接口可将消息推送至对应设备。\n\n\n请求\n\n\n\n\n\n\nurl ： https://api.bmob.cn/1/push\n\n\n\n\n\n\nmethod ：POST\n\n\n\n\n\n\nheader:\n\n\n\n\n\n\nX-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json\n\n\n\n\n\n\nbody: 根据不同的需求进行定制，具体看以下介绍。\n\n\n\n\n广播推送消息\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \ndata\n: {\n          \nalert\n: \nHello From Bmob.\n\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\n组播推送消息\n\n\n发送给订阅了Giants频道的用户\n\n\n curl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nwhere\n:{\n          \nchannels\n:[\nGiants\n]\n        },\n        \ndata\n: {\n          \nalert\n: \nHello From Bmob.\n\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\n或者更简便的方式\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nchannels\n:[\nGiants\n],\n        \ndata\n: {\n          \nalert\n: \nHello From Bmob.\n\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\n多播推送消息\n\n\n推送给不活跃的用户\n\n\n  curl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nwhere\n:{\n            \nupdatedAt\n:{\n                \n$lt\n:{\n__type\n:\nDate\n,\niso\n:\n2012-01-29 11:33:53\n}\n              }\n        },\n        \ndata\n: {\n            \nalert\n: \nHello From Bmob.\n\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\n根据查询条件做推送\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nwhere\n: {\n          \nscores\n: true\n        },\n        \ndata\n: {\n          \nalert\n: \nWillie Hayes injured by own pop fly.\n\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\n请注意，where 条件查询的都是 installations 表。这里是假设 installations 表存储了 scores 的布尔属性，你可以像查询普通对象一样构造where查询\n\n\n根据平台做推送\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nwhere\n: {\n          \ndeviceType\n: \nandroid\n\n        },\n        \ndata\n: {\n          \nalert\n: \nYour suitcase has been filled with tiny robots!\n\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nwhere\n: {\n          \ndeviceType\n: \nios\n\n        },\n        \ndata\n: {\n          \nalert\n: \nYour suitcase has been filled with tiny apples!\n\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\nWindows Phone平台的推送分三种格式：\n\n\na.推送Raw通知(\n默认\n)：\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nwhere\n: {\n          \ndeviceType\n: \nwindows phone\n\n        },\n        \ndata\n: {\n           \nalert\n: \nYour suitcase has been filled with tiny windows phone!\n,\n           \nwpAlert\n: \nTextBoxValue2\n\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\nb.推送Toast通知：\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nwhere\n: {\n          \ndeviceType\n: \nwindows phone\n\n        },\n        \ndata\n: {\n          \nalert\n: \nYour suitcase has been filled with tiny apples!\n,\n          \nwpAlert\n: \nTextBoxSubTitle\n,\n          \nwp\n: 2\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\nc.推送磁贴通知：\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nwhere\n: {\n          \ndeviceType\n: \nwindows phone\n\n        },\n        \ndata\n: {\n          \nalert\n: \nYour suitcase has been filled with tiny apples!\n,\n          \nbackgroundImage\n: \nbackgroundImage\n,\n          \ncount\n:\n1\n,\n          \nbackBackgroundImage\n: \nbackBackgroundImage\n,\n          \nbackTitle\n:\nbackTitle\n,\n          \nbackContent\n:\nbackContent\n,\n          \nwp\n: 1\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\n根据地理信息位置做推送\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nwhere\n: {\n          \nuser\n: {\n            \n$inQuery\n: {\n              \nlocation\n: {\n                \n$nearSphere\n: {\n                  \n__type\n: \nGeoPoint\n,\n                  \nlatitude\n: 30.0,\n                  \nlongitude\n: -20.0\n                },\n                \n$maxDistanceInMiles\n: 1.0\n              }\n            }\n          }\n        },\n        \ndata\n: {\n          \nalert\n: \nFree hotdogs at the bmob concession stand!\n\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\n上面的例子假设 installation 有个 user 属性指向_User 表的记录，并且用户有个 location 属性是 GeoPoint 类型，我们就可以根据地理信息位置做推送。\n\n\n点播推送消息\n\n\n发送给Android单个客户端\n\n\n  curl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nwhere\n:{\n            \ninstallationId\n:\n57234d4c-752f-4e78-81ad-a6d14048020d\n\n        },\n        \ndata\n: {\n          \nalert\n: \nHello From Bmob.\n\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\n发送给iOS单个客户端\n\n\n  curl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nwhere\n:{\n            \ndeviceToken\n:\nabcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789\n\n         },\n        \ndata\n: {\n          \naps\n:{\nalert\n:\ncashi\n,\nbadge\n:1,\nsound\n:\ndefault\n}\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\n发送给Windows Phone单个客户端Toast通知\n\n\n  curl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nwhere\n:{\n            \nnotificationUri\n:\nhttps://hk1.notify.live.net/unthrottledthirdparty/01.00/AQHgHh6EuwNtTa1TbwvaAjnmAgAAAAADEAAAAAQUZm52OkZDM0U5RDkxQzIzREJBNDYFBkFTRUEwMQ\n\n         },\n        \ndata\n: {\n          \nalert\n: \nHello From bmob\n,\n          \nwpAlert\n: \nbmob\n,\n          \nwp\n: 2\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\n发送选项设置\n\n\n推送通知不仅仅可以用来发送消息，iOS中，推送内容还可以包含要播放的声音和要显示的badge数字值,还可以定制任何你想发送的内容，对于Android，你甚至可以指定Intent应用于接收消息，对于时效有要求的消息你还可以设置一个消息过期时间。\n\n\n定制你的通知\n\n\n如果你想发送更多的消息，你可以在data的字典对象中设置其他字段，下面这些保留的字段有其特殊的意义：\n- \nalert\n : 通知的消息内容\n- \nbadge\n : (仅iOS)一个数字值将会高亮显示在应用图标的右上角。\n- \nsound\n : (仅iOS)应用绑定包中的声音\n- \ncontent-available\n : (仅iOS)如果你的应用是新闻类的，或者你的应用正在使用iOS7的Remote Notification Background Mode，设定这个值为1将会触发离线下载功能。\n- \naction\n : (仅Android)接收到推送消息时应用Intent，如果没有指定title或alert，Intent将被应用，但是没有通知呈现给用户。\n- \ntitle\n : (仅Android)这个值将显示在系统通知栏\n- \nwp\n : (仅Windows Phone)通知类型 0-Raw(默认) 1-Toast 2-磁贴\n- \nwpAlert\n : (仅Windows Phone)这个值将在Raw 和 Toast两种通知中有用，相对alert，作为子标题\n- \nbackgroundImage\n : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n- \ncount\n : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n- \nbackBackgroundImage\n : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n- \nbackTitle\n : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n- \nbackContent\n : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n\n\n例如，推送一条通知，将当前的badge值设置为一个数字值,并且播放iOS设备上定制的音乐，对于Android用户，将在系统通知栏中显示特殊的标题，其请求如下：\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nchannels\n: [\n          \nMets\n\n        ],\n        \ndata\n: {\n          \nalert\n: \nThe Mets scored! The game is now tied 1-1.\n,\n          \nbadge\n: 10,\n          \nsound\n: \ncheering.caf\n,\n          \ntitle\n: \nMets Score!\n\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\n当然，你也可以在data字典对象中定制自己的字段来推送消息，但推送到消息不显示在 Andoid 系统的通知栏中，而是执行应用程序预定义的逻辑，Android或iOS的接收消息文档中对此有说明，iOS只有当用户从通知中打开应用，才能访问data的数据，Android将提供这个数据在action Intent应用之后将提供这个数据,\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nchannels\n: [\n          \nIndians\n\n        ],\n        \ndata\n: {\n          \naction\n: \ncom.example.UPDATE_STATUS\n,\n          \nalert\n: \nRicky Vaughn was injured in last night's game!\n,\n          \nname\n: \nVaughn\n,\n          \nnewsItem\n: \nMan bites dog\n\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\n设置消息过期时间\n\n\n过期时间，可以是绝对时间：\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \nexpiration_time\n: \n2013-12-04 00:51:13\n,\n        \ndata\n: {\n          \nalert\n: \nSeason tickets on sale until December  4, 2013\n\n        }\n      }' \\\n  https://api.bmob.cn/1/push\n\n\n\n\n也可以是相对时间（根据push_time做定期推送，从push_time时间开始算起，直到expiration_interval时间后过期），下面的请求表示消息将在2012-01-28 00:51:13这个时间点开始推送，直到7天后过期:\n\n\ncurl -X POST \\\n  -H \nX-Bmob-Application-Id: Your Application ID\n          \\\n  -H \nX-Bmob-REST-API-Key: Your REST API Key\n        \\\n  -H \nContent-Type: application/json\n \\\n  -d '{\n        \npush_time\n: \n2012-01-28 00:51:13\n,\n        \nexpiration_interval\n: 518400,\n        \ndata\n: {\n          \nalert\n: \nSeason tickets on sale until December  4, 2013\n\n        }\n      }' \\\n  https://api.bmob.cn/1/push", 
            "title": "开发文档"
        }, 
        {
            "location": "/push/restful/#_1", 
            "text": "推送通知是让用户及时被通知、和你的应用保持联系的一种非常棒的方式，你可以快速而有效地通知到所有的用户，下面这个教程将会教你如何使用Bmob来推送消息。", 
            "title": "消息推送简介"
        }, 
        {
            "location": "/push/restful/#_2", 
            "text": "每一个Bmob的App被安装在用户的设备上后，如果要使用消息推送功能，Bmob SDK会自动生成一个Installation对象。Installation对象包含了推送所需要的所有信息。举例：一个棒球的App，你可以让用户订阅感兴趣的棒球队，然后及时将这个球队的消息推送给用户 。\n你可以使用 REST API，通过请求URL  /1/installations  对Installation对象进行一系列操作，就像你存储和获取其他的普通对象，如GameScore对象一样。\n注意Installation对象一般只在Client SDK中进行修改，但REST API对于大量导入或导出订阅数据的Installation对象是极其有用的。  Installation对象有几个系统默认的特殊字段来帮助你进行定位到设备等管理：\n-  badge  : iOS应用中右上角的图标标识，这不会在服务端进行自增，需要开发者自己实现自增统计\n-  channels  : 当前这个设备订阅的渠道名称数组\n-  timeZone  : 设备所在位置的时区， 如Asia/Shanghai，这个会在每个Installation对象更新时同步（只读）\n-  deviceType  : 设备的类型, 值为：\"ios\" 或 \"android\" (只读)\n-  installationId  : Bmob使用的设备唯一号，Android设备是必须的，iOS可选 (只读)\n-  deviceToken  : iOS设备由Apple APNS生成的唯一性token标识 (只读)\n-  notificationUri  : Windows Phone设备由Windows Push Center生成的唯一性token标识", 
            "title": "安装消息推送服务"
        }, 
        {
            "location": "/push/restful/#installation", 
            "text": "根据设备的不同往设备表中添加不同的值，body格式如下  {\n   deviceType : deviceType ( iOS , android ,  windows phone )\n   deviceToken : iOS需填\n   installationId :android需填\n   notificationUri :wp需填\n}  下面将针对具体平台分别举例。", 
            "title": "保存 installation"
        }, 
        {
            "location": "/push/restful/#iosdevicetoken", 
            "text": "iOS设备通常使用deviceToken来对一台设备进行惟一标识。  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         deviceType :  ios ,\n         deviceToken :  abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789 \n      }' \\\n  https://api.bmob.cn/1/installations", 
            "title": "保存iOS设备的deviceToken"
        }, 
        {
            "location": "/push/restful/#android-installationid", 
            "text": "对于Android设备， Bmob SDK会自动生成uuid作为installationId保存到 Bmob。 你可以使用以下REST API保存Android设备的installation ID。  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         deviceType :  android ,\n         installationId :  12345678-4312-1234-1234-1234567890ab \n      }' \\\n  https://api.bmob.cn/1/installations", 
            "title": "保存Android设备的 installationId"
        }, 
        {
            "location": "/push/restful/#windows-phone-notificationuri", 
            "text": "对于Windows Phone设备， Bmob SDK会自动从Windows Push Center获取到notificationUri并保存到 Bmob。 你可以使用以下REST API保存Windows Phone设备的notificationUri。  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         deviceType :  windows phone ,\n         notificationUri :  https://hk1.notify.live.net/unthrottledthirdparty/01.00/AQHgHh6EuwNtTa1TbwvaAjnmAgAAAAADEAAAAAQUZm52OkZDM0U5RDkxQzIzREJBNDYFBkFTRUEwMQ \n      }' \\\n  https://api.bmob.cn/1/installations", 
            "title": "保存Windows Phone设备的 notificationUri"
        }, 
        {
            "location": "/push/restful/#_3", 
            "text": "频道列的本质是一个数组，因此其操作与数组一致，具体可查看以下举例。", 
            "title": "订阅频道和退订"
        }, 
        {
            "location": "/push/restful/#_4", 
            "text": "覆盖已订阅的频道：  curl -X PUT \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         channels : [\n           Giants ,\n           Mets \n        ]\n      }' \\\n  https://api.bmob.cn/1/installations/mrmBZvsErB  订阅一个新频道，不覆盖已订阅的频道：  curl -X PUT \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{ channels :{ __op : AddUnique , objects :[ Giants ]}}' \\\n  https://api.bmob.cn/1/installations/mrmBZvsErB", 
            "title": "订阅频道"
        }, 
        {
            "location": "/push/restful/#_5", 
            "text": "curl -X PUT \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{ channels :{ __op : Remove , objects :[ Giants ， Mets ]}}' \\\n  https://api.bmob.cn/1/installations/mrmBZvsErB", 
            "title": "退订频道"
        }, 
        {
            "location": "/push/restful/#_6", 
            "text": "请求描述  使用推送接口可将消息推送至对应设备。  请求    url ： https://api.bmob.cn/1/push    method ：POST    header:    X-Bmob-Application-Id: Your Application ID\nX-Bmob-REST-API-Key: Your REST API Key\nContent-Type: application/json   body: 根据不同的需求进行定制，具体看以下介绍。", 
            "title": "推送消息"
        }, 
        {
            "location": "/push/restful/#_7", 
            "text": "curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         data : {\n           alert :  Hello From Bmob. \n        }\n      }' \\\n  https://api.bmob.cn/1/push", 
            "title": "广播推送消息"
        }, 
        {
            "location": "/push/restful/#_8", 
            "text": "发送给订阅了Giants频道的用户   curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         where :{\n           channels :[ Giants ]\n        },\n         data : {\n           alert :  Hello From Bmob. \n        }\n      }' \\\n  https://api.bmob.cn/1/push  或者更简便的方式  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         channels :[ Giants ],\n         data : {\n           alert :  Hello From Bmob. \n        }\n      }' \\\n  https://api.bmob.cn/1/push", 
            "title": "组播推送消息"
        }, 
        {
            "location": "/push/restful/#_9", 
            "text": "", 
            "title": "多播推送消息"
        }, 
        {
            "location": "/push/restful/#_10", 
            "text": "curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         where :{\n             updatedAt :{\n                 $lt :{ __type : Date , iso : 2012-01-29 11:33:53 }\n              }\n        },\n         data : {\n             alert :  Hello From Bmob. \n        }\n      }' \\\n  https://api.bmob.cn/1/push", 
            "title": "推送给不活跃的用户"
        }, 
        {
            "location": "/push/restful/#_11", 
            "text": "curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         where : {\n           scores : true\n        },\n         data : {\n           alert :  Willie Hayes injured by own pop fly. \n        }\n      }' \\\n  https://api.bmob.cn/1/push  请注意，where 条件查询的都是 installations 表。这里是假设 installations 表存储了 scores 的布尔属性，你可以像查询普通对象一样构造where查询", 
            "title": "根据查询条件做推送"
        }, 
        {
            "location": "/push/restful/#_12", 
            "text": "curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         where : {\n           deviceType :  android \n        },\n         data : {\n           alert :  Your suitcase has been filled with tiny robots! \n        }\n      }' \\\n  https://api.bmob.cn/1/push  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         where : {\n           deviceType :  ios \n        },\n         data : {\n           alert :  Your suitcase has been filled with tiny apples! \n        }\n      }' \\\n  https://api.bmob.cn/1/push  Windows Phone平台的推送分三种格式：  a.推送Raw通知( 默认 )：  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         where : {\n           deviceType :  windows phone \n        },\n         data : {\n            alert :  Your suitcase has been filled with tiny windows phone! ,\n            wpAlert :  TextBoxValue2 \n        }\n      }' \\\n  https://api.bmob.cn/1/push  b.推送Toast通知：  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         where : {\n           deviceType :  windows phone \n        },\n         data : {\n           alert :  Your suitcase has been filled with tiny apples! ,\n           wpAlert :  TextBoxSubTitle ,\n           wp : 2\n        }\n      }' \\\n  https://api.bmob.cn/1/push  c.推送磁贴通知：  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         where : {\n           deviceType :  windows phone \n        },\n         data : {\n           alert :  Your suitcase has been filled with tiny apples! ,\n           backgroundImage :  backgroundImage ,\n           count : 1 ,\n           backBackgroundImage :  backBackgroundImage ,\n           backTitle : backTitle ,\n           backContent : backContent ,\n           wp : 1\n        }\n      }' \\\n  https://api.bmob.cn/1/push", 
            "title": "根据平台做推送"
        }, 
        {
            "location": "/push/restful/#_13", 
            "text": "curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         where : {\n           user : {\n             $inQuery : {\n               location : {\n                 $nearSphere : {\n                   __type :  GeoPoint ,\n                   latitude : 30.0,\n                   longitude : -20.0\n                },\n                 $maxDistanceInMiles : 1.0\n              }\n            }\n          }\n        },\n         data : {\n           alert :  Free hotdogs at the bmob concession stand! \n        }\n      }' \\\n  https://api.bmob.cn/1/push  上面的例子假设 installation 有个 user 属性指向_User 表的记录，并且用户有个 location 属性是 GeoPoint 类型，我们就可以根据地理信息位置做推送。", 
            "title": "根据地理信息位置做推送"
        }, 
        {
            "location": "/push/restful/#_14", 
            "text": "发送给Android单个客户端    curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         where :{\n             installationId : 57234d4c-752f-4e78-81ad-a6d14048020d \n        },\n         data : {\n           alert :  Hello From Bmob. \n        }\n      }' \\\n  https://api.bmob.cn/1/push  发送给iOS单个客户端    curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         where :{\n             deviceToken : abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789 \n         },\n         data : {\n           aps :{ alert : cashi , badge :1, sound : default }\n        }\n      }' \\\n  https://api.bmob.cn/1/push  发送给Windows Phone单个客户端Toast通知    curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         where :{\n             notificationUri : https://hk1.notify.live.net/unthrottledthirdparty/01.00/AQHgHh6EuwNtTa1TbwvaAjnmAgAAAAADEAAAAAQUZm52OkZDM0U5RDkxQzIzREJBNDYFBkFTRUEwMQ \n         },\n         data : {\n           alert :  Hello From bmob ,\n           wpAlert :  bmob ,\n           wp : 2\n        }\n      }' \\\n  https://api.bmob.cn/1/push", 
            "title": "点播推送消息"
        }, 
        {
            "location": "/push/restful/#_15", 
            "text": "推送通知不仅仅可以用来发送消息，iOS中，推送内容还可以包含要播放的声音和要显示的badge数字值,还可以定制任何你想发送的内容，对于Android，你甚至可以指定Intent应用于接收消息，对于时效有要求的消息你还可以设置一个消息过期时间。", 
            "title": "发送选项设置"
        }, 
        {
            "location": "/push/restful/#_16", 
            "text": "如果你想发送更多的消息，你可以在data的字典对象中设置其他字段，下面这些保留的字段有其特殊的意义：\n-  alert  : 通知的消息内容\n-  badge  : (仅iOS)一个数字值将会高亮显示在应用图标的右上角。\n-  sound  : (仅iOS)应用绑定包中的声音\n-  content-available  : (仅iOS)如果你的应用是新闻类的，或者你的应用正在使用iOS7的Remote Notification Background Mode，设定这个值为1将会触发离线下载功能。\n-  action  : (仅Android)接收到推送消息时应用Intent，如果没有指定title或alert，Intent将被应用，但是没有通知呈现给用户。\n-  title  : (仅Android)这个值将显示在系统通知栏\n-  wp  : (仅Windows Phone)通知类型 0-Raw(默认) 1-Toast 2-磁贴\n-  wpAlert  : (仅Windows Phone)这个值将在Raw 和 Toast两种通知中有用，相对alert，作为子标题\n-  backgroundImage  : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n-  count  : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n-  backBackgroundImage  : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n-  backTitle  : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用\n-  backContent  : (仅Windows Phone)通知类型wp=2，磁贴类通知中有用  例如，推送一条通知，将当前的badge值设置为一个数字值,并且播放iOS设备上定制的音乐，对于Android用户，将在系统通知栏中显示特殊的标题，其请求如下：  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         channels : [\n           Mets \n        ],\n         data : {\n           alert :  The Mets scored! The game is now tied 1-1. ,\n           badge : 10,\n           sound :  cheering.caf ,\n           title :  Mets Score! \n        }\n      }' \\\n  https://api.bmob.cn/1/push  当然，你也可以在data字典对象中定制自己的字段来推送消息，但推送到消息不显示在 Andoid 系统的通知栏中，而是执行应用程序预定义的逻辑，Android或iOS的接收消息文档中对此有说明，iOS只有当用户从通知中打开应用，才能访问data的数据，Android将提供这个数据在action Intent应用之后将提供这个数据,  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID  \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key  \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         channels : [\n           Indians \n        ],\n         data : {\n           action :  com.example.UPDATE_STATUS ,\n           alert :  Ricky Vaughn was injured in last night's game! ,\n           name :  Vaughn ,\n           newsItem :  Man bites dog \n        }\n      }' \\\n  https://api.bmob.cn/1/push", 
            "title": "定制你的通知"
        }, 
        {
            "location": "/push/restful/#_17", 
            "text": "过期时间，可以是绝对时间：  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         expiration_time :  2013-12-04 00:51:13 ,\n         data : {\n           alert :  Season tickets on sale until December  4, 2013 \n        }\n      }' \\\n  https://api.bmob.cn/1/push  也可以是相对时间（根据push_time做定期推送，从push_time时间开始算起，直到expiration_interval时间后过期），下面的请求表示消息将在2012-01-28 00:51:13这个时间点开始推送，直到7天后过期:  curl -X POST \\\n  -H  X-Bmob-Application-Id: Your Application ID           \\\n  -H  X-Bmob-REST-API-Key: Your REST API Key         \\\n  -H  Content-Type: application/json  \\\n  -d '{\n         push_time :  2012-01-28 00:51:13 ,\n         expiration_interval : 518400,\n         data : {\n           alert :  Season tickets on sale until December  4, 2013 \n        }\n      }' \\\n  https://api.bmob.cn/1/push", 
            "title": "设置消息过期时间"
        }, 
        {
            "location": "/other/common_problem/", 
            "text": "平台常见问题\n\n\nQ: Bmob有哪些优势\n\nA: \n\n1.在很大程度上加快了用户产品的开发速度；对后端的支持让用户有更多的时间关注用户体验方面的设计。\n\n2.为用户节省了服务端人员的配备和服务器租借，节省了很多成本。\n\n3.在游戏方面，Bmob云端数据库保存玩家游戏数据，操作非常简单，用Api可以直接操作云端数据库。\n\n\n\n\nQ: Bmob有后台介绍视频吗\n\nA: \n\n感谢Bmob用户为我们的后台录制了视频。\n\n视频地址：\n使用 Bmob 搭建我们的第一个后端云 APP\n \n\n其它的基础视频：\n点击查看入门教程\n\n\n\n\nQ: Bmob支持多少用户同时在线存储查询\n\nA: 一个APP支持10w+读并发，5w+写并发\n\n\n\n\nQ: 服务器端运行在什么环境下\n\nA: 北京BGP c机房 \n\n\n\n\nQ: 你们的平台稳定吗\n\nA: Bmob采用南北双线，多路分流的方式，将服务器部署在国内外主流的大型服务器提供商中。部署时采用7层负载均衡技术，确保每个节点机房都能够承受大量的并发请求。而每个应用之间采用\nDocker\n容器虚拟化，确保应用之间的安全隔离性。自2013年7月创立至今，团队积累了大量的运维和服务经验，确保平台的稳定服务。 \n\n\n\n\nQ: 数据放在云端安全吗\n\nA: \n\n1.首先，数据在传输过程中采用了\nrequestId\n + \ntimestamp\n + \nApplication Key\n的一次性对称加密算法和服务端主动防御的技术，确保数据在传输过程中能够不被\nFiddler\n、\nWireshark\n等抓包工具恶意抓取进行分析破坏。\n\n2.应用之间除采用Docker虚拟化之外，系统还定期/实时做了3级容灾备份，确保数据的可用性。\n\n3.在软件架构层面，Bmob提供了应用层次、表层次、ACL、角色、IP白名单、签名等多种安全控制方式。如果你想更深入了解Bmob的安全架构，可以详细查看我们的\n数据安全文档\n。\n\n\n\n\nQ: Bmob支持国外数据访问吗\n\nA: 根据用户反馈，东南亚跟北美那边的访问速度还是可以的。欧洲那边的话，就我们的数据来看那边的访问量不是很高，但是可以访问。\n\n\n\n\nQ: 你们的SDK会不会有广告\n\nA: 没有，我们不做广告业务，SDK是非常纯净的，不会恶意嵌入广告的。\n\n\n\n\nQ: 你们支持什么平台\n\nA: \n\n1.Android、iOS和WP三种主流的移动操作系统平台\n\n2.Cocos2d-x和Unity两种主流的游戏引擎\n\n3.Js支持HTML5移动开发\n\n4.C#、php、Java支持PC端开发\n\n5.Restful开放API接口（可使用任何语言开发）\n\n\n\n\nQ: 不同SDK的数据是否打通\n\nA: 当然！本质上，所有的SDK都是基于Restful开发，数据是完全打通的。\n\n\n\n\nQ: 我想迁移数据到Bmob,但是user表如何迁移呢\n\nA: 调用restapi的注册接口来插入数据就行\n\n\n\n\nQ: Bmob怎么用做HTML5的数据管理后台\n\nA: 你可以用js sdk来开发对应的html5页面，开发好之后联系我们客服，我们帮你把h5页面放到你的bmob子域名中去，给用户访问。\n\n\n\n\nQ: 如何联系Bmob技术和商务\n\nA: \n\n技术客服QQ：\n2093289624\n\n商务QQ：\n2499654572\n\n商务合作邮件：partner@bmob.cn\n\n技术沙龙邮件：event@bmob.cn\n\n\n\n\nWeb开发者后台相关问题\n\n\nQ: 如何在Web后台上传文件\n\nA: \n\nBmob提供了一种非常简单的文件上传的方法：\n\n\n1.在Web后台中点击进入应用程序的控制面板中，如下图所示，选择需要用到文件的表，然后点击“添加一列”按钮，这时，弹出一个“添加新的表字段”的对话框。在这个对话框中，请输入字段名称，选择字段类型（\n注意：请选择File类型\n）。\n\n\n\n\n2.现在，你就可以快速上传文件了：点击“添加一行”按钮，在File字段中点击“Upload File”就可以直接上传文件。如下图所示。如果想要上传更多的文件，可以重复第二步操作。\n\n\n\n\n\n\nQ: 为什么导入CSV数据之后是乱码\n\nA: \n\n请先将导入的数据编码转换为“UTF-8无BOM格式编码”之后再上传（转换为UTF-8编码的一个简单方法是：用\nNotepad++\n打开要导入的CSV文件，然后点击“格式-\n以UTF-8无BOM格式编码”菜单）。\n\n\n\n\nQ: 为什么导出的CSV数据显示乱码\n\nA: \n\n导出的文件请以“UTF-8无BOM格式编码”格式打开查看(可使用\nNotepad++\n打开CSV文件，然后点击“格式-\n以UTF-8无BOM格式编码”菜单)，如果用excel直接打开可能出现中文乱码！\n\n\n\n\nQ: 能提供一个CSV文件参考下吗\n\nA: \n\n\n点击这里下载CSV文件模版\n\n\n使用方法：Web后台-\n创建应用-\n创建表-\n导入数据-\n选择这个CSV文件\n\n\n\n\nQ: 能直接在Web后台上传文件吗\n\nA: 可以，先在表中创建需要File类型的字段，然后新增一条记录就可以直接在Web端上传文件了。\n\n\n\n\nQ: 我如何修改Bmob上的表名及列名\n\nA: 不能修改，考虑发布后的APP会由于修改表名和列名而造成无法使用的问题。开发过程中可以通过删除再创建达到目的。\n\n\n\n\nQ: 导出数据表中的数据时可以自定义字段吗\n\nA: 可以的。开发者后台-\n数据浏览-\n更多-\n导出数据，可以选择导出需要的列。\n\n\n\n\n\n\nQ: 能通过在控制台添加Relation的数据吗\n\nA: 可以，你可以点击relation字段，进去之后添加数据\n\n\n\n\nQ: 如何获取_User表中的password\n\nA: Bmob没有提供直接获取密码的方法。如果直接可以获取密码的话，会存在安全隐患的。如果非要这样做，你可以新增一个字段，记录明文的密码。\n\n\n\n\nQ: Bmob中支持的String最大容量是多少\n\nA: 4M\n\n\n\n\nQ: 能不能设置主键\n\nA: 可以，存在重复值会留下最早创建的记录，其它的删除。\n\n\n\n\n\n\nQ: 创建了数据库，可以在后台直接添加数据吗\n\nA: 可以\n\n\n\n\nQ: 我想在eclipse用Java web开发，使用struts2框架，然后后台数据库用bmob可以实现吗，需要下载什么东西\n\nA: 可以使用java sdk或者自己封装，通过https调用restful接口\n\n\n\n\nQ: web端上传文件最大支持多少\n\nA: 控制台上传的文件最大为50M\n\n\n\n\nQ: 新建一张表添加字段为Relation，只能重新添加数据吗\n\nA: Web操作是这样的，但你可以用SDK，通过代码来实现数据的关联。\n\n\n\n\nQ: 后台能不能支持批量上传文件？\n\nA: 不支持，可以自己编写脚本完成。\n\n\n\n\nQ: http请求如何访问bomb\n\nA: 可以使用restful接口进行访问。\n\n\n\n\nQ: ie8下引用 bmob-min.js 出现 “缺少标识符、字符串或数字” 错误\n\nA: ie8不支持html5\n\n\n\n\nQ: angularJS如何与bmob配合使用\n\nA: 可以使用我们的JS SDK或者是使用angularJS的网络请求使用restful接口进行请求\n\n\n\n\nQ: 登录问题 能否实现只有通过验证的用户才能登\n\nA: 登陆成功之后，你再获取当前的登陆信息，判断这个verified字段是否为true，这样就可以实现你的想法了。\n\n\n\n\nQ: Bmob可以做微信公众平台的数据后台么\n\nA: 可以\n\n\n\n\nQ: 数据导出不带objectid 字段吗\n\nA: 这个问题我们持续跟进，因为我们无法保证objectId不被用户修改，所以大家开发的时候就没有支持导出objectId了，之后看看怎么解决这个问题。\n\n\n\n\nQ: 请问服务器上的表名和列名可以修改吗？\n\nA: 不能修改，考虑发布后的APP会由于修改表名和列名而造成无法使用的问题。\n开发过程中可以通过删除再创建达到目的的。\n\n\n\n\nQ: 可以在PC端写tool来操作服务器数据?\n\nA: 可以，使用restful接口\n\n\n\n\nQ: API请求数是实时统计更新的吗？\n\nA: 不是的，API请求数一天统计一次，每天凌晨3点进行统计。\n\n\nAPP官网相关问题\n\n\nQ: APP官网的一些案例\n\nA:\n\n\nhttp://bikenavi.bmob.site/\n\n\nhttp://drive.bmob.site/\n\n\nhttp://qlslylq.bmob.site/\n\n\n\n\nQ: 不使用SDK也可以创建APP官网吗\n\nA: 是的。APP官网是我们为开发者提供的扩展服务，与SDK、云数据库、文件服务等其他业务没有任何联系，完全是耦合的关系。\n使用APP官网的流程如下：注册进入官网-\n创建应用-\n点击“应用官网”-\n输入你想要的域名-\n选择模版-\n编辑保存。\n\n\n\n\nQ: 官网修改后怎么没有立即生效\n\nA: 我们采用生成静态文件的方式，生成和同步到泛域名服务器需要30秒的时间，请耐心等待。\n\n\n\n\nQ: 能使用其他域名吗\n\nA: 可以。但需要提交一些材料给我们（具体材料需要先联系我们的客服QQ），提交到工信部进行备案。\n\n\n\n\nQ: 怎么知道我的域名是否备案\n\nA: 登录网站 \nhttp://www.miitbeian.gov.cn/publish/query/indexFirst.action \n 按操作查询即可", 
            "title": "平台常见问题"
        }, 
        {
            "location": "/other/common_problem/#_1", 
            "text": "Q: Bmob有哪些优势 \nA:  \n1.在很大程度上加快了用户产品的开发速度；对后端的支持让用户有更多的时间关注用户体验方面的设计。 \n2.为用户节省了服务端人员的配备和服务器租借，节省了很多成本。 \n3.在游戏方面，Bmob云端数据库保存玩家游戏数据，操作非常简单，用Api可以直接操作云端数据库。   Q: Bmob有后台介绍视频吗 \nA:  \n感谢Bmob用户为我们的后台录制了视频。 \n视频地址： 使用 Bmob 搭建我们的第一个后端云 APP   \n其它的基础视频： 点击查看入门教程   Q: Bmob支持多少用户同时在线存储查询 \nA: 一个APP支持10w+读并发，5w+写并发   Q: 服务器端运行在什么环境下 \nA: 北京BGP c机房    Q: 你们的平台稳定吗 \nA: Bmob采用南北双线，多路分流的方式，将服务器部署在国内外主流的大型服务器提供商中。部署时采用7层负载均衡技术，确保每个节点机房都能够承受大量的并发请求。而每个应用之间采用 Docker 容器虚拟化，确保应用之间的安全隔离性。自2013年7月创立至今，团队积累了大量的运维和服务经验，确保平台的稳定服务。    Q: 数据放在云端安全吗 \nA:  \n1.首先，数据在传输过程中采用了 requestId  +  timestamp  +  Application Key 的一次性对称加密算法和服务端主动防御的技术，确保数据在传输过程中能够不被 Fiddler 、 Wireshark 等抓包工具恶意抓取进行分析破坏。 \n2.应用之间除采用Docker虚拟化之外，系统还定期/实时做了3级容灾备份，确保数据的可用性。 \n3.在软件架构层面，Bmob提供了应用层次、表层次、ACL、角色、IP白名单、签名等多种安全控制方式。如果你想更深入了解Bmob的安全架构，可以详细查看我们的 数据安全文档 。   Q: Bmob支持国外数据访问吗 \nA: 根据用户反馈，东南亚跟北美那边的访问速度还是可以的。欧洲那边的话，就我们的数据来看那边的访问量不是很高，但是可以访问。   Q: 你们的SDK会不会有广告 \nA: 没有，我们不做广告业务，SDK是非常纯净的，不会恶意嵌入广告的。   Q: 你们支持什么平台 \nA:  \n1.Android、iOS和WP三种主流的移动操作系统平台 \n2.Cocos2d-x和Unity两种主流的游戏引擎 \n3.Js支持HTML5移动开发 \n4.C#、php、Java支持PC端开发 \n5.Restful开放API接口（可使用任何语言开发）   Q: 不同SDK的数据是否打通 \nA: 当然！本质上，所有的SDK都是基于Restful开发，数据是完全打通的。   Q: 我想迁移数据到Bmob,但是user表如何迁移呢 \nA: 调用restapi的注册接口来插入数据就行   Q: Bmob怎么用做HTML5的数据管理后台 \nA: 你可以用js sdk来开发对应的html5页面，开发好之后联系我们客服，我们帮你把h5页面放到你的bmob子域名中去，给用户访问。   Q: 如何联系Bmob技术和商务 \nA:  \n技术客服QQ： 2093289624 \n商务QQ： 2499654572 \n商务合作邮件：partner@bmob.cn \n技术沙龙邮件：event@bmob.cn", 
            "title": "平台常见问题"
        }, 
        {
            "location": "/other/common_problem/#web", 
            "text": "Q: 如何在Web后台上传文件 \nA:  \nBmob提供了一种非常简单的文件上传的方法：  1.在Web后台中点击进入应用程序的控制面板中，如下图所示，选择需要用到文件的表，然后点击“添加一列”按钮，这时，弹出一个“添加新的表字段”的对话框。在这个对话框中，请输入字段名称，选择字段类型（ 注意：请选择File类型 ）。   2.现在，你就可以快速上传文件了：点击“添加一行”按钮，在File字段中点击“Upload File”就可以直接上传文件。如下图所示。如果想要上传更多的文件，可以重复第二步操作。    Q: 为什么导入CSV数据之后是乱码 \nA:  \n请先将导入的数据编码转换为“UTF-8无BOM格式编码”之后再上传（转换为UTF-8编码的一个简单方法是：用 Notepad++ 打开要导入的CSV文件，然后点击“格式- 以UTF-8无BOM格式编码”菜单）。   Q: 为什么导出的CSV数据显示乱码 \nA:  \n导出的文件请以“UTF-8无BOM格式编码”格式打开查看(可使用 Notepad++ 打开CSV文件，然后点击“格式- 以UTF-8无BOM格式编码”菜单)，如果用excel直接打开可能出现中文乱码！   Q: 能提供一个CSV文件参考下吗 \nA:   点击这里下载CSV文件模版  使用方法：Web后台- 创建应用- 创建表- 导入数据- 选择这个CSV文件   Q: 能直接在Web后台上传文件吗 \nA: 可以，先在表中创建需要File类型的字段，然后新增一条记录就可以直接在Web端上传文件了。   Q: 我如何修改Bmob上的表名及列名 \nA: 不能修改，考虑发布后的APP会由于修改表名和列名而造成无法使用的问题。开发过程中可以通过删除再创建达到目的。   Q: 导出数据表中的数据时可以自定义字段吗 \nA: 可以的。开发者后台- 数据浏览- 更多- 导出数据，可以选择导出需要的列。    Q: 能通过在控制台添加Relation的数据吗 \nA: 可以，你可以点击relation字段，进去之后添加数据   Q: 如何获取_User表中的password \nA: Bmob没有提供直接获取密码的方法。如果直接可以获取密码的话，会存在安全隐患的。如果非要这样做，你可以新增一个字段，记录明文的密码。   Q: Bmob中支持的String最大容量是多少 \nA: 4M   Q: 能不能设置主键 \nA: 可以，存在重复值会留下最早创建的记录，其它的删除。    Q: 创建了数据库，可以在后台直接添加数据吗 \nA: 可以   Q: 我想在eclipse用Java web开发，使用struts2框架，然后后台数据库用bmob可以实现吗，需要下载什么东西 \nA: 可以使用java sdk或者自己封装，通过https调用restful接口   Q: web端上传文件最大支持多少 \nA: 控制台上传的文件最大为50M   Q: 新建一张表添加字段为Relation，只能重新添加数据吗 \nA: Web操作是这样的，但你可以用SDK，通过代码来实现数据的关联。   Q: 后台能不能支持批量上传文件？ \nA: 不支持，可以自己编写脚本完成。   Q: http请求如何访问bomb \nA: 可以使用restful接口进行访问。   Q: ie8下引用 bmob-min.js 出现 “缺少标识符、字符串或数字” 错误 \nA: ie8不支持html5   Q: angularJS如何与bmob配合使用 \nA: 可以使用我们的JS SDK或者是使用angularJS的网络请求使用restful接口进行请求   Q: 登录问题 能否实现只有通过验证的用户才能登 \nA: 登陆成功之后，你再获取当前的登陆信息，判断这个verified字段是否为true，这样就可以实现你的想法了。   Q: Bmob可以做微信公众平台的数据后台么 \nA: 可以   Q: 数据导出不带objectid 字段吗 \nA: 这个问题我们持续跟进，因为我们无法保证objectId不被用户修改，所以大家开发的时候就没有支持导出objectId了，之后看看怎么解决这个问题。   Q: 请问服务器上的表名和列名可以修改吗？ \nA: 不能修改，考虑发布后的APP会由于修改表名和列名而造成无法使用的问题。\n开发过程中可以通过删除再创建达到目的的。   Q: 可以在PC端写tool来操作服务器数据? \nA: 可以，使用restful接口   Q: API请求数是实时统计更新的吗？ \nA: 不是的，API请求数一天统计一次，每天凌晨3点进行统计。", 
            "title": "Web开发者后台相关问题"
        }, 
        {
            "location": "/other/common_problem/#app", 
            "text": "Q: APP官网的一些案例 \nA:  http://bikenavi.bmob.site/  http://drive.bmob.site/  http://qlslylq.bmob.site/   Q: 不使用SDK也可以创建APP官网吗 \nA: 是的。APP官网是我们为开发者提供的扩展服务，与SDK、云数据库、文件服务等其他业务没有任何联系，完全是耦合的关系。\n使用APP官网的流程如下：注册进入官网- 创建应用- 点击“应用官网”- 输入你想要的域名- 选择模版- 编辑保存。   Q: 官网修改后怎么没有立即生效 \nA: 我们采用生成静态文件的方式，生成和同步到泛域名服务器需要30秒的时间，请耐心等待。   Q: 能使用其他域名吗 \nA: 可以。但需要提交一些材料给我们（具体材料需要先联系我们的客服QQ），提交到工信部进行备案。   Q: 怎么知道我的域名是否备案 \nA: 登录网站  http://www.miitbeian.gov.cn/publish/query/indexFirst.action   按操作查询即可", 
            "title": "APP官网相关问题"
        }, 
        {
            "location": "/other/common_problem/data/", 
            "text": "数据服务常见问题\n\n\nQ: Bmob怎么设计赞和踩功能？\n\nA: 利用原子计数器\n\n很多应用可能会有计数器功能的需求，比如文章点赞的功能，如果大量用户并发操作，用普通的更新方法操作的话，会存在数据不一致的情况。\n详情请查看对应平台的原子计数器章节。\n\n\n\n\nQ: 支持同步数据上传吗\n\nA: 不支持阻塞主线程同步上传数据的方法！\n\n\n\n\nQ: SDK请求时占用内存大吗\n\nA: 如果只是数据服务的话，占用内存非常小。如果涉及图片服务，需要视图片大小而定内存占用情况。\n\n\n\n\nQ: 文件能不能使用批量操作\n\nA: 当然可以。\n\n\n\n\nQ: 查询单条数据的时候，只能通过objectId来查询么？ \n\nA: 如果确定是只有一个的，条件查询也可以。\n\n\n\n\nQ: 注册和登录的流程是怎样开发的\n\nA: 注册成功之后，服务器会返回\nsessionToken\n（标识用户登录成功的会话信息）给\nBmobUser\n对象，这时即可立即显示登录后台的界面，同步在后台调用登录接口进行登录操作。\n\n\n\n\nQ: 登录踢人、改密码踢人相关\n\nA: 一处登录其他地方下线以及改密码的问题请看如下伪代码：\n\n\n\n\n\n\nQ: Bmob数据库的pointer和我自己使用外建字段的区别？\n\nA: pointer的好处是可以在查询的时候一并把关联的记录也查询下来，不需要二次查询。让查询的速度更快", 
            "title": "数据服务"
        }, 
        {
            "location": "/other/common_problem/data/#_1", 
            "text": "Q: Bmob怎么设计赞和踩功能？ \nA: 利用原子计数器 \n很多应用可能会有计数器功能的需求，比如文章点赞的功能，如果大量用户并发操作，用普通的更新方法操作的话，会存在数据不一致的情况。\n详情请查看对应平台的原子计数器章节。   Q: 支持同步数据上传吗 \nA: 不支持阻塞主线程同步上传数据的方法！   Q: SDK请求时占用内存大吗 \nA: 如果只是数据服务的话，占用内存非常小。如果涉及图片服务，需要视图片大小而定内存占用情况。   Q: 文件能不能使用批量操作 \nA: 当然可以。   Q: 查询单条数据的时候，只能通过objectId来查询么？  \nA: 如果确定是只有一个的，条件查询也可以。   Q: 注册和登录的流程是怎样开发的 \nA: 注册成功之后，服务器会返回 sessionToken （标识用户登录成功的会话信息）给 BmobUser 对象，这时即可立即显示登录后台的界面，同步在后台调用登录接口进行登录操作。   Q: 登录踢人、改密码踢人相关 \nA: 一处登录其他地方下线以及改密码的问题请看如下伪代码：    Q: Bmob数据库的pointer和我自己使用外建字段的区别？ \nA: pointer的好处是可以在查询的时候一并把关联的记录也查询下来，不需要二次查询。让查询的速度更快", 
            "title": "数据服务常见问题"
        }, 
        {
            "location": "/other/common_problem/data_android/", 
            "text": "对象\n\n\nQ: 为什么我修改表中的某个Number类型的字段，其他Number类型的都变为0呢？\n\nA: 继承自BmobObject的类不要用int类型，用Integer。\n\n\n\n\nQ: 定义类名必须和表中的名一致？\n\nA: 类名和表名一致，表内字段名和类变量名一致。\n\n\n\n\nQ: 插入一条数据之后怎么获得该数据的id \n\nA: \n\n\nGameScore gameScore = new GameScore();\n//注意：不能调用gameScore.setObjectId(\n)方法\ngameScore.setPlayerName(\n比目\n);\ngameScore.setScore(89);\ngameScore.setIsPay(false);\ngameScore.save(mContext, new SaveListener() {\n\n@Override\npublic void onSuccess() {\n    toast(\n添加数据成功，返回objectId为：\n+gameScore.getObjectId() + ”,数据在服务端的创建时间为：“ + gameScore.getCreatedAt());\n}\n\n@Override\npublic void onFailure(int code, String arg0) {\n    // 添加失败\n}\n});\n\n\n\n\n请看代码，成功后gameScore使用getObjectId()就可以获取objectId了。\n\n\n\n\nQ: success方法中获取的数据，用全局变量接收，但是在方法外就接受不到，变量为空\n\nA: 请先理解同步和异步的概念，回调中的onsuccess是异步方法，是不能用全局变量接收的，可以直接在onsuccess方法中做ui层面的更新\n\n\n\n\nQ: 缓存路径能指定吗？\n\nA: 不可以\n\n\n\n\nQ: 我在User表中增加了一个Number类型的字段，设置为以1自增，但几天过去了，里面的值并未自动增加，这个自增是怎样自增的，还要去哪里设置吗？\n\nA: 添加字段的时候选择num类型，有一个自增的checkbox和初始值的input，填一下就可以了\n\n\n\n\nQ: 场景是多个客户端共同操作同一个数据表，更新该表的一个字段的值，如何做到一个客户端更新时锁定该数据表，操作结束时解锁？\n\nA: 目前没有该功能，只有Number类型可以使用原子计算器达到该效果\n\n\n\n\nQ: 一次查询多条数据 算是调用了几次API？\n\nA: 一次调用算一次\n\n\n\n\nQ: 请问每条数据的objectId都是唯一的吗，我的意思是，假设有个user表，有userName和level两个属性。如果两个对象的这两个属性都相同，其objectId是否就相同？\n \nA: objectId是每一条数据的唯一标示，不会出现重复的。\n\n\n\n\nQ: String 数据类型最大可支持多大数据？\n\nA: 最大为16M\n\n\n\n\nQ: 求问怎么获取上传数据后生成的objectid \n\nA: 保存数据成功后，你的BmobObject对象就有objectId了的。\n或者你按条件查询得到的数据对象中也是包含objectId的。\n\n\n\n\nQ: 数据查询必须要objectId吗？在用户数据表中，在无法获取用户objectId的情况下，如何查询一个用户是否存在，是否可以通过其他字段查询？\n\nA: 单条查询必须使用ObjectId，多条查询时可以添加条件来进行查询。\n\n\n\n\n查询\n\n\nQ: 查询成功，但是list只能在onSuccess方法中使用,如何在本类中的其他地方使用？\n\nA: 网路请求都是异步独立线程的，你用\nhandler\n把数据传递出来就可以。\n\n\n\n\nQ: 如果不知道objectId，是否可以通过表中的元素获得数据？\n\nA：添加数据的时候，\nonSuccess\n中可以得到objectId。也可以通过条件查询得到对应的objectId的。\n\n\n\n\nQ: 在Activity关闭的时候如何动态关闭查询？\n\nA: 查询都是一次性的，并不需要取消\n\n\n\n\nQ: bmob怎么查询一列数据并合并相同数据？\n\nA: 可以使用统计查询中的groupby\n\n\n\n\nQ: bmob的数据库操作方法save insert这些都有开线程吗 \n\nA: bmob sdk提供的操作都是在线程中运行的，对外都是提供异步的回调方法，其回调方法，比如onsuccess和onFailure等是可以再UI线程中运行的，开发者不需要额外再开线程。\n\n\n\n\nQ: Bmob查询数据结束标志\n\nA: 在查询的回调方法中的onSuccess或onFailure触发时都是代表这个查询结束。\n\n\n\n\nQ: Bmob能否进行多表查询？\n\nA: 无法用一条语句查多张表，只能单独一个一个查\n\n\n\n\nQ: 怎么设置缓存 让缓存数据在listView显示\n\nA: 可以使用缓存查询，具体可以查看官方文档\n\n\n\n\nQ: 怎么通过BmobUser的一个属性列来获取其他列的信息\n\nA: 使用bmob的查询功能，查询Username 等于名称的用户信息即可，使用的是addWhereEqualTo方法\n\n\n\n\nQ: 我的应用想只查询最新上传的一组数据，请问该如何操作呢\n\nA: 可以根据时间来设置条件，再进行查询\n\n\n\n\nQ: 查询中findListener中的onerror方法不执行,两次测试均是数据库无该数据的，但是程序均不执行onerror方法\n\nA: 没有数据不代表查询出错，当没有数据符合你的查询条件时，就会返回空，此时还是执行onSuccess的\n\n\n\n\nQ: 想问问查询的时候排序有多个关键字怎么解决？\n\nA: 数据服务的文档中有的，在开发文档的查询数据-\n查询条件-\n排序那里：\n\n\n排序\n\n\n对应数据的排序，如数字或字符串，你可以使用升序或降序的方式来控制查询数据的结果顺序：\n\n\n// 根据score字段升序显示数据\nquery.order(\"score\");\n// 根据score字段降序显示数据\nquery.order(\"-score\");\n// 多个排序字段可以用（，）号分隔\nquery.order(\"-score,createdAt\");\n说明：多个字段排序时，先按第一个字段进行排序，再按第二个字段进行排序，依次进行。\n\n\n\n\n数据关联\n\n\nQ: 我有个Relation字段，想用它来记录喜欢这篇文章的用户，我该怎么添加里面的数据呢？\n\nA: 这个问题请看 \n数据关联\n 相关文档。\n\n\n\n\nQ: Relation字段 能否像pointer一样在查询的时候一并把关联的记录也查询下来，不需要二次查询\n\nA: 目前并没有这个功能，建议使用pointer\n\n\n\n\nQ: activity是一个表，里面有一个BmobPointer org指向BmobUser，activity.getOrg.getObjectId总是为空呢？\n\nA: 查询的时候应该没有用includ查询进去\n\n\n\n\nQ: 查询数据时，表中的一个字段是pointer字段，如何将这个pointer字段的一个属性作为查询匹配条件？\n\nA: \n\n\nBmobQuery\nComment\n query = new BmobQuery\nComment\n();\nBmobQuery\nPost\n innerQuery = new BmobQuery\nPost\n();\ninnerQuery.addWhereExists(\nimage\n, true);\n// 第一个参数为评论表中的帖子字段名post\n// 第二个参数为Post字段的表名，也可以直接用\nPost\n字符串的形式\n// 第三个参数为内部查询条件\nquery.addWhereMatchesQuery(\npost\n, \nPost\n, innerQuery);\nquery.findObjects(this, new FindListener\nComment\n() {\n@Override\npublic void onSuccess(List\nComment\n object) {\n    // TODO Auto-generated method stub\n    toast(\n查询成功:\n);\n}\n@Override\npublic void onError(int code, String msg) {\n    // TODO Auto-generated method stub\n    toast(\n查询失败:\n+msg);\n}\n});\n\n\n\n\n如上，就是使用内部查询就可以实现你的需求了，只需要将查询条件和表名换成你需要的就可以了～\n\n\n\n\nQ: 如果一个用户要收藏一个产品应该怎么定义对象\n\nA: 可以使用pointer类型\n\n\n\n\nQ: 删除关联关系\n\n我现在有评论类如下：\n\n\npublic class Comment extends BmobObject {\nprivate String comment;\nprivate Found found;\nprivate Lost lost;\nprivate MyUser user;\n}\n\n\n\n\n如果我想删除Lost类或者Found类的某条数据\n\n其对应的Comment会被同时删除吗？\n\n如果不能应该怎么实现同时删除？\n\nA: 不能同时删除，对于不同数据表的数据只能分别执行删除操作。\n\n\n\n\nQ: 查询时 include 两个Pointer字段后会把前一个的数据冲掉\n对表 AaaaEntity 查询时 include 两个Pointer字段后会把前一个的数据冲掉,如:\n\n\nbmobQuery.include(\nuserAuthor\n);\nbmobQuery.include(\nxxxxEntity\n);\n\n则:\naaaaEntity.getUserAuthor.getName()返回空\n\n如果去掉后一行\nbmobQuery.include(\nuserAuthor\n);\n//bmobQuery.include(\nxxxxEntity\n);\n或\n移到后面：\nbmobQuery.include(\nxxxxEntity\n);\nbmobQuery.include(\nuserAuthor\n);\n\naaaaEntity.getUserAuthor.getName() 就能正常返回值\n\n\n\n\nA: include的用法在文档里面已经说明了的(http://docs.bmob.cn/android/de ... clude用法),想include多个就这样用：query.include(\"x1,x2\");\n\n\n\n\n用户管理\n\n\nQ: 打开了邮箱验证功能，注册成功后未验证也能登录成功？\n\nA: Bmob SDK中，邮箱的验证和用户的注册登录是异步的关系，也就是说，即使用户没有点击邮箱验证功能，也是一样可以登录成功的。如果需要限制用户的登录或者只能查看到登录后的部分功能，可以使用\nBmobUser.getEmailVerified\n。\n\n\n\n\nQ: Bmob如何实现用户登录之后获取数据读写权限，以及如何实现登出操作的？\n\nA: 用户登录之后，我们会把获取到的用户信息保存在本地文件中，你可以通过\nBmobUser.getCurrentUser\n方法获取对应的值，当调用 \nlogout\n方法之后，这些缓存的数据就会清除。如果不调用\nlogout\n方法，下次重新打开这个应用，还是可以通过\nBmobUser.getCurrentUser\n方法获得上次登陆的用户信息，从而判断是否登陆过。\n\n\n\n\nQ: BmobUser.logOut(getApplicationContext()); //清除缓存用户对象\n这个只是针对本地缓存，看了源码，只是对本地清除，没有真正向服务端注销登录的账号，请问是怎么去处理这个问题\n\nA: BmobSDK中的BmobUser登录，只是登录成功后缓存用户信息到本地。服务端并没有记录用户的登录状态，所以退出登录并不需要向服务器注销。\n\n\n\n\nQ: Bmob支持第三方登录吗？怎么做？\n\nA: 支持，官方的文档上有介绍。\n\n\n\n\nQ: 为什么邮箱验证还没去验证却可以登录\n\nA: 是可以的，邮箱验证那个字段需要开发者根据需求自行决定要不要使用\n\n\n\n\nQ: 登录时异常退出MyUser declares multiple JSON fields named mobilePhoneNumber\n\nA: MyUser定义了一个Bmob的系统字段呀，你可以看看用户管理那里的文档，里面有介绍说明BmobUser的特有属性，以下摘抄自文档：\n\n\nBmobUser除了从BmobObject继承的属性外，还有几个特定的属性：\n\nusername: 用户的用户名（必需）。\n\npassword: 用户的密码（必需）。\n\nemail: 用户的电子邮件地址（可选）。\n\nemailVerified:邮箱认证状态（可选）。\n\nmobilePhoneNumber：手机号码（可选）。\n\nmobilePhoneNumberVerified：手机号码的认证状态（可选）。\n\n\n\n\nQ: 第三方登录之后该怎么获得User的objectId呢？\n\nA: 登陆成功之后，系统就会给你生成一个objectId的，你正常的通过 user.getObjectId() 就可以得到了\n\n\n\n\nQ: 如何修改user表中其他用户的数据\n\nA: 直接在web控制台修改或者使用masterkey\n\n\n\n\nQ: 修改数据提示User cannot be altered without sessionToken Error.\n\nA: 这种情况一般都是没有进行用户登录就对用户信息进行更新导致的\n\n\n\n\nQ: 更新用户update时失败，9012错误\n\nA: 9012是context is null,没传上下文对象\n\n\n\n\nQ: 用了getobjectId方法为什么还是显示objectId cant't be empty。\n\n\npublic void setsj(View v){\nfinal User setUser = new User();\nList\nString\n a=new ArrayList\nString\n();\na.add(\n5cd431f659\n);\na.add(\n4c2184e8ea\n);\nsetUser.setFriends(a);\nsetUser.update(this, setUser.getObjectId(), new UpdateListener() {\n\n    @Override\n    public void onSuccess() {\n        // TODO Auto-generated method stub\n        Log.i(\nbmob\n, \n更新成功：\n);\n        toast(\n更新成功\n);\n    }\n\n    @Override\n    public void onFailure(int code, String msg) {\n        // TODO Auto-generated method stub\n        Log.i(\nbmob\n,\n更新失败：\n+msg);\n        toast(\n更新失败\n);\n    }\n});\n}\n\n\n\n\n\n这段代码是通过点击一个button然后更新我写好的数据，可一直显示更新失败，查看logcat显示objectId cant't be empty。可是我有用setUser.getObjectId()啊，为什么还是说ID为空？\n\nA: 你的user并不是通过登录得到的，而是自己生成的，并没有objectid，需要从服务器上获取的数据才有objectid\n\n\n\n\nQ: 更新了用户信息后 服务器都更新了数据 但是本地缓存用户没有更新\n\nA: 更新用户信息后需要从新登陆，本地用户信息才会更新。\n\n\n\n\nQ: 登录后在个人资料中上传头像在用户表，并且要头像和用户要对应。\n\nA: 上传图片成功后，将BmobFile对象更新到当前用户的头像字段中即可。\n\n\n\n\nQ: 在数据下_User 下把email添加后为啥 emailVerified Boolean 这一栏显示的是false 是什么原因呢\n\nA: 该字段需要注册用户点击了验证邮件才会主动设置为true\n\n\n\n\n数据实时功能\n\n\nQ: 如何实现Bmob服务端向Android应用发送实时通知？如某个数据过高需要提醒APP用户\n\nA: 以使用实时数据监听功能来实现\n\n\n\n\nQ: 登录之后，怎么获取用户的信息并显示出来\n\nA: 登录成功之后就可以通过getCurrentUser方法获取本地用户信息\n\n\n\n\nACL和角色\n\n\nQ: 例如我已经有一个角色叫Chief，我怎么用代码给它添加成员？直接new BmobRole(\"Chief\")然后再getUsers().add然后再save?\n但这个代码不应该是新建一个角色吗？\n如果是用BmobQuery\n获取的话获取失败，返回101错误\n\nA:\n\n\n//创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\nBmobRole hr = new BmobRole(\nHR\n);\nBmobRole cashier = new BmobRole(\nCashier\n);\n\n//将hr_zhang和hr_luo归属到hr角色中\nhr.getUsers().add(hr_zhang);\nhr.getUsers().add(hr_luo);\n//保存到云端角色表中（web端可以查看Role表）\nhr.save(this); \n\n//将cashier_xie归属到cashier角色中\ncashier.getUsers().add(cashier_xie);\n//保存到云端角色表中（web端可以查看Role表）\ncashier.save(this);\n\n\n\n\n\n\nQ: 是否可以针一行数据的某一个字段控制读写权限 ？\n\n是否可以针一行数据的某一个字段控制读写权限 ？例如，UserA 发了一条说说，这条说说只有UserA可以写，其它用户可以读，但是其中有一个点赞计数字段，所有用户都可以对这条说说点赞，点赞后，这个点赞计数字段值就加1。\n\nA: 没有针对一个字段控制读写的，如果需要，可以将这些需要控制的另外建一个表，使用pointer字段指向该表来获取\n\n\n\n\n地理位置\n\n\nQ: 基于地理位置的查询是根据什么排序的\n\nA: 是按照距离从近到远来进行排序的\n\n\n\n\n自动更新\n\n\nQ: 自动更新生成的表和文档上的不一致\n\nA: 没有调用initAppversion方法\n\n\n\n\nQ: 自动更新，如何实现只获取是否有新版本，不弹出对话框。\n\nA: 目前SDK中暂没有这个功能，后续版本会考虑添加\n\n\n\n\n文件\n\n\nQ: Bmob如何实现储存和传输图片？\n\nA: 通过\nBmobFile\n类上传图片，上传成功之后，会返回一个\nBmobFile\n，你从这个\nBmobFile\n可以得到文件上传之后的url，把这个url保存到你的对应表中。下载的时候，先查询数据表得到url，然后下载这个图片就可以了。 \n\n\n\n\nQ: Bmob如何将整批图片下载在本地呢？\n\nA: 首先先查询，得到全部数据，从而得到图片的url列表，再用一些下载文件的代码把图片批量下载下来。\n\n\n\n\nQ: BmobFile类最多可以保存多少张图片？\n\nA: \nBmobFile\n类只能保存一张图片，你可以用\nBmobFile\n上传图片，得到图片的url，保存的字段用string或者array。\n\n\n\n\nQ: 怎么让表的某个字段包含多张图片？\n\nA: 用array来存储文件的url\n\n\n\n\nQ: 能把json文件放在bmob里，并配置一个专门的地址，然后APP通过这路径下载或者读取吗？\n\nA: 用文件服务实现即可。\n\n\n\n\nQ: 怎么通过objectID获得文件的下载路径？\n\nA:\n\n\n// 根据objectId查询数据\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\nquery.getObject(this, \na203eba875\n, new GetListener\nGameScore\n() {\n\n@Override\npublic void onSuccess(GameScore object) {\n// TODO Auto-generated method stub\ntoast(\n查询成功：\n);\n//获得playerName的信息\nobject.getPlayerName();\n//获得数据的objectId信息\nobject.getObjectId();\n//获得createdAt数据创建时间（注意是：createdAt，不是createAt）\nobject.getCreatedAt();\n\n// 假设GameScore对象中有一列是BmobFile类型的icon\n// 如下取出查询到的数据中的BmobFile类型，得到下载地址\nBmobFile icon = object.getIcon();\nString url = icon.getFileUrl();\n\n}\n\n@Override\npublic void onFailure(int code, String arg0) {\n// TODO Auto-generated method stub\ntoast(\n查询失败：\n+arg0);\n}\n\n});\n\n\n\n\n\n\n\nQ: 为什么最新的SDK里面的BmobFile没有loadImageThumbnail方法\n\nA: 最新的SDK已经将图像处理的接口去掉了，需要用户自己在本地处理\n\n\n\n\nQ: 怎么去在批量上完图片之后，取得对应的缩略图呢？\n\nA: 缩略图功能已经取消，请在客户端进行图片的处理\n\n\n\n\nQ: 9015your uploading task is canceled. 安卓文件上传无响应\n\nA: 调用了bmobfile.cancel()方法会出错该提示。\n\n\n\n\nQ: 表中有一列数据为BmobFile类型 ，数据为.TXT格式 ，怎么将文件下载下来\n\nA: 查询这一行数据，在结果中从这一列对应的BmobFile对象中用getFileUrl()得到文件的地址，再进行下载。\n\n\n\n\nQ: listview显示Bmob上的图片怎么实现？\n\nA: 图片上传后会返回相应url给客户端的，可以在表中，在需要显示的时候利用url将图片下载下来进行显示\n\n\n\n\nQ: 我通过软件上传了文件到bmob后端云。怎么获得该文件url。\n\nA: 上传后会有url返回\n\n\n\n\nQ: bmob可以通过客户端下载文件吗？\n\nA: 上传到Bmob之后就会返回文件的地址，至于怎么下载，由你来决定。\n\n\n\n\nQ: 为什么我上传的文件(图片)已经删除了，但是通过url仍然可以访问到图片呢？\n\nA: CDN缓存的，过一段时间就会完全删除\n\n\n\n\n其它问题\n\n\nQ: Cause: com.android.dex.DexException: Multiple dex files define Landroid/support/v4/accessibilityservice/AccessibilityServiceInfoCompat$AccessibilityServiceInfoVersionImpl;\nError:Execution failed for task ':app:transformClassesWithDexForDebug'.\n\nA: Cause: com.android.dex.DexException: Multiple dex files define Landroid/support/v4/accessibilityservice/AccessibilityServiceInfoCompat$AccessibilityServiceInfoVersionImpl;\nError:Execution failed for task ':app:transformClassesWithDexForDebug'.\n\n\n这是重复导包造成的，你用的v4和v7包重复了，你需要去掉报错的那个模块\n\n\n\n\nQ: 我使用BmobUser.login接口,返回onFailure的参数code分别对应什么情况?有说明文档么?\n\nA: \nandroid 错误码列表\n\n\n\n\nQ: App_ID is not setted出现什么原因？\n\nA: 初始化BmobSDK时需要传入你自己应用的ApplicationID\n\n\n\n\nQ: Duplicate files copied in APK META-INF/maven/com.squareup.okhttp/okhttp/pom.xml\n\nA: 导了重复的包\n\n\n\n\nQ: bomb_AndroidSDK_V3.4.7_0518 中文乱码\n\nA: SDK的demo的编码格式是gbk,换下格式就行\n\n\n\n\nQ: android Bmobquery 开两个线程 分别查两个不一样的表，返回数据有问题\n\nA: sdk中的很多方法本身就是在子线程中执行的，开发者没必要开子线程(创建子线程和线程池管理SDK都封装好了)。\n\n\n\n\nQ: 查询出了回调函数，List就变空了\n\nA: 请先理解下同步和异步的概念，bmob目前的接口提供的都是异步回调函数，建议在onsucess/onFailure中进行ui操作\n\n\n\n\nQ: Bmob的各个SDK可以使用Application的Context来初始化吗\n\nA: 可以的。最好是用Application的Context来初始化。\n\n\n\n\nQ: bmob的jar包和volley包冲突怎么回事\n\nA: bmob的jar里面包含了volley,无需再次导入\n\n\n\n\nQ: 移动端和WEB端能用BMOB作为云端，实现数据共享么？\n\nA: 可以的，使用同一个app id来进行操作即可\n\n\n\n\nQ: 真机运行时控制台输出 Error:warning: Ignoring InnerClasses attribute for an anonymous inner class\n\nA: 可以试试在你的app的build.gradle的android标签下添加如下：\n\n\nlintOptions {\nignoreWarnings true\n}\n\n\n\n\n\n\nQ: 把应用装到手机很慢，一直在Gradle Build\n\nA: 如果你确定你的应用所需的jar包已经下载完了，可以将gradle设置成离线模式\n\n\n\n\nQ: BmobSDK能导入源码开发编译吗\n\nA: BmobSDK目前并未开源\n\n\n\n\nQ: 3.4.7 sdk java.lang.UnsatisfiedLinkError 怎么破\n\njava.lang.UnsatisfiedLinkError: Couldn't load bmob from loader dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/top.kiuber.sharemy-1.apk\"],nativeLibraryDirectories=[/data/app-lib/top.kiuber.sharemy-1, /vendor/lib, /system/lib]]]: findLibrary returned null\n\nA: 详情移步到博客http://www.kiuber.top/2016/05/24/android-studio-add-so/ \n\n问题已经被攻克，原因是so库文件未导入。\n\n解决方法：在project视图下，在main文件夹内新建jniLibs文件夹，把对应so库文件夹及文件复制到jniLibs文件内，然后在MainActivity.java文件\n\n\n\n\nQ: 邮箱验证用哪个SDK \n\nA: 使用数据服务SDK即可\n\n\n\n\nQ: Android studio连接Bmob时报错\n\n\njava.lang.UnsatisfiedLinkError: com.android.tools.fd.runtime.IncrementalClassLoader$DelegateClassLoader[DexPathList[[dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-support-annotations-23.4.0_eff36cb3dd5776bcc7dfe63d3c4af3d7d0b02909-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_9-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_8-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_7-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_6-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_5-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_4-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_3-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_2-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_1-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_0-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-okio-1.7.0_16f89fb230458d29c309937f6ab11ce75258c504-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-okhttp-3.2.0_8f755226a0726d7921fa90d83c674c16a1bd0ee3-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-internal_impl-23.4.0_2c4831db21059d6465959fb999a28d5a6fe10599-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-support-vector-drawable-23.4.0_eb28b4ae1a0615e1130648d3b547db30e6e89fd0-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-support-v4-23.4.0_c594c96eba293bbb78cda22a0502566240fb4409-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-appcompat-v7-23.4.0_39e8b9d21669eb9eb3df764bcd49eb0facc75e07-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-animated-vector-drawable-23.4.0_613291d2784b41eebf3800d518847e90b2efa55b-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-bmob-sdk-3.4.7_3bb8e20fe85419a97fea506c0c8a8a8fe18f45d5-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-bmob-push-0.9_35e71e7e49d7888481221634e134fec14816f381-classes.dex\n],nativeLibraryDirectories=[/data/app/com.example.administrator.bmob2-2/lib/arm, /vendor/lib, /system/lib]]] couldn't find \nlibbmob.so\n\n\n\n\nA: 使用aar格式的SDK，这样就不用导入so库\n\n\n\n\nQ: sdk怎么和Retrofit这些库一起使用呢\n\n\nA: 出现这个问题的原因是retrofit依赖的okhttp和sdk的远程aar包中的okhttp重复导致的，将会导致编译不过，解决方式有：\n\n1 下载Retrofit的jar包，采用本地依赖的方式；\n\n2 compile Retrofit的配置加下exclude，把重复的okhttp除去，如下：\n\n\ncompile ('com.squareup.retrofit2:retrofit:2.1.0'){\n        exclude group : 'com.squareup.okhttp3'\n    }", 
            "title": "数据服务Android"
        }, 
        {
            "location": "/other/common_problem/data_android/#_1", 
            "text": "Q: 为什么我修改表中的某个Number类型的字段，其他Number类型的都变为0呢？ \nA: 继承自BmobObject的类不要用int类型，用Integer。   Q: 定义类名必须和表中的名一致？ \nA: 类名和表名一致，表内字段名和类变量名一致。   Q: 插入一条数据之后怎么获得该数据的id  \nA:   GameScore gameScore = new GameScore();\n//注意：不能调用gameScore.setObjectId( )方法\ngameScore.setPlayerName( 比目 );\ngameScore.setScore(89);\ngameScore.setIsPay(false);\ngameScore.save(mContext, new SaveListener() {\n\n@Override\npublic void onSuccess() {\n    toast( 添加数据成功，返回objectId为： +gameScore.getObjectId() + ”,数据在服务端的创建时间为：“ + gameScore.getCreatedAt());\n}\n\n@Override\npublic void onFailure(int code, String arg0) {\n    // 添加失败\n}\n});  请看代码，成功后gameScore使用getObjectId()就可以获取objectId了。   Q: success方法中获取的数据，用全局变量接收，但是在方法外就接受不到，变量为空 \nA: 请先理解同步和异步的概念，回调中的onsuccess是异步方法，是不能用全局变量接收的，可以直接在onsuccess方法中做ui层面的更新   Q: 缓存路径能指定吗？ \nA: 不可以   Q: 我在User表中增加了一个Number类型的字段，设置为以1自增，但几天过去了，里面的值并未自动增加，这个自增是怎样自增的，还要去哪里设置吗？ \nA: 添加字段的时候选择num类型，有一个自增的checkbox和初始值的input，填一下就可以了   Q: 场景是多个客户端共同操作同一个数据表，更新该表的一个字段的值，如何做到一个客户端更新时锁定该数据表，操作结束时解锁？ \nA: 目前没有该功能，只有Number类型可以使用原子计算器达到该效果   Q: 一次查询多条数据 算是调用了几次API？ \nA: 一次调用算一次   Q: 请问每条数据的objectId都是唯一的吗，我的意思是，假设有个user表，有userName和level两个属性。如果两个对象的这两个属性都相同，其objectId是否就相同？  \nA: objectId是每一条数据的唯一标示，不会出现重复的。   Q: String 数据类型最大可支持多大数据？ \nA: 最大为16M   Q: 求问怎么获取上传数据后生成的objectid  \nA: 保存数据成功后，你的BmobObject对象就有objectId了的。\n或者你按条件查询得到的数据对象中也是包含objectId的。   Q: 数据查询必须要objectId吗？在用户数据表中，在无法获取用户objectId的情况下，如何查询一个用户是否存在，是否可以通过其他字段查询？ \nA: 单条查询必须使用ObjectId，多条查询时可以添加条件来进行查询。", 
            "title": "对象"
        }, 
        {
            "location": "/other/common_problem/data_android/#_2", 
            "text": "Q: 查询成功，但是list只能在onSuccess方法中使用,如何在本类中的其他地方使用？ \nA: 网路请求都是异步独立线程的，你用 handler 把数据传递出来就可以。   Q: 如果不知道objectId，是否可以通过表中的元素获得数据？ \nA：添加数据的时候， onSuccess 中可以得到objectId。也可以通过条件查询得到对应的objectId的。   Q: 在Activity关闭的时候如何动态关闭查询？ \nA: 查询都是一次性的，并不需要取消   Q: bmob怎么查询一列数据并合并相同数据？ \nA: 可以使用统计查询中的groupby   Q: bmob的数据库操作方法save insert这些都有开线程吗  \nA: bmob sdk提供的操作都是在线程中运行的，对外都是提供异步的回调方法，其回调方法，比如onsuccess和onFailure等是可以再UI线程中运行的，开发者不需要额外再开线程。   Q: Bmob查询数据结束标志 \nA: 在查询的回调方法中的onSuccess或onFailure触发时都是代表这个查询结束。   Q: Bmob能否进行多表查询？ \nA: 无法用一条语句查多张表，只能单独一个一个查   Q: 怎么设置缓存 让缓存数据在listView显示 \nA: 可以使用缓存查询，具体可以查看官方文档   Q: 怎么通过BmobUser的一个属性列来获取其他列的信息 \nA: 使用bmob的查询功能，查询Username 等于名称的用户信息即可，使用的是addWhereEqualTo方法   Q: 我的应用想只查询最新上传的一组数据，请问该如何操作呢 \nA: 可以根据时间来设置条件，再进行查询   Q: 查询中findListener中的onerror方法不执行,两次测试均是数据库无该数据的，但是程序均不执行onerror方法 \nA: 没有数据不代表查询出错，当没有数据符合你的查询条件时，就会返回空，此时还是执行onSuccess的   Q: 想问问查询的时候排序有多个关键字怎么解决？ \nA: 数据服务的文档中有的，在开发文档的查询数据- 查询条件- 排序那里：  排序  对应数据的排序，如数字或字符串，你可以使用升序或降序的方式来控制查询数据的结果顺序：  // 根据score字段升序显示数据\nquery.order(\"score\");\n// 根据score字段降序显示数据\nquery.order(\"-score\");\n// 多个排序字段可以用（，）号分隔\nquery.order(\"-score,createdAt\");\n说明：多个字段排序时，先按第一个字段进行排序，再按第二个字段进行排序，依次进行。", 
            "title": "查询"
        }, 
        {
            "location": "/other/common_problem/data_android/#_3", 
            "text": "Q: 我有个Relation字段，想用它来记录喜欢这篇文章的用户，我该怎么添加里面的数据呢？ \nA: 这个问题请看  数据关联  相关文档。   Q: Relation字段 能否像pointer一样在查询的时候一并把关联的记录也查询下来，不需要二次查询 \nA: 目前并没有这个功能，建议使用pointer   Q: activity是一个表，里面有一个BmobPointer org指向BmobUser，activity.getOrg.getObjectId总是为空呢？ \nA: 查询的时候应该没有用includ查询进去   Q: 查询数据时，表中的一个字段是pointer字段，如何将这个pointer字段的一个属性作为查询匹配条件？ \nA:   BmobQuery Comment  query = new BmobQuery Comment ();\nBmobQuery Post  innerQuery = new BmobQuery Post ();\ninnerQuery.addWhereExists( image , true);\n// 第一个参数为评论表中的帖子字段名post\n// 第二个参数为Post字段的表名，也可以直接用 Post 字符串的形式\n// 第三个参数为内部查询条件\nquery.addWhereMatchesQuery( post ,  Post , innerQuery);\nquery.findObjects(this, new FindListener Comment () {\n@Override\npublic void onSuccess(List Comment  object) {\n    // TODO Auto-generated method stub\n    toast( 查询成功: );\n}\n@Override\npublic void onError(int code, String msg) {\n    // TODO Auto-generated method stub\n    toast( 查询失败: +msg);\n}\n});  如上，就是使用内部查询就可以实现你的需求了，只需要将查询条件和表名换成你需要的就可以了～   Q: 如果一个用户要收藏一个产品应该怎么定义对象 \nA: 可以使用pointer类型   Q: 删除关联关系 \n我现在有评论类如下：  public class Comment extends BmobObject {\nprivate String comment;\nprivate Found found;\nprivate Lost lost;\nprivate MyUser user;\n}  如果我想删除Lost类或者Found类的某条数据 \n其对应的Comment会被同时删除吗？ \n如果不能应该怎么实现同时删除？ \nA: 不能同时删除，对于不同数据表的数据只能分别执行删除操作。   Q: 查询时 include 两个Pointer字段后会把前一个的数据冲掉\n对表 AaaaEntity 查询时 include 两个Pointer字段后会把前一个的数据冲掉,如:  bmobQuery.include( userAuthor );\nbmobQuery.include( xxxxEntity );\n\n则:\naaaaEntity.getUserAuthor.getName()返回空\n\n如果去掉后一行\nbmobQuery.include( userAuthor );\n//bmobQuery.include( xxxxEntity );\n或\n移到后面：\nbmobQuery.include( xxxxEntity );\nbmobQuery.include( userAuthor );\n\naaaaEntity.getUserAuthor.getName() 就能正常返回值  A: include的用法在文档里面已经说明了的(http://docs.bmob.cn/android/de ... clude用法),想include多个就这样用：query.include(\"x1,x2\");", 
            "title": "数据关联"
        }, 
        {
            "location": "/other/common_problem/data_android/#_4", 
            "text": "Q: 打开了邮箱验证功能，注册成功后未验证也能登录成功？ \nA: Bmob SDK中，邮箱的验证和用户的注册登录是异步的关系，也就是说，即使用户没有点击邮箱验证功能，也是一样可以登录成功的。如果需要限制用户的登录或者只能查看到登录后的部分功能，可以使用 BmobUser.getEmailVerified 。   Q: Bmob如何实现用户登录之后获取数据读写权限，以及如何实现登出操作的？ \nA: 用户登录之后，我们会把获取到的用户信息保存在本地文件中，你可以通过 BmobUser.getCurrentUser 方法获取对应的值，当调用  logout 方法之后，这些缓存的数据就会清除。如果不调用 logout 方法，下次重新打开这个应用，还是可以通过 BmobUser.getCurrentUser 方法获得上次登陆的用户信息，从而判断是否登陆过。   Q: BmobUser.logOut(getApplicationContext()); //清除缓存用户对象\n这个只是针对本地缓存，看了源码，只是对本地清除，没有真正向服务端注销登录的账号，请问是怎么去处理这个问题 \nA: BmobSDK中的BmobUser登录，只是登录成功后缓存用户信息到本地。服务端并没有记录用户的登录状态，所以退出登录并不需要向服务器注销。   Q: Bmob支持第三方登录吗？怎么做？ \nA: 支持，官方的文档上有介绍。   Q: 为什么邮箱验证还没去验证却可以登录 \nA: 是可以的，邮箱验证那个字段需要开发者根据需求自行决定要不要使用   Q: 登录时异常退出MyUser declares multiple JSON fields named mobilePhoneNumber \nA: MyUser定义了一个Bmob的系统字段呀，你可以看看用户管理那里的文档，里面有介绍说明BmobUser的特有属性，以下摘抄自文档：  BmobUser除了从BmobObject继承的属性外，还有几个特定的属性： \nusername: 用户的用户名（必需）。 \npassword: 用户的密码（必需）。 \nemail: 用户的电子邮件地址（可选）。 \nemailVerified:邮箱认证状态（可选）。 \nmobilePhoneNumber：手机号码（可选）。 \nmobilePhoneNumberVerified：手机号码的认证状态（可选）。   Q: 第三方登录之后该怎么获得User的objectId呢？ \nA: 登陆成功之后，系统就会给你生成一个objectId的，你正常的通过 user.getObjectId() 就可以得到了   Q: 如何修改user表中其他用户的数据 \nA: 直接在web控制台修改或者使用masterkey   Q: 修改数据提示User cannot be altered without sessionToken Error. \nA: 这种情况一般都是没有进行用户登录就对用户信息进行更新导致的   Q: 更新用户update时失败，9012错误 \nA: 9012是context is null,没传上下文对象   Q: 用了getobjectId方法为什么还是显示objectId cant't be empty。  public void setsj(View v){\nfinal User setUser = new User();\nList String  a=new ArrayList String ();\na.add( 5cd431f659 );\na.add( 4c2184e8ea );\nsetUser.setFriends(a);\nsetUser.update(this, setUser.getObjectId(), new UpdateListener() {\n\n    @Override\n    public void onSuccess() {\n        // TODO Auto-generated method stub\n        Log.i( bmob ,  更新成功： );\n        toast( 更新成功 );\n    }\n\n    @Override\n    public void onFailure(int code, String msg) {\n        // TODO Auto-generated method stub\n        Log.i( bmob , 更新失败： +msg);\n        toast( 更新失败 );\n    }\n});\n}  这段代码是通过点击一个button然后更新我写好的数据，可一直显示更新失败，查看logcat显示objectId cant't be empty。可是我有用setUser.getObjectId()啊，为什么还是说ID为空？ \nA: 你的user并不是通过登录得到的，而是自己生成的，并没有objectid，需要从服务器上获取的数据才有objectid   Q: 更新了用户信息后 服务器都更新了数据 但是本地缓存用户没有更新 \nA: 更新用户信息后需要从新登陆，本地用户信息才会更新。   Q: 登录后在个人资料中上传头像在用户表，并且要头像和用户要对应。 \nA: 上传图片成功后，将BmobFile对象更新到当前用户的头像字段中即可。   Q: 在数据下_User 下把email添加后为啥 emailVerified Boolean 这一栏显示的是false 是什么原因呢 \nA: 该字段需要注册用户点击了验证邮件才会主动设置为true", 
            "title": "用户管理"
        }, 
        {
            "location": "/other/common_problem/data_android/#_5", 
            "text": "Q: 如何实现Bmob服务端向Android应用发送实时通知？如某个数据过高需要提醒APP用户 \nA: 以使用实时数据监听功能来实现   Q: 登录之后，怎么获取用户的信息并显示出来 \nA: 登录成功之后就可以通过getCurrentUser方法获取本地用户信息", 
            "title": "数据实时功能"
        }, 
        {
            "location": "/other/common_problem/data_android/#acl", 
            "text": "Q: 例如我已经有一个角色叫Chief，我怎么用代码给它添加成员？直接new BmobRole(\"Chief\")然后再getUsers().add然后再save?\n但这个代码不应该是新建一个角色吗？\n如果是用BmobQuery 获取的话获取失败，返回101错误 \nA:  //创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\nBmobRole hr = new BmobRole( HR );\nBmobRole cashier = new BmobRole( Cashier );\n\n//将hr_zhang和hr_luo归属到hr角色中\nhr.getUsers().add(hr_zhang);\nhr.getUsers().add(hr_luo);\n//保存到云端角色表中（web端可以查看Role表）\nhr.save(this); \n\n//将cashier_xie归属到cashier角色中\ncashier.getUsers().add(cashier_xie);\n//保存到云端角色表中（web端可以查看Role表）\ncashier.save(this);   Q: 是否可以针一行数据的某一个字段控制读写权限 ？ \n是否可以针一行数据的某一个字段控制读写权限 ？例如，UserA 发了一条说说，这条说说只有UserA可以写，其它用户可以读，但是其中有一个点赞计数字段，所有用户都可以对这条说说点赞，点赞后，这个点赞计数字段值就加1。 \nA: 没有针对一个字段控制读写的，如果需要，可以将这些需要控制的另外建一个表，使用pointer字段指向该表来获取", 
            "title": "ACL和角色"
        }, 
        {
            "location": "/other/common_problem/data_android/#_6", 
            "text": "Q: 基于地理位置的查询是根据什么排序的 \nA: 是按照距离从近到远来进行排序的", 
            "title": "地理位置"
        }, 
        {
            "location": "/other/common_problem/data_android/#_7", 
            "text": "Q: 自动更新生成的表和文档上的不一致 \nA: 没有调用initAppversion方法   Q: 自动更新，如何实现只获取是否有新版本，不弹出对话框。 \nA: 目前SDK中暂没有这个功能，后续版本会考虑添加", 
            "title": "自动更新"
        }, 
        {
            "location": "/other/common_problem/data_android/#_8", 
            "text": "Q: Bmob如何实现储存和传输图片？ \nA: 通过 BmobFile 类上传图片，上传成功之后，会返回一个 BmobFile ，你从这个 BmobFile 可以得到文件上传之后的url，把这个url保存到你的对应表中。下载的时候，先查询数据表得到url，然后下载这个图片就可以了。    Q: Bmob如何将整批图片下载在本地呢？ \nA: 首先先查询，得到全部数据，从而得到图片的url列表，再用一些下载文件的代码把图片批量下载下来。   Q: BmobFile类最多可以保存多少张图片？ \nA:  BmobFile 类只能保存一张图片，你可以用 BmobFile 上传图片，得到图片的url，保存的字段用string或者array。   Q: 怎么让表的某个字段包含多张图片？ \nA: 用array来存储文件的url   Q: 能把json文件放在bmob里，并配置一个专门的地址，然后APP通过这路径下载或者读取吗？ \nA: 用文件服务实现即可。   Q: 怎么通过objectID获得文件的下载路径？ \nA:  // 根据objectId查询数据\nBmobQuery GameScore  query = new BmobQuery GameScore ();\nquery.getObject(this,  a203eba875 , new GetListener GameScore () {\n\n@Override\npublic void onSuccess(GameScore object) {\n// TODO Auto-generated method stub\ntoast( 查询成功： );\n//获得playerName的信息\nobject.getPlayerName();\n//获得数据的objectId信息\nobject.getObjectId();\n//获得createdAt数据创建时间（注意是：createdAt，不是createAt）\nobject.getCreatedAt();\n\n// 假设GameScore对象中有一列是BmobFile类型的icon\n// 如下取出查询到的数据中的BmobFile类型，得到下载地址\nBmobFile icon = object.getIcon();\nString url = icon.getFileUrl();\n\n}\n\n@Override\npublic void onFailure(int code, String arg0) {\n// TODO Auto-generated method stub\ntoast( 查询失败： +arg0);\n}\n\n});   Q: 为什么最新的SDK里面的BmobFile没有loadImageThumbnail方法 \nA: 最新的SDK已经将图像处理的接口去掉了，需要用户自己在本地处理   Q: 怎么去在批量上完图片之后，取得对应的缩略图呢？ \nA: 缩略图功能已经取消，请在客户端进行图片的处理   Q: 9015your uploading task is canceled. 安卓文件上传无响应 \nA: 调用了bmobfile.cancel()方法会出错该提示。   Q: 表中有一列数据为BmobFile类型 ，数据为.TXT格式 ，怎么将文件下载下来 \nA: 查询这一行数据，在结果中从这一列对应的BmobFile对象中用getFileUrl()得到文件的地址，再进行下载。   Q: listview显示Bmob上的图片怎么实现？ \nA: 图片上传后会返回相应url给客户端的，可以在表中，在需要显示的时候利用url将图片下载下来进行显示   Q: 我通过软件上传了文件到bmob后端云。怎么获得该文件url。 \nA: 上传后会有url返回   Q: bmob可以通过客户端下载文件吗？ \nA: 上传到Bmob之后就会返回文件的地址，至于怎么下载，由你来决定。   Q: 为什么我上传的文件(图片)已经删除了，但是通过url仍然可以访问到图片呢？ \nA: CDN缓存的，过一段时间就会完全删除", 
            "title": "文件"
        }, 
        {
            "location": "/other/common_problem/data_android/#_9", 
            "text": "Q: Cause: com.android.dex.DexException: Multiple dex files define Landroid/support/v4/accessibilityservice/AccessibilityServiceInfoCompat$AccessibilityServiceInfoVersionImpl;\nError:Execution failed for task ':app:transformClassesWithDexForDebug'. \nA: Cause: com.android.dex.DexException: Multiple dex files define Landroid/support/v4/accessibilityservice/AccessibilityServiceInfoCompat$AccessibilityServiceInfoVersionImpl;\nError:Execution failed for task ':app:transformClassesWithDexForDebug'.  这是重复导包造成的，你用的v4和v7包重复了，你需要去掉报错的那个模块   Q: 我使用BmobUser.login接口,返回onFailure的参数code分别对应什么情况?有说明文档么? \nA:  android 错误码列表   Q: App_ID is not setted出现什么原因？ \nA: 初始化BmobSDK时需要传入你自己应用的ApplicationID   Q: Duplicate files copied in APK META-INF/maven/com.squareup.okhttp/okhttp/pom.xml \nA: 导了重复的包   Q: bomb_AndroidSDK_V3.4.7_0518 中文乱码 \nA: SDK的demo的编码格式是gbk,换下格式就行   Q: android Bmobquery 开两个线程 分别查两个不一样的表，返回数据有问题 \nA: sdk中的很多方法本身就是在子线程中执行的，开发者没必要开子线程(创建子线程和线程池管理SDK都封装好了)。   Q: 查询出了回调函数，List就变空了 \nA: 请先理解下同步和异步的概念，bmob目前的接口提供的都是异步回调函数，建议在onsucess/onFailure中进行ui操作   Q: Bmob的各个SDK可以使用Application的Context来初始化吗 \nA: 可以的。最好是用Application的Context来初始化。   Q: bmob的jar包和volley包冲突怎么回事 \nA: bmob的jar里面包含了volley,无需再次导入   Q: 移动端和WEB端能用BMOB作为云端，实现数据共享么？ \nA: 可以的，使用同一个app id来进行操作即可   Q: 真机运行时控制台输出 Error:warning: Ignoring InnerClasses attribute for an anonymous inner class \nA: 可以试试在你的app的build.gradle的android标签下添加如下：  lintOptions {\nignoreWarnings true\n}   Q: 把应用装到手机很慢，一直在Gradle Build \nA: 如果你确定你的应用所需的jar包已经下载完了，可以将gradle设置成离线模式   Q: BmobSDK能导入源码开发编译吗 \nA: BmobSDK目前并未开源   Q: 3.4.7 sdk java.lang.UnsatisfiedLinkError 怎么破 \njava.lang.UnsatisfiedLinkError: Couldn't load bmob from loader dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/top.kiuber.sharemy-1.apk\"],nativeLibraryDirectories=[/data/app-lib/top.kiuber.sharemy-1, /vendor/lib, /system/lib]]]: findLibrary returned null \nA: 详情移步到博客http://www.kiuber.top/2016/05/24/android-studio-add-so/  \n问题已经被攻克，原因是so库文件未导入。 \n解决方法：在project视图下，在main文件夹内新建jniLibs文件夹，把对应so库文件夹及文件复制到jniLibs文件内，然后在MainActivity.java文件   Q: 邮箱验证用哪个SDK  \nA: 使用数据服务SDK即可   Q: Android studio连接Bmob时报错  java.lang.UnsatisfiedLinkError: com.android.tools.fd.runtime.IncrementalClassLoader$DelegateClassLoader[DexPathList[[dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-support-annotations-23.4.0_eff36cb3dd5776bcc7dfe63d3c4af3d7d0b02909-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_9-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_8-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_7-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_6-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_5-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_4-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_3-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_2-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_1-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_0-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-okio-1.7.0_16f89fb230458d29c309937f6ab11ce75258c504-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-okhttp-3.2.0_8f755226a0726d7921fa90d83c674c16a1bd0ee3-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-internal_impl-23.4.0_2c4831db21059d6465959fb999a28d5a6fe10599-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-support-vector-drawable-23.4.0_eb28b4ae1a0615e1130648d3b547db30e6e89fd0-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-support-v4-23.4.0_c594c96eba293bbb78cda22a0502566240fb4409-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-appcompat-v7-23.4.0_39e8b9d21669eb9eb3df764bcd49eb0facc75e07-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-animated-vector-drawable-23.4.0_613291d2784b41eebf3800d518847e90b2efa55b-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-bmob-sdk-3.4.7_3bb8e20fe85419a97fea506c0c8a8a8fe18f45d5-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-bmob-push-0.9_35e71e7e49d7888481221634e134fec14816f381-classes.dex ],nativeLibraryDirectories=[/data/app/com.example.administrator.bmob2-2/lib/arm, /vendor/lib, /system/lib]]] couldn't find  libbmob.so  A: 使用aar格式的SDK，这样就不用导入so库   Q: sdk怎么和Retrofit这些库一起使用呢  A: 出现这个问题的原因是retrofit依赖的okhttp和sdk的远程aar包中的okhttp重复导致的，将会导致编译不过，解决方式有： \n1 下载Retrofit的jar包，采用本地依赖的方式； \n2 compile Retrofit的配置加下exclude，把重复的okhttp除去，如下：  compile ('com.squareup.retrofit2:retrofit:2.1.0'){\n        exclude group : 'com.squareup.okhttp3'\n    }", 
            "title": "其它问题"
        }, 
        {
            "location": "/other/common_problem/data_ios/", 
            "text": "对象\n\n\nQ: 查询表内容时不能获取到objectId的值\n\n通过[obj objectForKey:@\"objectId\"]获取到的是空值，其他字段是正常的\n\nA: BmobObject有一些基本属性，objectId，createdAt，updatedAt等，直接获取就可以了,如bmobObject.objectId。\n\n\n\n\nQ: 查询时可以设置只从本地缓存获取，但是创建和保存时是否能够只保存到本地缓存呢？\n\nA: 只有查询有缓存，其它操作没有缓存。\n\n\n\n\nQ: iOS 怎么获取到创建日期啊\n\nA: NSLog(@\"%@\",[NSString stringWithFormat:@\"%@\", Myobject.createdAt]);\n\n\n\n\nQ: bmob 怎样用代码写唯一键 \n\nA: 唯一键只能在控制台设置\n\n\n\n\nQ: 我的bmob对象中有一个属性是boolean属性，请问在ios代码中怎么设置它？\n\nA: BOOL cheatMode = [[object objectForKey:@\"cheatMode\"] boolValue];\nisStudent = [NSNumber numberWithBool:NO];\n用以上的方法来设置。\n\n\n\n\nQ: ios开发初始化一个对象指定一个id但是保存成功之后却不再是这个id了\n\nA: objectId系统生成的，并不是你来生成的，你用的下面这个方法，是用来构造已经存在的对象，然后对该对象进行更新删除操作的。\n\n\nBmobObject *gameScore = [BmobObject objectWithoutDatatWithClassName:@\nGameScore\n objectId:@\na\n]；\n\n\n\n\n\n\nQ: 原子计数器怎么用\n\nA: 查看\nhttp://docs.bmob.cn/data/iOS/b_developdoc/doc/index.html#对象\n原子计算器小节。\n\n\n\n\nQ: 在iOS中 在代码中如何创建一个空表 只包含各列的属性 而不创建具体的一条数据。\n\nA: 该需求无法可以通过在web控制台添加列来实现。\n\n\n\n\nQ: 如何删除表中所有的数据？(只知道表名的情况下)\n\nA: 先查询该表所以数据，获得数据后遍历删除～\n\n\n\n\nQ: 可不可以批量创建数据\n\nA: 可以,\n批量数据操作\n\n\n\n\nQ: 如何存储比较复杂的数据类型？比如数组里包含字典，字典里再包含数据\n\nA: 一般的数据类型使用使用JSON格式都可以存储的，可以多了解一下JSON格式\n\n\n\n\nQ: 'Invalid type in JSON write (CLPlacemark)' CLPlacemark类型熟悉无法写入\n\nA: 对象类型属性是无法写入的\n\n\n\n\n查询\n\n\nQ: iOS端集成 查询单条数据，只知道某个value的具体值，如何查询相应的该条数据的其他值？\n\nA: 使用多条查询并加上你的约束条件就可以了\n\n\n\n\nQ: iOS 查询条件是boolean 应该怎样设置？\n\nA: 类似于以下形式\n\n\n[bquery whereKey:@\nplayerName\n notEqualTo:[NSNumber numberWithBool:NO]];\n\n\n\n\n\n\nQ: 我想让模糊查询的条件key为所关联的_User表中的username 怎么弄\n\nA: 你好，文档中有关于模糊查询的介绍\n查询\n\n\n\n\nQ: BmobQuery查询多条数据时，查询结果无法传出\n\nA: 查询是异步的，可以采用通知机制来传递返回的数据，或者是把操作逻辑放在block里\n\n\n\n\nQ: user表查询返回的没有自定义列的数据，只有username自带属性\n\nA: 注意使用objectForKey来读取数据，而不是valueForKey。\n\n\n\n\nQ: iOS 如何判断表内存在某列存在某项值 然后作为类方法返回值返回呢？\n\nA: 查看以下文档中的“列值是否存在”小节\nhttp://docs.bmob.cn/data/iOS/b_developdoc/doc/index.html#查询\n\n\n\n\nQ: 支持一次可以查找多张结构类似的表吗\n\nA: 不支持\n\n\n\n\n数组\n\n\nQ: IOS 如何 查询 数组\n\nA:  \n\n\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n//查找GameScore表所有数据\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n    for (BmobObject *obj in array) {\n        //打印array\n        NSLog(@\nobj.array = %@\n, [obj objectForKey:@\narray\n]);\n}\n}];\n\n\n\n\n\n\nQ: 删除array数据类型的一个元素\n\nA: \n删除数组元素\n\n\n\n\n数据关联\n\n\nQ: 怎么获取relation中的数据? \n\nA: 假设你有一个帖子(Post)类和一个系统默认的用户(User)类, 而每一个帖子(Post)都可以被不同的用户(User)所喜欢。 如果帖子(Post)类下面有一个Key名为likes，且是 Relation 类型, 存储了喜欢这个帖子(Post)的用户(User)。那么你可以找到喜欢过同一个指定的帖子(Post)的所有用户：\n\n\nBmobQuery *bquery = [BmobQuery queryForUser];\n[bquery orderByDescending:@\"updatedAt\"];\nBmobObject *obj = [BmobObject objectWithoutDatatWithClassName:@\"Post\" objectId:@\"a1419df47a\"];\n[bquery whereObjectKey:@\"likes\" relatedTo:obj];\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n}];\n\n\n\n\n\nQ: 如何查询多个关联关系\n\nA: 如果查询多个关联关系，可以使用以下方法，使用逗号(,)操作来使查询中包含多个属性\n\n\n[bquery includeKey:@\ncolumn1,column2,...\n];\n\n\n\n\n\n\nQ: iOS-如何判断列值Pointer类型里的数据不为空\n\nA: 可以用下面的方法来实现～\n\n\n//设置查询中该字段是有值的结果\n-(void)whereKeyExists:(NSString *)key;\n//设置查询中该字段是没有值的结果\n-(void)whereKeyDoesNotExist:(NSString *)key;\n\n\n\n\n\n\nQ: Relation关系，如何进行逆向查询？\n\n基于User可以点赞Post，我现在在Post表中建立了一个Relation关系，指向User；借此我可以知道，喜欢了某一篇Post的User都有谁。\n\n\n现在我还需要知道某一个User喜欢了哪些Post，也就是利用User的ObjectID查询Post表的内容。貌似Bmob的Relation关系与数据库里面的多对多关系（借用建立中间表实现多对多）不同，不知道该怎样实现我所要的查询？\n\nA: 这个没法直接逆向查询的，你可以使用pointer来完成你的需求，重新建立一个表，两个字段，一个指向点赞者，一个指向点赞人\n\n\n\n\nQ: iOS中怎样同时查询两张表，做到获取两张表的内容，不是一张表的内容\n\nA: 可以采用pointer类型，使得一张表指向另一张表，再使用include接口可以来获得\n\n\n\n\n用户管理\n\n\nQ: 注册的时候如何给User表自定义的字段插值？\n\nA: 有个\nBmobUser\n类用来操作用户相关的数据  \n\n\n    BmobUser *bUser = [[BmobUser alloc] init];  \n    [bUser setUserName:@\n小明\n];  \n    [bUser setPassword:@\n123456\n];  \n    //age 为自定义  \n    [bUser setObject:@18 forKey:@\nage\n];  \n    [bUser signUpInBackground];\n\n\n\n\n\n\nQ: 打开了邮箱验证功能，注册成功后未验证也能登录成功？\n\nA: Bmob SDK中，邮箱的验证和用户的注册登录是异步的关系，也就是说，即使用户没有点击邮箱验证功能，也是一样可以登录成功的。如果需要限制用户的登录或者只能查看到登录后的部分功能，可以使用\n[[[BmobUser getCurrentUser] objectForKey:@\"emailVerified\"] boolValue]\n方法。\n\n\n\n\nQ: Bomb邮箱认证是只需要开启邮箱认证就可以了吗？里面的内容要不要设置啊，比如发送给谁，邮箱地址什么的？\n\nA: 开启就可以了使用了。内容可以不用设置，发送给谁、邮箱地址是什么是由SDK注册的时候用户填写的。\n\n\n\n\nQ: ios注册的时候如何给User表自定义的字段插值\n\nA: 有个BmobUser类用来操作用户相关的数据\n\n\nBmobUser *bUser = [[BmobUser alloc] init];\n[bUser setUserName:@\n小明\n];\n[bUser setPassword:@\n123456\n];\n//age 为自定义\n[bUser setObject:@18 forKey:@\nage\n];\n[bUser signUpInBackground];\n\n\n\n\n\n\nQ: 第三方用户授权注册登录后，如何绑定手机号呢？\n\nA: 可以使用该绑定手机号的功能\n手机号相关功能\n\n\n\n\nQ: 退出登录接口\n\nA: [BmobUser logout];\n\n\n\n\nQ: 手机号是用户名，在忘记密码这一块，用什么来方法来查询用户名？用什么回调方法去判断用户是否已经注册\n\nA: 可以直接使用条件查询来判断是否已经存在该用户\n\n\n\n\nQ: 用第三方登录时,怎么将用户头像存入BmobUser中\n\nA: 再建一个字段，将头像url存进去\n\n\n\n\nQ: 我做了两个页面（viewcontroller）,在注册页面用[BmobUser setUsername:]等方法保存了用户账号密码的信息，成功之后使用[BmobUser loginWithUsernameInBackground:,**]这个方法保存后台，但是我在另一个页面，登录页面提取数据进行账号密码对比验证的时候，使用[BmobUser getCurrentUser]提取当前的账号密码，发现他的账号内容保存了下来，而密码的内容是NULL。不知道这是为什么\n\nA: 密码是不能提取的，登录要用文档给定的接口\n\n\n\n\nQ: ios中 ，怎么判断用户注册或是登陆的时候 处于联网状态还是非联网状态\n\nA: 可以使用网络状态监听，这方面的资料有很多的～http://www.cnblogs.com/wendingding/p/3950114.html\n\n\n\n\nQ: 请问每次登录后都会缓存用户的信息，但是好像没有缓存密码，那怎么实现缓存登录，也就是下次自动登录。\n\nA: 密码是不会保存的，启动应用时直接使用下面代码判断用户是否已经登录\n\n\nBmobUser *bUser = [BmobUser getCurrentObject];\nif (bUser) {\n//进行操作\n}else{\n//对象为空时，可打开用户注册界面\n}\n密码是不会保存的，启动应用时直接使用下面代码判断用户是否已经登录\nBmobUser *bUser = [BmobUser getCurrentObject];\nif (bUser) {\n//进行操作\n}else{\n//对象为空时，可打开用户注册界面\n}\n密码是不会保存的，启动应用时直接使用下面代码判断用户是否已经登录\nBmobUser *bUser = [BmobUser getCurrentObject];\nif (bUser) {\n//进行操作\n}else{\n//对象为空时，可打开用户注册界面\n}\n\n\n\n\n\n\n数据实时功能\n\n\nQ: 客户端监控某个表或某一行数据，会使客户端电量或网络流量增加吗？如果表数据有变化时，是通过推送机制来通知客户端的吗？\n\nA: 不会消耗多少网络流量的，是用websocket机制来通知客户端，不是通过推送，也没有离线消息的概念，一旦socket连接关闭，就不会收到后续消息。\n\n\n\n\nACL和角色\n\n\nQ: 如果每个用户都有写入权限，安全应该怎么做？ \n\nA: 可以设置ACL，详情请查看文档\nACL和角色\n。\n\n\n\n\nQ: ios安全问题，如果每个用户都有写入权限，安全应该怎么做？\n\nA: 可以使用ACL来限制读写权限。\n\n\n\n\nQ: 关于ACL安全控制的几个问题\n\n1.在后台设置了某个表的权限为只读，那么app上调用setPublicWriteAccess，是不是对该表无效？\n\n2.app上是否有acl的api改变表是只读还是acl控制？ \n\n3.下面代码是不是对该应用中所有表进行acl权限设置？\n\n\nBmobACL *acl = [BmobACL ACL];\n//设置所有人读权限为true\n[acl setPublicReadAccess];\n//设置所有人写权限为true\n[acl setPublicWriteAccess];\n\n\n\n\n如果只是对blog表权限设置，在上面的基础上加上blog.ACL= acl;即可？但是我觉得这样好像有点矛盾，因为如果前面的代码成立，那么后面的后面代码没有达到“只是对blog表”的权限修改的目标，反而到时所有表的权限都被修改了。\n\n4.setPublicWriteAccess是对所有表的权限设置，有没有只针对某个表所有行的权限设置的api？\n\n5.开发文档中的关于发表一篇不公开的日志的例子，我理解为是对表中都一条单独的数据进行acl权限控制，这种理解是否正确？\n\n6.ACL能不能控制某个字段（也就是列）的访问权限？\n\n\nA: \n\n1.调用应该是有效的，这个你只需要简单测试一下就可以了。\n\n2.除了只读后，其它情况都是acl控制。\n\n3.不是对所有表进行设置，那个代码只是设置了权限，必须显示对某个表应用才行。\n\n4.同3，并不是针对所有表进行设置。\n\n5.是的\n\n6.不能，只能控制表的访问。\n\n\n\n\n文件\n\n\nQ: iOS上传文件只支持路径上传吗，不支持iOS的NSData或者image对象上传吗\n\nA: 支持路径和NSData上传，可以查看BmobFile的头文件，里面有相关注释\n\n\n\n\nQ: file字段中如何上传多张图片？\n\nA: 一个file字段只能保存一个图片文件，多个图片可以使用数组将图片url保存下来\n\n\n\n\nQ: File类型是视频文件，能不能在ios端直接通过File的地址播放视频呢？\n\nA: 支持\n\n\n\n\nQ: iOS 从相册获取到视频 然后如何上传\n\nA: 直接通过路径或者NSData都可以\n\n\n\n\nQ: 上传视频失败\n\n\n\nA: 这种情况是初始化没有完成就开始进行请求导致的，可以监听kBmobInitSuccessNotification通知，监听到该事件后再上传即可\n\n\n\n\nQ: 在ipv6下.无法获取到资源文件\n\nA: 先看看ipv6的环境是否设置正确\n设置方法\n,再看看相应的下载库是否支持ipv6。\n\n\n\n\nQ: 1.69 SDK 文件服务更换为CDN上传是指什么？文档在哪里？\n\nA: 原接口不变，只是服务器换了，服务会更稳定的\n\n\n\n\n地理位置\n\n\nQ: 地理位置查询 返回的结果是已经排序的\n\nA: 是排序好的，由近到远的顺序。\n\n\n\n\nQ: 想查询10KM内的所有用户，并且按用户的某个字段属性排序，应该怎么做呢？因为发现只要按地理位置设置了条件，不管排序条件怎么设，最终都是按距离远近进行排序的...\n\nA: 做不了的，有地理位置条件的时候都是按从近到远排序的。距离相同再按别的排序\n\n\n\n\n其它问题\n\n\nQ: 有iOS 点赞功能的demo吗？\n\nA: 有的，\nBmob点赞案例\n 实现的用户注册、用户登录、发贴、显示所有帖子资料以及对帖子进行点赞的功能 。\n\n\n\n\nQ: 请问有对应的swift开发方法吗？\n\nA: Swift项目中使用BmobSDK可以看这个文档：\nSwift项目中使用BmobSDK\n\n\n\n\nQ: 支持什么编译器\n\nA: Bmob完全支持iOS 64bit/32bit的真机和模拟器调试。\n\n\n\n\nQ: 数据库中file字段无法导出吗？\n\nA: 暂时只支持7种基本类型的导出：字符串(String)、数字(Number)、布尔值(Boolean)、\n数组（Array）、对象（Object）、日期（Date）和地理位置（GeoPoint）\n\n\n\n\nQ: iOS开发restAPI中条件查询如何拼接请求\n\nA: 写在url上面，可以先了解一下html中get和post的区别，get请求的参数都是写的url上的~\n\n\n\n\nQ: bmob有iOS国际化文件没有\n\nA: 国际化是需要你自己在本地做的，和Bmob无关。\n\n\n\n\nQ: 出现错误\"msg\":\"authorization has expired\",\"code\":40300006\n\nA: 应用太久没有请求导致的，先在控制台恢复一下应用数据就可以\n\n\n\n\nQ: 等到查询成功得到结果后再执行下一步怎么办？\n\nA: 需要放在block中进行。\n\n\n\n\nQ: 出现错误Error Domain=cn.bmob.www Code=20002 \"connect failed!\" UserInfo={NSLocalizedDescription=connect failed!\n\nA: 网络问题，连接失败了，请尝试更换网络再次进行连接。\n\n\n\n\nQ: The dependency \nBmobSDK\n is not used in any concrete target.\n\nA: 你好，应该是你的cocoapod升级了，新版本的需要指定下载的库给特定的target使用，如下，把CocoapodsDemo换成你的target名即可～\n\n\ntarget “CocoapodsDemo” do\npod ‘BmobSDK’\nend\n\n\n\n\n\n\nQ: 想迁移一个app的某个表数据到另一个app，怎么实现\n\nA: 可以直接使用A应用的备份数据生成新应用提供给B应用使用，点击进入应用，设置-备份还原，选择最近一次备份生成新应用即可\n\n\n\n\nQ: 怎样往一张表里面直接添加图片，不用代码\n\nA: web上传\n\n\n\n\nQ: os 用户删除 tableView 某一个单元格的数据，我怎么拿到用户点击的 index.row 去找到该行数据相应的 objectId？\n\nA: 显示的时候是把bmobobject放在一个数组中显示,直接根据row找到对应的bmobobject，里面就有objectid\n\n\n\n\nQ: 错误Error Domain=cn.bmob.www Code=100 \"db stopped\" UserInfo={NSLocalizedDescription=db stopped}\n\nA: 应用可能太久没使用被停止了，到控制台对应的应用的设置那里恢复一下数据\n\n\n\n\nQ: Cocoapod集成后打开报错，提示缺失库。\n\nA: 打开后缀xcworkspace的文件，而不是后缀xcodeproj 的文件\n\n\n\n\nQ: 哪里可以看到错误码\n\nA: 请查看iOS开发文档中的\n错误代码列表\n。", 
            "title": "数据服务iOS"
        }, 
        {
            "location": "/other/common_problem/data_ios/#_1", 
            "text": "Q: 查询表内容时不能获取到objectId的值 \n通过[obj objectForKey:@\"objectId\"]获取到的是空值，其他字段是正常的 \nA: BmobObject有一些基本属性，objectId，createdAt，updatedAt等，直接获取就可以了,如bmobObject.objectId。   Q: 查询时可以设置只从本地缓存获取，但是创建和保存时是否能够只保存到本地缓存呢？ \nA: 只有查询有缓存，其它操作没有缓存。   Q: iOS 怎么获取到创建日期啊 \nA: NSLog(@\"%@\",[NSString stringWithFormat:@\"%@\", Myobject.createdAt]);   Q: bmob 怎样用代码写唯一键  \nA: 唯一键只能在控制台设置   Q: 我的bmob对象中有一个属性是boolean属性，请问在ios代码中怎么设置它？ \nA: BOOL cheatMode = [[object objectForKey:@\"cheatMode\"] boolValue];\nisStudent = [NSNumber numberWithBool:NO];\n用以上的方法来设置。   Q: ios开发初始化一个对象指定一个id但是保存成功之后却不再是这个id了 \nA: objectId系统生成的，并不是你来生成的，你用的下面这个方法，是用来构造已经存在的对象，然后对该对象进行更新删除操作的。  BmobObject *gameScore = [BmobObject objectWithoutDatatWithClassName:@ GameScore  objectId:@ a ]；   Q: 原子计数器怎么用 \nA: 查看 http://docs.bmob.cn/data/iOS/b_developdoc/doc/index.html#对象 原子计算器小节。   Q: 在iOS中 在代码中如何创建一个空表 只包含各列的属性 而不创建具体的一条数据。 \nA: 该需求无法可以通过在web控制台添加列来实现。   Q: 如何删除表中所有的数据？(只知道表名的情况下) \nA: 先查询该表所以数据，获得数据后遍历删除～   Q: 可不可以批量创建数据 \nA: 可以, 批量数据操作   Q: 如何存储比较复杂的数据类型？比如数组里包含字典，字典里再包含数据 \nA: 一般的数据类型使用使用JSON格式都可以存储的，可以多了解一下JSON格式   Q: 'Invalid type in JSON write (CLPlacemark)' CLPlacemark类型熟悉无法写入 \nA: 对象类型属性是无法写入的", 
            "title": "对象"
        }, 
        {
            "location": "/other/common_problem/data_ios/#_2", 
            "text": "Q: iOS端集成 查询单条数据，只知道某个value的具体值，如何查询相应的该条数据的其他值？ \nA: 使用多条查询并加上你的约束条件就可以了   Q: iOS 查询条件是boolean 应该怎样设置？ \nA: 类似于以下形式  [bquery whereKey:@ playerName  notEqualTo:[NSNumber numberWithBool:NO]];   Q: 我想让模糊查询的条件key为所关联的_User表中的username 怎么弄 \nA: 你好，文档中有关于模糊查询的介绍 查询   Q: BmobQuery查询多条数据时，查询结果无法传出 \nA: 查询是异步的，可以采用通知机制来传递返回的数据，或者是把操作逻辑放在block里   Q: user表查询返回的没有自定义列的数据，只有username自带属性 \nA: 注意使用objectForKey来读取数据，而不是valueForKey。   Q: iOS 如何判断表内存在某列存在某项值 然后作为类方法返回值返回呢？ \nA: 查看以下文档中的“列值是否存在”小节 http://docs.bmob.cn/data/iOS/b_developdoc/doc/index.html#查询   Q: 支持一次可以查找多张结构类似的表吗 \nA: 不支持", 
            "title": "查询"
        }, 
        {
            "location": "/other/common_problem/data_ios/#_3", 
            "text": "Q: IOS 如何 查询 数组 \nA:    BmobQuery   *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n//查找GameScore表所有数据\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n    for (BmobObject *obj in array) {\n        //打印array\n        NSLog(@ obj.array = %@ , [obj objectForKey:@ array ]);\n}\n}];   Q: 删除array数据类型的一个元素 \nA:  删除数组元素", 
            "title": "数组"
        }, 
        {
            "location": "/other/common_problem/data_ios/#_4", 
            "text": "Q: 怎么获取relation中的数据?  \nA: 假设你有一个帖子(Post)类和一个系统默认的用户(User)类, 而每一个帖子(Post)都可以被不同的用户(User)所喜欢。 如果帖子(Post)类下面有一个Key名为likes，且是 Relation 类型, 存储了喜欢这个帖子(Post)的用户(User)。那么你可以找到喜欢过同一个指定的帖子(Post)的所有用户：  BmobQuery *bquery = [BmobQuery queryForUser];\n[bquery orderByDescending:@\"updatedAt\"];\nBmobObject *obj = [BmobObject objectWithoutDatatWithClassName:@\"Post\" objectId:@\"a1419df47a\"];\n[bquery whereObjectKey:@\"likes\" relatedTo:obj];\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n}];   Q: 如何查询多个关联关系 \nA: 如果查询多个关联关系，可以使用以下方法，使用逗号(,)操作来使查询中包含多个属性  [bquery includeKey:@ column1,column2,... ];   Q: iOS-如何判断列值Pointer类型里的数据不为空 \nA: 可以用下面的方法来实现～  //设置查询中该字段是有值的结果\n-(void)whereKeyExists:(NSString *)key;\n//设置查询中该字段是没有值的结果\n-(void)whereKeyDoesNotExist:(NSString *)key;   Q: Relation关系，如何进行逆向查询？ \n基于User可以点赞Post，我现在在Post表中建立了一个Relation关系，指向User；借此我可以知道，喜欢了某一篇Post的User都有谁。  现在我还需要知道某一个User喜欢了哪些Post，也就是利用User的ObjectID查询Post表的内容。貌似Bmob的Relation关系与数据库里面的多对多关系（借用建立中间表实现多对多）不同，不知道该怎样实现我所要的查询？ \nA: 这个没法直接逆向查询的，你可以使用pointer来完成你的需求，重新建立一个表，两个字段，一个指向点赞者，一个指向点赞人   Q: iOS中怎样同时查询两张表，做到获取两张表的内容，不是一张表的内容 \nA: 可以采用pointer类型，使得一张表指向另一张表，再使用include接口可以来获得", 
            "title": "数据关联"
        }, 
        {
            "location": "/other/common_problem/data_ios/#_5", 
            "text": "Q: 注册的时候如何给User表自定义的字段插值？ \nA: 有个 BmobUser 类用来操作用户相关的数据        BmobUser *bUser = [[BmobUser alloc] init];  \n    [bUser setUserName:@ 小明 ];  \n    [bUser setPassword:@ 123456 ];  \n    //age 为自定义  \n    [bUser setObject:@18 forKey:@ age ];  \n    [bUser signUpInBackground];   Q: 打开了邮箱验证功能，注册成功后未验证也能登录成功？ \nA: Bmob SDK中，邮箱的验证和用户的注册登录是异步的关系，也就是说，即使用户没有点击邮箱验证功能，也是一样可以登录成功的。如果需要限制用户的登录或者只能查看到登录后的部分功能，可以使用 [[[BmobUser getCurrentUser] objectForKey:@\"emailVerified\"] boolValue] 方法。   Q: Bomb邮箱认证是只需要开启邮箱认证就可以了吗？里面的内容要不要设置啊，比如发送给谁，邮箱地址什么的？ \nA: 开启就可以了使用了。内容可以不用设置，发送给谁、邮箱地址是什么是由SDK注册的时候用户填写的。   Q: ios注册的时候如何给User表自定义的字段插值 \nA: 有个BmobUser类用来操作用户相关的数据  BmobUser *bUser = [[BmobUser alloc] init];\n[bUser setUserName:@ 小明 ];\n[bUser setPassword:@ 123456 ];\n//age 为自定义\n[bUser setObject:@18 forKey:@ age ];\n[bUser signUpInBackground];   Q: 第三方用户授权注册登录后，如何绑定手机号呢？ \nA: 可以使用该绑定手机号的功能 手机号相关功能   Q: 退出登录接口 \nA: [BmobUser logout];   Q: 手机号是用户名，在忘记密码这一块，用什么来方法来查询用户名？用什么回调方法去判断用户是否已经注册 \nA: 可以直接使用条件查询来判断是否已经存在该用户   Q: 用第三方登录时,怎么将用户头像存入BmobUser中 \nA: 再建一个字段，将头像url存进去   Q: 我做了两个页面（viewcontroller）,在注册页面用[BmobUser setUsername:]等方法保存了用户账号密码的信息，成功之后使用[BmobUser loginWithUsernameInBackground:,**]这个方法保存后台，但是我在另一个页面，登录页面提取数据进行账号密码对比验证的时候，使用[BmobUser getCurrentUser]提取当前的账号密码，发现他的账号内容保存了下来，而密码的内容是NULL。不知道这是为什么 \nA: 密码是不能提取的，登录要用文档给定的接口   Q: ios中 ，怎么判断用户注册或是登陆的时候 处于联网状态还是非联网状态 \nA: 可以使用网络状态监听，这方面的资料有很多的～http://www.cnblogs.com/wendingding/p/3950114.html   Q: 请问每次登录后都会缓存用户的信息，但是好像没有缓存密码，那怎么实现缓存登录，也就是下次自动登录。 \nA: 密码是不会保存的，启动应用时直接使用下面代码判断用户是否已经登录  BmobUser *bUser = [BmobUser getCurrentObject];\nif (bUser) {\n//进行操作\n}else{\n//对象为空时，可打开用户注册界面\n}\n密码是不会保存的，启动应用时直接使用下面代码判断用户是否已经登录\nBmobUser *bUser = [BmobUser getCurrentObject];\nif (bUser) {\n//进行操作\n}else{\n//对象为空时，可打开用户注册界面\n}\n密码是不会保存的，启动应用时直接使用下面代码判断用户是否已经登录\nBmobUser *bUser = [BmobUser getCurrentObject];\nif (bUser) {\n//进行操作\n}else{\n//对象为空时，可打开用户注册界面\n}", 
            "title": "用户管理"
        }, 
        {
            "location": "/other/common_problem/data_ios/#_6", 
            "text": "Q: 客户端监控某个表或某一行数据，会使客户端电量或网络流量增加吗？如果表数据有变化时，是通过推送机制来通知客户端的吗？ \nA: 不会消耗多少网络流量的，是用websocket机制来通知客户端，不是通过推送，也没有离线消息的概念，一旦socket连接关闭，就不会收到后续消息。", 
            "title": "数据实时功能"
        }, 
        {
            "location": "/other/common_problem/data_ios/#acl", 
            "text": "Q: 如果每个用户都有写入权限，安全应该怎么做？  \nA: 可以设置ACL，详情请查看文档 ACL和角色 。   Q: ios安全问题，如果每个用户都有写入权限，安全应该怎么做？ \nA: 可以使用ACL来限制读写权限。   Q: 关于ACL安全控制的几个问题 \n1.在后台设置了某个表的权限为只读，那么app上调用setPublicWriteAccess，是不是对该表无效？ \n2.app上是否有acl的api改变表是只读还是acl控制？  \n3.下面代码是不是对该应用中所有表进行acl权限设置？  BmobACL *acl = [BmobACL ACL];\n//设置所有人读权限为true\n[acl setPublicReadAccess];\n//设置所有人写权限为true\n[acl setPublicWriteAccess];  如果只是对blog表权限设置，在上面的基础上加上blog.ACL= acl;即可？但是我觉得这样好像有点矛盾，因为如果前面的代码成立，那么后面的后面代码没有达到“只是对blog表”的权限修改的目标，反而到时所有表的权限都被修改了。 \n4.setPublicWriteAccess是对所有表的权限设置，有没有只针对某个表所有行的权限设置的api？ \n5.开发文档中的关于发表一篇不公开的日志的例子，我理解为是对表中都一条单独的数据进行acl权限控制，这种理解是否正确？ \n6.ACL能不能控制某个字段（也就是列）的访问权限？  A:  \n1.调用应该是有效的，这个你只需要简单测试一下就可以了。 \n2.除了只读后，其它情况都是acl控制。 \n3.不是对所有表进行设置，那个代码只是设置了权限，必须显示对某个表应用才行。 \n4.同3，并不是针对所有表进行设置。 \n5.是的 \n6.不能，只能控制表的访问。", 
            "title": "ACL和角色"
        }, 
        {
            "location": "/other/common_problem/data_ios/#_7", 
            "text": "Q: iOS上传文件只支持路径上传吗，不支持iOS的NSData或者image对象上传吗 \nA: 支持路径和NSData上传，可以查看BmobFile的头文件，里面有相关注释   Q: file字段中如何上传多张图片？ \nA: 一个file字段只能保存一个图片文件，多个图片可以使用数组将图片url保存下来   Q: File类型是视频文件，能不能在ios端直接通过File的地址播放视频呢？ \nA: 支持   Q: iOS 从相册获取到视频 然后如何上传 \nA: 直接通过路径或者NSData都可以   Q: 上传视频失败  \nA: 这种情况是初始化没有完成就开始进行请求导致的，可以监听kBmobInitSuccessNotification通知，监听到该事件后再上传即可   Q: 在ipv6下.无法获取到资源文件 \nA: 先看看ipv6的环境是否设置正确 设置方法 ,再看看相应的下载库是否支持ipv6。   Q: 1.69 SDK 文件服务更换为CDN上传是指什么？文档在哪里？ \nA: 原接口不变，只是服务器换了，服务会更稳定的", 
            "title": "文件"
        }, 
        {
            "location": "/other/common_problem/data_ios/#_8", 
            "text": "Q: 地理位置查询 返回的结果是已经排序的 \nA: 是排序好的，由近到远的顺序。   Q: 想查询10KM内的所有用户，并且按用户的某个字段属性排序，应该怎么做呢？因为发现只要按地理位置设置了条件，不管排序条件怎么设，最终都是按距离远近进行排序的... \nA: 做不了的，有地理位置条件的时候都是按从近到远排序的。距离相同再按别的排序", 
            "title": "地理位置"
        }, 
        {
            "location": "/other/common_problem/data_ios/#_9", 
            "text": "Q: 有iOS 点赞功能的demo吗？ \nA: 有的， Bmob点赞案例  实现的用户注册、用户登录、发贴、显示所有帖子资料以及对帖子进行点赞的功能 。   Q: 请问有对应的swift开发方法吗？ \nA: Swift项目中使用BmobSDK可以看这个文档： Swift项目中使用BmobSDK   Q: 支持什么编译器 \nA: Bmob完全支持iOS 64bit/32bit的真机和模拟器调试。   Q: 数据库中file字段无法导出吗？ \nA: 暂时只支持7种基本类型的导出：字符串(String)、数字(Number)、布尔值(Boolean)、\n数组（Array）、对象（Object）、日期（Date）和地理位置（GeoPoint）   Q: iOS开发restAPI中条件查询如何拼接请求 \nA: 写在url上面，可以先了解一下html中get和post的区别，get请求的参数都是写的url上的~   Q: bmob有iOS国际化文件没有 \nA: 国际化是需要你自己在本地做的，和Bmob无关。   Q: 出现错误\"msg\":\"authorization has expired\",\"code\":40300006 \nA: 应用太久没有请求导致的，先在控制台恢复一下应用数据就可以   Q: 等到查询成功得到结果后再执行下一步怎么办？ \nA: 需要放在block中进行。   Q: 出现错误Error Domain=cn.bmob.www Code=20002 \"connect failed!\" UserInfo={NSLocalizedDescription=connect failed! \nA: 网络问题，连接失败了，请尝试更换网络再次进行连接。   Q: The dependency  BmobSDK  is not used in any concrete target. \nA: 你好，应该是你的cocoapod升级了，新版本的需要指定下载的库给特定的target使用，如下，把CocoapodsDemo换成你的target名即可～  target “CocoapodsDemo” do\npod ‘BmobSDK’\nend   Q: 想迁移一个app的某个表数据到另一个app，怎么实现 \nA: 可以直接使用A应用的备份数据生成新应用提供给B应用使用，点击进入应用，设置-备份还原，选择最近一次备份生成新应用即可   Q: 怎样往一张表里面直接添加图片，不用代码 \nA: web上传   Q: os 用户删除 tableView 某一个单元格的数据，我怎么拿到用户点击的 index.row 去找到该行数据相应的 objectId？ \nA: 显示的时候是把bmobobject放在一个数组中显示,直接根据row找到对应的bmobobject，里面就有objectid   Q: 错误Error Domain=cn.bmob.www Code=100 \"db stopped\" UserInfo={NSLocalizedDescription=db stopped} \nA: 应用可能太久没使用被停止了，到控制台对应的应用的设置那里恢复一下数据   Q: Cocoapod集成后打开报错，提示缺失库。 \nA: 打开后缀xcworkspace的文件，而不是后缀xcodeproj 的文件   Q: 哪里可以看到错误码 \nA: 请查看iOS开发文档中的 错误代码列表 。", 
            "title": "其它问题"
        }, 
        {
            "location": "/other/common_problem/data_cocos2d-x/", 
            "text": "Cocos2d-x 常见问题\n\n\nQ: BmobQuery查询 怎么查看返回的data？\n\nA: CCLOG(\"%s\",(const char*)data);或者是BmobLog::bmob_log()\n\n\n\n\nQ: 要添加头文件？\n\n\n\n\nA: 不是添加文件的问题，是你的SecondScene没有实现BmobSaveDelegate接口，你实现BmobSaveDelegate接口就好了．\n\n\n\n\nQ: bmob中的cocos2d-x怎么不提供静态和动态库！而且里面还存在多种编码格式！请提供一下bmob coocs2d-x的动态库和静态库。或告知相信解决办法。\n\nA: 目前暂不提供。", 
            "title": "数据服务Cocos2d-X"
        }, 
        {
            "location": "/other/common_problem/data_cocos2d-x/#cocos2d-x", 
            "text": "Q: BmobQuery查询 怎么查看返回的data？ \nA: CCLOG(\"%s\",(const char*)data);或者是BmobLog::bmob_log()   Q: 要添加头文件？   A: 不是添加文件的问题，是你的SecondScene没有实现BmobSaveDelegate接口，你实现BmobSaveDelegate接口就好了．   Q: bmob中的cocos2d-x怎么不提供静态和动态库！而且里面还存在多种编码格式！请提供一下bmob coocs2d-x的动态库和静态库。或告知相信解决办法。 \nA: 目前暂不提供。", 
            "title": "Cocos2d-x 常见问题"
        }, 
        {
            "location": "/other/common_problem/data_csharp/", 
            "text": "C# 常见问题\n\n\nQ: 为什么我调用支付应用无论是支付宝还是微信点击都没有反应呢(请教一下unity接支付)\n\nA: 目前暂不支持Unity支持\n\n\n\n\nQ: unity端 查询表，会出现失败情况\n\n失败原因 Failed to connect to api.bmob.cn port 443: Timed out, and response content is \nUnityEngine.MonoBehaviour:print(Object)\n\nA: 提示连接超时，先检查一下网络状况。\n\n\n\n\nQ: unity不能缓存用户吗？\n\nA: c#没有进行用户缓存\n\n\n\n\nQ: Bmob能存放Unity的AssetBundle么\n\nA: 可以使用文件上传来存储～\n\n\n\n\nQ: 如何通过SDK删除用户表_User的数据\n\nA: 可以通过调用restful接口+master key来完成删除用户\n\n\n\n\nQ: C#SDK，使用Find功能，我自己封装一层查询的方法，想要获得bool的返回值，应该怎么实现\n\nA: 不能返回，只能使用回调，因为Find方法是异步执行的．\n\n\n\n\nQ: 请问在c#sdk可以使用master key吗？还是说要自己重新写？\n\nA: 不可以直接使用的，只有Restful api可以使用master key，你可以使用C#的http请求api来调用restful api\n\n\n\n\nQ: Bmob如何实现两张表的关联呢?\n\n比如我需要将User表与Role表进行关联，登录用户后，系统可以通过User的帐号来获取与之相应的Role表里面的信息？\n\nA: 可以，用列的pointer或者relation类型，具体用法看文档\n\n\n\n\nQ: Unity可以使用短信验证么，为什么找不到API\n\nA: 可以使用Unity的网络访问接口，调用restful来使用短信验证～\n\n\n\n\nQ: bmob sdk for unity3D 在unity3d5.3 下转il2cpp无法使用\n\n用 unity3D 5.3 打il2cpp 转c++ 后会报错：\n\nUnsupported internal call for IL2CPP:DynamicMethod::create_dynamic_method - System.Reflection.Emit is not supported.\n\n应该c++静态代码是不支持 System.Reflection.Emit 的反射类，能有其他解决方法吗？\nA: 这个目前还没有好的解决方法，JSON很多操作都用了反射～\n\n\n\n\nQ: unity3d bomb sdk 打包到IOS上.请求返回缺少404里面的数据.\n\nA: 升级u3d版本至5.3.2f以上。\n\n\n\n\nQ: 怎么做点赞的用户唯一性\n\n要做点赞，可以用原子计数器，但是无法知道是哪个用户点的赞，而且每个用户只能最多加一个赞，用Array来存用户objectid可以，但是存在多用户同时点赞相互覆盖对方的objectid的情况，请问有什么办法可以解决吗？\n\nA: 可以重新建立一张表，两个pointer字段一个指向点赞用户，一个指向被点赞的内容。\n\n\n\n\nQ: 怎样把github上下载的unitysdk注入到unity project里面\n\nA: 官网的文档比较老没有同步更新。直接看下案例（接下来把文档整理下）：\n\n\nhttps://github.com/bmob/bmob-demo-csharp/tree/master/examples/bmob-unity-demo\n\n\nlibs路径：\n\n\nhttps://github.com/bmob/bmob-demo-csharp/tree/master/examples/bmob-unity-demo/Assets/libs\n\n\n\n\nQ: untiy 开发怎么集成周围的人功能\n\nuntiy 开发怎么集成周围的人功能 可以做这个功能吗 大概怎么个思路 有相关的文档吗？\n\nA: 可以采用地理位置来实现，我们有现成的api返回一定范围内的用户记录。\n\n\n\n\nQ: C# BmobRelation做粉丝和关注怎么做\n\nA: 看RoleTest这个例子,https://github.com/bmob/BmobSharp/blob/master/BmobTest/BmobTask.cs\n\n\n\n\nQ: unity5中，最新版的bmob什么地方可以输入Application ID？\n\nA: https://github.com/bmob/bmob-demo-csharp/tree/master/examples/bmob-unity-demo\n\n\n\n\nQ: unity下，我如何传递参数到云端代码，然后获取云端运行后的回调呢？\n\nA:\n\n\n云端代码：\nfunction onRequest(request, response, modules) {\nvar res = {\nvalue\n: \njust string...\n} ;\nresponse.end(JSON.stringify(res));\n} \n\nC#调用代码：\n\n[TestMethod()]\npublic void EndpointParamAndStringTest()\n{\nvar p = new Dictionary\nString, Object\n();\n\nvar future = Bmob.EndpointTaskAsync\nObject\n(\ntestString\n, p);\nFinishedCallback(future.Result, null);\n}\n\n\n\n\n\n\n\nQ: bmob查询时记录返回值的表必须是自己新建的表吗？c#里不能用datatable吗？\n\nA: 返回值都是你创建的表，不一定是新的。这样C#才能映射到对应的object中去，让你对象化调用。\n\n\n\n\nQ: bmob使用指定列查询时会多出几种数据,分别是_type,，createdAt等。\n\nA: 是的，这些是默认的系统列，一定要有的。\n\n\n\n\nQ:\n\n1.unity里面必须使用BmobUnity Bmob = gameObject.GetComponent\n();\n\n来获取bmob对象吗 ？能不能 用C#DLL里面的 new方法呢？因为BmobUnity继承了mono所以不能new这个很麻烦，毕竟数据操作是模型层干的事情\n\n2.在查找数据的时候，Main.Bmob.Find方法不在主线程 ，也没有回调，导致后面的代码在结果出来之前优先执行了。\n\n3.以上两面我看c#的SDK完美解决了，可惜unity里面不能用c#的bmob.dll\n\n\nA:\n\n1.不能用new的方式，bmob异步请求用了MonoBehaviour#StartCoroutine\n\n2.没有回调？？自己先查看下API。\n\n3.Unity和C#不同的，Unity是一个封装的版本，需要兼容各个平台的东西。\n\n\n\n\nQ: C# sdk 只可以用Unity开发吗？visual c#可以用这SDK么？\n\nA: C# SDK可以用来开发Unity、visual c#，wp8这几类的程序。\n\n\n\n\nQ: unity中调用restapi方法分享\n\nA:", 
            "title": "数据服务C#"
        }, 
        {
            "location": "/other/common_problem/data_csharp/#c", 
            "text": "Q: 为什么我调用支付应用无论是支付宝还是微信点击都没有反应呢(请教一下unity接支付) \nA: 目前暂不支持Unity支持   Q: unity端 查询表，会出现失败情况 \n失败原因 Failed to connect to api.bmob.cn port 443: Timed out, and response content is \nUnityEngine.MonoBehaviour:print(Object) \nA: 提示连接超时，先检查一下网络状况。   Q: unity不能缓存用户吗？ \nA: c#没有进行用户缓存   Q: Bmob能存放Unity的AssetBundle么 \nA: 可以使用文件上传来存储～   Q: 如何通过SDK删除用户表_User的数据 \nA: 可以通过调用restful接口+master key来完成删除用户   Q: C#SDK，使用Find功能，我自己封装一层查询的方法，想要获得bool的返回值，应该怎么实现 \nA: 不能返回，只能使用回调，因为Find方法是异步执行的．   Q: 请问在c#sdk可以使用master key吗？还是说要自己重新写？ \nA: 不可以直接使用的，只有Restful api可以使用master key，你可以使用C#的http请求api来调用restful api   Q: Bmob如何实现两张表的关联呢? \n比如我需要将User表与Role表进行关联，登录用户后，系统可以通过User的帐号来获取与之相应的Role表里面的信息？ \nA: 可以，用列的pointer或者relation类型，具体用法看文档   Q: Unity可以使用短信验证么，为什么找不到API \nA: 可以使用Unity的网络访问接口，调用restful来使用短信验证～   Q: bmob sdk for unity3D 在unity3d5.3 下转il2cpp无法使用 \n用 unity3D 5.3 打il2cpp 转c++ 后会报错： \nUnsupported internal call for IL2CPP:DynamicMethod::create_dynamic_method - System.Reflection.Emit is not supported. \n应该c++静态代码是不支持 System.Reflection.Emit 的反射类，能有其他解决方法吗？\nA: 这个目前还没有好的解决方法，JSON很多操作都用了反射～   Q: unity3d bomb sdk 打包到IOS上.请求返回缺少404里面的数据. \nA: 升级u3d版本至5.3.2f以上。   Q: 怎么做点赞的用户唯一性 \n要做点赞，可以用原子计数器，但是无法知道是哪个用户点的赞，而且每个用户只能最多加一个赞，用Array来存用户objectid可以，但是存在多用户同时点赞相互覆盖对方的objectid的情况，请问有什么办法可以解决吗？ \nA: 可以重新建立一张表，两个pointer字段一个指向点赞用户，一个指向被点赞的内容。   Q: 怎样把github上下载的unitysdk注入到unity project里面 \nA: 官网的文档比较老没有同步更新。直接看下案例（接下来把文档整理下）：  https://github.com/bmob/bmob-demo-csharp/tree/master/examples/bmob-unity-demo  libs路径：  https://github.com/bmob/bmob-demo-csharp/tree/master/examples/bmob-unity-demo/Assets/libs   Q: untiy 开发怎么集成周围的人功能 \nuntiy 开发怎么集成周围的人功能 可以做这个功能吗 大概怎么个思路 有相关的文档吗？ \nA: 可以采用地理位置来实现，我们有现成的api返回一定范围内的用户记录。   Q: C# BmobRelation做粉丝和关注怎么做 \nA: 看RoleTest这个例子,https://github.com/bmob/BmobSharp/blob/master/BmobTest/BmobTask.cs   Q: unity5中，最新版的bmob什么地方可以输入Application ID？ \nA: https://github.com/bmob/bmob-demo-csharp/tree/master/examples/bmob-unity-demo   Q: unity下，我如何传递参数到云端代码，然后获取云端运行后的回调呢？ \nA:  云端代码：\nfunction onRequest(request, response, modules) {\nvar res = { value :  just string... } ;\nresponse.end(JSON.stringify(res));\n} \n\nC#调用代码：\n\n[TestMethod()]\npublic void EndpointParamAndStringTest()\n{\nvar p = new Dictionary String, Object ();\n\nvar future = Bmob.EndpointTaskAsync Object ( testString , p);\nFinishedCallback(future.Result, null);\n}   Q: bmob查询时记录返回值的表必须是自己新建的表吗？c#里不能用datatable吗？ \nA: 返回值都是你创建的表，不一定是新的。这样C#才能映射到对应的object中去，让你对象化调用。   Q: bmob使用指定列查询时会多出几种数据,分别是_type,，createdAt等。 \nA: 是的，这些是默认的系统列，一定要有的。   Q: \n1.unity里面必须使用BmobUnity Bmob = gameObject.GetComponent (); \n来获取bmob对象吗 ？能不能 用C#DLL里面的 new方法呢？因为BmobUnity继承了mono所以不能new这个很麻烦，毕竟数据操作是模型层干的事情 \n2.在查找数据的时候，Main.Bmob.Find方法不在主线程 ，也没有回调，导致后面的代码在结果出来之前优先执行了。 \n3.以上两面我看c#的SDK完美解决了，可惜unity里面不能用c#的bmob.dll  A: \n1.不能用new的方式，bmob异步请求用了MonoBehaviour#StartCoroutine \n2.没有回调？？自己先查看下API。 \n3.Unity和C#不同的，Unity是一个封装的版本，需要兼容各个平台的东西。   Q: C# sdk 只可以用Unity开发吗？visual c#可以用这SDK么？ \nA: C# SDK可以用来开发Unity、visual c#，wp8这几类的程序。   Q: unity中调用restapi方法分享 \nA:", 
            "title": "C# 常见问题"
        }, 
        {
            "location": "/other/common_problem/data_javascript/", 
            "text": "JavaScript 常见问题\n\n\nQ: 请问比目有TypeScript的前端sdk吗？主要是用在白鹭游戏引擎引擎里的。\n\nA: 这个暂时没有，有普通js的sdk\n\n\n\n\nQ: angularJs如何与bmob配合使用\n\nA: 一般这种情况需要将和Bmob的数据交互封装为一个service，从service中返回数据\n基本的调用层次就是controller调用service，service调用Bmob\nbmobservice.js\n\n\napp.service(\nbmobservice\n, function () {\n//添加一个资源  Bmob对象在index中初始化或者在app.run中进行初始化\nthis.AddResource =function(resource){\n    var ResourceInfo = Bmob.Object.extend(\nResourceInfo\n);\n\n    //创建对象\n    var resourceInfo = new ResourceInfo();\n    //为对象赋值\n    resourceInfo.set(\nTitle\n,resource.Title);\n    resourceInfo.set(\nResourceType\n,resource.ResourceType);\n    resourceInfo.set(\nTarget\n,resource.Target);\n\n    //resourceInfo.save();\n    var array = new Array();\n    var SubResourceInfo = Bmob.Object.extend(\nSubResourceInfo\n);\n    var subResourceInfo = new SubResourceInfo();\n    subResourceInfo.set(\nName\n,resource.SubResourceInfo[0].Name);\n    subResourceInfo.set(\nUrl\n,resource.SubResourceInfo[0].Url);\n    resourceInfo.set(\nSubResource\n,subResourceInfo);\n    resourceInfo.save();\n}\n});\n\n\n\n\n\ntestcontroller.js\n\n\napp.controller('testcontroller',function($scope,$resource,bmobservice){\n        $scope.addresource = function(){\n            var resource = {\n                \nTitle\n:\ntest\n,\n                \nResourceType\n:0,\n                \nTarget\n:\ntest\n,\n                \nSubResourceInfo\n:[{\n                    \nUrl\n:\ntesturl\n,\n                    \nName\n:\ntestname\n\n                }]\n            }\n            bmobservice.AddResource(resource);\n        }\n\n\n\n\n\n\nQ: 没有客户端请求的情况下服务端能主动向客户端发送数据吗？\n\nA: 不能\n\n\n\n\nQ: 有没有比较数据表中内容相似度的方法\n\n例如 我表里面有 一个组数据 name: 你好中国人， 我要往里面房数据但是如果我的数据为 name：中国人 ，就不放进去了。。判断两者为同一数据\n\nA: 这种定制化的需求需要开发者自行实现。\n\n\n\n\nQ: 有没有办法可以获取password\n\nA: 为安全考虑，我们不对外提供获取password字段值的功能。\n\n\n\n\nQ: Javascript的bmob的数据处理都是异步的，如何设置为同步\n\nA: 如果是在nodejs中，可使用async这个同步类库\n\n\n\n\nQ: 如何在node.js的代码中调用bmob\n\nA: 用bmob的nodejs模块\n\n\n\n\nQ: JS如果想产生多行数据保存到表中怎么办?\n\nA: 一次只能保存一条数据，多条数据需要使用批量操作，可以使用restful接口\n\n\n\n\nQ: js sdk中有更新某个表某个字段所有值的函数吗\n\nA: 没有的，只能一个个更新，restful有一个批量更新的接口，但是每次最多只能操作50条数据\n\n\n\n\nQ: JavaScript 传输数据时，自动加密了吗？\n\nA: Bmob所有SDK的通讯过程都进行了加密。\n\n\n\n\nQ: 消息推送 JS SDK支持吗？我使用H5进行APP开发\n\nA: JS有推送功能，可以查看推送文档。\n\n\n\n\nQ: BmobSocketIo.onUpdateTable可以无视ACL\n\nA: 实时监听功能不受ACL的限制。\n\n\n\n\nQ: JS SDK 的初始化语句应该放在哪里？\n\nA: 用框架集成到一个页面，例如angularjs 的ng-view。不然只能哪里用到，哪里调用\n\n\n\n\nQ: JS SDK可以增加模糊查询吗\n\nA: 目前JS并没有该接口，可使用JS的网络访问接口调用restful api实现，restful api中含有模糊查询的功能。\n\n\n\n\nQ: 我需要将数据加密后再保存到Bmob表吗？\n\nA: 所有SDK到服务器之间的数据都是经过对称加密算法加密后传输的。\n\n\n\n\nQ: JavaScript怎么在bomb数据库里面存入date类型。\n\nA:\n\n\nvar number = 42;\nvar string = \nthe number is \n + number;\nvar date = new Date();\nvar array = [string, number];\nvar object = { number: number, string: string };\n\nvar bigObject = new BigObject();\nbigObject.set(\nmyNumber\n, number);\nbigObject.set(\nmyString\n, string);\nbigObject.set(\nmyDate\n, date);\nbigObject.set(\nmyArray\n, array);\nbigObject.set(\nmyObject\n, object);\nbigObject.set(\nmyNull\n, null);\nbigObject.save();\n\n\n\n\n\n\nQ: bmob的query查询可以做对指定列做sum之类的聚合查询吗？\n\nA: 可以。具体查看JS使用文档\n\n\n\n\nQ: JS版里有多图片上传吗\n\nA: JS版没有多图片上传，需要自行处理\n\n\n\n\nQ: js中用户登录返回的session是不是都一样？\n\nA: 同一个用户多次登录返回的SessionToken是一样", 
            "title": "数据服务JavaScript"
        }, 
        {
            "location": "/other/common_problem/data_javascript/#javascript", 
            "text": "Q: 请问比目有TypeScript的前端sdk吗？主要是用在白鹭游戏引擎引擎里的。 \nA: 这个暂时没有，有普通js的sdk   Q: angularJs如何与bmob配合使用 \nA: 一般这种情况需要将和Bmob的数据交互封装为一个service，从service中返回数据\n基本的调用层次就是controller调用service，service调用Bmob\nbmobservice.js  app.service( bmobservice , function () {\n//添加一个资源  Bmob对象在index中初始化或者在app.run中进行初始化\nthis.AddResource =function(resource){\n    var ResourceInfo = Bmob.Object.extend( ResourceInfo );\n\n    //创建对象\n    var resourceInfo = new ResourceInfo();\n    //为对象赋值\n    resourceInfo.set( Title ,resource.Title);\n    resourceInfo.set( ResourceType ,resource.ResourceType);\n    resourceInfo.set( Target ,resource.Target);\n\n    //resourceInfo.save();\n    var array = new Array();\n    var SubResourceInfo = Bmob.Object.extend( SubResourceInfo );\n    var subResourceInfo = new SubResourceInfo();\n    subResourceInfo.set( Name ,resource.SubResourceInfo[0].Name);\n    subResourceInfo.set( Url ,resource.SubResourceInfo[0].Url);\n    resourceInfo.set( SubResource ,subResourceInfo);\n    resourceInfo.save();\n}\n});  testcontroller.js  app.controller('testcontroller',function($scope,$resource,bmobservice){\n        $scope.addresource = function(){\n            var resource = {\n                 Title : test ,\n                 ResourceType :0,\n                 Target : test ,\n                 SubResourceInfo :[{\n                     Url : testurl ,\n                     Name : testname \n                }]\n            }\n            bmobservice.AddResource(resource);\n        }   Q: 没有客户端请求的情况下服务端能主动向客户端发送数据吗？ \nA: 不能   Q: 有没有比较数据表中内容相似度的方法 \n例如 我表里面有 一个组数据 name: 你好中国人， 我要往里面房数据但是如果我的数据为 name：中国人 ，就不放进去了。。判断两者为同一数据 \nA: 这种定制化的需求需要开发者自行实现。   Q: 有没有办法可以获取password \nA: 为安全考虑，我们不对外提供获取password字段值的功能。   Q: Javascript的bmob的数据处理都是异步的，如何设置为同步 \nA: 如果是在nodejs中，可使用async这个同步类库   Q: 如何在node.js的代码中调用bmob \nA: 用bmob的nodejs模块   Q: JS如果想产生多行数据保存到表中怎么办? \nA: 一次只能保存一条数据，多条数据需要使用批量操作，可以使用restful接口   Q: js sdk中有更新某个表某个字段所有值的函数吗 \nA: 没有的，只能一个个更新，restful有一个批量更新的接口，但是每次最多只能操作50条数据   Q: JavaScript 传输数据时，自动加密了吗？ \nA: Bmob所有SDK的通讯过程都进行了加密。   Q: 消息推送 JS SDK支持吗？我使用H5进行APP开发 \nA: JS有推送功能，可以查看推送文档。   Q: BmobSocketIo.onUpdateTable可以无视ACL \nA: 实时监听功能不受ACL的限制。   Q: JS SDK 的初始化语句应该放在哪里？ \nA: 用框架集成到一个页面，例如angularjs 的ng-view。不然只能哪里用到，哪里调用   Q: JS SDK可以增加模糊查询吗 \nA: 目前JS并没有该接口，可使用JS的网络访问接口调用restful api实现，restful api中含有模糊查询的功能。   Q: 我需要将数据加密后再保存到Bmob表吗？ \nA: 所有SDK到服务器之间的数据都是经过对称加密算法加密后传输的。   Q: JavaScript怎么在bomb数据库里面存入date类型。 \nA:  var number = 42;\nvar string =  the number is   + number;\nvar date = new Date();\nvar array = [string, number];\nvar object = { number: number, string: string };\n\nvar bigObject = new BigObject();\nbigObject.set( myNumber , number);\nbigObject.set( myString , string);\nbigObject.set( myDate , date);\nbigObject.set( myArray , array);\nbigObject.set( myObject , object);\nbigObject.set( myNull , null);\nbigObject.save();   Q: bmob的query查询可以做对指定列做sum之类的聚合查询吗？ \nA: 可以。具体查看JS使用文档   Q: JS版里有多图片上传吗 \nA: JS版没有多图片上传，需要自行处理   Q: js中用户登录返回的session是不是都一样？ \nA: 同一个用户多次登录返回的SessionToken是一样", 
            "title": "JavaScript 常见问题"
        }, 
        {
            "location": "/other/common_problem/data_php/", 
            "text": "PHP 常见问题\n\n\nQ: php为什么添加数据的时候字段的值为中文就会出错\n\nA: 检查下你的php编码，建议改为utf-8编码。\n\n\n\n\nQ: 有没有ts的sdk\n\nA: php的sdk只有一个\n\n\n\n\nQ: 使用PHP CURL 推送消息的代码，推送不成功,能否给个例子\n\nA: 请检查证书是否设置好\n\n\n\n\nQ: 操作数据库的话，比如更新两个表，数据回滚有没有？\n\nA: Bmob暂时没有事务操作，你要想同时更新两个表的话，可以使用批量操作。\n\n\n\n\nQ: test.php出现unauthorized\n下载sdk之后，修改了配置文件的Application ID和REST API Key\n运行test.php出现BmobException: [0]: unauthorized \nA: app id 或 restful key不正确\n\n\n\n\nQ: php 这边可以插入关联对象吗？\n\nA: 现在官方有生成关联对象的方法 ：\n具体在bmob官方php接口中的BmobRestClient.class.php文件中的dataType()方法,可以自行阅读\n\n\n\n\nQ: bmob 最多能取多少条数据\n\nA: 一次最多1000条\n\n\n\n\nQ: bmob bql多表查询如何实现\n\nA: 目前不支持多表查询\n\n\n\n\nQ: php如何使用get（）方法取得不只100条数据？(PHPSDK如何循环获取数据?)\n\nA: 请使用分页查询，设置limit值，limit值默认为100，可以根据需要进行设置，具体可查看php文档https://github.com/bmob/bmob-php-sdk/tree/master/doc_develop中的分页查询章节\n\n\n\n\nQ: 获取表中所有数据后怎么单个输出自己需要的数据\n\nA: 查询后返回的是对象数组，您只需要遍历该数组即可。\n\n\n\n\nQ: PC上如何使用Bmob\n\nPC上只能用C#和PHP开发吗？\n\nA: #和PHP是我们官方出的SDK，你还可以根据restapi文档开发更多的SDK，非常简单。开发的时候需要注意点的是：1、https协议的问题； 2、header 和 body 的问题； 3、发送方式的问题，如POST、GET、PUT、DELETE。\n\n\n\n\nQ: 我有两个表，_User可以放用户的数据，另一个表的password怎么设置成密码？\n\nA: 只有使用_User表的密码才能使用BmobUser的功能，否则接口需要自己再写\n\n\n\n\nQ: 实时数据是什么原理？是客户端轮询吗？\n\nA: 客户端与服务器维护了一个长连接，有消息时由服务端主动推送消息", 
            "title": "数据服务PHP"
        }, 
        {
            "location": "/other/common_problem/data_php/#php", 
            "text": "Q: php为什么添加数据的时候字段的值为中文就会出错 \nA: 检查下你的php编码，建议改为utf-8编码。   Q: 有没有ts的sdk \nA: php的sdk只有一个   Q: 使用PHP CURL 推送消息的代码，推送不成功,能否给个例子 \nA: 请检查证书是否设置好   Q: 操作数据库的话，比如更新两个表，数据回滚有没有？ \nA: Bmob暂时没有事务操作，你要想同时更新两个表的话，可以使用批量操作。   Q: test.php出现unauthorized\n下载sdk之后，修改了配置文件的Application ID和REST API Key\n运行test.php出现BmobException: [0]: unauthorized \nA: app id 或 restful key不正确   Q: php 这边可以插入关联对象吗？ \nA: 现在官方有生成关联对象的方法 ：\n具体在bmob官方php接口中的BmobRestClient.class.php文件中的dataType()方法,可以自行阅读   Q: bmob 最多能取多少条数据 \nA: 一次最多1000条   Q: bmob bql多表查询如何实现 \nA: 目前不支持多表查询   Q: php如何使用get（）方法取得不只100条数据？(PHPSDK如何循环获取数据?) \nA: 请使用分页查询，设置limit值，limit值默认为100，可以根据需要进行设置，具体可查看php文档https://github.com/bmob/bmob-php-sdk/tree/master/doc_develop中的分页查询章节   Q: 获取表中所有数据后怎么单个输出自己需要的数据 \nA: 查询后返回的是对象数组，您只需要遍历该数组即可。   Q: PC上如何使用Bmob \nPC上只能用C#和PHP开发吗？ \nA: #和PHP是我们官方出的SDK，你还可以根据restapi文档开发更多的SDK，非常简单。开发的时候需要注意点的是：1、https协议的问题； 2、header 和 body 的问题； 3、发送方式的问题，如POST、GET、PUT、DELETE。   Q: 我有两个表，_User可以放用户的数据，另一个表的password怎么设置成密码？ \nA: 只有使用_User表的密码才能使用BmobUser的功能，否则接口需要自己再写   Q: 实时数据是什么原理？是客户端轮询吗？ \nA: 客户端与服务器维护了一个长连接，有消息时由服务端主动推送消息", 
            "title": "PHP 常见问题"
        }, 
        {
            "location": "/other/common_problem/data_restful/", 
            "text": "Restful 常见问题\n\n\nQ: RestApi 如何进行ACL查询呢\n\n比如有一张表，设置了某条数据，某个用户才能读取查看，那该用户如何获取该条数据呢使用RestApi\n\nA: 普通的查询就可以获取了，只要设置了ACL，其它使用就是正常的读写，如果没有权限会有提示\n\n\n\n\nQ: 上传成功，移动文件位置，请问keyoffile 和group代表什么\n\n请问我用C#调用restApi上传文件成功，想把文件移动到指定的位置，文档说用PUT请求，发送data： {keyOfFile:{\"__type\":\"File\",\"group\":\"upyun\",\"filename\": fileName, url: url}，请问里面的keyoffile 和group代表什么\n\nA: keyOfFile表示你存文件的那个表的字段名，group填个group1就可以了\n\n\n\n\nQ: STM32主板上其他模块获取到的数据怎么通过GPRS上传到服务器上\n\nA: 得看你的板子是否支持https请求，如果支持https请求则可以直接使用restful接口进行上传\n\n\n\n\nQ: RESTAPI 的文档中提到了发送请求创建ACL规则时的body内容，请问发送该请求时的url是什么？\n\nA: 访问哪张表，就给那张表的acl字段进行更新就可以了\n\n\n\n\nQ: bql是否支持limit order by\n\nA: 支持，写法如下bql=select * from VersionInfo limit 0,1 order by -version，limit 后面跟两个参数，第一个表示跳过的记录，第二个表示返回的记录数\n\n\n\n\nQ: restAPI只能通过443端口https访问不能通过80http访问吗？\n\nA: 是的，只能通过htts访问\n\n\n\n\nQ: RestApi如何让数据库的某一字段增加1\n\nA: 使用原子计算器来实现\n\n\n\n\nQ: 想通过GPRS模块利用tcp协议上传数据，利用restapi，怎么确认云服务器的ip地址？\n\nA: restapi都是通过https协议来进行请求的\n\n\n\n\nQ: 在Android应用中，不使用BmobSDK，仅用RestAPI, 做到接收推送消息\n\nA: 发布推送可以不使用sdk，但接收推送需要用到。\n\n\n\n\nQ: C++ 使用curl post 数据产生中文乱码\n\nA: ，把文件改为 UTF-8 无BOM格式\n\n\n\n\nQ: restAPI 使用短信验证码进行密码重置问题\n\n用短信验证码进行密码重置 的接口 https://api.bmob.cn/1/resetPasswordBySmsCode ，从接口描述来看，需要上传的信息只有 验证码和新密码，用户的 session 或手机号都不需要上传。\n\n那后台如何知道这个验证码是哪个手机号发来的呢？\n\nA: 后台是根据你的手机号来生成验证码的，服务端可以知道具体的验证码对应哪个手机号，请放心使用\n\n\n\n\nQ: 我需要多图上传，云端数据库的表应该怎么处理多图逻辑，类似于qq空间的多图上传，\n\nA: 可以在图片上传后把url保存在一个数组当中\n\n\n\n\nQ: 如何用Rest api创建表设置唯一键\n\nA: 唯一键的的设置暂时没有开放restapi接口，我们会考虑进去，后续加入。\n\n\n\n\nQ: 使用Pointer能否“反向”查询？\n\n有一个用户表User，一个公司表Company。每个用户都有一个Pointer字段指向某一个公司。请问如何在查询公司信息的时候，一次性把公司包含的所有用户都查出来？\n\nA: 目前没有这样的功能，只能在查询到具体的公司信息后，再用Company对象去约束用户表，把该公司下的用户信息查询出来\n\n\n\n\nQ: 可否使用C++集成\n\nA: 用restapi文档对接C++就可以了\n\n\n\n\nQ: 如何比较updatedAt字段\n\nA: 例:where={\"createdAt\":{\"$gte\":{\"__type\":\"Date\",\"iso\":\"2011-08-21 18:02:52\"}}}\n\n\n\n\nQ: 想要测试一下平台的短信服务，出现错误10011 no remaining number for send messages. 该账户无可用的发送短信条数，每个账号不是存在100条可用短信吗？\n\nA: 除了100条限制外还有以下限制的，短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条。\n\n\n\n\nQ: 如果列没数据为空，返回行据然列字段名都不返回\n\nA: Bmob使用的MongoDB数据库，该数据库是无模式的，也就是说您并不需要事先设置列值，而对于某个对象，如果你没有明确设置其值，那么该值就是空的，不存在默认值。\n\n\n\n\nQ: 我在一张表中加关系性字段，为什么是在关联表里新建一行，而不可以选择关联表里已经存在的对象\n\nA: 目前只能通过请求添加relation关系，web端无法添加。\n\n\n\n\nQ: 在【快速入门】【RestAPI快速入门】的CURL例子中的URL的“GameScore”是什么意思？\n\n在【快速入门】【RestAPI快速入门】的CURL例子中的URL的“GameScore”是什么意思？我需要将这个\"GameScore\"改为我的应用名字吗？还是改成我的表的名字？\n\nA: GameScore是表名，你可以改为你自己的表的名字。\napplication id才是对应你的应用。\n\n\n\n\nQ: restAPI一个post请求后，提示error：unauthorized是什么意思\n\nA: 发送方式有问题，没有把application id 和 rest key正确发送到Bmob后端\n\n\n\n\nQ: 使用httpClient POST请求一个接口返回的错误信息content is empty.\n\nA: 错误的含义：post请求里body内容为空\n\n\n\n\nQ: Master Key不能用在RestApi上吗？\n\nA: 可以。masterkey是超级权限，不会受到表是否只读的限制，对于restapi、云端代码和SDK都一样的。\n\n\n\n\nQ: restApi中注册用户邮箱验证功能，可不可以在注册时emailVerified直接赋true\n\nA: 不行的，emailVerified是系统内置的字段，后端有邮件的触发行为，不能直接的赋值为true。如果你不想用这个字段，完全忽略就可以了。\n\n\n\n\nQ: restApi查询表可以去掉重复的记录吗 就像sql的 distinct\n\nA: 暂无该功能。\n\n\n\n\nQ: restapi 过滤用中文过滤不了\n\nwhere={\"name\":\"guangzhou\"} 这个ok\n\nwhere={\"name\":\"广州\"} 这个不行\n\nA: 注意使用urlencode编码，不会存在中文匹配不了的问题的。\n\n\n\n\nQ: ajax不支持非标准的http请求头，像“X-Bmob-Application-Id”这种非标准的请求头，在ajax中是不被接受的，当ajax请求中设置了“X-Bmob-Application-Id”，这个请求的method就变成了\"options\"这个非标准的方法。\n\nA: js的调用请使用bmob提供的js sdk，在sdk中已经解决了这个问题\n\n\n\n\nQ: 在我不知道用户密码的情况下 可以通过其他字段进行查询user用户表吗\n\nA: 可以查询\n\n\n\n\nQ:  如何在线测试RestApi\n\nA: 使用Chrome浏览器的Postman插件就可以进行调试了。\n点击链接Postman下载地址\n。\n\n\n界面效果\n点击这里查看\n。\n\n\n\n\nQ: Postman发起数据请求没有反应\n\nA: 首先先检查本地网络，通常是因为本地网络或者Postman没有成功发出数据请求，其次可以打开\nhttps://api.bmob.cn/\n查看是否能打开进行测试。\n\n\n\n\nQ: 其他语言用RestApi开发遇到请求security的错误\n\nA: 请查找相关语言访问HTTPS的配置问题。\n如PHP用CURL开发时，需要添加如下脚本：\n\n\ncurl_setopt($c, CURLOPT_SSL_VERIFYPEER, FALSE);\ncurl_setopt($c, CURLOPT_SSL_VERIFYHOST, FALSE);\n\n\n\n\n\n\nQ: 能提供Java调用RestApi的示例代码吗\n\nA: 点击下面的链接可以看到Java调用RestApi的示例代码：\n\n\nhttp://wenda.bmob.cn//?/question/51\n\n\nhttp://wenda.bmob.cn/?/question/859\n\n\n\n\nQ: 关于where条件的问题\n\nA: 有开发者提出用PostMan请求的时候没有问题，但是用Java请求构造了where查询条件的时候有错（请求的格式大致如， \nhttps://api.bmob.cn/1/classes/Footballer?limit=20\nwhere={\"location\": {\"$nearSphere\": {\"__type\": \"GeoPoint\",\"latitude\": 32.31735060,\"longitude\": 118.32457035 }}}\n ）。\n\n\n这个问题是因为特殊字符导致的问题，大家可以参考以下的解决方案：\n\n\nhttp://stackoverflow.com/questions/636770/is-there-any-java-equivalent-of-phps-http-build-query-function\n\n\n顺便说一句，PHP中的话，可以直接用\nhttp_build_query\n方法构造请求参数。\n\n\n\n\nQ: Restapi有IM吗？\n\nA: restapi可以发送推送信息，也可以通过get的方式获取聊天内容，但没有开放长连接服务，也就是说用restapi可以实现im功能，但方法只能通过定时器+get数据的方式。\n\n\n\n\nQ: 哪里可以看到错误码\n\nA: \n点击这里\n可以查看RestApi的错误码列表。", 
            "title": "数据服务RESTful"
        }, 
        {
            "location": "/other/common_problem/data_restful/#restful", 
            "text": "Q: RestApi 如何进行ACL查询呢 \n比如有一张表，设置了某条数据，某个用户才能读取查看，那该用户如何获取该条数据呢使用RestApi \nA: 普通的查询就可以获取了，只要设置了ACL，其它使用就是正常的读写，如果没有权限会有提示   Q: 上传成功，移动文件位置，请问keyoffile 和group代表什么 \n请问我用C#调用restApi上传文件成功，想把文件移动到指定的位置，文档说用PUT请求，发送data： {keyOfFile:{\"__type\":\"File\",\"group\":\"upyun\",\"filename\": fileName, url: url}，请问里面的keyoffile 和group代表什么 \nA: keyOfFile表示你存文件的那个表的字段名，group填个group1就可以了   Q: STM32主板上其他模块获取到的数据怎么通过GPRS上传到服务器上 \nA: 得看你的板子是否支持https请求，如果支持https请求则可以直接使用restful接口进行上传   Q: RESTAPI 的文档中提到了发送请求创建ACL规则时的body内容，请问发送该请求时的url是什么？ \nA: 访问哪张表，就给那张表的acl字段进行更新就可以了   Q: bql是否支持limit order by \nA: 支持，写法如下bql=select * from VersionInfo limit 0,1 order by -version，limit 后面跟两个参数，第一个表示跳过的记录，第二个表示返回的记录数   Q: restAPI只能通过443端口https访问不能通过80http访问吗？ \nA: 是的，只能通过htts访问   Q: RestApi如何让数据库的某一字段增加1 \nA: 使用原子计算器来实现   Q: 想通过GPRS模块利用tcp协议上传数据，利用restapi，怎么确认云服务器的ip地址？ \nA: restapi都是通过https协议来进行请求的   Q: 在Android应用中，不使用BmobSDK，仅用RestAPI, 做到接收推送消息 \nA: 发布推送可以不使用sdk，但接收推送需要用到。   Q: C++ 使用curl post 数据产生中文乱码 \nA: ，把文件改为 UTF-8 无BOM格式   Q: restAPI 使用短信验证码进行密码重置问题 \n用短信验证码进行密码重置 的接口 https://api.bmob.cn/1/resetPasswordBySmsCode ，从接口描述来看，需要上传的信息只有 验证码和新密码，用户的 session 或手机号都不需要上传。 \n那后台如何知道这个验证码是哪个手机号发来的呢？ \nA: 后台是根据你的手机号来生成验证码的，服务端可以知道具体的验证码对应哪个手机号，请放心使用   Q: 我需要多图上传，云端数据库的表应该怎么处理多图逻辑，类似于qq空间的多图上传， \nA: 可以在图片上传后把url保存在一个数组当中   Q: 如何用Rest api创建表设置唯一键 \nA: 唯一键的的设置暂时没有开放restapi接口，我们会考虑进去，后续加入。   Q: 使用Pointer能否“反向”查询？ \n有一个用户表User，一个公司表Company。每个用户都有一个Pointer字段指向某一个公司。请问如何在查询公司信息的时候，一次性把公司包含的所有用户都查出来？ \nA: 目前没有这样的功能，只能在查询到具体的公司信息后，再用Company对象去约束用户表，把该公司下的用户信息查询出来   Q: 可否使用C++集成 \nA: 用restapi文档对接C++就可以了   Q: 如何比较updatedAt字段 \nA: 例:where={\"createdAt\":{\"$gte\":{\"__type\":\"Date\",\"iso\":\"2011-08-21 18:02:52\"}}}   Q: 想要测试一下平台的短信服务，出现错误10011 no remaining number for send messages. 该账户无可用的发送短信条数，每个账号不是存在100条可用短信吗？ \nA: 除了100条限制外还有以下限制的，短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条。   Q: 如果列没数据为空，返回行据然列字段名都不返回 \nA: Bmob使用的MongoDB数据库，该数据库是无模式的，也就是说您并不需要事先设置列值，而对于某个对象，如果你没有明确设置其值，那么该值就是空的，不存在默认值。   Q: 我在一张表中加关系性字段，为什么是在关联表里新建一行，而不可以选择关联表里已经存在的对象 \nA: 目前只能通过请求添加relation关系，web端无法添加。   Q: 在【快速入门】【RestAPI快速入门】的CURL例子中的URL的“GameScore”是什么意思？ \n在【快速入门】【RestAPI快速入门】的CURL例子中的URL的“GameScore”是什么意思？我需要将这个\"GameScore\"改为我的应用名字吗？还是改成我的表的名字？ \nA: GameScore是表名，你可以改为你自己的表的名字。\napplication id才是对应你的应用。   Q: restAPI一个post请求后，提示error：unauthorized是什么意思 \nA: 发送方式有问题，没有把application id 和 rest key正确发送到Bmob后端   Q: 使用httpClient POST请求一个接口返回的错误信息content is empty. \nA: 错误的含义：post请求里body内容为空   Q: Master Key不能用在RestApi上吗？ \nA: 可以。masterkey是超级权限，不会受到表是否只读的限制，对于restapi、云端代码和SDK都一样的。   Q: restApi中注册用户邮箱验证功能，可不可以在注册时emailVerified直接赋true \nA: 不行的，emailVerified是系统内置的字段，后端有邮件的触发行为，不能直接的赋值为true。如果你不想用这个字段，完全忽略就可以了。   Q: restApi查询表可以去掉重复的记录吗 就像sql的 distinct \nA: 暂无该功能。   Q: restapi 过滤用中文过滤不了 \nwhere={\"name\":\"guangzhou\"} 这个ok \nwhere={\"name\":\"广州\"} 这个不行 \nA: 注意使用urlencode编码，不会存在中文匹配不了的问题的。   Q: ajax不支持非标准的http请求头，像“X-Bmob-Application-Id”这种非标准的请求头，在ajax中是不被接受的，当ajax请求中设置了“X-Bmob-Application-Id”，这个请求的method就变成了\"options\"这个非标准的方法。 \nA: js的调用请使用bmob提供的js sdk，在sdk中已经解决了这个问题   Q: 在我不知道用户密码的情况下 可以通过其他字段进行查询user用户表吗 \nA: 可以查询   Q:  如何在线测试RestApi \nA: 使用Chrome浏览器的Postman插件就可以进行调试了。 点击链接Postman下载地址 。  界面效果 点击这里查看 。   Q: Postman发起数据请求没有反应 \nA: 首先先检查本地网络，通常是因为本地网络或者Postman没有成功发出数据请求，其次可以打开 https://api.bmob.cn/ 查看是否能打开进行测试。   Q: 其他语言用RestApi开发遇到请求security的错误 \nA: 请查找相关语言访问HTTPS的配置问题。\n如PHP用CURL开发时，需要添加如下脚本：  curl_setopt($c, CURLOPT_SSL_VERIFYPEER, FALSE);\ncurl_setopt($c, CURLOPT_SSL_VERIFYHOST, FALSE);   Q: 能提供Java调用RestApi的示例代码吗 \nA: 点击下面的链接可以看到Java调用RestApi的示例代码：  http://wenda.bmob.cn//?/question/51  http://wenda.bmob.cn/?/question/859   Q: 关于where条件的问题 \nA: 有开发者提出用PostMan请求的时候没有问题，但是用Java请求构造了where查询条件的时候有错（请求的格式大致如，  https://api.bmob.cn/1/classes/Footballer?limit=20 where={\"location\": {\"$nearSphere\": {\"__type\": \"GeoPoint\",\"latitude\": 32.31735060,\"longitude\": 118.32457035 }}}  ）。  这个问题是因为特殊字符导致的问题，大家可以参考以下的解决方案：  http://stackoverflow.com/questions/636770/is-there-any-java-equivalent-of-phps-http-build-query-function  顺便说一句，PHP中的话，可以直接用 http_build_query 方法构造请求参数。   Q: Restapi有IM吗？ \nA: restapi可以发送推送信息，也可以通过get的方式获取聊天内容，但没有开放长连接服务，也就是说用restapi可以实现im功能，但方法只能通过定时器+get数据的方式。   Q: 哪里可以看到错误码 \nA:  点击这里 可以查看RestApi的错误码列表。", 
            "title": "Restful 常见问题"
        }, 
        {
            "location": "/other/common_problem/cloud_function/", 
            "text": "云函数常见问题\n\n\nQ:使用云函数需要掌握什么语言\n\n\nA:\nJavascript\n，因为云函数是用\nNodejs\n部署架构的。\n\n\n\n\nQ:云函数能做什么事情\n\n\nA:云函数的推出是为了给大家解决更多后端业务逻辑的问题，让大家尽可能把更多的业务逻辑挪到云端，实现更快的更新迭代。目前，云函数除可以自由操作云端数据库外，还提供了\n邮件模块\n、\nHTTP模块\n和\n事件模块\n等，方便大家自由发挥。\n\n\n\n\nQ:云函数能上传文件吗\n\n\nA:暂不支持。\n\n\n\n\nQ:如何调试云函数\n\n\nA:\n- Bmob在Web端（当前云函数的下边）为大家提供最简单的云函数的调试工具。\n- 云函数本地化调试工具：\nhttps://github.com/bmob/bmob-cloud-tool\n 。\n\n\n\n\nQ:云函数或者android上update能否不用objectid用组合条件\n\n\nA:只能根据objectid来，在查询返回的结果集中有objectid\n\n\n\n\nQ:云函数，可以把消息发给IMSDK吗\n\n\nA:目前不可以。\n\n\n\n\nQ:url转码怎么转\n\n\nA: encodeURI(url)\n\n\n\n\nQ:如何使用同步的ohttp.post请求\n\n\nA:用eventproxy\n\n\n\n\nQ:相同的代码，在Local中可以返回正确的结果，在Server中返回错误。请问如何解决？\n\n\nA:把本地的nodejs版本改成和云端一样，然后调试通过就可以了\n\n\n\n\nQ:bmob的短信服务端验证接口云函数怎么做？要发送一个post请求\n\n\nA:使用云函数发送http请求即可\n\n\n\n\nQ:生成新应用时云函数没有复制到新应用\n\n\nA:可使用云函数的本地调试工具可以运行后可以直接导入\n\n\n\n\nQ:云函数能否实现 WebSocket ？\n\n\nA:云函数无法使用第三方库\n\n\n\n\nQ:往表中添加基本类型的数据是调用数据库对象的insert方法，而添加关联关系对象是用add方法？？那我的表里有这两种数据类型，该怎么添加数据\n\n\nA:分别存储\n\n\n\n\nQ:保存一个Object类型字段的值为null的时候会报错\n\n\nA:保存为这样{}\n\n\n\n\nQ:如何实现一个签到的逻辑\n\n\nA:在用户表添加一个字段--签到时间，当用户发送请求的时候，更新这个签到时间，如果签到时间为今天，说明已经签到\n\n\n\n\nQ:where语句如何查询24小时之前创建的记录？\n\n\nA:查询createdAt在24小时之前的记录就可以了\n\n\n\n\nQ:删除数据库记录只能用objectId吗？不能用where条件吗\n\n\nA:只能用objectId,where条件用于查询，查询后的结果集中会有ObjectId的。\n\n\n\n\nQ:云函数怎么设定where条件\n\n\nA:\n\n\nwhere\n:{\n\nupdatedAt\n:{\n\n$lt\n:{\n__type\n:\nDate\n,\niso\n:\n2014-01-29 11:33:53\n}\n}\n\n\n\n\n\n\n\nQ:在查找数据库的回调里面再查找，不能收到回调消息\n\n\ndb.find(\n{\n\ntable\n:strTableName,\n\ncount\n:1,\n\nlimit\n:0,\n},\nfunction(err1,data1)\n{ \nvar searchNum = data1; //表的总行数，用sql语句获得\nvar limitnum=1000; //默认最多返回1000条记录\nvar runcount= parseInt(searchNum/1000); \nvar strOutID = '';\n\n//分多次获取记录，因为每次只能获取1000条\nvar i = 0;\n\nfor(i = 0;i !== runcount; i++){\n\nvar skipNum= 1000*i;\nif( i==runcount ) {\nlimitnum=searchNum-skipNum;\n} else {\nlimitnum=1000;\n}\n//能执行到这里，\n//response.send('data1'); \ndb.find(\n{\n\ntable\n:strTableName,\n\ncount\n:1,\n\nlimit\n:0,\n},\nfunction(err2,data2)\n{\n//这里执行不到\nresponse.send('data2'); \n}\n);\n} \n}\n);\n\n\n\n\nA:不能这样取，只能取一次，然后再取一次，不能在里面for循环\n\n\n\n\nQ:云函数可以查询支付订单吗？返回订单结果和数额之类的，有相关函数吗\n\n\nA:可以使用云函数去调用restful接口来查询\n\n\n\n\nQ:云函数可以实现抓取别的网页信息吗\n比如说，我客户端去请求云函数，让云函数实现抓取某个咨询网站的信息\n\n\nA:可以，使用云函数的http请求抓取即可。\n\n\n\n\nQ:请问云函数可以发送短信吗？\n\n\nA:可以通过云函数调用restful接口来实现。\n\n\n\n\nQ:云函数更新用户表错误\n但是最后返回的err包含错误信息\n{\"code\":206,\"message\":\"User cannot be altered without sessionToken Error.\"}\n\n\nA:必须先登录才能更新\n\n\n\n\nQ:请问云函数怎么返回JSON数据\n\n\nA:\n\n\nvar data = { dir: 'kunhony', param: 'archive' };\nvar str = JSON.stringify(data);\nresponse.end(str);\n\n\n\n\n\n\nQ:如何在云端请求微信\n\n\nA:http://docs.bmob.cn/cloudcode/WEB/d_cloudcodeweixin/doc/index.html\n\n\n\n\nQ:Bmob中如何支持Cookie？用于将SessionID分配给浏览器\n\n\nA:不支持set-cookie的方法。\n\n\n\n\nQ:请问云函数如何返回错误？\n\n\nA:如下，代码一般为这种形式，如果错误，返回response.send(err);\n\n\nfunction onRequest(request, response, modules) {\n\nvar functions = modules.oFunctions;\n\nfunctions.run({\n   \nname\n: \ntest\n,\n   \ndata\n:{\ncontent\n:\n你好\n,\naddress\n:\nguangzhou\n}\n},function(err,data){\n   //回调函数\n   if(err){\n       response.send(err);\n    }else {\n       response.send(data);\n    }\n});\n}\n\n\n\n\n\n\nQ:开发公众号可以获取微信的openid吗\n\n\nA:可以\n\n\n\n\nQ:云函数如何进行模糊查询\n\n\nA:调用restful的模糊查询接口\n\n\n\n\nQ:云函数能引入第三方模块吗？如underscore\n\n\nA:不可以，如要使用第三方模块，可考虑使用窗口服务。\n\n\n\n\nQ:我有一个云函数，客户端访问的时候查看一条数据库对象，如果不存在，则创建、返回，如果存在则直接返回。所有客户端的访问都是查看同一个对象，如何保证多个客户端同时访问的时候不会同时创建多个对象？\n\n\nA:目前这个无法做到。\n\n\n\n\nQ:bql不支持 delete语句吗\n\n\nA:目前bql只支持查询语句。\n\n\n\n\nQ:表设置了 ACL， 我想用 master key 或 用户的 token 去更新表，在云端用批量更新模块，如何传入master key 或 用户的 token ？\n\n\nA:目前不支持\n\n\n\n\nQ:云函数怎么延迟执行一个操作\n\n\nA:目前并无该项功能\n\n\n\n\nQ:云函数中不同的模块中经常出现相同代码 有没有办法把这些代码提取到公共区域来复用\n\n\nA:云函数之间是可以相互调用的，具体查看云函数云对象章节。\n\n\n\n\nQ:如何清空某个数据表？\n\n\nA:需要先将表的所有值查询下来，然后遍历去删除，具体参考文档的查询及删除对象章节\n\n\n\n\nQ:怎么在云端调用 获取短信验证码、验证短信验证码\n\n\nA:使用云函数进行http请求，请求RESTful接口即可\n\n\n\n\nQ:云端如何自定义返回数据\n\n\nA:定义好格式后以JSON形式返回\n\n\n\n\nQ:云函数MD5加密中文，结果怎么和PHP的不一样？\n\n\nA:编码问题，https://cnodejs.org/topic/54ad4e40ce87bace2444cc49\n\n\n\n\nQ:BMOB云端数据库导入需手动导入CSV格式，如何做到自动抓取我本地CSV文件传入云端数据库\n\n\nA:Bmob导入数据，只可以从web后台手动导入。如果你要自动从本地传入数据库的话，可以自己写代码（程序）实现，用Bmob提供的SDK或基于RestApi来插入数据到云端数据库中。\n\n\n\n\nQ:云端数据库更新需上传CSV文件，如何实现自动云端更新\n\n\nA:云端数据库与你本地数据库的结构可能会有区别，需要你针对自己的数据库特点，读取本地数据库，转换后再进行上传\n\n\n\n\nQ:用云端查询db.find，查询到表里的数据，返回的字段名也是表的列名，有没有像sql里面as的方式修改这个名字\n\n\nA:目前还没有这个功能\n\n\n\n\nQ:如果一个字段里没有值，查询后返回的内容也没有这个字段，如果才能让这个字段也出现在返回的内容里。\n\n\nA:由于后台使用的是MongoDB，是无模式的，没有初始值，因此只有显示地给该字段赋值才会有内容返回。\n\n\n\n\nQ:写云函数的时候，只能通过objectId来查询符合条件的一行数据？我想用表中的其他字段当做查询条件怎么写?\n\n\nA:可以使用条件查询，具体查看数据库对象中的查询多条数据小节。\n\n\n\n\nQ:用skip和limit来实现分页查询的话，如果表里的数据更新的很快的话，会不会查询出重复的数据？\n\n\nA:会出现重复数据，因此，一般您在查询时可以加上限制，比如，查询第一页时的时间为A，那您可以约束查询创建时间在A之前的数据，在那之后的数据不查询，这样就不会有重复了。\n\n\n\n\nQ:该如何实现类似乐观锁的功能\n\n\nA:目前并没有提供该类型的接口\n\n\n\n\nQ:连上vpn没有数据返回\n\n\nA:可以在连上VPN时ping https://api.bmob.cn/看看能否ping通，有可能是VPN屏蔽了\n\n\n\n\nQ:云函数中where条件怎么表示!=？\n\n\nA:您好，可以参考restful文档中的查询数据中的条件查询，大概的形式为\"type\":{\"$ne\":\"delete\"}\n\n\n\n\nQ:如何更新1000条以上的记录\n\n\nA:可以采用分页，先取1000条数据进行更新，再取1000条之后的数据接着更新\n\n\n\n\nQ:请问云函数请求HTTP时如何获取cookies和带cookies访问？\n\n\nA:将var http = modules.oHttp；\n改成var http = modules.oHttp.defaults({jar: true});\n即可使用全局cookie，后面的链接就不需要手动输入cookie了。\n\n\n\n\nQ:JavaScript能调用云函数吗（xx平台能调用云函数）\n\n\nA:只要支持https请求就可以通过restful来调用云函数，部分sdk直接封装了调用云函数的接口，具体可以查看云函数文档。\n\n\n\n\nQ:请问云端new Date()如何获取和createTime里面一样的时间\n\n\nA:createAt这个属性是特殊字段，为了节约HTTP流量，我们没有进行特殊字段类型处理，直接返回string类型。你在云函数里面new Date()获取的是一样的时间，因为服务器的时间是保持一致的。至于两者的数据格式问题，你可以自行处理。\n\n\n\n\nQ:云函数数据库可以返回多少条记录？\n\n\nA:一次最多只能返回1000次数据，如果要获取的数据大于整个数目，必须要分多次查询\n\n\n\n\nQ:云函数只能添加方法吗\n我想在云函数中添加一个功能模块，但是发现云函数中的每个文件都是独立的，而且只能是方法，我想问一下能不能实现。\n\n\nA:完全可以在方法内声明方法或者类的，这个不影响，而且可以通过间接调用的方式调用其他云函数的执行。\n\n\n\n\nQ:webstorm在本地搭好服务器，在不联网的情况下，使用ios调用运行在本地的服务端代码，能不能利用这样的方式测试？\n\n\nA:不可以，数据保存在云端，不联网无法操作数据，本地调试过程中不需要客户端的参与。\n\n\n\n\nQ:云函数执行console.log无输出\n\n\nA:在真正的云函数上，不支持console.log这种输出，只能使用res.end()\n\n\n\n\nQ:云端怎么实现 var wpwp = require('wpwp')('YOUR-KEY');\n\n\nA:云函数进行了封装，无法加载非官方模块。\n\n\n\n\nQ:如何更新数据表中Date的数据\n\n\nA:\n\n\nvar userData = dataObject.results[0];\nvar checkDate = userData.checkDate.iso;\n\nvar lastDate = new Date(checkDate.toString());\nvar nowDate = new Date();\n\ndb.setHeader({\nx-bmob-session-token\n:request.body.sessionToken.toString()});\nuserData.checkDate.iso=nowDate;\ndb.updateUserByObjectId({\nobjectId\n:request.body.objectId.toString() ,data: {\ncheckDate\n:userData.checkDate,\ndiamond\n:parseInt(userData.diamond)+10}},function(err,data)\n{\n})\n\n\n\n\n\n\nQ:containedIn在云函数里面是什么指令\n\n\nA:对应为 \nhttp://docs.bmob.cn/data/Restful/b_developdoc/doc/index.html#查询\n 里面的 $in 查询，你可以参考restful文档，在where条件中使用就可以了。\n\n\n\n\nQ:如何在云函数中计算两个时间的时间差\n\n\nA:\n\n\nvar lastDate;//一定要是Date哦\nvar nowDate = new Date(data); \n\nDate.parse(nowDate) - Date.parse(lastDate)\n\n//注意：单位是毫秒级的哦\n\n\n\n\n\n\nQ:批量操作对象中 \"path\": \"/1/classes/GameScore\" ，其中的 \"/1/class/ \"是什么来的？怎么确定下来的？\n\n\nA:/1/classse/ 是系统规定的路径，其中1是系统内部的版本号，classes表示接下来要操作的是数据表。\n\n\n\n\nQ:云函数能不能实现函数递归调用\n\n\nA:可以，但要注意不能过于复杂，5s内无回调会提示超时。\n\n\n\n\nQ:我想用云函数修改user表中的数组，要如何设置？如何先获取表中的数组呢？获取了之后又要如何用arr.addUnique更新？求示例。\n\n\nA:要修改User表中的数据需要注意：\n1. 要么你有登录用户的sessionToken信息（也就是权限），这样可以修改用户信息；\n2. 要么你用masterKey（也就是超级权限）来修改用户信息。\n\n\n获取表中的信息非常简单，你直接Get就可以了，获取之后，你直接用类似如下的方法解决：\n\n\nvar arr = modules.oArray;\narr.addUnique({\n\ntable\n:\n_User\n,\n\n\nobjectId\n:\nj4w2DDDT\n, //这个对应是这个用户的objectId\n\ndata\n:{\nskills\n:{\n__op\n:\nAddUnique\n,\nobjects\n:[\nflying\n,\nkungfu\n]}}\n\n},function(err,data){\n//回调函数\n});\n\n\n\n\n\n\nQ:云函数比较复杂的时候，很难找出根本原因\n1. 能否支持加入日志，通过查看日志来debug？\n2. 能否有类似IDE的断点，或者是报错信息更明确一点在哪里出错？\n\n\nA:可以借助我们开发的这个云函数本地化调试工具来调试：\nhttps://github.com/bmob/bmob-cloud-tool\n\n\n\n\nQ:对于设置了ACL为用户只读的数据，如何在云函数里将其全部读出？\n\n\nA:使用masterKey\n云函数设置masterkey的方法：\n\n\nfunction onRequest(request, response, modules) {\nvar db = modules.oData;\ndb.setHeader({\nX-Bmob-Master-Key\n:\n这里填写Master Key信息\n});\ndb.updateUserByObjectId({\nobjectId\n:\n这里是需要更新的用户ObjectId信息\n ,data:{\nusername\n:\n123\n}},function(err,data){\nresponse.end(\n更新成功\n);\n}); \n}\n\n\n\n\n\n\nQ:如果把代码放在云端，本地JS调用时，是否需要输入Application ID、REST API Key才能进行调用呢？\n\n\nA:只需要在初始化js sdk的时候传人Application ID、REST API Key就行了，在js调用云函数的时候不需要传入\n\n\n\n\nQ:云函数里如何获取当前时间\n\n\nA:云函数是运行在nodejs的环境中，所以js的函数能用在云函数上。\n获取时间： var now = new Date();\n\n\n\n\nQ:调用云函数，能否获取调用者的真实IP,想用IP来做排行榜的地理位置统计\n\n\nA:云函数打印headers\n\n\nfunction onRequest(request, response, modules) {\nresponse.send(request.headers);\n} \n\n\n\n\n结果：\n\n\nResponse Body\n{\n\ncode\n: 200,\n\nmsg\n:\n{\n\nx-real-ip\n: \n114.114.114.114\n,\n\nx-forwarded-for\n: \n114.114.114.114\n,\n\nhost\n: \ncloud.bmob.cn\n,\n\nx-nginx-proxy\n: \ntrue\n,\n\nconnection\n: \nclose\n,\n\naccept\n: \n/\n,\n\na\n: \n,\n\ncontent-length\n: \n7\n,\n\ncontent-type\n: \napplication/x-www-form-urlencoded\n\n}\n}\n\n\n\n\nx-real-ip就是用户的真实ip的\n\n\n\n\nQ:请问怎么查询用户当前排名\n比如:我有个GameScore 表 \n字段有:username,score\n现在排行榜里面数据有5000多条，我知道某个用户objectId，如果快速找出排名位置呢？\n\n\nA:解决方案：\n根据order排名，把所有排名按次序放到一个数组中，然后根据objectId查找到某个用户名，用户名在这个数组中的位置即是他的排名。 \nRestAPI查询条件如下：\n第一步：先查询到某个用户的用户名：\n\n\ncurl -X GET \\\n-H \nX-Bmob-Application-Id: Your Application ID\n \\\n-H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n-G \\\n--data-urlencode 'keys=username' \\\nhttps://api.bmob.cn/1/users/某个用户的objectId\n\n\n\n\n第二步：score降序获取前1000名的用户的用户名：\n\n\ncurl -X GET \\\n-H \nX-Bmob-Application-Id: Your Application ID\n \\\n-H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n-G \\\n--data-urlencode 'keys=username\norder=-score\ncount=true\nlimit=1000\nskip=0' \\\nhttps://api.bmob.cn/1/classes/GameScore\n\n\n\n\n返回前1000名的用户名，判断前一个查询的用户名是否在这个数组的哪个位置，如果没有找到，继续第二步, skip设为1000，直到找到为止。\n\n\n优化方案：\nGameScore应该添加Pointer类型指向某个用户，然后在GameScore添加一个排名的列，更新score的时候更新排名，这样就可以直接根据用户的objectId一条查询就出来了。", 
            "title": "云函数"
        }, 
        {
            "location": "/other/common_problem/cloud_function/#_1", 
            "text": "Q:使用云函数需要掌握什么语言  A: Javascript ，因为云函数是用 Nodejs 部署架构的。   Q:云函数能做什么事情  A:云函数的推出是为了给大家解决更多后端业务逻辑的问题，让大家尽可能把更多的业务逻辑挪到云端，实现更快的更新迭代。目前，云函数除可以自由操作云端数据库外，还提供了 邮件模块 、 HTTP模块 和 事件模块 等，方便大家自由发挥。   Q:云函数能上传文件吗  A:暂不支持。   Q:如何调试云函数  A:\n- Bmob在Web端（当前云函数的下边）为大家提供最简单的云函数的调试工具。\n- 云函数本地化调试工具： https://github.com/bmob/bmob-cloud-tool  。   Q:云函数或者android上update能否不用objectid用组合条件  A:只能根据objectid来，在查询返回的结果集中有objectid   Q:云函数，可以把消息发给IMSDK吗  A:目前不可以。   Q:url转码怎么转  A: encodeURI(url)   Q:如何使用同步的ohttp.post请求  A:用eventproxy   Q:相同的代码，在Local中可以返回正确的结果，在Server中返回错误。请问如何解决？  A:把本地的nodejs版本改成和云端一样，然后调试通过就可以了   Q:bmob的短信服务端验证接口云函数怎么做？要发送一个post请求  A:使用云函数发送http请求即可   Q:生成新应用时云函数没有复制到新应用  A:可使用云函数的本地调试工具可以运行后可以直接导入   Q:云函数能否实现 WebSocket ？  A:云函数无法使用第三方库   Q:往表中添加基本类型的数据是调用数据库对象的insert方法，而添加关联关系对象是用add方法？？那我的表里有这两种数据类型，该怎么添加数据  A:分别存储   Q:保存一个Object类型字段的值为null的时候会报错  A:保存为这样{}   Q:如何实现一个签到的逻辑  A:在用户表添加一个字段--签到时间，当用户发送请求的时候，更新这个签到时间，如果签到时间为今天，说明已经签到   Q:where语句如何查询24小时之前创建的记录？  A:查询createdAt在24小时之前的记录就可以了   Q:删除数据库记录只能用objectId吗？不能用where条件吗  A:只能用objectId,where条件用于查询，查询后的结果集中会有ObjectId的。   Q:云函数怎么设定where条件  A:  where :{ updatedAt :{ $lt :{ __type : Date , iso : 2014-01-29 11:33:53 }\n}   Q:在查找数据库的回调里面再查找，不能收到回调消息  db.find(\n{ table :strTableName, count :1, limit :0,\n},\nfunction(err1,data1)\n{ \nvar searchNum = data1; //表的总行数，用sql语句获得\nvar limitnum=1000; //默认最多返回1000条记录\nvar runcount= parseInt(searchNum/1000); \nvar strOutID = '';\n\n//分多次获取记录，因为每次只能获取1000条\nvar i = 0;\n\nfor(i = 0;i !== runcount; i++){\n\nvar skipNum= 1000*i;\nif( i==runcount ) {\nlimitnum=searchNum-skipNum;\n} else {\nlimitnum=1000;\n}\n//能执行到这里，\n//response.send('data1'); \ndb.find(\n{ table :strTableName, count :1, limit :0,\n},\nfunction(err2,data2)\n{\n//这里执行不到\nresponse.send('data2'); \n}\n);\n} \n}\n);  A:不能这样取，只能取一次，然后再取一次，不能在里面for循环   Q:云函数可以查询支付订单吗？返回订单结果和数额之类的，有相关函数吗  A:可以使用云函数去调用restful接口来查询   Q:云函数可以实现抓取别的网页信息吗\n比如说，我客户端去请求云函数，让云函数实现抓取某个咨询网站的信息  A:可以，使用云函数的http请求抓取即可。   Q:请问云函数可以发送短信吗？  A:可以通过云函数调用restful接口来实现。   Q:云函数更新用户表错误\n但是最后返回的err包含错误信息\n{\"code\":206,\"message\":\"User cannot be altered without sessionToken Error.\"}  A:必须先登录才能更新   Q:请问云函数怎么返回JSON数据  A:  var data = { dir: 'kunhony', param: 'archive' };\nvar str = JSON.stringify(data);\nresponse.end(str);   Q:如何在云端请求微信  A:http://docs.bmob.cn/cloudcode/WEB/d_cloudcodeweixin/doc/index.html   Q:Bmob中如何支持Cookie？用于将SessionID分配给浏览器  A:不支持set-cookie的方法。   Q:请问云函数如何返回错误？  A:如下，代码一般为这种形式，如果错误，返回response.send(err);  function onRequest(request, response, modules) {\n\nvar functions = modules.oFunctions;\n\nfunctions.run({\n    name :  test ,\n    data :{ content : 你好 , address : guangzhou }\n},function(err,data){\n   //回调函数\n   if(err){\n       response.send(err);\n    }else {\n       response.send(data);\n    }\n});\n}   Q:开发公众号可以获取微信的openid吗  A:可以   Q:云函数如何进行模糊查询  A:调用restful的模糊查询接口   Q:云函数能引入第三方模块吗？如underscore  A:不可以，如要使用第三方模块，可考虑使用窗口服务。   Q:我有一个云函数，客户端访问的时候查看一条数据库对象，如果不存在，则创建、返回，如果存在则直接返回。所有客户端的访问都是查看同一个对象，如何保证多个客户端同时访问的时候不会同时创建多个对象？  A:目前这个无法做到。   Q:bql不支持 delete语句吗  A:目前bql只支持查询语句。   Q:表设置了 ACL， 我想用 master key 或 用户的 token 去更新表，在云端用批量更新模块，如何传入master key 或 用户的 token ？  A:目前不支持   Q:云函数怎么延迟执行一个操作  A:目前并无该项功能   Q:云函数中不同的模块中经常出现相同代码 有没有办法把这些代码提取到公共区域来复用  A:云函数之间是可以相互调用的，具体查看云函数云对象章节。   Q:如何清空某个数据表？  A:需要先将表的所有值查询下来，然后遍历去删除，具体参考文档的查询及删除对象章节   Q:怎么在云端调用 获取短信验证码、验证短信验证码  A:使用云函数进行http请求，请求RESTful接口即可   Q:云端如何自定义返回数据  A:定义好格式后以JSON形式返回   Q:云函数MD5加密中文，结果怎么和PHP的不一样？  A:编码问题，https://cnodejs.org/topic/54ad4e40ce87bace2444cc49   Q:BMOB云端数据库导入需手动导入CSV格式，如何做到自动抓取我本地CSV文件传入云端数据库  A:Bmob导入数据，只可以从web后台手动导入。如果你要自动从本地传入数据库的话，可以自己写代码（程序）实现，用Bmob提供的SDK或基于RestApi来插入数据到云端数据库中。   Q:云端数据库更新需上传CSV文件，如何实现自动云端更新  A:云端数据库与你本地数据库的结构可能会有区别，需要你针对自己的数据库特点，读取本地数据库，转换后再进行上传   Q:用云端查询db.find，查询到表里的数据，返回的字段名也是表的列名，有没有像sql里面as的方式修改这个名字  A:目前还没有这个功能   Q:如果一个字段里没有值，查询后返回的内容也没有这个字段，如果才能让这个字段也出现在返回的内容里。  A:由于后台使用的是MongoDB，是无模式的，没有初始值，因此只有显示地给该字段赋值才会有内容返回。   Q:写云函数的时候，只能通过objectId来查询符合条件的一行数据？我想用表中的其他字段当做查询条件怎么写?  A:可以使用条件查询，具体查看数据库对象中的查询多条数据小节。   Q:用skip和limit来实现分页查询的话，如果表里的数据更新的很快的话，会不会查询出重复的数据？  A:会出现重复数据，因此，一般您在查询时可以加上限制，比如，查询第一页时的时间为A，那您可以约束查询创建时间在A之前的数据，在那之后的数据不查询，这样就不会有重复了。   Q:该如何实现类似乐观锁的功能  A:目前并没有提供该类型的接口   Q:连上vpn没有数据返回  A:可以在连上VPN时ping https://api.bmob.cn/看看能否ping通，有可能是VPN屏蔽了   Q:云函数中where条件怎么表示!=？  A:您好，可以参考restful文档中的查询数据中的条件查询，大概的形式为\"type\":{\"$ne\":\"delete\"}   Q:如何更新1000条以上的记录  A:可以采用分页，先取1000条数据进行更新，再取1000条之后的数据接着更新   Q:请问云函数请求HTTP时如何获取cookies和带cookies访问？  A:将var http = modules.oHttp；\n改成var http = modules.oHttp.defaults({jar: true});\n即可使用全局cookie，后面的链接就不需要手动输入cookie了。   Q:JavaScript能调用云函数吗（xx平台能调用云函数）  A:只要支持https请求就可以通过restful来调用云函数，部分sdk直接封装了调用云函数的接口，具体可以查看云函数文档。   Q:请问云端new Date()如何获取和createTime里面一样的时间  A:createAt这个属性是特殊字段，为了节约HTTP流量，我们没有进行特殊字段类型处理，直接返回string类型。你在云函数里面new Date()获取的是一样的时间，因为服务器的时间是保持一致的。至于两者的数据格式问题，你可以自行处理。   Q:云函数数据库可以返回多少条记录？  A:一次最多只能返回1000次数据，如果要获取的数据大于整个数目，必须要分多次查询   Q:云函数只能添加方法吗\n我想在云函数中添加一个功能模块，但是发现云函数中的每个文件都是独立的，而且只能是方法，我想问一下能不能实现。  A:完全可以在方法内声明方法或者类的，这个不影响，而且可以通过间接调用的方式调用其他云函数的执行。   Q:webstorm在本地搭好服务器，在不联网的情况下，使用ios调用运行在本地的服务端代码，能不能利用这样的方式测试？  A:不可以，数据保存在云端，不联网无法操作数据，本地调试过程中不需要客户端的参与。   Q:云函数执行console.log无输出  A:在真正的云函数上，不支持console.log这种输出，只能使用res.end()   Q:云端怎么实现 var wpwp = require('wpwp')('YOUR-KEY');  A:云函数进行了封装，无法加载非官方模块。   Q:如何更新数据表中Date的数据  A:  var userData = dataObject.results[0];\nvar checkDate = userData.checkDate.iso;\n\nvar lastDate = new Date(checkDate.toString());\nvar nowDate = new Date();\n\ndb.setHeader({ x-bmob-session-token :request.body.sessionToken.toString()});\nuserData.checkDate.iso=nowDate;\ndb.updateUserByObjectId({ objectId :request.body.objectId.toString() ,data: { checkDate :userData.checkDate, diamond :parseInt(userData.diamond)+10}},function(err,data)\n{\n})   Q:containedIn在云函数里面是什么指令  A:对应为  http://docs.bmob.cn/data/Restful/b_developdoc/doc/index.html#查询  里面的 $in 查询，你可以参考restful文档，在where条件中使用就可以了。   Q:如何在云函数中计算两个时间的时间差  A:  var lastDate;//一定要是Date哦\nvar nowDate = new Date(data); \n\nDate.parse(nowDate) - Date.parse(lastDate)\n\n//注意：单位是毫秒级的哦   Q:批量操作对象中 \"path\": \"/1/classes/GameScore\" ，其中的 \"/1/class/ \"是什么来的？怎么确定下来的？  A:/1/classse/ 是系统规定的路径，其中1是系统内部的版本号，classes表示接下来要操作的是数据表。   Q:云函数能不能实现函数递归调用  A:可以，但要注意不能过于复杂，5s内无回调会提示超时。   Q:我想用云函数修改user表中的数组，要如何设置？如何先获取表中的数组呢？获取了之后又要如何用arr.addUnique更新？求示例。  A:要修改User表中的数据需要注意：\n1. 要么你有登录用户的sessionToken信息（也就是权限），这样可以修改用户信息；\n2. 要么你用masterKey（也就是超级权限）来修改用户信息。  获取表中的信息非常简单，你直接Get就可以了，获取之后，你直接用类似如下的方法解决：  var arr = modules.oArray;\narr.addUnique({ table : _User , objectId : j4w2DDDT , //这个对应是这个用户的objectId data :{ skills :{ __op : AddUnique , objects :[ flying , kungfu ]}}\n\n},function(err,data){\n//回调函数\n});   Q:云函数比较复杂的时候，很难找出根本原因\n1. 能否支持加入日志，通过查看日志来debug？\n2. 能否有类似IDE的断点，或者是报错信息更明确一点在哪里出错？  A:可以借助我们开发的这个云函数本地化调试工具来调试：\nhttps://github.com/bmob/bmob-cloud-tool   Q:对于设置了ACL为用户只读的数据，如何在云函数里将其全部读出？  A:使用masterKey\n云函数设置masterkey的方法：  function onRequest(request, response, modules) {\nvar db = modules.oData;\ndb.setHeader({ X-Bmob-Master-Key : 这里填写Master Key信息 });\ndb.updateUserByObjectId({ objectId : 这里是需要更新的用户ObjectId信息  ,data:{ username : 123 }},function(err,data){\nresponse.end( 更新成功 );\n}); \n}   Q:如果把代码放在云端，本地JS调用时，是否需要输入Application ID、REST API Key才能进行调用呢？  A:只需要在初始化js sdk的时候传人Application ID、REST API Key就行了，在js调用云函数的时候不需要传入   Q:云函数里如何获取当前时间  A:云函数是运行在nodejs的环境中，所以js的函数能用在云函数上。\n获取时间： var now = new Date();   Q:调用云函数，能否获取调用者的真实IP,想用IP来做排行榜的地理位置统计  A:云函数打印headers  function onRequest(request, response, modules) {\nresponse.send(request.headers);\n}   结果：  Response Body\n{ code : 200, msg :\n{ x-real-ip :  114.114.114.114 , x-forwarded-for :  114.114.114.114 , host :  cloud.bmob.cn , x-nginx-proxy :  true , connection :  close , accept :  / , a :  , content-length :  7 , content-type :  application/x-www-form-urlencoded \n}\n}  x-real-ip就是用户的真实ip的   Q:请问怎么查询用户当前排名\n比如:我有个GameScore 表 \n字段有:username,score\n现在排行榜里面数据有5000多条，我知道某个用户objectId，如果快速找出排名位置呢？  A:解决方案：\n根据order排名，把所有排名按次序放到一个数组中，然后根据objectId查找到某个用户名，用户名在这个数组中的位置即是他的排名。 \nRestAPI查询条件如下：\n第一步：先查询到某个用户的用户名：  curl -X GET \\\n-H  X-Bmob-Application-Id: Your Application ID  \\\n-H  X-Bmob-REST-API-Key: Your REST API Key  \\\n-G \\\n--data-urlencode 'keys=username' \\\nhttps://api.bmob.cn/1/users/某个用户的objectId  第二步：score降序获取前1000名的用户的用户名：  curl -X GET \\\n-H  X-Bmob-Application-Id: Your Application ID  \\\n-H  X-Bmob-REST-API-Key: Your REST API Key  \\\n-G \\\n--data-urlencode 'keys=username order=-score count=true limit=1000 skip=0' \\\nhttps://api.bmob.cn/1/classes/GameScore  返回前1000名的用户名，判断前一个查询的用户名是否在这个数组的哪个位置，如果没有找到，继续第二步, skip设为1000，直到找到为止。  优化方案：\nGameScore应该添加Pointer类型指向某个用户，然后在GameScore添加一个排名的列，更新score的时候更新排名，这样就可以直接根据用户的objectId一条查询就出来了。", 
            "title": "云函数常见问题"
        }, 
        {
            "location": "/other/common_problem/cloud_function_ios/", 
            "text": "iOS 常见问题\n\n\nQ:本地iOS工程怎么调用云函数\n\n\nA:\nhttp://docs.bmob.cn/cloudcode/iOS/b_developdoc/doc/index.html", 
            "title": "云函数iOS"
        }, 
        {
            "location": "/other/common_problem/cloud_function_ios/#ios", 
            "text": "Q:本地iOS工程怎么调用云函数  A: http://docs.bmob.cn/cloudcode/iOS/b_developdoc/doc/index.html", 
            "title": "iOS 常见问题"
        }, 
        {
            "location": "/other/common_problem/im/", 
            "text": "即时通讯常见问题\n\n\nQ:IM的开源地址是什么？\nA:\nAndroid：\nbmob-android-im-sdk\n \n\n   iOS : \nbmob-iOS-im-sdk\n\n\n\n\nQ:为什么我的手机接收不到信息\nA:请先在Web后台配置包名或者证书。\n\n\n\n\nQ:消息推送的时候我没开启网络，在推送一段时间后再开启网络，会收到消息吗？\nA:在断网开始的一分钟内发的消息是接收不到的，因为心跳包的默认时间是一分钟，这一分钟内，服务器不认为该链接是断开的，所以消息不会保存成离线消息。\n\n\n\n\nQ:Bmob可以做群聊吗？\nA:可以利用\n数据实时同步\n来实现群聊。\n\n\n思路可以这样：\n\n\n1.创建一个群聊表，包括 群组id信息 发送人信息 聊天信息，这里可以把所有的聊天内容放进去;\n\n2.创建一个群组信息表，包括 群组用户列表 创建时间 群组名称等;\n\n3.创建一个群组信息变更表，包括 群组id信息，用一个字段记录有消息新增;\n\n\n当有人在群组中发起聊天时，首先先往群聊表中新增一条记录，然后往群组信息表更表中更新一下记录。所有群组的人都监听自己群组对应的群组信息表更表的几行。 \n\n\n\n\nQ:为什么发送位置的时候定位不了\nA:\n1.如果你是直接用demo里面的bin目录下的apk的话，是不存在这个问题的。\n2.如果你是下载demo之后直接运行的话，需要去重新去百度地图官网申请key,因为demo里面的可以是和我的eclipse绑定在一起的，相信做过百度地图开发的知道这是为什么。\n\n\nQ:我想实现私信功能 应该用IM来实现吗\nA:有两种方案：\n1.使用IM实现\n2.如果私信功能对实时信要求并不是很高，那么也可以将聊天记录放在表中，并且采用定时拉取的方法。\n\n\n\n\nQ:im sdk支持群聊活着广播消息么？\nA:SDK内部暂时还没有实现群聊部分，只是在内部预留了相关的接口，方便后续开发而已。\n\n\n\n\nQ:android新版IM不支持好友管理?\nA:新版IM不同于旧版IM，不再提供与用户相关的操作了，比如登录、注册、好友管理相关的。开发者可以自行实现\n\n\n\n\nQ:用自己的key运行新版BmobIMDemo，IM通讯的各种消息的数据库表在哪？（IM即使通讯的注册数据是保存在哪里，BmobIM里面的聊天数据储存在哪个数据库\n）\nA:目前新版IM是没有将发送的消息存储到Bmob后台的，开发者可自行选择存储，sdk的聊天消息都是本地存储的\n\n\n\n\nQ:不论对方是否为我的好友，开启聊天的方式都是BmobIM.getInstance().startPrivateConversation（）吗\n\n\n意思是说好友和陌生人开启聊天的方式都是一样的?只是好友在聊天列表里方便查找？\n\n\n那陌生人的好友的区别在哪里？ 可以在聊天界面的标题 设置类似qq的添加好友吗？\nA:只有会话的概念，没有好友的概念，新版的IM好友管理需要开发者自行实现。\n\n\n\n\nQ:Unity使用Android和iOS的IM的SDK，可以实现即时通讯么？\nA:Unity支持调用android和iOS和IMSDK，可以实现\n\n\n\n\nQ:Bmob Im 是采用什么协议?\nA:基于TCP的自定义协议。\n\n\n\n\nQ:新版本IM兼容老版本吗？\nA:不兼容，新版IM采用全新的协议实现。\n\n\n\n\nQ:利用数据同步功能实现群聊\n答：用数据实时同步实现群聊的思路可以这样：\n\n\n1.创建一个群聊表，包括 群组id信息 发送人信息 聊天信息，这里可以把所有的聊天内容放进去\n2.创建一个群组信息表，包括 群组用户列表 创建时间 群组名称等\n3.创建一个群组信息变更表，包括 群组id信息，用一个字段记录有消息新增\n\n\n当有人在群组中发起聊天时，首先先往群聊表中新增一条记录，然后往群组信息表更表中更新一下记录。所有群组的人都监听自己群组对应的群组信息表更表的几行。\n\n\n热心的用户实现了一个\nAndroid基于Bmob群聊功能的实现\n\n\n\n\nQ:怎样用邮箱查找用户？\n\n\n参考查找用户那部分的代码：（如果希望邮箱是唯一的话，还需要在Web后台指定email字段是唯一键）\n\n\n查询用户\n查询用户和查询普通对象一样，只需指定BmobUser类即可，如下：\n\n\nBmobQuery\nBmobUser\n query = new BmobQuery\nBmobUser\n();\nquery.addWhereEqualTo(\nemail\n, \nheshaoyue@bmob.cn\n);\nquery.findObjects(this, new FindListener\nBmobUser\n() {\n@Override\npublic void onSuccess(List\nBmobUser\n object) {\n// TODO Auto-generated method stub\n//这里得到的就是用户信息\ntoast(\n查询用户邮箱成功：\n+object.size());\n}\n@Override\npublic void onError(int code, String msg) {\n// TODO Auto-generated method stub\ntoast(\n查询用户失败：\n+msg);\n}\n});\n\n\n\n\n\n\nQ:关于离线消息的推送机制问题\n为什么我们离线能接受到消息呢？我们登陆的时候是不是因为服务器知道我们的帐号id再某个地方登陆了，就把消息推送到那个设备上，那么我们离线的时候下次再上线能接受到消息是怎么做到的？\nA:离线消息这个需要服务端支撑的，服务端在向特定用户（设备）下发消息的时候，会去检测下当前用户的客户端连接是否正常，如果连接已经关闭了，表明该设备下线或者处于关机状态，此时服务端会将发给该用户的所有消息凑存在一个数组中，之后在等该用户上线（重新建立连接）的时候，服务器会再将这些离线消息按照时间先后顺序依次下发给该用户。\n\n\n\n\nQ:使用了IM组件，推送怎么搞？\nA:最新版本的IM不需要再使用推送，如果需要在用户离线时使用推送功能，可以直接使用推送sdk推送内容。\n\n\n\n\nQ:为什么IM组件在有的手机上可以接受到聊天推送，有的手机上就接收不到呢？\nA:有一些定制过的机器，比如小米、魅族这些，你根据系统的情况做一下处理。\n\n\n\n\nQ:一个用户发送消息，另一个用户怎么知道他发送消息了。里面的工作原理是什么\nA:首先，两个用户对应的终端都跟Bmob服务器保持了一个心跳长连接服务，这样的话，终端和服务器端就可以双通道通讯了。\n\n\n接着，一个用户发送消息给另外一个用户，消息首先到Bmob服务器，Bmob服务器根据消息的内容体判断是发给哪个终端，然后再把消息发送下去。\n\n\n整个的工作原理就是：websocket长连接。\n\n\n\n\nQ:关于 BmobRealTimeData 的几个问题\n1.isConnected() 的返回结果是实时更新的吗？比如用户本来连接成功，但是过一会儿没有网络了，再调用该函数是不是会返回false？\n2.失去网络连接，然后又恢复网络连接后，BmobRealTimeData 实例会不会自动重连？\n3.这个是基于长连接的吗？耗电情况如何？\n\n\nA:\n1.实时的,没有网络返回false.\n2.会自动重连\n3.长连接, websocket,不会怎么耗电,你可以自行测试下\n\n\n\n\nQ:在IMSDK中如何获得用户的状态（在线，或下线，无打扰，等）\nA:可以定时（比如5分钟）更新一下用户表，这样就可以通过用户表的updatedAt和当前时间的比较，知道用户是否在线了。\n\n\n\n\nQ:BmobI'M2.0 有没有系统消息功能\nA:没有，需要用户自行扩展\n\n\n\n\nQ:发送请求添加好友，BmobIMUserInfo 是发送方，还是接收方的信息啊？\nA:发送方的信息，SDK内部已经弄好了，给别人发送消息，肯定需要接收方的信息\n\n\n\n\nQ:新版本IM是不是没有附近的人这个功能了\nA:新版IM已经不提供这样的功能了，这些功能开发者可以自行封装，新版IM采用的是全新架构，只负责消息的发送和接收，并不再提供与具体业务逻辑相关的API方法", 
            "title": "IM服务"
        }, 
        {
            "location": "/other/common_problem/im/#_1", 
            "text": "Q:IM的开源地址是什么？\nA:\nAndroid： bmob-android-im-sdk   \n   iOS :  bmob-iOS-im-sdk   Q:为什么我的手机接收不到信息\nA:请先在Web后台配置包名或者证书。   Q:消息推送的时候我没开启网络，在推送一段时间后再开启网络，会收到消息吗？\nA:在断网开始的一分钟内发的消息是接收不到的，因为心跳包的默认时间是一分钟，这一分钟内，服务器不认为该链接是断开的，所以消息不会保存成离线消息。   Q:Bmob可以做群聊吗？\nA:可以利用 数据实时同步 来实现群聊。  思路可以这样：  1.创建一个群聊表，包括 群组id信息 发送人信息 聊天信息，这里可以把所有的聊天内容放进去; \n2.创建一个群组信息表，包括 群组用户列表 创建时间 群组名称等; \n3.创建一个群组信息变更表，包括 群组id信息，用一个字段记录有消息新增;  当有人在群组中发起聊天时，首先先往群聊表中新增一条记录，然后往群组信息表更表中更新一下记录。所有群组的人都监听自己群组对应的群组信息表更表的几行。    Q:为什么发送位置的时候定位不了\nA:\n1.如果你是直接用demo里面的bin目录下的apk的话，是不存在这个问题的。\n2.如果你是下载demo之后直接运行的话，需要去重新去百度地图官网申请key,因为demo里面的可以是和我的eclipse绑定在一起的，相信做过百度地图开发的知道这是为什么。  Q:我想实现私信功能 应该用IM来实现吗\nA:有两种方案：\n1.使用IM实现\n2.如果私信功能对实时信要求并不是很高，那么也可以将聊天记录放在表中，并且采用定时拉取的方法。   Q:im sdk支持群聊活着广播消息么？\nA:SDK内部暂时还没有实现群聊部分，只是在内部预留了相关的接口，方便后续开发而已。   Q:android新版IM不支持好友管理?\nA:新版IM不同于旧版IM，不再提供与用户相关的操作了，比如登录、注册、好友管理相关的。开发者可以自行实现   Q:用自己的key运行新版BmobIMDemo，IM通讯的各种消息的数据库表在哪？（IM即使通讯的注册数据是保存在哪里，BmobIM里面的聊天数据储存在哪个数据库\n）\nA:目前新版IM是没有将发送的消息存储到Bmob后台的，开发者可自行选择存储，sdk的聊天消息都是本地存储的   Q:不论对方是否为我的好友，开启聊天的方式都是BmobIM.getInstance().startPrivateConversation（）吗  意思是说好友和陌生人开启聊天的方式都是一样的?只是好友在聊天列表里方便查找？  那陌生人的好友的区别在哪里？ 可以在聊天界面的标题 设置类似qq的添加好友吗？\nA:只有会话的概念，没有好友的概念，新版的IM好友管理需要开发者自行实现。   Q:Unity使用Android和iOS的IM的SDK，可以实现即时通讯么？\nA:Unity支持调用android和iOS和IMSDK，可以实现   Q:Bmob Im 是采用什么协议?\nA:基于TCP的自定义协议。   Q:新版本IM兼容老版本吗？\nA:不兼容，新版IM采用全新的协议实现。   Q:利用数据同步功能实现群聊\n答：用数据实时同步实现群聊的思路可以这样：  1.创建一个群聊表，包括 群组id信息 发送人信息 聊天信息，这里可以把所有的聊天内容放进去\n2.创建一个群组信息表，包括 群组用户列表 创建时间 群组名称等\n3.创建一个群组信息变更表，包括 群组id信息，用一个字段记录有消息新增  当有人在群组中发起聊天时，首先先往群聊表中新增一条记录，然后往群组信息表更表中更新一下记录。所有群组的人都监听自己群组对应的群组信息表更表的几行。  热心的用户实现了一个 Android基于Bmob群聊功能的实现   Q:怎样用邮箱查找用户？  参考查找用户那部分的代码：（如果希望邮箱是唯一的话，还需要在Web后台指定email字段是唯一键）  查询用户\n查询用户和查询普通对象一样，只需指定BmobUser类即可，如下：  BmobQuery BmobUser  query = new BmobQuery BmobUser ();\nquery.addWhereEqualTo( email ,  heshaoyue@bmob.cn );\nquery.findObjects(this, new FindListener BmobUser () {\n@Override\npublic void onSuccess(List BmobUser  object) {\n// TODO Auto-generated method stub\n//这里得到的就是用户信息\ntoast( 查询用户邮箱成功： +object.size());\n}\n@Override\npublic void onError(int code, String msg) {\n// TODO Auto-generated method stub\ntoast( 查询用户失败： +msg);\n}\n});   Q:关于离线消息的推送机制问题\n为什么我们离线能接受到消息呢？我们登陆的时候是不是因为服务器知道我们的帐号id再某个地方登陆了，就把消息推送到那个设备上，那么我们离线的时候下次再上线能接受到消息是怎么做到的？\nA:离线消息这个需要服务端支撑的，服务端在向特定用户（设备）下发消息的时候，会去检测下当前用户的客户端连接是否正常，如果连接已经关闭了，表明该设备下线或者处于关机状态，此时服务端会将发给该用户的所有消息凑存在一个数组中，之后在等该用户上线（重新建立连接）的时候，服务器会再将这些离线消息按照时间先后顺序依次下发给该用户。   Q:使用了IM组件，推送怎么搞？\nA:最新版本的IM不需要再使用推送，如果需要在用户离线时使用推送功能，可以直接使用推送sdk推送内容。   Q:为什么IM组件在有的手机上可以接受到聊天推送，有的手机上就接收不到呢？\nA:有一些定制过的机器，比如小米、魅族这些，你根据系统的情况做一下处理。   Q:一个用户发送消息，另一个用户怎么知道他发送消息了。里面的工作原理是什么\nA:首先，两个用户对应的终端都跟Bmob服务器保持了一个心跳长连接服务，这样的话，终端和服务器端就可以双通道通讯了。  接着，一个用户发送消息给另外一个用户，消息首先到Bmob服务器，Bmob服务器根据消息的内容体判断是发给哪个终端，然后再把消息发送下去。  整个的工作原理就是：websocket长连接。   Q:关于 BmobRealTimeData 的几个问题\n1.isConnected() 的返回结果是实时更新的吗？比如用户本来连接成功，但是过一会儿没有网络了，再调用该函数是不是会返回false？\n2.失去网络连接，然后又恢复网络连接后，BmobRealTimeData 实例会不会自动重连？\n3.这个是基于长连接的吗？耗电情况如何？  A:\n1.实时的,没有网络返回false.\n2.会自动重连\n3.长连接, websocket,不会怎么耗电,你可以自行测试下   Q:在IMSDK中如何获得用户的状态（在线，或下线，无打扰，等）\nA:可以定时（比如5分钟）更新一下用户表，这样就可以通过用户表的updatedAt和当前时间的比较，知道用户是否在线了。   Q:BmobI'M2.0 有没有系统消息功能\nA:没有，需要用户自行扩展   Q:发送请求添加好友，BmobIMUserInfo 是发送方，还是接收方的信息啊？\nA:发送方的信息，SDK内部已经弄好了，给别人发送消息，肯定需要接收方的信息   Q:新版本IM是不是没有附近的人这个功能了\nA:新版IM已经不提供这样的功能了，这些功能开发者可以自行封装，新版IM采用的是全新架构，只负责消息的发送和接收，并不再提供与具体业务逻辑相关的API方法", 
            "title": "即时通讯常见问题"
        }, 
        {
            "location": "/other/common_problem/im_android/", 
            "text": "Android 常见问题\n\n\nQ:我看了官网即时聊天的demo，同样都是继承BombObject的javabean类（数据表）为什么有的是创建在云端，有的保存在本地数据库？这是怎么设置的\nA:自己控制的呀，想保存到后台，那你就调用save方法来创建数据，保存到本地就自己创建数据库\n\n\n\n\nQ:BmobIM2.0 发送自定义消息失败\n\n\nSendCommentMessage commentMessage=new SendCommentMessage();\n            User currentUser = BmobUser.getCurrentUser(DynamicDetailActivity.this,User.class);\n            Map\nString,Object\n map =new HashMap\n();\n            map.put(\nname\n, currentUser.getUsername());//发送者姓名，这里只是举个例子，其实可以不需要传发送者的信息过去\n            map.put(\navatar\n,currentUser.getAvatar());//发送者的头像\n            map.put(\ndynamicId\n,dynamicid);//发送者的uid\n            //启动一个会话，如果isTransient设置为true,则不会创建在本地会话表中创建记录，\n            //设置isTransient设置为false,则会在本地数据库的会话列表中先创建（如果没有）与该用户的会话信息，且将用户信息存储到本地的用户表中\n            //构造聊天方的用户信息:传入用户id、用户名和用户头像三个参数\n            BmobIMUserInfo info;\n            if (atUser!=null){\n                info = new BmobIMUserInfo(atUser.getObjectId(),atUser.getUsername(),atUser.getAvatar());\n            }else{\n                info = new BmobIMUserInfo(dynamic.getAuthor().getObjectId(),dynamic.getAuthor().getUsername(),dynamic.getAuthor().getAvatar());\n            }\n            BmobIMConversation c = BmobIM.getInstance().startPrivateConversation(info, true,null);\n            c.sendMessage(commentMessage, new MessageSendListener() {\n                @Override\n                public void done(BmobIMMessage bmobIMMessage, BmobException e) {\n                    if (bmobIMMessage!=null){\n\n                    }\n                }\n            });\n\n\n\n\nA:还少了一个步骤，使用obtain方法创建一个用于控制发送消息的会话实例\n\n\n\n\nQ:BmobIMUserInfo info为null\nBmobIMUserInfo info = BmobIM.getInstance().getUserInfo((String) BmobUser.getObjectByKey(mContext, \"objectId\"));\ninfo为null是为什么\n\n\nA:用户信息需要开发者自己调用sdk提供的更新本地用户信息的方法（BmobIM.getInstance().updateUserInfo(BmobIMUserInfo info)）来存储的，然后才能通过getUserInfo方法获取的，因为IMSDK内部维护了一个用户表。\n\n\n\n\nQ:怎么查询别人要请求添加我为好友的信息？就是想加我好友的人的列表。\nandroid，即时通讯，我用另外一个小号发送了请求加我大号为好友的请求，但是我怎么查询出谁发送了这个请求，查询出来后我才能点击同意啊。文档上只说加好友和同意加好友，没说怎么查询列举出添加好友的请求的信息。\n\n\nA:目前的demo里面的好友添加请求是查询本地数据库的（可查看\nNewFriendActivity\n中的query方法，NewFriendManager.getInstance(this).getAllNewFriend()方法查询好友添加请求），查询出来的就是谁添加我为好友的请求\n\n\n\n\nQ:Android Im拖动未阅读的会话数量控件调用conversation.updateLocalCache()不能将会话标记为已经阅读\nA:conversation.updateLocalCache();这个方法需要先开启私聊并创建会话后拿到的新会话实例才可以调用的，具体可参考ChatActivity中的用法。\n\n\n\n\nQ:Android使用Bmob IM聊天时有离线消息就会闪退\nA:android.content.res.Resources$NotFoundException: String resource ID #0x7f060015\n你这个错误是因为没有导入bmob_im_notification_strings.xml这个文件造成的。\n\n\n请查看官方IM文档中关于下载NewIMSDK及官方Demo的描述：\nvalues(bmob_im_notification_strings.xml)-用于通知栏显示\n\n\n\n\nQ:想用聊天组件，连接服务器出错误\nA:看Android开发文档中SDK导入部分的解释：\n\n\n每个版本的im依赖特定版本的bmob-sdk：\n\n\nbmob-im:1.1.8---\nbmob-sdk:3.3.5\nbmob-im:1.1.9---\nbmob-sdk:3.4.3\nbmob-im:2.0.1---\nbmob-sdk:3.4.6-0304\nbmob-im:2.0.2---\nbmob-sdk:3.4.6-0304\nbmob-im:2.0.3---\nbmob-sdk:3.4.6\n\n\n\n\nQ:发送消息的时候添加的额外参数在接收的时候怎么拿到\nA:getExtra返回的是一个字符串，再自行解析。\n\n\n\n\nQ:用android studio打开后，报不是gradle工程，是啥原因？\nA:使用as 是需要依赖gradle来下载各种jar包的，因为需要翻墙下载", 
            "title": "IM服务Android"
        }, 
        {
            "location": "/other/common_problem/im_android/#android", 
            "text": "Q:我看了官网即时聊天的demo，同样都是继承BombObject的javabean类（数据表）为什么有的是创建在云端，有的保存在本地数据库？这是怎么设置的\nA:自己控制的呀，想保存到后台，那你就调用save方法来创建数据，保存到本地就自己创建数据库   Q:BmobIM2.0 发送自定义消息失败  SendCommentMessage commentMessage=new SendCommentMessage();\n            User currentUser = BmobUser.getCurrentUser(DynamicDetailActivity.this,User.class);\n            Map String,Object  map =new HashMap ();\n            map.put( name , currentUser.getUsername());//发送者姓名，这里只是举个例子，其实可以不需要传发送者的信息过去\n            map.put( avatar ,currentUser.getAvatar());//发送者的头像\n            map.put( dynamicId ,dynamicid);//发送者的uid\n            //启动一个会话，如果isTransient设置为true,则不会创建在本地会话表中创建记录，\n            //设置isTransient设置为false,则会在本地数据库的会话列表中先创建（如果没有）与该用户的会话信息，且将用户信息存储到本地的用户表中\n            //构造聊天方的用户信息:传入用户id、用户名和用户头像三个参数\n            BmobIMUserInfo info;\n            if (atUser!=null){\n                info = new BmobIMUserInfo(atUser.getObjectId(),atUser.getUsername(),atUser.getAvatar());\n            }else{\n                info = new BmobIMUserInfo(dynamic.getAuthor().getObjectId(),dynamic.getAuthor().getUsername(),dynamic.getAuthor().getAvatar());\n            }\n            BmobIMConversation c = BmobIM.getInstance().startPrivateConversation(info, true,null);\n            c.sendMessage(commentMessage, new MessageSendListener() {\n                @Override\n                public void done(BmobIMMessage bmobIMMessage, BmobException e) {\n                    if (bmobIMMessage!=null){\n\n                    }\n                }\n            });  A:还少了一个步骤，使用obtain方法创建一个用于控制发送消息的会话实例   Q:BmobIMUserInfo info为null\nBmobIMUserInfo info = BmobIM.getInstance().getUserInfo((String) BmobUser.getObjectByKey(mContext, \"objectId\"));\ninfo为null是为什么  A:用户信息需要开发者自己调用sdk提供的更新本地用户信息的方法（BmobIM.getInstance().updateUserInfo(BmobIMUserInfo info)）来存储的，然后才能通过getUserInfo方法获取的，因为IMSDK内部维护了一个用户表。   Q:怎么查询别人要请求添加我为好友的信息？就是想加我好友的人的列表。\nandroid，即时通讯，我用另外一个小号发送了请求加我大号为好友的请求，但是我怎么查询出谁发送了这个请求，查询出来后我才能点击同意啊。文档上只说加好友和同意加好友，没说怎么查询列举出添加好友的请求的信息。  A:目前的demo里面的好友添加请求是查询本地数据库的（可查看\nNewFriendActivity\n中的query方法，NewFriendManager.getInstance(this).getAllNewFriend()方法查询好友添加请求），查询出来的就是谁添加我为好友的请求   Q:Android Im拖动未阅读的会话数量控件调用conversation.updateLocalCache()不能将会话标记为已经阅读\nA:conversation.updateLocalCache();这个方法需要先开启私聊并创建会话后拿到的新会话实例才可以调用的，具体可参考ChatActivity中的用法。   Q:Android使用Bmob IM聊天时有离线消息就会闪退\nA:android.content.res.Resources$NotFoundException: String resource ID #0x7f060015\n你这个错误是因为没有导入bmob_im_notification_strings.xml这个文件造成的。  请查看官方IM文档中关于下载NewIMSDK及官方Demo的描述：\nvalues(bmob_im_notification_strings.xml)-用于通知栏显示   Q:想用聊天组件，连接服务器出错误\nA:看Android开发文档中SDK导入部分的解释：  每个版本的im依赖特定版本的bmob-sdk：  bmob-im:1.1.8--- bmob-sdk:3.3.5\nbmob-im:1.1.9--- bmob-sdk:3.4.3\nbmob-im:2.0.1--- bmob-sdk:3.4.6-0304\nbmob-im:2.0.2--- bmob-sdk:3.4.6-0304\nbmob-im:2.0.3--- bmob-sdk:3.4.6   Q:发送消息的时候添加的额外参数在接收的时候怎么拿到\nA:getExtra返回的是一个字符串，再自行解析。   Q:用android studio打开后，报不是gradle工程，是啥原因？\nA:使用as 是需要依赖gradle来下载各种jar包的，因为需要翻墙下载", 
            "title": "Android 常见问题"
        }, 
        {
            "location": "/other/common_problem/im_ios/", 
            "text": "iOS常见问题\n\n\nQ:BmobIm服务器的消息怎么删除，每次删除程序再打开都会有离线消息\nA:这些是服务端自动存储的，并不是保存在表中，而是后端以另一种形式保存，无需用户自行维护～", 
            "title": "IM服务iOS"
        }, 
        {
            "location": "/other/common_problem/im_ios/#ios", 
            "text": "Q:BmobIm服务器的消息怎么删除，每次删除程序再打开都会有离线消息\nA:这些是服务端自动存储的，并不是保存在表中，而是后端以另一种形式保存，无需用户自行维护～", 
            "title": "iOS常见问题"
        }, 
        {
            "location": "/other/common_problem/push/", 
            "text": "推送功能常见问题\n\n\nQ:推送服务采用的协议是什么\nA: \nWebsocket\n\n\n\n\nQ:会不会限制推送消息的数量\nA:没有限制！\n\n\n推送的用户数量没有限制，每天推送的消息条数也没有限制，所有都没有限制。\n\n\n\n\nQ:服务器能支撑的长连接有多大\nA:Bmob的推送服务器是耗内存型的，保持1个长连接占用\n10KB的内存，64GB的内存能够支撑600万用户的长连接。\n\n\n\n\nQ:Android推送收不到消息\nA:\n1.手机是否连入网络 \n\n2.包名（应用包名，看配置文件）是否正确填写在web后台中  \n\n\n如果还是不能接收到推送，请检查：  \n\n\n3.手机是否有bmob的推送后台在运行\n\n4.后台的Installation表有没有该手机对应的设备信息\n\n\n\n\nQ:iOS推送接收不到消息\nA:\niOS的推送都是用apns。你确认是否操作了几点：\n\n1.检查推送的代码是否写错; \n\n2.真机操作；\n\n3.Bmob后台上传了未加密的p12证书； \n\n4.Bmob数据后台的Installation表是否可以看到对应数据。\n\n5.push token是否保存到服务器了\n\n\n\n\nQ:推送的耗电和耗流量情况怎样\nA:\n以下说到的，不考虑推送的内容部分。推送内容的多少是由开发者决定的。\n\n\n另外，实测电量、流量消耗，与网络状况相关比较大。\n\n\n所以这里的数据是理论平均值：流量消耗 50K/天，电量消耗 60mAh/天。\n\n\n\n\nQ:可以推送富文本到客户端吗\nA:不直接支持文件的推送，但可以通过推送 url 来实现。\n即先推送文件下载 url，到客户端触发逻辑来通过 url 下载文件。\n\n\n\n\nQ:iOS在服务端如何推送有声音和Badge提示\nA:需要开发者自己定义JSON格式，格式如下：\n\n\n{\n    \nalert\n : \nYou got your emails.\n,\n    \nbadge\n : 9,\n    \nsound\n : \nbingbong.aiff\n\n}", 
            "title": "推送服务"
        }, 
        {
            "location": "/other/common_problem/push/#_1", 
            "text": "Q:推送服务采用的协议是什么\nA:  Websocket   Q:会不会限制推送消息的数量\nA:没有限制！  推送的用户数量没有限制，每天推送的消息条数也没有限制，所有都没有限制。   Q:服务器能支撑的长连接有多大\nA:Bmob的推送服务器是耗内存型的，保持1个长连接占用 10KB的内存，64GB的内存能够支撑600万用户的长连接。   Q:Android推送收不到消息\nA:\n1.手机是否连入网络  \n2.包名（应用包名，看配置文件）是否正确填写在web后台中    如果还是不能接收到推送，请检查：    3.手机是否有bmob的推送后台在运行 \n4.后台的Installation表有没有该手机对应的设备信息   Q:iOS推送接收不到消息\nA:\niOS的推送都是用apns。你确认是否操作了几点： \n1.检查推送的代码是否写错;  \n2.真机操作； \n3.Bmob后台上传了未加密的p12证书；  \n4.Bmob数据后台的Installation表是否可以看到对应数据。 \n5.push token是否保存到服务器了   Q:推送的耗电和耗流量情况怎样\nA:\n以下说到的，不考虑推送的内容部分。推送内容的多少是由开发者决定的。  另外，实测电量、流量消耗，与网络状况相关比较大。  所以这里的数据是理论平均值：流量消耗 50K/天，电量消耗 60mAh/天。   Q:可以推送富文本到客户端吗\nA:不直接支持文件的推送，但可以通过推送 url 来实现。\n即先推送文件下载 url，到客户端触发逻辑来通过 url 下载文件。   Q:iOS在服务端如何推送有声音和Badge提示\nA:需要开发者自己定义JSON格式，格式如下：  {\n     alert  :  You got your emails. ,\n     badge  : 9,\n     sound  :  bingbong.aiff \n}", 
            "title": "推送功能常见问题"
        }, 
        {
            "location": "/other/common_problem/push_android/", 
            "text": "Android 常见问题\n\n\nQ: 手机中安装两个包含bmob push sdk的app，那么这时另一个包含bmobpush sdk的app会报错。\nA:解决方法：\n删除androidMainfest.xml中\n\npermission android:protectionLevel=\"normal\" android:name=\"cn.bmob.permission.push\"\n/permission\n\n这一句。\n\n\n其实这一句完全可以不加，也可以正常使用，亲测2个app推送正常，且不报错，关于原因请百度android permission相关知识（如果找不到再找客服吧~）\n\n\n\n\nQ:消息推送后点击消息进入不同的fragment页面\nA:这个是需要自己去定义的，在点击进入时应该有一个地方可以控制页面的行为的，具体的谷歌百度会有很多资料\n\n\n\n\nQ:用PushManager.pushMessage(text)推送的消息能设置过期时间吗？默认的过期时间是多久？\nA:暂时没有该功能。\n\n\n\n\nQ:消息推送里要设置的包名是指什么包\nA:消息推送里要设置的包名是你应用的包名（Androidmanifest文件中的package）", 
            "title": "推送服务Android"
        }, 
        {
            "location": "/other/common_problem/push_android/#android", 
            "text": "Q: 手机中安装两个包含bmob push sdk的app，那么这时另一个包含bmobpush sdk的app会报错。\nA:解决方法：\n删除androidMainfest.xml中 permission android:protectionLevel=\"normal\" android:name=\"cn.bmob.permission.push\" /permission \n这一句。  其实这一句完全可以不加，也可以正常使用，亲测2个app推送正常，且不报错，关于原因请百度android permission相关知识（如果找不到再找客服吧~）   Q:消息推送后点击消息进入不同的fragment页面\nA:这个是需要自己去定义的，在点击进入时应该有一个地方可以控制页面的行为的，具体的谷歌百度会有很多资料   Q:用PushManager.pushMessage(text)推送的消息能设置过期时间吗？默认的过期时间是多久？\nA:暂时没有该功能。   Q:消息推送里要设置的包名是指什么包\nA:消息推送里要设置的包名是你应用的包名（Androidmanifest文件中的package）", 
            "title": "Android 常见问题"
        }, 
        {
            "location": "/other/common_problem/push_ios/", 
            "text": "iOS 常见问题\n\n\nQ:按照设制好了IOS推送，推送后显示状态为“发送至APNS”，但前面写着“推送0条”，此时，手机也未接收到信息，是为什么？\nA:\n1.看看Installation表是否有设备信息；\n2.Bmob后台中是否把推送证书添加上去（不能加密）；\n3.你先尝试推送给所有的真实手机。\n\n\n\n\nQ:如何用 BmobPush发送原始apns报文？\nA:要发送原始信息的可以使用-(void)setData:(NSDictionary *)data;方法\n\n\n\n\nQ:在iOS中 在代码中如何创建一个空表 只包含各列的属性 而不创建具体的一条数据。\nA:参考代码\n\n\nBmobInstallation *ins = [BmobInstallation currentInstallation];\n[ins saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (error) {\n        NSLog(@\n%@\n,error);\n    } else {\n        NSLog(@\nsuccess\n);\n        NSLog(@\n%@\n,ins.objectId);\n    }\n}];\n\n\n\n\n\n\nQ:消息推送的条件查询（根据特定的查询条件进行推送）能在自己创建的表格中进行查询条件推送\nA:只能使用自带的installation表来查询。\n\n\n\n\nQ:在installation 表中创立新的列无法添加进去数据\n\n\nBmobInstallation *currentIntallation = [BmobInstallation currentInstallation];\n[currentIntallation setObject:@\n123\n forKey:@\nclasses\n];\n\n[currentIntallation saveInBackground];\n\n\n\n\nA:确实是无法直接这么加的，建议使用channel来实现业务需求\n\n\n\n\nQ:消息推送的条件查询（根据特定的查询条件进行推送）能在自己创建的表格中进行查询条件推送吗！！！\nA:不可以，只能使用自带的installation表来查询", 
            "title": "推送服务iOS"
        }, 
        {
            "location": "/other/common_problem/push_ios/#ios", 
            "text": "Q:按照设制好了IOS推送，推送后显示状态为“发送至APNS”，但前面写着“推送0条”，此时，手机也未接收到信息，是为什么？\nA:\n1.看看Installation表是否有设备信息；\n2.Bmob后台中是否把推送证书添加上去（不能加密）；\n3.你先尝试推送给所有的真实手机。   Q:如何用 BmobPush发送原始apns报文？\nA:要发送原始信息的可以使用-(void)setData:(NSDictionary *)data;方法   Q:在iOS中 在代码中如何创建一个空表 只包含各列的属性 而不创建具体的一条数据。\nA:参考代码  BmobInstallation *ins = [BmobInstallation currentInstallation];\n[ins saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (error) {\n        NSLog(@ %@ ,error);\n    } else {\n        NSLog(@ success );\n        NSLog(@ %@ ,ins.objectId);\n    }\n}];   Q:消息推送的条件查询（根据特定的查询条件进行推送）能在自己创建的表格中进行查询条件推送\nA:只能使用自带的installation表来查询。   Q:在installation 表中创立新的列无法添加进去数据  BmobInstallation *currentIntallation = [BmobInstallation currentInstallation];\n[currentIntallation setObject:@ 123  forKey:@ classes ];\n\n[currentIntallation saveInBackground];  A:确实是无法直接这么加的，建议使用channel来实现业务需求   Q:消息推送的条件查询（根据特定的查询条件进行推送）能在自己创建的表格中进行查询条件推送吗！！！\nA:不可以，只能使用自带的installation表来查询", 
            "title": "iOS 常见问题"
        }, 
        {
            "location": "/other/common_problem/pay/", 
            "text": "移动支付常见问题\n\n\nQ:请问你们的支付sdk怎么收费\n\n\nA:渠道费和公司税共收取10%。其中渠道费是支付宝/微信收取的费用。\n\n\n\n\nQ:为什么我支付了0.01但后台看到只有0.00\n\n\nA:请勿担心，在Bmob财务管理平台订单管理处，金额从小数点后第三位开始不显示，比如支付了0.01元实收0.00，其实是0.0095。\n\n\n\n\nQ:有哪些其它需要注意的事项\n\n\nA:支付问题：\n点击查看其它注意事项", 
            "title": "支付服务"
        }, 
        {
            "location": "/other/common_problem/pay/#_1", 
            "text": "Q:请问你们的支付sdk怎么收费  A:渠道费和公司税共收取10%。其中渠道费是支付宝/微信收取的费用。   Q:为什么我支付了0.01但后台看到只有0.00  A:请勿担心，在Bmob财务管理平台订单管理处，金额从小数点后第三位开始不显示，比如支付了0.01元实收0.00，其实是0.0095。   Q:有哪些其它需要注意的事项  A:支付问题： 点击查看其它注意事项", 
            "title": "移动支付常见问题"
        }, 
        {
            "location": "/other/common_problem/pay_android/", 
            "text": "Android 常见问题\n\n\nQ:网页支付的地址到底是什么？(php支付接口报异常)\n\n\nA:因为支付宝安全团队封杀的问题，网页支付暂时不支持，待寻求到解决方案再开放。\n\n\n\n\nQ:支付 弹出\"抱歉，该商户未开通支付宝服务，无法付款\"\n\n\nA:如果出现这种情况则表示支付宝账号并封了，bmob需要一定的时间去申请账号重新恢复。\n\n\n\n\nQ:新版的Android的Bmob Pay一直提示插件已过期\n运行BP.pay()后会弹出toast显示“bmob pay plugin is out-of-date, please update it”\n已经换成5月31日最新版本的sdk了，还是不行\n\n\nA:versionCode必须为6和6以上的才是最新版，你可以通过高BP.getPluginVersion来获取\n\n\n\n\nQ:新版支付SDK里的demo换成我自己的appID为什么不能支付，用Demo里的appID就可以？\n\n\nA:请创建自己的应用，用自己的appId使用支付SDK。具体的使用方法可以参考Demo和文档。\n\n\n\n\nQ:微信支付总是返回错误码10003， 是什么原因? 支付宝可以正常使用\n\n\nA:商品名或者商品描述不符合规范，或者是金额不是double\n\n\n\n\nQ:移动支付功能是否支持类似美团这种，用户购买了优惠券，资金暂存在我的账户，然后到期后，再由我把钱打给商家\n\n\nA:购买优惠券存到您的账户可以用我们的支付来实现，您的钱打给商家需要自行实现\n\n\n\n\nQ:Android客户端支付后如何反馈到自己的服务器\n\n\nA:在web端的“支付”--\n”支付配置“里可以填上你自己服务器的url地址，支付成功时会往这个地址发送一些订单成功的数据。\n\n\n\n\nQ:新版Android支付SDK在虚拟机下测试报错\n\n\nA:虚拟机上有很多的问题，不支持虚拟机调试。\n\n\n\n\nQ:微信支付插件在哪里？\n\n\nA:下载Bmob Android SDK之后，解压，可以看到 assets 文件夹下有一个 BmobPayPlugin.apk ，就是插件\n\n\n\n\nQ:支付宝支付显示的订单信息，怎么过滤了空格..?\nname of item ， 显示成了 nameofitem， 是支付宝过滤的空格还是bmob过滤的？这样英文显示不了\n\n\nA:是我们过滤的，文档中有描述的哦“商品名及商品描述只支持输入中文、英语、数字、下划线(_)及英文破折号(-)，其余字符自动过滤”，这个是由于支付宝那边是这么要求的，如果有除了刚刚说的那些字符外的其它字符会报错，因此我们这边主动过滤了。\n\n\n\n\nQ:开启验证后数据服务正常但发起支付提示verify error: sign incorrect.\n\n\nA:你在后台开启了应用安全验证并填写了签名，可以在调试时先关掉。发布正式版本时开启\n\n\n\n\nQ:bmob plugin isn't installed 支付这个是什么问题\n\n\nA:支付功能需要先安装支付插件才能使用\n\n\n\n\nQ:为什么一直提示支付中断，必须使用支付宝先发起一次支付请求后，然后切换为微信支付，点击支付后才可提示获取订单成功，并跳转至微信支付页面\n\n\nA:这个问题是因为部分手机（小米手机）不允许未打开过Activity的App访问网络的权限，而支付宝需要先打开Activity，所以可以成功，但微信支付首先是在Service中调用，所以网络请求被拒绝。解决的办法是在BP.pay方法调用之前加上如下代码：\n\n\ntry {\n    Intent intent = new Intent(Intent.ACTION_MAIN);\n    intent.addCategory(Intent.CATEGORY_LAUNCHER);\n    ComponentName cn = new ComponentName(\ncom.bmob.app.sport\n,\n            \ncom.bmob.app.sport.wxapi.BmobActivity\n);\n    intent.setComponent(cn);\n    this.startActivity(intent);\n} catch (Throwable e) {\n    e.printStackTrace();\n}\n这段代码加在BP.pay方法调用之前\n\n\n\n\n\n\nQ:unity怎么使用Bmob的支付呢？\n\n\nA:参考\n这里", 
            "title": "推送服务Android"
        }, 
        {
            "location": "/other/common_problem/pay_android/#android", 
            "text": "Q:网页支付的地址到底是什么？(php支付接口报异常)  A:因为支付宝安全团队封杀的问题，网页支付暂时不支持，待寻求到解决方案再开放。   Q:支付 弹出\"抱歉，该商户未开通支付宝服务，无法付款\"  A:如果出现这种情况则表示支付宝账号并封了，bmob需要一定的时间去申请账号重新恢复。   Q:新版的Android的Bmob Pay一直提示插件已过期\n运行BP.pay()后会弹出toast显示“bmob pay plugin is out-of-date, please update it”\n已经换成5月31日最新版本的sdk了，还是不行  A:versionCode必须为6和6以上的才是最新版，你可以通过高BP.getPluginVersion来获取   Q:新版支付SDK里的demo换成我自己的appID为什么不能支付，用Demo里的appID就可以？  A:请创建自己的应用，用自己的appId使用支付SDK。具体的使用方法可以参考Demo和文档。   Q:微信支付总是返回错误码10003， 是什么原因? 支付宝可以正常使用  A:商品名或者商品描述不符合规范，或者是金额不是double   Q:移动支付功能是否支持类似美团这种，用户购买了优惠券，资金暂存在我的账户，然后到期后，再由我把钱打给商家  A:购买优惠券存到您的账户可以用我们的支付来实现，您的钱打给商家需要自行实现   Q:Android客户端支付后如何反馈到自己的服务器  A:在web端的“支付”-- ”支付配置“里可以填上你自己服务器的url地址，支付成功时会往这个地址发送一些订单成功的数据。   Q:新版Android支付SDK在虚拟机下测试报错  A:虚拟机上有很多的问题，不支持虚拟机调试。   Q:微信支付插件在哪里？  A:下载Bmob Android SDK之后，解压，可以看到 assets 文件夹下有一个 BmobPayPlugin.apk ，就是插件   Q:支付宝支付显示的订单信息，怎么过滤了空格..?\nname of item ， 显示成了 nameofitem， 是支付宝过滤的空格还是bmob过滤的？这样英文显示不了  A:是我们过滤的，文档中有描述的哦“商品名及商品描述只支持输入中文、英语、数字、下划线(_)及英文破折号(-)，其余字符自动过滤”，这个是由于支付宝那边是这么要求的，如果有除了刚刚说的那些字符外的其它字符会报错，因此我们这边主动过滤了。   Q:开启验证后数据服务正常但发起支付提示verify error: sign incorrect.  A:你在后台开启了应用安全验证并填写了签名，可以在调试时先关掉。发布正式版本时开启   Q:bmob plugin isn't installed 支付这个是什么问题  A:支付功能需要先安装支付插件才能使用   Q:为什么一直提示支付中断，必须使用支付宝先发起一次支付请求后，然后切换为微信支付，点击支付后才可提示获取订单成功，并跳转至微信支付页面  A:这个问题是因为部分手机（小米手机）不允许未打开过Activity的App访问网络的权限，而支付宝需要先打开Activity，所以可以成功，但微信支付首先是在Service中调用，所以网络请求被拒绝。解决的办法是在BP.pay方法调用之前加上如下代码：  try {\n    Intent intent = new Intent(Intent.ACTION_MAIN);\n    intent.addCategory(Intent.CATEGORY_LAUNCHER);\n    ComponentName cn = new ComponentName( com.bmob.app.sport ,\n             com.bmob.app.sport.wxapi.BmobActivity );\n    intent.setComponent(cn);\n    this.startActivity(intent);\n} catch (Throwable e) {\n    e.printStackTrace();\n}\n这段代码加在BP.pay方法调用之前   Q:unity怎么使用Bmob的支付呢？  A:参考 这里", 
            "title": "Android 常见问题"
        }, 
        {
            "location": "/other/common_problem/sms/", 
            "text": "短信服务常见问题\n\n\nQ:购买方法及发票问题\nA:登录开发者后台--\n点击某个应用--\n短信--\n短信信息--\n充值 里面进行自由购买。\n需要发票报销的可以联系客服开具发票。\n\n\n\n\nQ:为什么有时候收不到短信\n\n\nA:请检查你是否短时间内给同一个手机号码发送了多次短信，短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条。\n\n\n还有一种情况是回复过TD退订的会被运营商列为黑名单，该通道不回再给该号码发送任何短信信息。如需要接收信息，需要在官网上联系客服QQ解封。\n\n\n\n\nQ:短信服务的签名可以换成我们自己定义的吗\n\n\nA:短信服务支持自定义签名，只需要在控制台短信设置处进行设置即可。\n\n\n\n\nQ:提交短信验证码模板时需注意什么\nA:\n1.模板中不能有【】和 [] ，否则审核不通过；\n\n2.如果你提交的短信模板无法发送，则有可能包含一些敏感监控词，具体可去Github下载 \n短信关键字监控参考文档\n 来查看提交内容是否合法。\n\n3.一天一个应用给同一手机号发送的短信不能超过10条，否则会报10010错误，其他错误码可查看 \n短信功能相关错误码\n 。\n\n\n\n\nQ:注册短信验证码发送以后多久后才能重发\nA:短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条\n\n\n\n\nQ:当使用不是Bmob的短信功能时,如何通过短信找回密码\n现在短信验证mob(shard sdk)是免费的,而bmob的收费的.像我们这种没资本的开发者只能刚开始是用免费的,所以注册时都是用mob的短信sdk进行验证.但是假如有一天用户的密码忘记了.想通过短信的方式来找回的话.那么就不能用mob的短信功能来做了.只能通过bmob的邮箱方式,但是作为手机端这个显然是体验不好\nA:可以结合云端代码来解决。用mob验证验证码成功之后，就用 云端代码+master key 的方式，修改_User表的密码记录。", 
            "title": "短信服务"
        }, 
        {
            "location": "/other/common_problem/sms/#_1", 
            "text": "Q:购买方法及发票问题\nA:登录开发者后台-- 点击某个应用-- 短信-- 短信信息-- 充值 里面进行自由购买。\n需要发票报销的可以联系客服开具发票。   Q:为什么有时候收不到短信  A:请检查你是否短时间内给同一个手机号码发送了多次短信，短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条。  还有一种情况是回复过TD退订的会被运营商列为黑名单，该通道不回再给该号码发送任何短信信息。如需要接收信息，需要在官网上联系客服QQ解封。   Q:短信服务的签名可以换成我们自己定义的吗  A:短信服务支持自定义签名，只需要在控制台短信设置处进行设置即可。   Q:提交短信验证码模板时需注意什么\nA:\n1.模板中不能有【】和 [] ，否则审核不通过； \n2.如果你提交的短信模板无法发送，则有可能包含一些敏感监控词，具体可去Github下载  短信关键字监控参考文档  来查看提交内容是否合法。 \n3.一天一个应用给同一手机号发送的短信不能超过10条，否则会报10010错误，其他错误码可查看  短信功能相关错误码  。   Q:注册短信验证码发送以后多久后才能重发\nA:短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条   Q:当使用不是Bmob的短信功能时,如何通过短信找回密码\n现在短信验证mob(shard sdk)是免费的,而bmob的收费的.像我们这种没资本的开发者只能刚开始是用免费的,所以注册时都是用mob的短信sdk进行验证.但是假如有一天用户的密码忘记了.想通过短信的方式来找回的话.那么就不能用mob的短信功能来做了.只能通过bmob的邮箱方式,但是作为手机端这个显然是体验不好\nA:可以结合云端代码来解决。用mob验证验证码成功之后，就用 云端代码+master key 的方式，修改_User表的密码记录。", 
            "title": "短信服务常见问题"
        }, 
        {
            "location": "/other/common_problem/sms_ios/", 
            "text": "iOS 常见问题\n\n\nQ:iOS 新安装的短信SDK 和之前安装的BmobSDK有冲突\nA:短信SDK是在不需要使用BmobSDK时才使用的，BmobSDK里本身包含的短信SDK的所有内容，所以你将短信SDK移除就可以了\n\n\n\n\nQ:手机验证码注册不成功\n如果注册前不验证验证码是否正确，直接发送注册请求，就可以注册成功，如果先验证，就会报错。提示：code error 207 ，输入的验证码是正确的。请问如何解决。\n\n\n- (IBAction)registerNewUser:(id)sender {\n// 验证注册码是否正确\n[BmobSMS verifySMSCodeInBackgroundWithPhoneNumber:self.phoneNumber.text andSMSCode:self.smsNumber.text resultBlock:^(BOOL isSuccessful, NSError *error) {\nif (isSuccessful) {\n// 发送注册请求\nBmobUser *buser = [[BmobUser alloc]init];\n[buser setUsername:self.phoneNumber.text];\n[buser setPassword:self.password.text];\n[buser setMobilePhoneNumber:self.phoneNumber.text];\n\n[buser signUpOrLoginInbackgroundWithSMSCode:self.smsNumber.text block:^(BOOL isSuccessful, NSError *error) {\n\nif (isSuccessful) {\nNSLog(@\n注册成功\n);\n}else{\nNSLog(@\n注册失败%@\n,error);\n}\n}];\n\n}else{\n\nNSLog(@\n输入的验证码不正确\n);\n}\n\n}];\n\n}\n\n\n\n\nA:验证码注册只需要在注册的时候输入即可，不需要先进行一次验证的，verifySMSCodeInBackgroundWithPhoneNumber方法是用于注册以后的验证功能\n\n\n\n\nQ:注册时需要短信验证， 改怎么实现\nA:注册时让用户填写手机号码，再进行验证即可，有手机注册验证接口", 
            "title": "短信服务"
        }, 
        {
            "location": "/other/common_problem/sms_ios/#ios", 
            "text": "Q:iOS 新安装的短信SDK 和之前安装的BmobSDK有冲突\nA:短信SDK是在不需要使用BmobSDK时才使用的，BmobSDK里本身包含的短信SDK的所有内容，所以你将短信SDK移除就可以了   Q:手机验证码注册不成功\n如果注册前不验证验证码是否正确，直接发送注册请求，就可以注册成功，如果先验证，就会报错。提示：code error 207 ，输入的验证码是正确的。请问如何解决。  - (IBAction)registerNewUser:(id)sender {\n// 验证注册码是否正确\n[BmobSMS verifySMSCodeInBackgroundWithPhoneNumber:self.phoneNumber.text andSMSCode:self.smsNumber.text resultBlock:^(BOOL isSuccessful, NSError *error) {\nif (isSuccessful) {\n// 发送注册请求\nBmobUser *buser = [[BmobUser alloc]init];\n[buser setUsername:self.phoneNumber.text];\n[buser setPassword:self.password.text];\n[buser setMobilePhoneNumber:self.phoneNumber.text];\n\n[buser signUpOrLoginInbackgroundWithSMSCode:self.smsNumber.text block:^(BOOL isSuccessful, NSError *error) {\n\nif (isSuccessful) {\nNSLog(@ 注册成功 );\n}else{\nNSLog(@ 注册失败%@ ,error);\n}\n}];\n\n}else{\n\nNSLog(@ 输入的验证码不正确 );\n}\n\n}];\n\n}  A:验证码注册只需要在注册的时候输入即可，不需要先进行一次验证的，verifySMSCodeInBackgroundWithPhoneNumber方法是用于注册以后的验证功能   Q:注册时需要短信验证， 改怎么实现\nA:注册时让用户填写手机号码，再进行验证即可，有手机注册验证接口", 
            "title": "iOS 常见问题"
        }, 
        {
            "location": "/other/error_code/", 
            "text": "AndroidSDK错误码列表\n\n\n\n\n\n\n\n\n错误码\n\n\n内容\n\n\n含义\n\n\n\n\n\n\n\n\n\n\n9001\n\n\nAppKey is Null, Please initialize BmobSDK.\n\n\nApplication Id为空，请初始化.\n\n\n\n\n\n\n9002\n\n\nParse data error\n\n\n解析返回数据出错\n\n\n\n\n\n\n9003\n\n\nupload file error\n\n\n上传文件出错\n\n\n\n\n\n\n9004\n\n\nupload file failure\n\n\n文件上传失败\n\n\n\n\n\n\n9005\n\n\nA batch operation can not be more than 50\n\n\n批量操作只支持最多50条\n\n\n\n\n\n\n9006\n\n\nobjectId is null\n\n\nobjectId为空\n\n\n\n\n\n\n9007\n\n\nBmobFile File size must be less than 10M.\n\n\n文件大小超过10M\n\n\n\n\n\n\n9008\n\n\nBmobFile File does not exist.\n\n\n上传文件不存在\n\n\n\n\n\n\n9009\n\n\nNo cache data.\n\n\n没有缓存数据\n\n\n\n\n\n\n9010\n\n\nThe network is not normal.(Time out)\n\n\n网络超时\n\n\n\n\n\n\n9011\n\n\nBmobUser does not support batch operations.\n\n\nBmobUser类不支持批量操作\n\n\n\n\n\n\n9012\n\n\ncontext is null.\n\n\n上下文为空\n\n\n\n\n\n\n9013\n\n\nBmobObject Object names(database table name) \nformat is not correct.\n\n\nBmobObject（数据表名称）格式不正确\n\n\n\n\n\n\n9014\n\n\n第三方账号授权失败\n\n\n第三方账号授权失败\n\n\n\n\n\n\n9015\n\n\n其他错误均返回此code\n\n\n其他错误均返回此code\n\n\n\n\n\n\n9016\n\n\nThe network is not available,please check your network!\n\n\n无网络连接，请检查您的手机网络.\n\n\n\n\n\n\n9017\n\n\n与第三方登录有关的错误，具体请看对应的错误描述\n\n\n与第三方登录有关的错误，具体请看对应的错误描述\n\n\n\n\n\n\n9018\n\n\n参数不能为空\n\n\n参数不能为空\n\n\n\n\n\n\n9019\n\n\n格式不正确：手机号码、邮箱地址、验证码\n\n\n格式不正确：手机号码、邮箱地址、验证码\n\n\n\n\n\n\n9020\n\n\n保存CDN信息失败\n\n\n保存CDN信息失败\n\n\n\n\n\n\n9021\n\n\npermission not defined.You must write android\n.permission.WAKE_LOCK  in AndroidManifest.xml \"\n android:name=\"android.permission.WAKE_LOCK\".\n\n\n文件上传缺少wakelock权限\n\n\n\n\n\n\n9022\n\n\nupload failure,please retry.\n\n\n文件上传失败，请重新上传\n\n\n\n\n\n\n9023\n\n\nplease call Bmob.initialize to init sdk.\n\n\n请调用Bmob类的initialize方法去初始化SDK\n\n\n\n\n\n\n\n\niOSSDK错误码列表\n\n\n\n\n\n\n\n\n错误码\n\n\n内容\n\n\n含义\n\n\n\n\n\n\n\n\n\n\n100\n\n\nIt is busy...Try it later!\n\n\n一般是请求服务器的内容有误，如果是查询的话，请检查一下查询条件是否有误.\n\n\n\n\n\n\n20000\n\n\nnil password!\n\n\n登录或者注册时输入的密码为空.\n\n\n\n\n\n\n20001\n\n\nnil username!\n\n\n登录或者注册时输入的用户名为空.\n\n\n\n\n\n\n20002\n\n\nconnect failed!\n\n\n请求失败.\n\n\n\n\n\n\n20003\n\n\nnone objectid!\n\n\n更新对象、删除对象、查询单个对象时没有objectid\n\n\n\n\n\n\n20004\n\n\nnone object!\n\n\n查询时，查询结果为空\n\n\n\n\n\n\n20005\n\n\nexpired!\n\n\n缓存查询时，查询时间已过期\n\n\n\n\n\n\n20006\n\n\ncloud function failed!\n\n\n云端逻辑调用失败\n\n\n\n\n\n\n20008\n\n\nnone filename!\n\n\n上传文件时，文件名为空\n\n\n\n\n\n\n20009\n\n\nnone file!\n\n\n上传文件时，找不到文件\n\n\n\n\n\n\n20010\n\n\nunknow error!\n\n\n未知错误\n\n\n\n\n\n\n20011\n\n\nnone filendata!\n\n\n上传文件时，文件内容为空\n\n\n\n\n\n\n20012\n\n\nupdate content is nil!\n\n\n更新时，更新内容为空\n\n\n\n\n\n\n20013\n\n\nfuction name is nil!\n\n\n调用云端逻辑时，函数名为空\n\n\n\n\n\n\n20014\n\n\narray is too big!\n\n\n批量操作时，传入的数组超过界限\n\n\n\n\n\n\n20015\n\n\nnil array!\n\n\n批量操作时，传入的数组为空\n\n\n\n\n\n\n20016\n\n\nnil push content!\n\n\n推送时，推送内容为空\n\n\n\n\n\n\n20017\n\n\ninit is not finish,please wait a moment\n\n\n初始化未完成\n\n\n\n\n\n\n20023\n\n\ninit fail\n\n\n初始化失败\n\n\n\n\n\n\n20024\n\n\nformat error\n\n\n批量文件上传时格式错误\n\n\n\n\n\n\n20025\n\n\nnil class name\n\n\n表名为空\n\n\n\n\n\n\n20027\n\n\nstring is nil or equal \"\"\n\n\n传的参数有错，一般是传入空字符串造成\n\n\n\n\n\n\n20028\n\n\nInvalid mobile phone number, the format can't be empty or null\n\n\n非法手机号\n\n\n\n\n\n\n20029\n\n\nInvalid sms code, the format can't be empty or null\n\n\n非法验证码\n\n\n\n\n\n\n20030\n\n\nFile not exist\n\n\n获取文件url、删除文件时传入的文件名不存在\n\n\n\n\n\n\n\n\nRESTAPI错误码列表\n\n\n\n\n\n\n\n\nHttpResponseCode\n\n\n错误码\n\n\n含义\n\n\n\n\n\n\n\n\n\n\n401\n\n\n\n\nunauthorized\n\n\n\n\n\n\n500\n\n\n\n\nIt is busy...Try it later!\n\n\n\n\n\n\n当HttpResponseCode的值为401或500时，接口返回的内容格式如下：\n\n\n\n\n\n\n\n\n\n\n\n\n{\n    \nerror\n: \nunauthorized\n\n}\n\n\n\n\nerror为上表中含义的值\n\n\n当HttpResponseCode的值为400时，接口返回的内容格式如下：\n\n\n{\n    \ncode\n: 101,\n    \nerror\n: \nobject not found for e1kXT22L\n\n}\n\n\n\n\ncode为下表中的错误码，error为下表中的内容\n以下是HttpResponseCode为404时返回内容的详细说明，信息中的%s，%d，%f将替换为详细的信息或具体的值。\n\n\n\n\n\n\n\n\n错误码\n\n\n内容\n\n\n含义\n\n\n\n\n\n\n\n\n\n\n101\n\n\nobject not found for %s. OR username or password incorrect\n\n\n查询的 对象或Class 不存在 或者 登录接口的用户名或密码不正确\n\n\n\n\n\n\n102\n\n\nInvalid key '%s' for find OR Invalid value for key '%s'. OR %s: invalid geopoint object.\n\n\n查询中的字段名是大小写敏感的，且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线。，或查询对应的字段值不匹配，或提供的地理位置格式不正确\n\n\n\n\n\n\n103\n\n\nobjectId required. OR classname '%s' must start with a letter.\n\n\n查询单个对象或更新对象时必须提供objectId 或 非法的 class 名称，class 名称是大小写敏感的，并且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线.\n\n\n\n\n\n\n104\n\n\nrelation className '%s' not exists.\n\n\n关联的class名称不存在\n\n\n\n\n\n\n105\n\n\ninvalid field name: %s. OR It is a reserved field: %s.\n\n\n字段名是大小写敏感的，且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线 或 字段名是\nBmob\n默认保留的，如objectId,createdAt,updateAt,ACL\n\n\n\n\n\n\n106\n\n\n%s: is not a valid Pointer.\n\n\n不是一个正确的指针类型\n\n\n\n\n\n\n107\n\n\ninvalid json: %s.\n\n\n输入的json不是正确的json格式\n\n\n\n\n\n\n107\n\n\nThis endpoint only supports Content-Type: application/json requests, not %s.\n\n\n请求只支持Header头部Content-Type值为application/json或application/json; charset=utf-8\n\n\n\n\n\n\n107\n\n\ninvalid date: %s.\n\n\n时间格式不正确\n\n\n\n\n\n\n107\n\n\nACL shoud be like: {\"*\":{\"read\":true},\"eAfHB29gP9\":{\"write\":true}}.\n\n\nACL应该像这样的{\"*\":{\"read\":true},\"eAfHB29gP9\":{\"write\":true}}\n\n\n\n\n\n\n107\n\n\ninvalid op value\n\n\n不是正确的__op的值\n\n\n\n\n\n\n108\n\n\nusername and password required.\n\n\n用户名和密码是必需的\n\n\n\n\n\n\n109\n\n\nlogin data required.\n\n\n登录信息是必需的，如邮箱和密码时缺少其中一个提示此信息\n\n\n\n\n\n\n111\n\n\ninvalid type for key '%s', expected '%s', but got '%s'.\n\n\n传入的字段值与字段类型不匹配，期望是这样(%s)的，但传过来却是这样(%s)的\n\n\n\n\n\n\n112\n\n\nrequests must be an array.\n\n\nrequests的值必须是数组\n\n\n\n\n\n\n113\n\n\nevery request shoud be an object like:{\"method\": \"POST\",\"path\": \"/1/classes/GameScore\",\"body\": {\"score\": 1337,\"playerName\": \"Sean Plott\"}}\n\n\nrequests数组中每个元素应该是一个像这样子的json对象\n\n\n\n\n\n\n114\n\n\nrequests array larger than %d\n\n\nrequests数组大于50\n\n\n\n\n\n\n117\n\n\nLatitude must be in [-90, 90]: %f. OR Longitude must be in [-180, 180]: %f.\n\n\n纬度范围在[-90, 90] 或 经度范围在[-180, 180]\n\n\n\n\n\n\n120\n\n\nEmail verify should be opened in your app setup page of bmob\n\n\n要使用此功能，请在\nBmob\n后台应用设置中打开邮箱认证功能开关\n\n\n\n\n\n\n131\n\n\nInvalid device token:%s\n\n\n不正确的deviceToken\n\n\n\n\n\n\n132\n\n\nInvalid installation ID:%s\n\n\n不正确的installationId\n\n\n\n\n\n\n133\n\n\nInvalid device type:%s\n\n\n不正确的deviceType\n\n\n\n\n\n\n134\n\n\ndevice token '%s' already token.\n\n\ndeviceToken已经存在\n\n\n\n\n\n\n135\n\n\ninstallation ID '%s' already token.\n\n\ninstallationId已经存在\n\n\n\n\n\n\n136\n\n\n%s cannot be changed by this operation OR deviceToken may not be set for deviceType android\n\n\n只读属性不能修改 或 android设备不需要设置deviceToken\n\n\n\n\n\n\n138\n\n\n%s is read only.\n\n\n表是只读的\n\n\n\n\n\n\n139\n\n\nRole names must be restricted to alphanumeric characters, dashes(-), underscores(_), and spaces.\n\n\n角色名称是大小写敏感的，并且必须以英文字母开头，有效的字符仅限在英文字母、数字、空格、横线以及下划线。\n\n\n\n\n\n\n\n\nrole name '%s' already taken.\n\n\n角色名称已经存在。\n\n\n\n\n\n\n141\n\n\nMissing the push data.\n\n\n缺失推送需要的data参数\n\n\n\n\n\n\n142\n\n\n%s shoule be like: 2013-12-04 00:51:13\n\n\n时间格式应该如下： 2013-12-04 00:51:13\n\n\n\n\n\n\n143\n\n\n%s must be a number\"\n\n\n必须是一个数字\n\n\n\n\n\n\n144\n\n\n%s cannot before now\n\n\n不能是之前的时间\n\n\n\n\n\n\n145\n\n\nfile size error\n\n\n文件大小错误\n\n\n\n\n\n\n146\n\n\nfile name error\n\n\n文件名错误\n\n\n\n\n\n\n147\n\n\nfile offeset error\n\n\n文件分页上传偏移量错误\n\n\n\n\n\n\n148\n\n\nfile ctx error\n\n\n文件上下文错误\n\n\n\n\n\n\n149\n\n\nempty file\n\n\n空文件\n\n\n\n\n\n\n150\n\n\nfile upload error\n\n\n文件上传错误\n\n\n\n\n\n\n151\n\n\nfile delete error\n\n\n文件删除错误\n\n\n\n\n\n\n160\n\n\nimage error\n\n\n图片错误\n\n\n\n\n\n\n161\n\n\nimage mode error\n\n\n图片模式错误\n\n\n\n\n\n\n162\n\n\nimage width error\n\n\n图片宽度错误\n\n\n\n\n\n\n163\n\n\nimage height error\n\n\n图片高度错误\n\n\n\n\n\n\n164\n\n\nimage longEdge error\n\n\n图片长边错误\n\n\n\n\n\n\n165\n\n\nimage shortgEdge error\n\n\n图片短边错误\n\n\n\n\n\n\n201\n\n\n%s missing\n\n\n缺失数据\n\n\n\n\n\n\n202\n\n\nusername '%s' already taken.\n\n\n用户名已经存在\n\n\n\n\n\n\n203\n\n\nemail '%s' already taken.\n\n\n邮箱已经存在\n\n\n\n\n\n\n204\n\n\nyou must provide an email.\n\n\n必须提供一个邮箱地址\n\n\n\n\n\n\n205\n\n\nno user found with email '%s'.\n\n\n没有找到此邮件的用户\n\n\n\n\n\n\n\n\nno user found with username '%s'.\n\n\n没有找到此用户名的用户\n\n\n\n\n\n\n206\n\n\nUser cannot be altered without sessionToken Error.\n\n\n登录用户才能修改自己的信息。RestAPI的Http Header中没有提供sessionToken的正确值，不能修改或删除用户\n\n\n\n\n\n\n207\n\n\ncode error.\n\n\n验证码错误\n\n\n\n\n\n\n208\n\n\nauthData error.\n\n\nauthData不正确\n\n\n\n\n\n\n\n\nauthData already linked by other user.\n\n\nauthData已经绑定了其他用户账户\n\n\n\n\n\n\n209\n\n\nmobilePhoneNumber '%s' already taken.\n\n\n该手机号码已经存在\n\n\n\n\n\n\n210\n\n\nold password incorrect.\n\n\n旧密码不正确\n\n\n\n\n\n\n301\n\n\n%s\n\n\n验证错误详细提示，如邮箱格式不正确\n\n\n\n\n\n\n302\n\n\nyour app setting '%s'.\n\n\nBmob后台设置了应用设置值， 如'不允许SDK创建表 '\n\n\n\n\n\n\n310\n\n\n%s\n\n\n云端逻辑运行错误的详细信息\n\n\n\n\n\n\n311\n\n\ninvalid cloudcode name: %s.\n\n\n云端逻辑名称是大小写敏感的，且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线。\n\n\n\n\n\n\n401\n\n\nunique index cannot has duplicate value: %s\n\n\n唯一键不能存在重复的值\n\n\n\n\n\n\n402\n\n\nquery where larger than %d bytes.\n\n\n查询的wher语句长度大于具体多少个字节\n\n\n\n\n\n\n601\n\n\nInvalid bql:%s\n\n\n不正确的BQL查询语句\n\n\n\n\n\n\n\n\nVIP付费限制相关错误码\n\n\n\n\n\n\n\n\n错误码\n\n\n内容\n\n\n含义\n\n\n\n\n\n\n\n\n\n\n1002\n\n\nTables of the app can create has reached to limit\n\n\n该应用能创建的表数已达到限制\n\n\n\n\n\n\n1003\n\n\nRows of the table can add has reached to limit\n\n\n该表的行数已达到限制\n\n\n\n\n\n\n1004\n\n\nFields of the table can add has reached to limit\n\n\n该表的列数已达到限制\n\n\n\n\n\n\n1005\n\n\nRequest api of the this month has reached to limit\n\n\n每月api请求数量已达到限制\n\n\n\n\n\n\n1006\n\n\nCrontab jobs of the app has reached to limit\n\n\n该应用能创建定时任务数已达到限制\n\n\n\n\n\n\n1007\n\n\nCloudCodes of the app has reached to limit\n\n\n该应用能创建云端逻辑数已达到限制\n\n\n\n\n\n\n1500\n\n\nThe file is larger than file size you can upload\n\n\n你上传的文件大小已超出限制\n\n\n\n\n\n\n\n\n短信功能相关错误码\n\n\n短信功能包含的错误码，除了包括以上的109, 207, 209 状态码外，还定义了以下错误码：\n\n\n\n\n\n\n\n\n错误码\n\n\n内容\n\n\n含义\n\n\n\n\n\n\n\n\n\n\n10010\n\n\nmobile '%s' send message limited.\n\n\n该手机号发送短信达到限制(对于一个应用来说，一天给同\n一手机号发送短信不能超过10条，一小时给同一手机号发\n送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条)\n\n\n\n\n\n\n10011\n\n\nno remaining number for send messages.\n\n\n该账户无可用的发送短信条数\n\n\n\n\n\n\n10012\n\n\nyour credit info must verify ok.\n\n\n身份信息必须审核通过才能使用该功能\n\n\n\n\n\n\n10013\n\n\nsms content illegal.\n\n\n非法短信内容\n\n\n\n\n\n\n\n\n支付功能错误码\n\n\n\n\n\n\n\n\n错误码\n\n\n模块\n\n\n内容\n\n\n含义\n\n\n\n\n\n\n\n\n\n\n-1\n\n\nAndroid\n\n\n\n\n微信返回的错误码，可能是未安装微信，也可能是微信没获得网络权限等\n\n\n\n\n\n\n-2\n\n\nAndroid\n\n\n\n\n微信支付用户中断操作\n\n\n\n\n\n\n-3\n\n\nAndroid\n\n\n\n\n未安装支付插件\n\n\n\n\n\n\n102\n\n\nAndroid\n\n\n\n\n设置了安全验证，但是签名或IP不对\n\n\n\n\n\n\n6001\n\n\nAndroid\n\n\n\n\n支付宝支付用户中断操作\n\n\n\n\n\n\n4000\n\n\nAndroid\n\n\n\n\n支付宝支付出错，可能是参数有问题\n\n\n\n\n\n\n1111\n\n\nAndroid\n\n\n\n\n解析服务器返回的数据出错，可能是提交参数有问题\n\n\n\n\n\n\n2222\n\n\nAndroid\n\n\n\n\n服务器端返回参数出错，可能是提交的参数有问题（如查询的订单号不存在）\n\n\n\n\n\n\n3333\n\n\nAndroid\n\n\n\n\n解析服务器数据出错，可能是提交参数有问题\n\n\n\n\n\n\n5277\n\n\nAndroid\n\n\n\n\n查询订单号时未输入订单号\n\n\n\n\n\n\n7777\n\n\nAndroid\n\n\n\n\n微信客户端未安装\n\n\n\n\n\n\n8888\n\n\nAndroid\n\n\n\n\n微信客户端版本不支持微信支付\n\n\n\n\n\n\n9010\n\n\nAndroid\n\n\n\n\n网络异常，可能是没有给应用网络权限\n\n\n\n\n\n\n10003\n\n\nAndroid\n\n\n\n\n商品名或详情不符合微信/支付宝的规定（如微信商品名不可以超过42个中文）\n\n\n\n\n\n\n10777\n\n\nAndroid\n\n\n\n\n上次发起的请求还未处理完成，禁止下次请求，可用BP.ForceFree()解除\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4000\n\n\niOS\n\n\n\n\n支付类型错误，请填写 BmobAlipay\n\n\n\n\n\n\n4001\n\n\niOS\n\n\n\n\n解析服务器返回的数据出错，可能是提交参数有问题\n\n\n\n\n\n\n4002\n\n\niOS\n\n\n\n\n查询不到订单号，请在支付回调执行后查询\n\n\n\n\n\n\n4004\n\n\niOS\n\n\n\n\n网络错误，请检查网络\n\n\n\n\n\n\n4005\n\n\niOS\n\n\n\n\n支付宝未安装，或者没有配置 info.plist 参数\n\n\n\n\n\n\n4006\n\n\niOS\n\n\n\n\n用户执行取消付款操作\n\n\n\n\n\n\n4007\n\n\niOS\n\n\n\n\n价格超出限额\n\n\n\n\n\n\n4008\n\n\niOS\n\n\n\n\n获取支付参数错误，请稍后重试\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n150\n\n\nRestful\n\n\norder_no is null.\n\n\n订单号是空的.\n\n\n\n\n\n\n10001\n\n\nRestful\n\n\n%s required\n\n\n有些项是必填的\n\n\n\n\n\n\n10002\n\n\nRestful\n\n\norder_no not exists.\n\n\n你要查询的订单号不存在.\n\n\n\n\n\n\n10003\n\n\nRestful\n\n\n%s.\n\n\n详细错误信息，如微信或支付宝返回的详细错误.\n\n\n\n\n\n\n10004\n\n\nRestful\n\n\n%s.\n\n\n详细错误信息，如微信或支付宝返回的详细错误.", 
            "title": "错误码"
        }, 
        {
            "location": "/other/error_code/#androidsdk", 
            "text": "错误码  内容  含义      9001  AppKey is Null, Please initialize BmobSDK.  Application Id为空，请初始化.    9002  Parse data error  解析返回数据出错    9003  upload file error  上传文件出错    9004  upload file failure  文件上传失败    9005  A batch operation can not be more than 50  批量操作只支持最多50条    9006  objectId is null  objectId为空    9007  BmobFile File size must be less than 10M.  文件大小超过10M    9008  BmobFile File does not exist.  上传文件不存在    9009  No cache data.  没有缓存数据    9010  The network is not normal.(Time out)  网络超时    9011  BmobUser does not support batch operations.  BmobUser类不支持批量操作    9012  context is null.  上下文为空    9013  BmobObject Object names(database table name)  format is not correct.  BmobObject（数据表名称）格式不正确    9014  第三方账号授权失败  第三方账号授权失败    9015  其他错误均返回此code  其他错误均返回此code    9016  The network is not available,please check your network!  无网络连接，请检查您的手机网络.    9017  与第三方登录有关的错误，具体请看对应的错误描述  与第三方登录有关的错误，具体请看对应的错误描述    9018  参数不能为空  参数不能为空    9019  格式不正确：手机号码、邮箱地址、验证码  格式不正确：手机号码、邮箱地址、验证码    9020  保存CDN信息失败  保存CDN信息失败    9021  permission not defined.You must write android .permission.WAKE_LOCK  in AndroidManifest.xml \"  android:name=\"android.permission.WAKE_LOCK\".  文件上传缺少wakelock权限    9022  upload failure,please retry.  文件上传失败，请重新上传    9023  please call Bmob.initialize to init sdk.  请调用Bmob类的initialize方法去初始化SDK", 
            "title": "AndroidSDK错误码列表"
        }, 
        {
            "location": "/other/error_code/#iossdk", 
            "text": "错误码  内容  含义      100  It is busy...Try it later!  一般是请求服务器的内容有误，如果是查询的话，请检查一下查询条件是否有误.    20000  nil password!  登录或者注册时输入的密码为空.    20001  nil username!  登录或者注册时输入的用户名为空.    20002  connect failed!  请求失败.    20003  none objectid!  更新对象、删除对象、查询单个对象时没有objectid    20004  none object!  查询时，查询结果为空    20005  expired!  缓存查询时，查询时间已过期    20006  cloud function failed!  云端逻辑调用失败    20008  none filename!  上传文件时，文件名为空    20009  none file!  上传文件时，找不到文件    20010  unknow error!  未知错误    20011  none filendata!  上传文件时，文件内容为空    20012  update content is nil!  更新时，更新内容为空    20013  fuction name is nil!  调用云端逻辑时，函数名为空    20014  array is too big!  批量操作时，传入的数组超过界限    20015  nil array!  批量操作时，传入的数组为空    20016  nil push content!  推送时，推送内容为空    20017  init is not finish,please wait a moment  初始化未完成    20023  init fail  初始化失败    20024  format error  批量文件上传时格式错误    20025  nil class name  表名为空    20027  string is nil or equal \"\"  传的参数有错，一般是传入空字符串造成    20028  Invalid mobile phone number, the format can't be empty or null  非法手机号    20029  Invalid sms code, the format can't be empty or null  非法验证码    20030  File not exist  获取文件url、删除文件时传入的文件名不存在", 
            "title": "iOSSDK错误码列表"
        }, 
        {
            "location": "/other/error_code/#restapi", 
            "text": "HttpResponseCode  错误码  含义      401   unauthorized    500   It is busy...Try it later!    当HttpResponseCode的值为401或500时，接口返回的内容格式如下：       {\n     error :  unauthorized \n}  error为上表中含义的值  当HttpResponseCode的值为400时，接口返回的内容格式如下：  {\n     code : 101,\n     error :  object not found for e1kXT22L \n}  code为下表中的错误码，error为下表中的内容\n以下是HttpResponseCode为404时返回内容的详细说明，信息中的%s，%d，%f将替换为详细的信息或具体的值。     错误码  内容  含义      101  object not found for %s. OR username or password incorrect  查询的 对象或Class 不存在 或者 登录接口的用户名或密码不正确    102  Invalid key '%s' for find OR Invalid value for key '%s'. OR %s: invalid geopoint object.  查询中的字段名是大小写敏感的，且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线。，或查询对应的字段值不匹配，或提供的地理位置格式不正确    103  objectId required. OR classname '%s' must start with a letter.  查询单个对象或更新对象时必须提供objectId 或 非法的 class 名称，class 名称是大小写敏感的，并且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线.    104  relation className '%s' not exists.  关联的class名称不存在    105  invalid field name: %s. OR It is a reserved field: %s.  字段名是大小写敏感的，且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线 或 字段名是 Bmob 默认保留的，如objectId,createdAt,updateAt,ACL    106  %s: is not a valid Pointer.  不是一个正确的指针类型    107  invalid json: %s.  输入的json不是正确的json格式    107  This endpoint only supports Content-Type: application/json requests, not %s.  请求只支持Header头部Content-Type值为application/json或application/json; charset=utf-8    107  invalid date: %s.  时间格式不正确    107  ACL shoud be like: {\"*\":{\"read\":true},\"eAfHB29gP9\":{\"write\":true}}.  ACL应该像这样的{\"*\":{\"read\":true},\"eAfHB29gP9\":{\"write\":true}}    107  invalid op value  不是正确的__op的值    108  username and password required.  用户名和密码是必需的    109  login data required.  登录信息是必需的，如邮箱和密码时缺少其中一个提示此信息    111  invalid type for key '%s', expected '%s', but got '%s'.  传入的字段值与字段类型不匹配，期望是这样(%s)的，但传过来却是这样(%s)的    112  requests must be an array.  requests的值必须是数组    113  every request shoud be an object like:{\"method\": \"POST\",\"path\": \"/1/classes/GameScore\",\"body\": {\"score\": 1337,\"playerName\": \"Sean Plott\"}}  requests数组中每个元素应该是一个像这样子的json对象    114  requests array larger than %d  requests数组大于50    117  Latitude must be in [-90, 90]: %f. OR Longitude must be in [-180, 180]: %f.  纬度范围在[-90, 90] 或 经度范围在[-180, 180]    120  Email verify should be opened in your app setup page of bmob  要使用此功能，请在 Bmob 后台应用设置中打开邮箱认证功能开关    131  Invalid device token:%s  不正确的deviceToken    132  Invalid installation ID:%s  不正确的installationId    133  Invalid device type:%s  不正确的deviceType    134  device token '%s' already token.  deviceToken已经存在    135  installation ID '%s' already token.  installationId已经存在    136  %s cannot be changed by this operation OR deviceToken may not be set for deviceType android  只读属性不能修改 或 android设备不需要设置deviceToken    138  %s is read only.  表是只读的    139  Role names must be restricted to alphanumeric characters, dashes(-), underscores(_), and spaces.  角色名称是大小写敏感的，并且必须以英文字母开头，有效的字符仅限在英文字母、数字、空格、横线以及下划线。     role name '%s' already taken.  角色名称已经存在。    141  Missing the push data.  缺失推送需要的data参数    142  %s shoule be like: 2013-12-04 00:51:13  时间格式应该如下： 2013-12-04 00:51:13    143  %s must be a number\"  必须是一个数字    144  %s cannot before now  不能是之前的时间    145  file size error  文件大小错误    146  file name error  文件名错误    147  file offeset error  文件分页上传偏移量错误    148  file ctx error  文件上下文错误    149  empty file  空文件    150  file upload error  文件上传错误    151  file delete error  文件删除错误    160  image error  图片错误    161  image mode error  图片模式错误    162  image width error  图片宽度错误    163  image height error  图片高度错误    164  image longEdge error  图片长边错误    165  image shortgEdge error  图片短边错误    201  %s missing  缺失数据    202  username '%s' already taken.  用户名已经存在    203  email '%s' already taken.  邮箱已经存在    204  you must provide an email.  必须提供一个邮箱地址    205  no user found with email '%s'.  没有找到此邮件的用户     no user found with username '%s'.  没有找到此用户名的用户    206  User cannot be altered without sessionToken Error.  登录用户才能修改自己的信息。RestAPI的Http Header中没有提供sessionToken的正确值，不能修改或删除用户    207  code error.  验证码错误    208  authData error.  authData不正确     authData already linked by other user.  authData已经绑定了其他用户账户    209  mobilePhoneNumber '%s' already taken.  该手机号码已经存在    210  old password incorrect.  旧密码不正确    301  %s  验证错误详细提示，如邮箱格式不正确    302  your app setting '%s'.  Bmob后台设置了应用设置值， 如'不允许SDK创建表 '    310  %s  云端逻辑运行错误的详细信息    311  invalid cloudcode name: %s.  云端逻辑名称是大小写敏感的，且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线。    401  unique index cannot has duplicate value: %s  唯一键不能存在重复的值    402  query where larger than %d bytes.  查询的wher语句长度大于具体多少个字节    601  Invalid bql:%s  不正确的BQL查询语句", 
            "title": "RESTAPI错误码列表"
        }, 
        {
            "location": "/other/error_code/#vip", 
            "text": "错误码  内容  含义      1002  Tables of the app can create has reached to limit  该应用能创建的表数已达到限制    1003  Rows of the table can add has reached to limit  该表的行数已达到限制    1004  Fields of the table can add has reached to limit  该表的列数已达到限制    1005  Request api of the this month has reached to limit  每月api请求数量已达到限制    1006  Crontab jobs of the app has reached to limit  该应用能创建定时任务数已达到限制    1007  CloudCodes of the app has reached to limit  该应用能创建云端逻辑数已达到限制    1500  The file is larger than file size you can upload  你上传的文件大小已超出限制", 
            "title": "VIP付费限制相关错误码"
        }, 
        {
            "location": "/other/error_code/#_1", 
            "text": "短信功能包含的错误码，除了包括以上的109, 207, 209 状态码外，还定义了以下错误码：     错误码  内容  含义      10010  mobile '%s' send message limited.  该手机号发送短信达到限制(对于一个应用来说，一天给同 一手机号发送短信不能超过10条，一小时给同一手机号发 送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条)    10011  no remaining number for send messages.  该账户无可用的发送短信条数    10012  your credit info must verify ok.  身份信息必须审核通过才能使用该功能    10013  sms content illegal.  非法短信内容", 
            "title": "短信功能相关错误码"
        }, 
        {
            "location": "/other/error_code/#_2", 
            "text": "错误码  模块  内容  含义      -1  Android   微信返回的错误码，可能是未安装微信，也可能是微信没获得网络权限等    -2  Android   微信支付用户中断操作    -3  Android   未安装支付插件    102  Android   设置了安全验证，但是签名或IP不对    6001  Android   支付宝支付用户中断操作    4000  Android   支付宝支付出错，可能是参数有问题    1111  Android   解析服务器返回的数据出错，可能是提交参数有问题    2222  Android   服务器端返回参数出错，可能是提交的参数有问题（如查询的订单号不存在）    3333  Android   解析服务器数据出错，可能是提交参数有问题    5277  Android   查询订单号时未输入订单号    7777  Android   微信客户端未安装    8888  Android   微信客户端版本不支持微信支付    9010  Android   网络异常，可能是没有给应用网络权限    10003  Android   商品名或详情不符合微信/支付宝的规定（如微信商品名不可以超过42个中文）    10777  Android   上次发起的请求还未处理完成，禁止下次请求，可用BP.ForceFree()解除          4000  iOS   支付类型错误，请填写 BmobAlipay    4001  iOS   解析服务器返回的数据出错，可能是提交参数有问题    4002  iOS   查询不到订单号，请在支付回调执行后查询    4004  iOS   网络错误，请检查网络    4005  iOS   支付宝未安装，或者没有配置 info.plist 参数    4006  iOS   用户执行取消付款操作    4007  iOS   价格超出限额    4008  iOS   获取支付参数错误，请稍后重试          150  Restful  order_no is null.  订单号是空的.    10001  Restful  %s required  有些项是必填的    10002  Restful  order_no not exists.  你要查询的订单号不存在.    10003  Restful  %s.  详细错误信息，如微信或支付宝返回的详细错误.    10004  Restful  %s.  详细错误信息，如微信或支付宝返回的详细错误.", 
            "title": "支付功能错误码"
        }, 
        {
            "location": "/other/data_safety/", 
            "text": "简介\n\n\n数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了传输层面、应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）、发布层次等不同粒度的权限控制的方式，确保用户数据的安全。\n\n\n传输层面\n\n\nBmob SDK对数据进行了加密封装，采用\nrequestId\n + \ntimestamp\n + \nApplication Key\n 的一次性对称加密算法和服务端主动防御的技术，确保数据在传输过程中能够不被Fiddler、Wireshark等抓包工具恶意抓取进行分析破坏。\n\n\n应用层次\n\n\n在创建应用时Bmob会自动给每个应用分配三个Key，分别是Application Key, 、REST API Key 、Master Key（这些Key可以在开发者后台对应应用的“应用密钥”中找到）。\n\n\n\n\n\n\nApplication Key 应用程序Key：\n主要是iOS/Android/Unity/Cocos2d-x等SDK开发测试和发布时，用于请求、数据的凭证。\n\n\n\n\n\n\nREST API Key：\n主要是REST API接口开发测试和发布时，用于请求数据的凭证。\n\n\n\n\n\n\nMaster Key：\n超级权限Key，开发者内部使用，使用此Key请求数据，表、对象、ACL等其他层次的权限不起作用（\n请妥善保管Master Key，不要泄露\n）。\n\n\n\n\n\n\n表层次\n\n\nBmob在表权限管理方面可以设置该表只读还是使用ACL的权限（设置方法：登录开发者后台-\n选择某个应用-\n数据-\n选择某个需要设置权限的表-\n点击“更多”-\n点击“权限设置”，如下图）。\n\n\n\n\n表的只读权限设置非常有价值，比如，你用Bmob开发了一款新闻应用，或者是一个广告墙应用，或者是有排行榜功能的某款游戏，你肯定不希望黑客或者竞争对手通过破解你的应用获取了App Key就可以做出毁灭性破坏。换言之，你希望这些表是只读的，这时候，Bmob的表只读权限的价值就体现出来了。\n\n\n此外，由于默认情况下，SDK可以创建任何表，因此Bmob还提供了一个功能：是否允许SDK动态建表。这在一定程度上也给破坏者带来了破坏的困难。设置的方法如下图所示：\n\n\n\n\nACL和角色\n\n\n最灵活的方法是通过ACL和角色，它的思路是每一个对象有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。\n\n\n大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：\n\n\n\n\n对于私有数据，读写权限可以只局限于数据的所有者。\n\n\n对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。\n\n\n对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。\n\n\n属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。\n\n\n一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。\n\n\n\n\n用Bmob SDK，你可以对这些数据设置一个默认的ACL，这样，即使黑客反编译了你的应用，获取到Application Key，也仍然无法操作和破坏你的用户数据，确保了用户数据的安全可靠。而作为开发者，当你需要对这些数据进行管理时，可以通过超级权限Key（Master Key）进行。\n\n\n\n\n发布层次\n\n\n当APP进入发布阶段，你可以做更多的工作，防止某些不法人士破解了你的APP，获取Application KEY，而随意更改里面的数据。需要做的事情非常简单，你只需要进入到这个APP的Bmob后台，依次点击“应用设置-\n安全认证”，将APP的签名/Bundle ID信息填写在里面，就可以确保数据的安全。如下图：\n\n\n\n\n如果你的APP已经处于发布状态，也开启了安全认证，那么，当你需要对这个APP进行调试时，要把调试时的网络IP加到IP白名单上面。这样的话，这个IP就能够绕过安全认证进行操作。有点繁琐，但为了确保你的数据安全，Bmob后端云建议你进行相应的操作。", 
            "title": "数据安全"
        }, 
        {
            "location": "/other/data_safety/#_1", 
            "text": "数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了传输层面、应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）、发布层次等不同粒度的权限控制的方式，确保用户数据的安全。", 
            "title": "简介"
        }, 
        {
            "location": "/other/data_safety/#_2", 
            "text": "Bmob SDK对数据进行了加密封装，采用 requestId  +  timestamp  +  Application Key  的一次性对称加密算法和服务端主动防御的技术，确保数据在传输过程中能够不被Fiddler、Wireshark等抓包工具恶意抓取进行分析破坏。", 
            "title": "传输层面"
        }, 
        {
            "location": "/other/data_safety/#_3", 
            "text": "在创建应用时Bmob会自动给每个应用分配三个Key，分别是Application Key, 、REST API Key 、Master Key（这些Key可以在开发者后台对应应用的“应用密钥”中找到）。    Application Key 应用程序Key：\n主要是iOS/Android/Unity/Cocos2d-x等SDK开发测试和发布时，用于请求、数据的凭证。    REST API Key：\n主要是REST API接口开发测试和发布时，用于请求数据的凭证。    Master Key：\n超级权限Key，开发者内部使用，使用此Key请求数据，表、对象、ACL等其他层次的权限不起作用（ 请妥善保管Master Key，不要泄露 ）。", 
            "title": "应用层次"
        }, 
        {
            "location": "/other/data_safety/#_4", 
            "text": "Bmob在表权限管理方面可以设置该表只读还是使用ACL的权限（设置方法：登录开发者后台- 选择某个应用- 数据- 选择某个需要设置权限的表- 点击“更多”- 点击“权限设置”，如下图）。   表的只读权限设置非常有价值，比如，你用Bmob开发了一款新闻应用，或者是一个广告墙应用，或者是有排行榜功能的某款游戏，你肯定不希望黑客或者竞争对手通过破解你的应用获取了App Key就可以做出毁灭性破坏。换言之，你希望这些表是只读的，这时候，Bmob的表只读权限的价值就体现出来了。  此外，由于默认情况下，SDK可以创建任何表，因此Bmob还提供了一个功能：是否允许SDK动态建表。这在一定程度上也给破坏者带来了破坏的困难。设置的方法如下图所示：", 
            "title": "表层次"
        }, 
        {
            "location": "/other/data_safety/#acl", 
            "text": "最灵活的方法是通过ACL和角色，它的思路是每一个对象有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。  大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：   对于私有数据，读写权限可以只局限于数据的所有者。  对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。  对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。  属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。  一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。   用Bmob SDK，你可以对这些数据设置一个默认的ACL，这样，即使黑客反编译了你的应用，获取到Application Key，也仍然无法操作和破坏你的用户数据，确保了用户数据的安全可靠。而作为开发者，当你需要对这些数据进行管理时，可以通过超级权限Key（Master Key）进行。", 
            "title": "ACL和角色"
        }, 
        {
            "location": "/other/data_safety/#_5", 
            "text": "当APP进入发布阶段，你可以做更多的工作，防止某些不法人士破解了你的APP，获取Application KEY，而随意更改里面的数据。需要做的事情非常简单，你只需要进入到这个APP的Bmob后台，依次点击“应用设置- 安全认证”，将APP的签名/Bundle ID信息填写在里面，就可以确保数据的安全。如下图：   如果你的APP已经处于发布状态，也开启了安全认证，那么，当你需要对这个APP进行调试时，要把调试时的网络IP加到IP白名单上面。这样的话，这个IP就能够绕过安全认证进行操作。有点繁琐，但为了确保你的数据安全，Bmob后端云建议你进行相应的操作。", 
            "title": "发布层次"
        }, 
        {
            "location": "/other/bql/", 
            "text": "Bmob Query Language（简称 BQL） 是 Bmob 为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 Bmob 查询的 API 的成本，可以使用传统的 SQL 语法来查询 Bmob 应用内的数据。\n\n\n本文档将详细介绍 BQL 的语法和常见用法。\n\n\n介绍及基本语法\n\n\n最基本的一个查询:\n\n\n查询某个 class 下的 100 条数据：\n\n\nselect * from GameScore\n\n\n\n\n等价于（以 Android 为例）:\n\n\n//查询GameScore的100条数据\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\nquery.findObjects(context, new FindListener\nGameScore\n() {\n\n    @Override\n    public void onSuccess(List\nGameScore\n object) {\n        // TODO Auto-generated method stub\n    }\n\n    @Override\n    public void onError(int code, String msg) {\n        // TODO Auto-generated method stub\n    }\n});\n\n\n\n\nselect一个完整的语法形式类似这样：\n\n\nselect [查询字段列表，多个以逗号隔开] from [class 名称]\n   [where [条件列表]\n   [limit skip,limit\n   [order by [排序字段列表] [asc |desc]]]]\n\n\n\n\n举例：\n\n\n\n//查询结果只包含 name,playScore 以及内置字段(objectId,createdAt等)\nselect name,playScore from GameScore\n\n//根据 name 查找\nselect * from GameScore where name='smile'\n\n//根据 name 和 playScore 同时查找\nselect * from GameScore where name is exists and playScore \n 80 and playScore \n= 100\n\n//分页查找，从第 10 条开始向后查找 10 条数据\nselect * from GameScore limit 10,10\n\n//根据 score 和 name 排序\nselect * from GameScore order by -playScore,+name\n\n\n\n\n\n注：当查询的表为系统表（目前系统表有User、Installation、Role）时，需要带上下划线\n_\n。\n\n\n比如，你想查询的是用户\nsmile\n的信息，则：\n\n\n\n`select * from _User where username= smile`\n\n\n\n\n\n查询条件\n\n\n比较查询\n\n\n查询指定信息的对象，用 \n=\n 比较符：\n\n\nselect * from GameScore where name='smile'\n\n\n\n\n查询\n不等于\n指定信息的对象，用\n!=\n比较符：\n\n\nselect * from GameScore where name!='smile'\n\n\n\n\n也可以用\n运算符来表示不等于。\n\n\n比较日期，使用\ndate\n函数来转换，比如查询特定时间之前创建的对象：\n\n\nselect * from GameScore where createdAt \n date('2015-05-20 00:00:00')\n\n\n\n\n\ndate 函数接收的日期格式必须是 \nyyyy-MM-dd HH:mm:ss\n。更多内置函数请看最后的 \n内置函数\n。\n\n\n一些常见的查询运算符：\n\n\n\n\n\n\n\n\nKey\n\n\nOperation\n\n\n对应Bmob的查询API\n\n\n\n\n\n\n\n\n\n\n=\n\n\n等于\n\n\naddWhereEqualTo\n\n\n\n\n\n\n!= 或者 \n\n\n不等于\n\n\naddWhereNotEqualTo\n\n\n\n\n\n\n\n\n小于\n\n\naddWhereLessThan\n\n\n\n\n\n\n=\n\n\n小于等于\n\n\naddWhereLessThanOrEqualTo\n\n\n\n\n\n\n\n\n大于\n\n\naddWhereGreaterThan\n\n\n\n\n\n\n=\n\n\n大于等于\n\n\naddWhereGreaterThanOrEqualTo\n\n\n\n\n\n\n[not] like\n\n\n模糊查询\n\n\naddWhereStartsWith或addWhereEndsWith\n\n\n\n\n\n\n[not] regexp\n\n\n正则匹配\n\n\naddWhereMatches\n\n\n\n\n\n\n[not] in(子查询或者数组)\n\n\n包含或者不包含\n\n\naddWhereMatchesQuery或者addWhereDoesNotMatchQuery\n\n\n\n\n\n\nis [not] exists\n\n\n这个Key有值或者不存在值\n\n\naddWhereExists或addWhereDoesNotExists\n\n\n\n\n\n\n\n\n注：比较运算符可以用在\n日期\n、\n字符串\n、\n数字\n甚至\n对象\n上。\n\n\n模糊查询\n\n\n注:模糊查询只对付费用户开放，付费后可直接使用。\n\n\n模糊查询可以使用 \nlike\n，比如查询名字以 smile 开头的对象\n\n\nselect * from GameScore where name like 'smile%'\n\n\n\n\n% 表示模糊匹配的位置占位符。\n\n\nlike\n 本质上是转成\nregexp\n的正则匹配查询，因此上面的例子还可以写成：\n\n\nselect * from GameScore where name regexp 'smile.*'\n\n\n\n\n否定形式，以\nnot like\n 来查询名字不以 smile 开头的对象：\n\n\nselect * from GameScore where name not like 'smile%'\n\n\n\n\n等价于\nnot regexp\n:\n\n\nselect * from GameScore where name not regexp 'smile.*'\n\n\n\n\n值是否存在查询\n\n\n只返回 name 字段值存在的对象：\n\n\nselect * from GameScore where name is exists\n\n\n\n\n反之，使用 \nis not exists\n。\n\n\n数组查询\n\n\n假设\nhobby\n表示一个人的爱好，其字段类型是List\n对应服务端的\n数组Array\n类型，如我们想查询有游泳爱好的人：\n\n\nselect * from Person where hobby ='游泳'\n\n\n\n\n\n查询既爱好游泳也爱好看书的人：\n\n\nselect * from Person where hobby all ('游泳','看书')\n\n\n\n\n注：all 表示数组完全匹配。\n\n\n子查询\n\n\n1、使用 \nin\n来做子查询，后面跟的可以是一个列表，例如 查询游戏名为地铁跑酷、部落冲突两种游戏的记录：\n\n\nselect * from GameScore where game in ('地铁跑酷','部落冲突')\n\n\n\n\n当然，如果想查询的不在列表里，那可以使用\nnot in\n:\n\n\nselect * from GameScore where game not in ('地铁跑酷','部落冲突')\n\n\n\n\n2、\nin\n后面还可以是一个子查询:\n\n\n比如：要查询游戏得分大于10的玩家信息\n\n\n这里需要\nusername\n的值必须要在子查询产生的数组中，因此,我在\nGameScore\n表中新建了一个\nname\n字段来表示玩家的姓名\n\n\nselect * from _User where username in (select name from GameScore where playScore\n10)\n\n\n\n\n比如：查询年龄大于20的玩家的游戏信息\n\n\nselect * from GameScore where name in (select username from _User where age\n20)\n\n\n\n\n3、子查询另一种常见形式：使用\n= 或 !=\n后面跟一条查询语句：\n\n\n比如：查询游戏得分大于80的玩家\n\n\nselect * from _User where username =(select name from GameScore where playScore\n10)\nselect * from _User where username !=(select name from GameScore where playScore\n=10)\n\n\n\n\n注：子查询的语句也受上限 1000 条记录的限制\n\n\n地理位置查询\n\n\n我们可以通过 BQL 进行地理位置查询。\n\n\n附近的人\n\n\n使用\nnear\n来查询附近的人\n\n\n比如我想查询指定地理位置附近的玩家（从近到远排序），假设 \ngps\n 字段是 \nBmobGeoPoint\n类型：\n\n\nselect * from GameScore where gps near [112.934755,24.52065]\n\n\n\n\n注：[112.934755,24.52065] 是经纬度坐标。必须是经度在前，纬度在后\n\n\n也可以使用 \ngeopoint\n 函数来创建：\n\n\nselect * from GameScore where gps near geopoint(112.934755,24.52065)\n\n\n\n\n注：只有在地理位置信息查询里才可以使用 \n[longitude, latitude]\n这样的语法。在其他查询里将被作为数组类型。\n\n\n限定搜索范围\n\n\n为了限定搜索的最大距离，还可以使用 \nmax distance 单位\n来限定，比如,搜索附近1公里内的人：\n\n\nselect * from GameScore where gps near [112.934755,24.52065] max 1 km\n\n\n\n\n\n注：单位包括 miles（英里）、radians（弧度），默认是弧度。\n\n\n查询矩形范围\n\n\n如果想查询某个矩形框内的对象，可以使用\nwithin [西南坐标] and [东北坐标]\n的语法：\n\n\nselect * from GameScore where gps within [102.934755,24.52065] and [112.934755,24.52065]\n\n\n\n\n查询个数\n\n\n使用 \ncount\n 查询来返回符合查询条件的数目。\n\n\n比如:查询整张表的记录数：\n\n\nselect count(*) from GameScore\n\n\n\n\n注：count 不支持distinct等语法。仅限count(*)和count(objectId)\n\n\n查询总的记录数并返回得分在10-20之间的游戏分数信息\n\n\nselect count(*) from GameScore where playScore\n10 and where playScore\n20\n\n\n\n\n查询个数的同时可以返回对象,使用\n,\n隔开：\n\n\nselect count(*),* from GameScore\n\n\n\n\n也可以返回特定的字段：\n\n\n比如：查询GameScore表中的总数并返回每条记录的游戏名\n\n\nselect count(*),game from GameScore\n\n\n\n\n\n关系查询\n\n\n有如下几种方式来查询对象之间的关系数据 \n\n\n1、如果您想获取对象，而这个对象的一个字段对应了另一个对象, 您可以用一个 \nwhere\n 查询, 自己构造一个 \nPointer\n 函数, 和其他数据类型一样。\n\n\n例如： \nWeibo\n类中有一个\nUser\n（继承自BmobUser）类型的\nauthor\n字段表示这条微博的发送方，现在你想查询当前用户发布的所有微博信息，那么可以这样写：\n\n\nselect include author,* from Weibo where author = pointer('_User', '6720c14c28')\n\n\n\n\npointer\n内置函数接收 className 和 objectId。\n\n\n2、如果您想获取对象, 这个对象的一个字段指向的对象（必须是BmobPointer类型）是符合另一个查询的, 您可以使用\nin\n查询。\n\n\n例如, 假设您有一个 \nWeibo\n 类和一个 \nComment\n 类, 每个\nComment\n 都有一个指向它的 \nWeibo\n 的 weibo字段（BmobPointer类型）, 现在您想查询带有图片的 \nWeibo\n 的 Comment列表:\n\n\nselect * from Comment where weibo in (select * from Weibo where image is exists)\n\n\n\n\n注:默认的 limit 是 100 而且最大的 limit 是 1000，这个限制同样适用于内部的查询, 所以对于较大的数据集您可能需要细心地构建查询来获得期望的行为。\n\n\n3、如果 \nWeibo\n 类下有一个\nBmobRelation\n类型的\ncomment\n字段，它存储了这条微博所有的评论列表。你可以查询到这些评论信息，因为他们都关联到了同一条微博：\n\n\nselect * from Comment where related comment to pointer('Weibo', '262f6ace1a')\n\n\n\n\n基本的查询形式是 \nreleated \nkey\n to \npointer\n。\n\n\n4、如果某个字段是 Pointer ，默认查询的时候，只会返回 {__type: 'Pointer', objectId: 'xxxxxx', className:'Weibo'} 这些基本信息，如果希望同时将这个对象的其他信息查询下来，可以使用\ninclude\n。\n\n\n1）、采用 \ninclude \nkey\n 就可以将某个 \nPointer\n字段关联查询出来：\n\n\n比如查询 \nComment\n 同时将 \nauthor\n带下来：\n\n\nselect include author, * from Comment\n\n\n\n\n2）、\n多个字段要多次 include\n:\n\n\nselect include weibo,include author from Comment\n\n\n\n\n3）、还可以支持\n嵌套的 include 查询\n：\n\n\n比如 \nWeibo\n 里还有一个 Pointer 指向 author(表示这条微博是谁发的):\n\n\nselect include weibo.author,* from Comment\n\n\n\n\n复合查询\n\n\n使用 \nand\n 和 \nor\n进行复合查询\n\n\n比如：查询游戏得分在10-15之间的数据,可以使用\nand\n查询:\n\n\nselect * from GameScore where playScore\n10 and playScore\n=15\n\n\n\n\n如果你想再加个条件：再查询分数为0的数据，可以使用\nor\n查询：\n\n\nselect * from GameScore where playScore\n10 and playScore\n=15 or playScore=5\n\n\n\n\n由于\nand\n的优先级高于\nor\n，因此,上面的查询也可以用括号来明确地表示这种优先级：\n\n\nselect * from GameScore where (playScore\n10 and playScore\n=15) or playScore=5\n\n\n\n\n占位符\n\n\n查询条件\nwhere\n和 \nlimit\n 子句支持占位符，也就是可以用问号 ? 替代值，值的列表通过 SDK 提供的方法传入，具体请参考各 SDK 用法。\n\n\n普通查询\n\n\n例如：\n\n\nselect * from GameScore where name=? and playScore\n? limit ?,?\n\n\n\n\n内置函数\n\n\n占位符查询中用到的内置函数，请看最后的 \n占位符查询用到的内置函数\n。\n\n\n例如：\n\n\n\nselect * from GameScore where createdAt \n date(?) and player = pointer(?,?) and gps near geopoint(?,?)\n\n\n\n\n\n注意：\n\n\n和统计查询有关的\ngroup by\n、\norder by\n、\nhaving\n等字句是不支持占位符的。\n\n\n正确\n写法：\n\n\nselect sum(playScore),count(*) from GameScore group by game having _sumPlayScore\n200\n\n\n\n\n错误\n写法：\n\n\nselect sum(playScore),count(*) from GameScore group by ? having ?\n\n\n\n\n注：我们推荐使用占位符的方式来使用 BQL，查询语句可以通过预编译得到缓存，降低 BQL 的转换开销。\n\n\n限定返回值\n\n\n通过 \nlimit\n 语句来限定返回结果大小，比如限定返回 10 个：\n\n\nselect * from GameScore limit 10\n\n\n\n\n可以设定从第\nm+1\n个元素开始，例如从第 11 个元素（包含）开始往后取 10 个：\n\n\nselect * from GameScore limit 10,10\n\n\n\n\n注：如果查询语句没有设定 limit ，默认的 limit 是 100 而且最大的 limit 是 1000。\n\n\n排序\n\n\n通过 \norder\n 语句来排序，\norder\n 语句只能出现在最后，不能在 \nwhere\n 和 \nlimit\n 之前。\n\n\n比如：按照得分降序排列（得分高的在前）：\n\n\nselect * from GameScore order by playScore desc\n\n\n\n\n也可以写成：\n\n\nselect * from GameScore order by -playScore\n\n\n\n\n注：加号表示升序，减号表示降序。\n\n\n多个字段组合排序\n\n\n比如：得分高的在前（playScore降序），当得分一样的情况下，再按照名称（字母顺序）更小的在前（name升序）：\n\n\nselect * from GameScore order by -playScore,name\n\n\n\n\n同样的语句可以写成：\n\n\nselect * from GameScore order by playScore,+name desc\n\n\n\n\n或者\n\n\nselect * from GameScore order by -playScore,name asc\n\n\n\n\n注：没有写上明确的加号或者减号的字段，将根据最后的 desc 或者 asc 来决定采用升序还是降序。\n\n\n统计查询\n\n\n统计查询只适用于 \nNumber\n 类型的列，支持 \nsum\n (计算总和), \naverage\n (计算平均值), \nmax\n (计算最大值), \nmin\n (计算最小值)\n\n\n举几个例子（以sum求和）:\n\n\n计算总和\n\n\n比如：查询\nGameScore\n表所有玩家的得分总和:\n\n\nselect sum(playScore) from GameScore\n\n\n\n\n分组计算总和\n\n\n比如：按玩家分组，获取每个玩家的总得分：\n\n\nselect sum(playScore) from GameScore group by name\n\n\n\n\n添加过滤条件\n\n\n比如 按玩家分组，获取每个玩家的总得分，并且总得分大于100的：\n\n\nselect sum(playScore) from GameScore group by name having _sumPlayScore \n 100\n\n\n\n\n统计分组记录数\n\n\n同时支持返回每个组用于计算总和的总数：\n\n\nselect sum(playScore),count(*) from GameScore group by name having _sumPlayScore \n 100\n\n\n\n\n注：\n\n\n1、查询语句中含有\nsum\n或 \ngroup by\n的时候不支持返回表中的其他列，只返回group by后面接的列名、sum的列名为 \n(_sum+(首字母大写的列名))\n 以及有count(*)会返回的 \n_count\n等数据。所以只应该用于统计的功能时候使用。\n\n\n2、其他关键字和sum的使用类似，只需要以上的\nsum\n换为\naverage\n,\nmax\n, \nmin\n，其中\naverage\n返回的平均值列名为：\n(_avg+(首字母大写的列名))\n。\n\n\n内置函数介绍\n\n\nBQL提供了一些\n内置函数\n来方便地创建 \npointer\n、\ngeopoint\n、\ndate\n、\nfile\n等类型：\n\n\n基本BQL查询用到的内置函数\n\n\n\n\n\n\n\n\nKey\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\ndate('yyyy-MM-dd HH:mm:ss')\n\n\n创建日期类型\n\n\n\n\n\n\npointer(className,objectId)\n\n\n创建 Pointer\n\n\n\n\n\n\ngeopoint(经度，维度)\n\n\n创建 GeoPoint\n\n\n\n\n\n\nfile(filename,url)\n\n\n创建 file 类型\n\n\n\n\n\n\ncurrent_timestamp()\n\n\n创建当前日期\n\n\n\n\n\n\n\n\n\n\n占位符查询用到的内置函数\n\n\n如果使用占位符查询，比较特殊，其内置函数的形式如下\n\n\n\n\n\n\n\n\nKey\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\ndate(?)\n\n\n创建日期类型\n\n\n\n\n\n\npointer(?,?)\n\n\n创建 Pointer\n\n\n\n\n\n\ngeopoint(?,?)\n\n\n创建 GeoPoint\n\n\n\n\n\n\nfile(?,?)\n\n\n创建 file 类型\n\n\n\n\n\n\n\n\n\n\n举例子（以Android为例）：\n\n\n1、Date类型：\n\n\nString dateString = \n2015-05-12\n;  \nSimpleDateFormat sdf = new SimpleDateFormat(\nyyyy-MM-dd\n);\nDate date  = null;\ntry {\n    date = sdf.parse(dateString);\n} catch (ParseException e) {\n}  \nString sql = \nselect * from GameScore where createdAt \n date('\n+new BmobDate(date).getDate()+\n')\n\n\n\n\n\n等价于：（以下是REST API文档中定义的创建\nDate类型\n的JSON对象）\n\n\nselect * from GameScore where createdAt \n {'__type': 'Date','iso': '\n+new BmobDate(date).getDate()+\n'}\n\n\n\n\n2、Pointer类型：\n\n\nUser user = BmobUser.getCurrentUser(this, User.class);\nString sql = select * from GameScore where player = pointer('_User', \n+\n'\n+user.getObjectId()+\n')\n\n\n\n\n\n等价于：（以下是REST API文档中定义的创建\nPointer类型\n的JSON对象）\n\n\nselect * from GameScore where player = {'__type':'Pointer','className':'_User','objectId':'\n+user.getObjectId()+\n'}\n\n\n\n\n3、GeoPoint类型\n\n\nselect * from GameScore where gps = geopoint(112.934755,24.52065)\n\n\n\n\n等价于：（以下是REST API文档中定义的创建\nGeoPoint类型\n的JSON对象）\n\n\nselect * from GameScore where gps = {'__type':'GeoPoint','latitude':24.52065,'longitude':112.934755}\n\n\n\n\n注：\n\n\n1、如果不使用\n内置函数\n，你也使用 \nRest API文档\n定义的 JSON 对象来创建特定类型,不过这样写相对来说比较繁琐。\n\n\n2、占位符查询中如果要用到内置函数，其形式必须为上述列出的，最后的可变参数会自动替换类型中的\n?\n。\n\n\n性能和建议\n\n\nBQL 最终还是转换成 \nRest API文档\n 里查询部分提到的各种 where 条件，因为多了一层转换，理论上会比直接使用 where 查询慢一点。并且 BQL 对长度有所限制，要求在 4096 字节以内。\n\n\n此外，我们推荐查询语句都采用占位符的方式，使用占位符的查询语句将有机会被缓存复用，避免重复解释的开销。", 
            "title": "BQL"
        }, 
        {
            "location": "/other/bql/#_1", 
            "text": "最基本的一个查询:  查询某个 class 下的 100 条数据：  select * from GameScore  等价于（以 Android 为例）:  //查询GameScore的100条数据\nBmobQuery GameScore  query = new BmobQuery GameScore ();\nquery.findObjects(context, new FindListener GameScore () {\n\n    @Override\n    public void onSuccess(List GameScore  object) {\n        // TODO Auto-generated method stub\n    }\n\n    @Override\n    public void onError(int code, String msg) {\n        // TODO Auto-generated method stub\n    }\n});  select一个完整的语法形式类似这样：  select [查询字段列表，多个以逗号隔开] from [class 名称]\n   [where [条件列表]\n   [limit skip,limit\n   [order by [排序字段列表] [asc |desc]]]]  举例：  \n//查询结果只包含 name,playScore 以及内置字段(objectId,createdAt等)\nselect name,playScore from GameScore\n\n//根据 name 查找\nselect * from GameScore where name='smile'\n\n//根据 name 和 playScore 同时查找\nselect * from GameScore where name is exists and playScore   80 and playScore  = 100\n\n//分页查找，从第 10 条开始向后查找 10 条数据\nselect * from GameScore limit 10,10\n\n//根据 score 和 name 排序\nselect * from GameScore order by -playScore,+name  注：当查询的表为系统表（目前系统表有User、Installation、Role）时，需要带上下划线 _ 。  比如，你想查询的是用户 smile 的信息，则：  \n`select * from _User where username= smile`", 
            "title": "介绍及基本语法"
        }, 
        {
            "location": "/other/bql/#_2", 
            "text": "", 
            "title": "查询条件"
        }, 
        {
            "location": "/other/bql/#_3", 
            "text": "查询指定信息的对象，用  =  比较符：  select * from GameScore where name='smile'  查询 不等于 指定信息的对象，用 != 比较符：  select * from GameScore where name!='smile'  也可以用 运算符来表示不等于。  比较日期，使用 date 函数来转换，比如查询特定时间之前创建的对象：  select * from GameScore where createdAt   date('2015-05-20 00:00:00')  date 函数接收的日期格式必须是  yyyy-MM-dd HH:mm:ss 。更多内置函数请看最后的  内置函数 。  一些常见的查询运算符：     Key  Operation  对应Bmob的查询API      =  等于  addWhereEqualTo    != 或者   不等于  addWhereNotEqualTo     小于  addWhereLessThan    =  小于等于  addWhereLessThanOrEqualTo     大于  addWhereGreaterThan    =  大于等于  addWhereGreaterThanOrEqualTo    [not] like  模糊查询  addWhereStartsWith或addWhereEndsWith    [not] regexp  正则匹配  addWhereMatches    [not] in(子查询或者数组)  包含或者不包含  addWhereMatchesQuery或者addWhereDoesNotMatchQuery    is [not] exists  这个Key有值或者不存在值  addWhereExists或addWhereDoesNotExists     注：比较运算符可以用在 日期 、 字符串 、 数字 甚至 对象 上。", 
            "title": "比较查询"
        }, 
        {
            "location": "/other/bql/#_4", 
            "text": "注:模糊查询只对付费用户开放，付费后可直接使用。  模糊查询可以使用  like ，比如查询名字以 smile 开头的对象  select * from GameScore where name like 'smile%'  % 表示模糊匹配的位置占位符。  like  本质上是转成 regexp 的正则匹配查询，因此上面的例子还可以写成：  select * from GameScore where name regexp 'smile.*'  否定形式，以 not like  来查询名字不以 smile 开头的对象：  select * from GameScore where name not like 'smile%'  等价于 not regexp :  select * from GameScore where name not regexp 'smile.*'", 
            "title": "模糊查询"
        }, 
        {
            "location": "/other/bql/#_5", 
            "text": "只返回 name 字段值存在的对象：  select * from GameScore where name is exists  反之，使用  is not exists 。", 
            "title": "值是否存在查询"
        }, 
        {
            "location": "/other/bql/#_6", 
            "text": "假设 hobby 表示一个人的爱好，其字段类型是List 对应服务端的 数组Array 类型，如我们想查询有游泳爱好的人：  select * from Person where hobby ='游泳'   查询既爱好游泳也爱好看书的人：  select * from Person where hobby all ('游泳','看书')  注：all 表示数组完全匹配。", 
            "title": "数组查询"
        }, 
        {
            "location": "/other/bql/#_7", 
            "text": "1、使用  in 来做子查询，后面跟的可以是一个列表，例如 查询游戏名为地铁跑酷、部落冲突两种游戏的记录：  select * from GameScore where game in ('地铁跑酷','部落冲突')  当然，如果想查询的不在列表里，那可以使用 not in :  select * from GameScore where game not in ('地铁跑酷','部落冲突')  2、 in 后面还可以是一个子查询:  比如：要查询游戏得分大于10的玩家信息  这里需要 username 的值必须要在子查询产生的数组中，因此,我在 GameScore 表中新建了一个 name 字段来表示玩家的姓名  select * from _User where username in (select name from GameScore where playScore 10)  比如：查询年龄大于20的玩家的游戏信息  select * from GameScore where name in (select username from _User where age 20)  3、子查询另一种常见形式：使用 = 或 != 后面跟一条查询语句：  比如：查询游戏得分大于80的玩家  select * from _User where username =(select name from GameScore where playScore 10)\nselect * from _User where username !=(select name from GameScore where playScore =10)  注：子查询的语句也受上限 1000 条记录的限制", 
            "title": "子查询"
        }, 
        {
            "location": "/other/bql/#_8", 
            "text": "我们可以通过 BQL 进行地理位置查询。", 
            "title": "地理位置查询"
        }, 
        {
            "location": "/other/bql/#_9", 
            "text": "使用 near 来查询附近的人  比如我想查询指定地理位置附近的玩家（从近到远排序），假设  gps  字段是  BmobGeoPoint 类型：  select * from GameScore where gps near [112.934755,24.52065]  注：[112.934755,24.52065] 是经纬度坐标。必须是经度在前，纬度在后  也可以使用  geopoint  函数来创建：  select * from GameScore where gps near geopoint(112.934755,24.52065)  注：只有在地理位置信息查询里才可以使用  [longitude, latitude] 这样的语法。在其他查询里将被作为数组类型。", 
            "title": "附近的人"
        }, 
        {
            "location": "/other/bql/#_10", 
            "text": "为了限定搜索的最大距离，还可以使用  max distance 单位 来限定，比如,搜索附近1公里内的人：  select * from GameScore where gps near [112.934755,24.52065] max 1 km  注：单位包括 miles（英里）、radians（弧度），默认是弧度。", 
            "title": "限定搜索范围"
        }, 
        {
            "location": "/other/bql/#_11", 
            "text": "如果想查询某个矩形框内的对象，可以使用 within [西南坐标] and [东北坐标] 的语法：  select * from GameScore where gps within [102.934755,24.52065] and [112.934755,24.52065]", 
            "title": "查询矩形范围"
        }, 
        {
            "location": "/other/bql/#_12", 
            "text": "使用  count  查询来返回符合查询条件的数目。  比如:查询整张表的记录数：  select count(*) from GameScore  注：count 不支持distinct等语法。仅限count(*)和count(objectId)  查询总的记录数并返回得分在10-20之间的游戏分数信息  select count(*) from GameScore where playScore 10 and where playScore 20  查询个数的同时可以返回对象,使用 , 隔开：  select count(*),* from GameScore  也可以返回特定的字段：  比如：查询GameScore表中的总数并返回每条记录的游戏名  select count(*),game from GameScore", 
            "title": "查询个数"
        }, 
        {
            "location": "/other/bql/#_13", 
            "text": "有如下几种方式来查询对象之间的关系数据   1、如果您想获取对象，而这个对象的一个字段对应了另一个对象, 您可以用一个  where  查询, 自己构造一个  Pointer  函数, 和其他数据类型一样。  例如：  Weibo 类中有一个 User （继承自BmobUser）类型的 author 字段表示这条微博的发送方，现在你想查询当前用户发布的所有微博信息，那么可以这样写：  select include author,* from Weibo where author = pointer('_User', '6720c14c28')  pointer 内置函数接收 className 和 objectId。  2、如果您想获取对象, 这个对象的一个字段指向的对象（必须是BmobPointer类型）是符合另一个查询的, 您可以使用 in 查询。  例如, 假设您有一个  Weibo  类和一个  Comment  类, 每个 Comment  都有一个指向它的  Weibo  的 weibo字段（BmobPointer类型）, 现在您想查询带有图片的  Weibo  的 Comment列表:  select * from Comment where weibo in (select * from Weibo where image is exists)  注:默认的 limit 是 100 而且最大的 limit 是 1000，这个限制同样适用于内部的查询, 所以对于较大的数据集您可能需要细心地构建查询来获得期望的行为。  3、如果  Weibo  类下有一个 BmobRelation 类型的 comment 字段，它存储了这条微博所有的评论列表。你可以查询到这些评论信息，因为他们都关联到了同一条微博：  select * from Comment where related comment to pointer('Weibo', '262f6ace1a')  基本的查询形式是  releated  key  to  pointer 。  4、如果某个字段是 Pointer ，默认查询的时候，只会返回 {__type: 'Pointer', objectId: 'xxxxxx', className:'Weibo'} 这些基本信息，如果希望同时将这个对象的其他信息查询下来，可以使用 include 。  1）、采用  include  key  就可以将某个  Pointer 字段关联查询出来：  比如查询  Comment  同时将  author 带下来：  select include author, * from Comment  2）、 多个字段要多次 include :  select include weibo,include author from Comment  3）、还可以支持 嵌套的 include 查询 ：  比如  Weibo  里还有一个 Pointer 指向 author(表示这条微博是谁发的):  select include weibo.author,* from Comment", 
            "title": "关系查询"
        }, 
        {
            "location": "/other/bql/#_14", 
            "text": "使用  and  和  or 进行复合查询  比如：查询游戏得分在10-15之间的数据,可以使用 and 查询:  select * from GameScore where playScore 10 and playScore =15  如果你想再加个条件：再查询分数为0的数据，可以使用 or 查询：  select * from GameScore where playScore 10 and playScore =15 or playScore=5  由于 and 的优先级高于 or ，因此,上面的查询也可以用括号来明确地表示这种优先级：  select * from GameScore where (playScore 10 and playScore =15) or playScore=5", 
            "title": "复合查询"
        }, 
        {
            "location": "/other/bql/#_15", 
            "text": "查询条件 where 和  limit  子句支持占位符，也就是可以用问号 ? 替代值，值的列表通过 SDK 提供的方法传入，具体请参考各 SDK 用法。", 
            "title": "占位符"
        }, 
        {
            "location": "/other/bql/#_16", 
            "text": "例如：  select * from GameScore where name=? and playScore ? limit ?,?", 
            "title": "普通查询"
        }, 
        {
            "location": "/other/bql/#_17", 
            "text": "占位符查询中用到的内置函数，请看最后的  占位符查询用到的内置函数 。  例如：  \nselect * from GameScore where createdAt   date(?) and player = pointer(?,?) and gps near geopoint(?,?)  注意：  和统计查询有关的 group by 、 order by 、 having 等字句是不支持占位符的。  正确 写法：  select sum(playScore),count(*) from GameScore group by game having _sumPlayScore 200  错误 写法：  select sum(playScore),count(*) from GameScore group by ? having ?  注：我们推荐使用占位符的方式来使用 BQL，查询语句可以通过预编译得到缓存，降低 BQL 的转换开销。", 
            "title": "内置函数"
        }, 
        {
            "location": "/other/bql/#_18", 
            "text": "通过  limit  语句来限定返回结果大小，比如限定返回 10 个：  select * from GameScore limit 10  可以设定从第 m+1 个元素开始，例如从第 11 个元素（包含）开始往后取 10 个：  select * from GameScore limit 10,10  注：如果查询语句没有设定 limit ，默认的 limit 是 100 而且最大的 limit 是 1000。", 
            "title": "限定返回值"
        }, 
        {
            "location": "/other/bql/#_19", 
            "text": "通过  order  语句来排序， order  语句只能出现在最后，不能在  where  和  limit  之前。  比如：按照得分降序排列（得分高的在前）：  select * from GameScore order by playScore desc  也可以写成：  select * from GameScore order by -playScore  注：加号表示升序，减号表示降序。  多个字段组合排序  比如：得分高的在前（playScore降序），当得分一样的情况下，再按照名称（字母顺序）更小的在前（name升序）：  select * from GameScore order by -playScore,name  同样的语句可以写成：  select * from GameScore order by playScore,+name desc  或者  select * from GameScore order by -playScore,name asc  注：没有写上明确的加号或者减号的字段，将根据最后的 desc 或者 asc 来决定采用升序还是降序。", 
            "title": "排序"
        }, 
        {
            "location": "/other/bql/#_20", 
            "text": "统计查询只适用于  Number  类型的列，支持  sum  (计算总和),  average  (计算平均值),  max  (计算最大值),  min  (计算最小值)  举几个例子（以sum求和）:", 
            "title": "统计查询"
        }, 
        {
            "location": "/other/bql/#_21", 
            "text": "比如：查询 GameScore 表所有玩家的得分总和:  select sum(playScore) from GameScore", 
            "title": "计算总和"
        }, 
        {
            "location": "/other/bql/#_22", 
            "text": "比如：按玩家分组，获取每个玩家的总得分：  select sum(playScore) from GameScore group by name", 
            "title": "分组计算总和"
        }, 
        {
            "location": "/other/bql/#_23", 
            "text": "比如 按玩家分组，获取每个玩家的总得分，并且总得分大于100的：  select sum(playScore) from GameScore group by name having _sumPlayScore   100", 
            "title": "添加过滤条件"
        }, 
        {
            "location": "/other/bql/#_24", 
            "text": "同时支持返回每个组用于计算总和的总数：  select sum(playScore),count(*) from GameScore group by name having _sumPlayScore   100  注：  1、查询语句中含有 sum 或  group by 的时候不支持返回表中的其他列，只返回group by后面接的列名、sum的列名为  (_sum+(首字母大写的列名))  以及有count(*)会返回的  _count 等数据。所以只应该用于统计的功能时候使用。  2、其他关键字和sum的使用类似，只需要以上的 sum 换为 average , max ,  min ，其中 average 返回的平均值列名为： (_avg+(首字母大写的列名)) 。", 
            "title": "统计分组记录数"
        }, 
        {
            "location": "/other/bql/#_25", 
            "text": "BQL提供了一些 内置函数 来方便地创建  pointer 、 geopoint 、 date 、 file 等类型：", 
            "title": "内置函数介绍"
        }, 
        {
            "location": "/other/bql/#bql", 
            "text": "Key  Operation      date('yyyy-MM-dd HH:mm:ss')  创建日期类型    pointer(className,objectId)  创建 Pointer    geopoint(经度，维度)  创建 GeoPoint    file(filename,url)  创建 file 类型    current_timestamp()  创建当前日期", 
            "title": "基本BQL查询用到的内置函数"
        }, 
        {
            "location": "/other/bql/#_26", 
            "text": "如果使用占位符查询，比较特殊，其内置函数的形式如下     Key  Operation      date(?)  创建日期类型    pointer(?,?)  创建 Pointer    geopoint(?,?)  创建 GeoPoint    file(?,?)  创建 file 类型      举例子（以Android为例）：  1、Date类型：  String dateString =  2015-05-12 ;  \nSimpleDateFormat sdf = new SimpleDateFormat( yyyy-MM-dd );\nDate date  = null;\ntry {\n    date = sdf.parse(dateString);\n} catch (ParseException e) {\n}  \nString sql =  select * from GameScore where createdAt   date(' +new BmobDate(date).getDate()+ ')   等价于：（以下是REST API文档中定义的创建 Date类型 的JSON对象）  select * from GameScore where createdAt   {'__type': 'Date','iso': ' +new BmobDate(date).getDate()+ '}  2、Pointer类型：  User user = BmobUser.getCurrentUser(this, User.class);\nString sql = select * from GameScore where player = pointer('_User',  + ' +user.getObjectId()+ ')  等价于：（以下是REST API文档中定义的创建 Pointer类型 的JSON对象）  select * from GameScore where player = {'__type':'Pointer','className':'_User','objectId':' +user.getObjectId()+ '}  3、GeoPoint类型  select * from GameScore where gps = geopoint(112.934755,24.52065)  等价于：（以下是REST API文档中定义的创建 GeoPoint类型 的JSON对象）  select * from GameScore where gps = {'__type':'GeoPoint','latitude':24.52065,'longitude':112.934755}  注：  1、如果不使用 内置函数 ，你也使用  Rest API文档 定义的 JSON 对象来创建特定类型,不过这样写相对来说比较繁琐。  2、占位符查询中如果要用到内置函数，其形式必须为上述列出的，最后的可变参数会自动替换类型中的 ? 。", 
            "title": "占位符查询用到的内置函数"
        }, 
        {
            "location": "/other/bql/#_27", 
            "text": "BQL 最终还是转换成  Rest API文档  里查询部分提到的各种 where 条件，因为多了一层转换，理论上会比直接使用 where 查询慢一点。并且 BQL 对长度有所限制，要求在 4096 字节以内。  此外，我们推荐查询语句都采用占位符的方式，使用占位符的查询语句将有机会被缓存复用，避免重复解释的开销。", 
            "title": "性能和建议"
        }
    ]
}